import {
  ButtonView,
  View
} from "./chunk-SGTDNT4V.js";
import {
  CKEditorError,
  Collection,
  ObservableMixin,
  PendingActions,
  Plugin,
  logWarning,
  uid
} from "./chunk-JI2V5GJZ.js";

// node_modules/@ckeditor/ckeditor5-upload/src/filereader.js
var FileReader = class extends ObservableMixin() {
  /**
   * Creates an instance of the FileReader.
   */
  constructor() {
    super();
    const reader = new window.FileReader();
    this._reader = reader;
    this._data = void 0;
    this.set("loaded", 0);
    reader.onprogress = (evt) => {
      this.loaded = evt.loaded;
    };
  }
  /**
   * Returns error that occurred during file reading.
   */
  get error() {
    return this._reader.error;
  }
  /**
   * Holds the data of an already loaded file. The file must be first loaded
   * by using {@link module:upload/filereader~FileReader#read `read()`}.
   */
  get data() {
    return this._data;
  }
  /**
   * Reads the provided file.
   *
   * @param file Native File object.
   * @returns Returns a promise that will be resolved with file's content.
   * The promise will be rejected in case of an error or when the reading process is aborted.
   */
  read(file) {
    const reader = this._reader;
    this.total = file.size;
    return new Promise((resolve, reject) => {
      reader.onload = () => {
        const result = reader.result;
        this._data = result;
        resolve(result);
      };
      reader.onerror = () => {
        reject("error");
      };
      reader.onabort = () => {
        reject("aborted");
      };
      this._reader.readAsDataURL(file);
    });
  }
  /**
   * Aborts file reader.
   */
  abort() {
    this._reader.abort();
  }
};

// node_modules/@ckeditor/ckeditor5-upload/src/filerepository.js
var FileRepository = class extends Plugin {
  constructor() {
    super(...arguments);
    this.loaders = new Collection();
    this._loadersMap = /* @__PURE__ */ new Map();
    this._pendingAction = null;
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FileRepository";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [PendingActions];
  }
  /**
   * @inheritDoc
   */
  init() {
    this.loaders.on("change", () => this._updatePendingAction());
    this.set("uploaded", 0);
    this.set("uploadTotal", null);
    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (uploaded, total) => {
      return total ? uploaded / total * 100 : 0;
    });
  }
  /**
   * Returns the loader associated with specified file or promise.
   *
   * To get loader by id use `fileRepository.loaders.get( id )`.
   *
   * @param fileOrPromise Native file or promise handle.
   */
  getLoader(fileOrPromise) {
    return this._loadersMap.get(fileOrPromise) || null;
  }
  /**
   * Creates a loader instance for the given file.
   *
   * Requires {@link #createUploadAdapter} factory to be defined.
   *
   * @param fileOrPromise Native File object or native Promise object which resolves to a File.
   */
  createLoader(fileOrPromise) {
    if (!this.createUploadAdapter) {
      logWarning("filerepository-no-upload-adapter");
      return null;
    }
    const loader = new FileLoader(Promise.resolve(fileOrPromise), this.createUploadAdapter);
    this.loaders.add(loader);
    this._loadersMap.set(fileOrPromise, loader);
    if (fileOrPromise instanceof Promise) {
      loader.file.then((file) => {
        this._loadersMap.set(file, loader);
      }).catch(() => {
      });
    }
    loader.on("change:uploaded", () => {
      let aggregatedUploaded = 0;
      for (const loader2 of this.loaders) {
        aggregatedUploaded += loader2.uploaded;
      }
      this.uploaded = aggregatedUploaded;
    });
    loader.on("change:uploadTotal", () => {
      let aggregatedTotal = 0;
      for (const loader2 of this.loaders) {
        if (loader2.uploadTotal) {
          aggregatedTotal += loader2.uploadTotal;
        }
      }
      this.uploadTotal = aggregatedTotal;
    });
    return loader;
  }
  /**
   * Destroys the given loader.
   *
   * @param fileOrPromiseOrLoader File or Promise associated with that loader or loader itself.
   */
  destroyLoader(fileOrPromiseOrLoader) {
    const loader = fileOrPromiseOrLoader instanceof FileLoader ? fileOrPromiseOrLoader : this.getLoader(fileOrPromiseOrLoader);
    loader._destroy();
    this.loaders.remove(loader);
    this._loadersMap.forEach((value, key) => {
      if (value === loader) {
        this._loadersMap.delete(key);
      }
    });
  }
  /**
   * Registers or deregisters pending action bound with upload progress.
   */
  _updatePendingAction() {
    const pendingActions = this.editor.plugins.get(PendingActions);
    if (this.loaders.length) {
      if (!this._pendingAction) {
        const t = this.editor.t;
        const getMessage = (value) => `${t("Upload in progress")} ${parseInt(value)}%.`;
        this._pendingAction = pendingActions.add(getMessage(this.uploadedPercent));
        this._pendingAction.bind("message").to(this, "uploadedPercent", getMessage);
      }
    } else {
      pendingActions.remove(this._pendingAction);
      this._pendingAction = null;
    }
  }
};
var FileLoader = class extends ObservableMixin() {
  /**
   * Creates a new instance of `FileLoader`.
   *
   * @param filePromise A promise which resolves to a file instance.
   * @param uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.
   */
  constructor(filePromise, uploadAdapterCreator) {
    super();
    this.id = uid();
    this._filePromiseWrapper = this._createFilePromiseWrapper(filePromise);
    this._adapter = uploadAdapterCreator(this);
    this._reader = new FileReader();
    this.set("status", "idle");
    this.set("uploaded", 0);
    this.set("uploadTotal", null);
    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (uploaded, total) => {
      return total ? uploaded / total * 100 : 0;
    });
    this.set("uploadResponse", null);
  }
  /**
   * A `Promise` which resolves to a `File` instance associated with this file loader.
   */
  get file() {
    if (!this._filePromiseWrapper) {
      return Promise.resolve(null);
    } else {
      return this._filePromiseWrapper.promise.then((file) => this._filePromiseWrapper ? file : null);
    }
  }
  /**
   * Returns the file data. To read its data, you need for first load the file
   * by using the {@link module:upload/filerepository~FileLoader#read `read()`} method.
   */
  get data() {
    return this._reader.data;
  }
  /**
   * Reads file using {@link module:upload/filereader~FileReader}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status
   * is different than `idle`.
   *
   * Example usage:
   *
   * ```ts
   * fileLoader.read()
   * 	.then( data => { ... } )
   * 	.catch( err => {
   * 		if ( err === 'aborted' ) {
   * 			console.log( 'Reading aborted.' );
   * 		} else {
   * 			console.log( 'Reading error.', err );
   * 		}
   * 	} );
   * ```
   *
   * @returns Returns promise that will be resolved with read data. Promise will be rejected if error
   * occurs or if read process is aborted.
   */
  read() {
    if (this.status != "idle") {
      throw new CKEditorError("filerepository-read-wrong-status", this);
    }
    this.status = "reading";
    return this.file.then((file) => this._reader.read(file)).then((data) => {
      if (this.status !== "reading") {
        throw this.status;
      }
      this.status = "idle";
      return data;
    }).catch((err) => {
      if (err === "aborted") {
        this.status = "aborted";
        throw "aborted";
      }
      this.status = "error";
      throw this._reader.error ? this._reader.error : err;
    });
  }
  /**
   * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status
   * is different than `idle`.
   * Example usage:
   *
   * ```ts
   * fileLoader.upload()
   * 	.then( data => { ... } )
   * 	.catch( e => {
   * 		if ( e === 'aborted' ) {
   * 			console.log( 'Uploading aborted.' );
   * 		} else {
   * 			console.log( 'Uploading error.', e );
   * 		}
   * 	} );
   * ```
   *
   * @returns Returns promise that will be resolved with response data. Promise will be rejected if error
   * occurs or if read process is aborted.
   */
  upload() {
    if (this.status != "idle") {
      throw new CKEditorError("filerepository-upload-wrong-status", this);
    }
    this.status = "uploading";
    return this.file.then(() => this._adapter.upload()).then((data) => {
      this.uploadResponse = data;
      this.status = "idle";
      return data;
    }).catch((err) => {
      if (this.status === "aborted") {
        throw "aborted";
      }
      this.status = "error";
      throw err;
    });
  }
  /**
   * Aborts loading process.
   */
  abort() {
    const status = this.status;
    this.status = "aborted";
    if (!this._filePromiseWrapper.isFulfilled) {
      this._filePromiseWrapper.promise.catch(() => {
      });
      this._filePromiseWrapper.rejecter("aborted");
    } else if (status == "reading") {
      this._reader.abort();
    } else if (status == "uploading" && this._adapter.abort) {
      this._adapter.abort();
    }
    this._destroy();
  }
  /**
   * Performs cleanup.
   *
   * @internal
   */
  _destroy() {
    this._filePromiseWrapper = void 0;
    this._reader = void 0;
    this._adapter = void 0;
    this.uploadResponse = void 0;
  }
  /**
   * Wraps a given file promise into another promise giving additional
   * control (resolving, rejecting, checking if fulfilled) over it.
   *
   * @param filePromise The initial file promise to be wrapped.
   */
  _createFilePromiseWrapper(filePromise) {
    const wrapper = {};
    wrapper.promise = new Promise((resolve, reject) => {
      wrapper.rejecter = reject;
      wrapper.isFulfilled = false;
      filePromise.then((file) => {
        wrapper.isFulfilled = true;
        resolve(file);
      }).catch((err) => {
        wrapper.isFulfilled = true;
        reject(err);
      });
    });
    return wrapper;
  }
};

// node_modules/@ckeditor/ckeditor5-upload/src/ui/filedialogbuttonview.js
var FileDialogButtonView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.buttonView = new ButtonView(locale);
    this._fileInputView = new FileInputView(locale);
    this._fileInputView.bind("acceptedType").to(this);
    this._fileInputView.bind("allowMultipleFiles").to(this);
    this._fileInputView.delegate("done").to(this);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: "ck-file-dialog-button"
      },
      children: [
        this.buttonView,
        this._fileInputView
      ]
    });
    this.buttonView.on("execute", () => {
      this._fileInputView.open();
    });
  }
  /**
   * Focuses the {@link #buttonView}.
   */
  focus() {
    this.buttonView.focus();
  }
};
var FileInputView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("acceptedType", void 0);
    this.set("allowMultipleFiles", false);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck-hidden"
        ],
        type: "file",
        tabindex: "-1",
        accept: bind.to("acceptedType"),
        multiple: bind.to("allowMultipleFiles")
      },
      on: {
        // Removing from code coverage since we cannot programmatically set input element files.
        change: bind.to(
          /* istanbul ignore next -- @preserve */
          () => {
            if (this.element && this.element.files && this.element.files.length) {
              this.fire("done", this.element.files);
            }
            this.element.value = "";
          }
        )
      }
    });
  }
  /**
   * Opens file dialog.
   */
  open() {
    this.element.click();
  }
};

export {
  FileRepository,
  FileDialogButtonView
};
/*! Bundled license information:

@ckeditor/ckeditor5-upload/src/filereader.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-upload/src/filerepository.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-upload/src/ui/filedialogbuttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-upload/src/adapters/base64uploadadapter.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-upload/src/adapters/simpleuploadadapter.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-upload/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-upload/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/upload.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-P3DP7CWK.js.map
