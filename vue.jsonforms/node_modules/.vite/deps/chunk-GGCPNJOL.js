import {
  BubblingEventInfo,
  Command,
  DomEventData,
  Observer,
  Plugin,
  env_default
} from "./chunk-JI2V5GJZ.js";

// node_modules/@ckeditor/ckeditor5-enter/src/utils.js
function* getCopyOnEnterAttributes(schema, allAttributes) {
  for (const attribute of allAttributes) {
    if (attribute && schema.getAttributeProperties(attribute[0]).copyOnEnter) {
      yield attribute;
    }
  }
}

// node_modules/@ckeditor/ckeditor5-enter/src/entercommand.js
var EnterCommand = class extends Command {
  /**
   * @inheritDoc
   */
  execute() {
    this.editor.model.change((writer) => {
      this.enterBlock(writer);
      this.fire("afterExecute", { writer });
    });
  }
  /**
   * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:
   *
   * ```
   * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>
   * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>
   * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>
   * ```
   *
   * In some cases, the split will not happen:
   *
   * ```
   * // The selection parent is a limit element:
   * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>
   *
   * // The selection spans over multiple elements:
   * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>
   * ```
   *
   * @param writer Writer to use when performing the enter action.
   * @returns Boolean indicating if the block was split.
   */
  enterBlock(writer) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const schema = model.schema;
    const isSelectionEmpty = selection.isCollapsed;
    const range = selection.getFirstRange();
    const startElement = range.start.parent;
    const endElement = range.end.parent;
    if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
      if (!isSelectionEmpty && startElement == endElement) {
        model.deleteContent(selection);
      }
      return false;
    }
    if (isSelectionEmpty) {
      const attributesToCopy = getCopyOnEnterAttributes(writer.model.schema, selection.getAttributes());
      splitBlock(writer, range.start);
      writer.setSelectionAttribute(attributesToCopy);
      return true;
    } else {
      const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
      const isContainedWithinOneElement = startElement == endElement;
      model.deleteContent(selection, { leaveUnmerged });
      if (leaveUnmerged) {
        if (isContainedWithinOneElement) {
          splitBlock(writer, selection.focus);
          return true;
        } else {
          writer.setSelection(endElement, 0);
        }
      }
    }
    return false;
  }
};
function splitBlock(writer, splitPos) {
  writer.split(splitPos);
  writer.setSelection(splitPos.parent.nextSibling, 0);
}

// node_modules/@ckeditor/ckeditor5-enter/src/enterobserver.js
var ENTER_EVENT_TYPES = {
  insertParagraph: { isSoft: false },
  insertLineBreak: { isSoft: true }
};
var EnterObserver = class extends Observer {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    const doc = this.document;
    let shiftPressed = false;
    doc.on("keydown", (evt, data) => {
      shiftPressed = data.shiftKey;
    });
    doc.on("beforeinput", (evt, data) => {
      if (!this.isEnabled) {
        return;
      }
      let inputType = data.inputType;
      if (env_default.isSafari && shiftPressed && inputType == "insertParagraph") {
        inputType = "insertLineBreak";
      }
      const domEvent = data.domEvent;
      const enterEventSpec = ENTER_EVENT_TYPES[inputType];
      if (!enterEventSpec) {
        return;
      }
      const event = new BubblingEventInfo(doc, "enter", data.targetRanges[0]);
      doc.fire(event, new DomEventData(view, domEvent, {
        isSoft: enterEventSpec.isSoft
      }));
      if (event.stop.called) {
        evt.stop();
      }
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
};

// node_modules/@ckeditor/ckeditor5-enter/src/enter.js
var Enter = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Enter";
  }
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    view.addObserver(EnterObserver);
    editor.commands.add("enter", new EnterCommand(editor));
    this.listenTo(viewDocument, "enter", (evt, data) => {
      if (!viewDocument.isComposing) {
        data.preventDefault();
      }
      if (data.isSoft) {
        return;
      }
      editor.execute("enter");
      view.scrollToTheSelection();
    }, { priority: "low" });
  }
};

// node_modules/@ckeditor/ckeditor5-enter/src/shiftentercommand.js
var ShiftEnterCommand = class extends Command {
  /**
   * @inheritDoc
   */
  execute() {
    const model = this.editor.model;
    const doc = model.document;
    model.change((writer) => {
      softBreakAction(model, writer, doc.selection);
      this.fire("afterExecute", { writer });
    });
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.isEnabled = isEnabled(model.schema, doc.selection);
  }
};
function isEnabled(schema, selection) {
  if (selection.rangeCount > 1) {
    return false;
  }
  const anchorPos = selection.anchor;
  if (!anchorPos || !schema.checkChild(anchorPos, "softBreak")) {
    return false;
  }
  const range = selection.getFirstRange();
  const startElement = range.start.parent;
  const endElement = range.end.parent;
  if ((isInsideLimitElement(startElement, schema) || isInsideLimitElement(endElement, schema)) && startElement !== endElement) {
    return false;
  }
  return true;
}
function softBreakAction(model, writer, selection) {
  const isSelectionEmpty = selection.isCollapsed;
  const range = selection.getFirstRange();
  const startElement = range.start.parent;
  const endElement = range.end.parent;
  const isContainedWithinOneElement = startElement == endElement;
  if (isSelectionEmpty) {
    const attributesToCopy = getCopyOnEnterAttributes(model.schema, selection.getAttributes());
    insertBreak(model, writer, range.end);
    writer.removeSelectionAttribute(selection.getAttributeKeys());
    writer.setSelectionAttribute(attributesToCopy);
  } else {
    const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
    model.deleteContent(selection, { leaveUnmerged });
    if (isContainedWithinOneElement) {
      insertBreak(model, writer, selection.focus);
    } else {
      if (leaveUnmerged) {
        writer.setSelection(endElement, 0);
      }
    }
  }
}
function insertBreak(model, writer, position) {
  const breakLineElement = writer.createElement("softBreak");
  model.insertContent(breakLineElement, position);
  writer.setSelection(breakLineElement, "after");
}
function isInsideLimitElement(element, schema) {
  if (element.is("rootElement")) {
    return false;
  }
  return schema.isLimit(element) || isInsideLimitElement(element.parent, schema);
}

// node_modules/@ckeditor/ckeditor5-enter/src/shiftenter.js
var ShiftEnter = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ShiftEnter";
  }
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const view = editor.editing.view;
    const viewDocument = view.document;
    schema.register("softBreak", {
      allowWhere: "$text",
      isInline: true
    });
    conversion.for("upcast").elementToElement({
      model: "softBreak",
      view: "br"
    });
    conversion.for("downcast").elementToElement({
      model: "softBreak",
      view: (modelElement, { writer }) => writer.createEmptyElement("br")
    });
    view.addObserver(EnterObserver);
    editor.commands.add("shiftEnter", new ShiftEnterCommand(editor));
    this.listenTo(viewDocument, "enter", (evt, data) => {
      if (!viewDocument.isComposing) {
        data.preventDefault();
      }
      if (!data.isSoft) {
        return;
      }
      editor.execute("shiftEnter");
      view.scrollToTheSelection();
    }, { priority: "low" });
  }
};

export {
  Enter,
  ShiftEnter
};
/*! Bundled license information:

@ckeditor/ckeditor5-enter/src/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/entercommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/enterobserver.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/enter.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/shiftentercommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/shiftenter.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-GGCPNJOL.js.map
