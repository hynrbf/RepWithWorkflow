{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js", "../../@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js", "../../@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js", "../../@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js", "../../@ckeditor/ckeditor5-clipboard/src/clipboardpipeline.js", "../../@ckeditor/ckeditor5-clipboard/src/dragdrop.js", "../../@ckeditor/ckeditor5-clipboard/src/pasteplaintext.js", "../../@ckeditor/ckeditor5-clipboard/src/clipboard.js", "../../@ckeditor/ckeditor5-clipboard/src/lineview.js", "../../@ckeditor/ckeditor5-clipboard/src/dragdropexperimental.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboardobserver\n */\nimport { EventInfo } from '@ckeditor/ckeditor5-utils';\nimport { DataTransfer, DomEventObserver } from '@ckeditor/ckeditor5-engine';\n/**\n * Clipboard events observer.\n *\n * Fires the following events:\n *\n * * {@link module:engine/view/document~Document#event:clipboardInput},\n * * {@link module:engine/view/document~Document#event:paste},\n * * {@link module:engine/view/document~Document#event:copy},\n * * {@link module:engine/view/document~Document#event:cut},\n * * {@link module:engine/view/document~Document#event:drop},\n * * {@link module:engine/view/document~Document#event:dragover},\n * * {@link module:engine/view/document~Document#event:dragging},\n * * {@link module:engine/view/document~Document#event:dragstart},\n * * {@link module:engine/view/document~Document#event:dragend},\n * * {@link module:engine/view/document~Document#event:dragenter},\n * * {@link module:engine/view/document~Document#event:dragleave}.\n *\n * **Note**: This observer is not available by default (ckeditor5-engine does not add it on its own).\n * To make it available, it needs to be added to {@link module:engine/view/document~Document} by using\n * the {@link module:engine/view/view~View#addObserver `View#addObserver()`} method. Alternatively, you can load the\n * {@link module:clipboard/clipboard~Clipboard} plugin which adds this observer automatically (because it uses it).\n */\nexport default class ClipboardObserver extends DomEventObserver {\n    constructor(view) {\n        super(view);\n        this.domEventType = [\n            'paste', 'copy', 'cut', 'drop', 'dragover', 'dragstart', 'dragend', 'dragenter', 'dragleave'\n        ];\n        const viewDocument = this.document;\n        this.listenTo(viewDocument, 'paste', handleInput('clipboardInput'), { priority: 'low' });\n        this.listenTo(viewDocument, 'drop', handleInput('clipboardInput'), { priority: 'low' });\n        this.listenTo(viewDocument, 'dragover', handleInput('dragging'), { priority: 'low' });\n        function handleInput(type) {\n            return (evt, data) => {\n                data.preventDefault();\n                const targetRanges = data.dropRange ? [data.dropRange] : null;\n                const eventInfo = new EventInfo(viewDocument, type);\n                viewDocument.fire(eventInfo, {\n                    dataTransfer: data.dataTransfer,\n                    method: evt.name,\n                    targetRanges,\n                    target: data.target,\n                    domEvent: data.domEvent\n                });\n                // If CKEditor handled the input, do not bubble the original event any further.\n                // This helps external integrations recognize that fact and act accordingly.\n                // https://github.com/ckeditor/ckeditor5-upload/issues/92\n                if (eventInfo.stop.called) {\n                    data.stopPropagation();\n                }\n            };\n        }\n    }\n    onDomEvent(domEvent) {\n        const nativeDataTransfer = 'clipboardData' in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;\n        const cacheFiles = domEvent.type == 'drop' || domEvent.type == 'paste';\n        const evtData = {\n            dataTransfer: new DataTransfer(nativeDataTransfer, { cacheFiles })\n        };\n        if (domEvent.type == 'drop' || domEvent.type == 'dragover') {\n            evtData.dropRange = getDropViewRange(this.view, domEvent);\n        }\n        this.fire(domEvent.type, domEvent, evtData);\n    }\n}\nfunction getDropViewRange(view, domEvent) {\n    const domDoc = domEvent.target.ownerDocument;\n    const x = domEvent.clientX;\n    const y = domEvent.clientY;\n    let domRange;\n    // Webkit & Blink.\n    if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x, y)) {\n        domRange = domDoc.caretRangeFromPoint(x, y);\n    }\n    // FF.\n    else if (domEvent.rangeParent) {\n        domRange = domDoc.createRange();\n        domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);\n        domRange.collapse(true);\n    }\n    if (domRange) {\n        return view.domConverter.domRangeToView(domRange);\n    }\n    return null;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/utils/plaintexttohtml\n */\n/**\n * Converts plain text to its HTML-ized version.\n *\n * @param text The plain text to convert.\n * @returns HTML generated from the plain text.\n */\nexport default function plainTextToHtml(text) {\n    text = text\n        // Encode <>.\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        // Creates a paragraph for each double line break.\n        .replace(/\\r?\\n\\r?\\n/g, '</p><p>')\n        // Creates a line break for each single line break.\n        .replace(/\\r?\\n/g, '<br>')\n        // Replace tabs with four spaces.\n        .replace(/\\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')\n        // Preserve trailing spaces (only the first and last one – the rest is handled below).\n        .replace(/^\\s/, '&nbsp;')\n        .replace(/\\s$/, '&nbsp;')\n        // Preserve other subsequent spaces now.\n        .replace(/\\s\\s/g, ' &nbsp;');\n    if (text.includes('</p><p>') || text.includes('<br>')) {\n        // If we created paragraphs above, add the trailing ones.\n        text = `<p>${text}</p>`;\n    }\n    // TODO:\n    // * What about '\\nfoo' vs ' foo'?\n    return text;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/utils/normalizeclipboarddata\n */\n/**\n * Removes some popular browser quirks out of the clipboard data (HTML).\n * Removes all HTML comments. These are considered an internal thing and it makes little sense if they leak into the editor data.\n *\n * @param data The HTML data to normalize.\n * @returns Normalized HTML.\n */\nexport default function normalizeClipboardData(data) {\n    return data\n        .replace(/<span(?: class=\"Apple-converted-space\"|)>(\\s+)<\\/span>/g, (fullMatch, spaces) => {\n        // Handle the most popular and problematic case when even a single space becomes an nbsp;.\n        // Decode those to normal spaces. Read more in https://github.com/ckeditor/ckeditor5-clipboard/issues/2.\n        if (spaces.length == 1) {\n            return ' ';\n        }\n        return spaces;\n    })\n        // Remove all HTML comments.\n        .replace(/<!--[\\s\\S]*?-->/g, '');\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n// Elements which should not have empty-line padding.\n// Most `view.ContainerElement` want to be separate by new-line, but some are creating one structure\n// together (like `<li>`) so it is better to separate them by only one \"\\n\".\nconst smallPaddingElements = ['figcaption', 'li'];\n/**\n * Converts {@link module:engine/view/item~Item view item} and all of its children to plain text.\n *\n * @param viewItem View item to convert.\n * @returns Plain text representation of `viewItem`.\n */\nexport default function viewToPlainText(viewItem) {\n    let text = '';\n    if (viewItem.is('$text') || viewItem.is('$textProxy')) {\n        // If item is `Text` or `TextProxy` simple take its text data.\n        text = viewItem.data;\n    }\n    else if (viewItem.is('element', 'img') && viewItem.hasAttribute('alt')) {\n        // Special case for images - use alt attribute if it is provided.\n        text = viewItem.getAttribute('alt');\n    }\n    else if (viewItem.is('element', 'br')) {\n        // A soft break should be converted into a single line break (#8045).\n        text = '\\n';\n    }\n    else {\n        // Other elements are document fragments, attribute elements or container elements.\n        // They don't have their own text value, so convert their children.\n        let prev = null;\n        for (const child of viewItem.getChildren()) {\n            const childText = viewToPlainText(child);\n            // Separate container element children with one or more new-line characters.\n            if (prev && (prev.is('containerElement') || child.is('containerElement'))) {\n                if (smallPaddingElements.includes(prev.name) ||\n                    smallPaddingElements.includes(child.name)) {\n                    text += '\\n';\n                }\n                else {\n                    text += '\\n\\n';\n                }\n            }\n            text += childText;\n            prev = child;\n        }\n    }\n    return text;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboardpipeline\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { EventInfo } from '@ckeditor/ckeditor5-utils';\nimport ClipboardObserver from './clipboardobserver';\nimport plainTextToHtml from './utils/plaintexttohtml';\nimport normalizeClipboardHtml from './utils/normalizeclipboarddata';\nimport viewToPlainText from './utils/viewtoplaintext';\n// Input pipeline events overview:\n//\n//              ┌──────────────────────┐          ┌──────────────────────┐\n//              │     view.Document    │          │     view.Document    │\n//              │         paste        │          │         drop         │\n//              └───────────┬──────────┘          └───────────┬──────────┘\n//                          │                                 │\n//                          └────────────────┌────────────────┘\n//                                           │\n//                                 ┌─────────V────────┐\n//                                 │   view.Document  │   Retrieves text/html or text/plain from data.dataTransfer\n//                                 │  clipboardInput  │   and processes it to view.DocumentFragment.\n//                                 └─────────┬────────┘\n//                                           │\n//                               ┌───────────V───────────┐\n//                               │   ClipboardPipeline   │   Converts view.DocumentFragment to model.DocumentFragment.\n//                               │  inputTransformation  │\n//                               └───────────┬───────────┘\n//                                           │\n//                                ┌──────────V──────────┐\n//                                │  ClipboardPipeline  │   Calls model.insertContent().\n//                                │   contentInsertion  │\n//                                └─────────────────────┘\n//\n//\n// Output pipeline events overview:\n//\n//              ┌──────────────────────┐          ┌──────────────────────┐\n//              │     view.Document    │          │     view.Document    │   Retrieves the selected model.DocumentFragment\n//              │         copy         │          │          cut         │   and converts it to view.DocumentFragment.\n//              └───────────┬──────────┘          └───────────┬──────────┘\n//                          │                                 │\n//                          └────────────────┌────────────────┘\n//                                           │\n//                                 ┌─────────V────────┐\n//                                 │   view.Document  │   Processes view.DocumentFragment to text/html and text/plain\n//                                 │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                                 └──────────────────┘\n//\n/**\n * The clipboard pipeline feature. It is responsible for intercepting the `paste` and `drop` events and\n * passing the pasted content through a series of events in order to insert it into the editor's content.\n * It also handles the `cut` and `copy` events to fill the native clipboard with the serialized editor's data.\n *\n * # Input pipeline\n *\n * The behavior of the default handlers (all at a `low` priority):\n *\n * ## Event: `paste` or `drop`\n *\n * 1. Translates the event data.\n * 2. Fires the {@link module:engine/view/document~Document#event:clipboardInput `view.Document#clipboardInput`} event.\n *\n * ## Event: `view.Document#clipboardInput`\n *\n * 1. If the `data.content` event field is already set (by some listener on a higher priority), it takes this content and fires the event\n *    from the last point.\n * 2. Otherwise, it retrieves `text/html` or `text/plain` from `data.dataTransfer`.\n * 3. Normalizes the raw data by applying simple filters on string data.\n * 4. Processes the raw data to {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`} with the\n *    {@link module:engine/controller/datacontroller~DataController#htmlProcessor `DataController#htmlProcessor`}.\n * 5. Fires the {@link module:clipboard/clipboardpipeline~ClipboardPipeline#event:inputTransformation\n *   `ClipboardPipeline#inputTransformation`} event with the view document fragment in the `data.content` event field.\n *\n * ## Event: `ClipboardPipeline#inputTransformation`\n *\n * 1. Converts {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`} from the `data.content` field to\n *    {@link module:engine/model/documentfragment~DocumentFragment `model.DocumentFragment`}.\n * 2. Fires the {@link module:clipboard/clipboardpipeline~ClipboardPipeline#event:contentInsertion `ClipboardPipeline#contentInsertion`}\n *    event with the model document fragment in the `data.content` event field.\n *    **Note**: The `ClipboardPipeline#contentInsertion` event is fired within a model change block to allow other handlers\n *    to run in the same block without post-fixers called in between (i.e., the selection post-fixer).\n *\n * ## Event: `ClipboardPipeline#contentInsertion`\n *\n * 1. Calls {@link module:engine/model/model~Model#insertContent `model.insertContent()`} to insert `data.content`\n *    at the current selection position.\n *\n * # Output pipeline\n *\n * The behavior of the default handlers (all at a `low` priority):\n *\n * ## Event: `copy`, `cut` or `dragstart`\n *\n * 1. Retrieves the selected {@link module:engine/model/documentfragment~DocumentFragment `model.DocumentFragment`} by calling\n *    {@link module:engine/model/model~Model#getSelectedContent `model#getSelectedContent()`}.\n * 2. Converts the model document fragment to {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`}.\n * 3. Fires the {@link module:engine/view/document~Document#event:clipboardOutput `view.Document#clipboardOutput`} event\n *    with the view document fragment in the `data.content` event field.\n *\n * ## Event: `view.Document#clipboardOutput`\n *\n * 1. Processes `data.content` to HTML and plain text with the\n *    {@link module:engine/controller/datacontroller~DataController#htmlProcessor `DataController#htmlProcessor`}.\n * 2. Updates the `data.dataTransfer` data for `text/html` and `text/plain` with the processed data.\n * 3. For the `cut` method, calls {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n *    on the current selection.\n *\n * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.\n */\nexport default class ClipboardPipeline extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ClipboardPipeline';\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        view.addObserver(ClipboardObserver);\n        this._setupPasteDrop();\n        this._setupCopyCut();\n    }\n    /**\n     * The clipboard paste pipeline.\n     */\n    _setupPasteDrop() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        // Pasting is disabled when selection is in non-editable place.\n        // Dropping is disabled in drag and drop handler.\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            if (data.method == 'paste' && !editor.model.canEditAt(editor.model.document.selection)) {\n                evt.stop();\n            }\n        }, { priority: 'highest' });\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            const dataTransfer = data.dataTransfer;\n            let content;\n            // Some feature could already inject content in the higher priority event handler (i.e., codeBlock).\n            if (data.content) {\n                content = data.content;\n            }\n            else {\n                let contentData = '';\n                if (dataTransfer.getData('text/html')) {\n                    contentData = normalizeClipboardHtml(dataTransfer.getData('text/html'));\n                }\n                else if (dataTransfer.getData('text/plain')) {\n                    contentData = plainTextToHtml(dataTransfer.getData('text/plain'));\n                }\n                content = this.editor.data.htmlProcessor.toView(contentData);\n            }\n            const eventInfo = new EventInfo(this, 'inputTransformation');\n            this.fire(eventInfo, {\n                content,\n                dataTransfer,\n                targetRanges: data.targetRanges,\n                method: data.method\n            });\n            // If CKEditor handled the input, do not bubble the original event any further.\n            // This helps external integrations recognize this fact and act accordingly.\n            // https://github.com/ckeditor/ckeditor5-upload/issues/92\n            if (eventInfo.stop.called) {\n                evt.stop();\n            }\n            view.scrollToTheSelection();\n        }, { priority: 'low' });\n        this.listenTo(this, 'inputTransformation', (evt, data) => {\n            if (data.content.isEmpty) {\n                return;\n            }\n            const dataController = this.editor.data;\n            // Convert the pasted content into a model document fragment.\n            // The conversion is contextual, but in this case an \"all allowed\" context is needed\n            // and for that we use the $clipboardHolder item.\n            const modelFragment = dataController.toModel(data.content, '$clipboardHolder');\n            if (modelFragment.childCount == 0) {\n                return;\n            }\n            evt.stop();\n            // Fire content insertion event in a single change block to allow other handlers to run in the same block\n            // without post-fixers called in between (i.e., the selection post-fixer).\n            model.change(() => {\n                this.fire('contentInsertion', {\n                    content: modelFragment,\n                    method: data.method,\n                    dataTransfer: data.dataTransfer,\n                    targetRanges: data.targetRanges\n                });\n            });\n        }, { priority: 'low' });\n        this.listenTo(this, 'contentInsertion', (evt, data) => {\n            data.resultRange = model.insertContent(data.content);\n        }, { priority: 'low' });\n    }\n    /**\n     * The clipboard copy/cut pipeline.\n     */\n    _setupCopyCut() {\n        const editor = this.editor;\n        const modelDocument = editor.model.document;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const onCopyCut = (evt, data) => {\n            const dataTransfer = data.dataTransfer;\n            data.preventDefault();\n            const content = editor.data.toView(editor.model.getSelectedContent(modelDocument.selection));\n            viewDocument.fire('clipboardOutput', {\n                dataTransfer,\n                content,\n                method: evt.name\n            });\n        };\n        this.listenTo(viewDocument, 'copy', onCopyCut, { priority: 'low' });\n        this.listenTo(viewDocument, 'cut', (evt, data) => {\n            // Cutting is disabled when selection is in non-editable place.\n            // See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.\n            if (!editor.model.canEditAt(editor.model.document.selection)) {\n                data.preventDefault();\n            }\n            else {\n                onCopyCut(evt, data);\n            }\n        }, { priority: 'low' });\n        this.listenTo(viewDocument, 'clipboardOutput', (evt, data) => {\n            if (!data.content.isEmpty) {\n                data.dataTransfer.setData('text/html', this.editor.data.htmlProcessor.toData(data.content));\n                data.dataTransfer.setData('text/plain', viewToPlainText(data.content));\n            }\n            if (data.method == 'cut') {\n                editor.model.deleteContent(modelDocument.selection);\n            }\n        }, { priority: 'low' });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/dragdrop\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { LiveRange, MouseObserver } from '@ckeditor/ckeditor5-engine';\nimport { Widget, isWidget } from '@ckeditor/ckeditor5-widget';\nimport { env, uid, delay } from '@ckeditor/ckeditor5-utils';\nimport ClipboardPipeline from './clipboardpipeline';\nimport ClipboardObserver from './clipboardobserver';\nimport { throttle } from 'lodash-es';\nimport '../theme/clipboard.css';\n// Drag and drop events overview:\n//\n//                ┌──────────────────┐\n//                │     mousedown    │   Sets the draggable attribute.\n//                └─────────┬────────┘\n//                          │\n//                          └─────────────────────┐\n//                          │                     │\n//                          │           ┌─────────V────────┐\n//                          │           │      mouseup     │   Dragging did not start, removes the draggable attribute.\n//                          │           └──────────────────┘\n//                          │\n//                ┌─────────V────────┐   Retrieves the selected model.DocumentFragment\n//                │     dragstart    │   and converts it to view.DocumentFragment.\n//                └─────────┬────────┘\n//                          │\n//                ┌─────────V────────┐   Processes view.DocumentFragment to text/html and text/plain\n//                │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                └─────────┬────────┘\n//                          │\n//                          │   DOM dragover\n//                          ┌────────────┐\n//                          │            │\n//                ┌─────────V────────┐   │\n//                │     dragging     │   │   Updates the drop target marker.\n//                └─────────┬────────┘   │\n//                          │            │\n//            ┌─────────────└────────────┘\n//            │             │            │\n//            │   ┌─────────V────────┐   │\n//            │   │     dragleave    │   │   Removes the drop target marker.\n//            │   └─────────┬────────┘   │\n//            │             │            │\n//        ┌───│─────────────┘            │\n//        │   │             │            │\n//        │   │   ┌─────────V────────┐   │\n//        │   │   │     dragenter    │   │   Focuses the editor view.\n//        │   │   └─────────┬────────┘   │\n//        │   │             │            │\n//        │   │             └────────────┘\n//        │   │\n//        │   └─────────────┐\n//        │   │             │\n//        │   │   ┌─────────V────────┐\n//        └───┐   │       drop       │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐   Resolves the final data.targetRanges.\n//            │   │  clipboardInput  │   Aborts if dropping on dragged content.\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐\n//            │   │  clipboardInput  │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │ ┌───────────V───────────┐\n//            │ │  inputTransformation  │   (The default handler of the clipboard pipeline).\n//            │ └───────────┬───────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Updates the document selection to drop range.\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   (The default handler of the clipboard pipeline).\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Removes the content from the original range if the insertion was successful.\n//            │  └──────────┬──────────┘\n//            │             │\n//            └─────────────┐\n//                          │\n//                ┌─────────V────────┐\n//                │      dragend     │   Removes the drop marker and cleans the state.\n//                └──────────────────┘\n//\n/**\n * The drag and drop feature. It works on top of the {@link module:clipboard/clipboardpipeline~ClipboardPipeline}.\n *\n * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.\n */\nexport default class DragDrop extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DragDrop';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardPipeline, Widget];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        this._draggedRange = null;\n        this._draggingUid = '';\n        this._draggableElement = null;\n        this._updateDropMarkerThrottled = throttle(targetRange => this._updateDropMarker(targetRange), 40);\n        this._removeDropMarkerDelayed = delay(() => this._removeDropMarker(), 40);\n        this._clearDraggableAttributesDelayed = delay(() => this._clearDraggableAttributes(), 40);\n        if (editor.plugins.has('DragDropExperimental')) {\n            this.forceDisabled('DragDropExperimental');\n            return;\n        }\n        view.addObserver(ClipboardObserver);\n        view.addObserver(MouseObserver);\n        this._setupDragging();\n        this._setupContentInsertionIntegration();\n        this._setupClipboardInputIntegration();\n        this._setupDropMarker();\n        this._setupDraggableAttributeHandling();\n        this.listenTo(editor, 'change:isReadOnly', (evt, name, isReadOnly) => {\n            if (isReadOnly) {\n                this.forceDisabled('readOnlyMode');\n            }\n            else {\n                this.clearForceDisabled('readOnlyMode');\n            }\n        });\n        this.on('change:isEnabled', (evt, name, isEnabled) => {\n            if (!isEnabled) {\n                this._finalizeDragging(false);\n            }\n        });\n        if (env.isAndroid) {\n            this.forceDisabled('noAndroidSupport');\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        if (this._draggedRange) {\n            this._draggedRange.detach();\n            this._draggedRange = null;\n        }\n        this._updateDropMarkerThrottled.cancel();\n        this._removeDropMarkerDelayed.cancel();\n        this._clearDraggableAttributesDelayed.cancel();\n        return super.destroy();\n    }\n    /**\n     * Drag and drop events handling.\n     */\n    _setupDragging() {\n        const editor = this.editor;\n        const model = editor.model;\n        const modelDocument = model.document;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        // The handler for the drag start; it is responsible for setting data transfer object.\n        this.listenTo(viewDocument, 'dragstart', (evt, data) => {\n            const selection = modelDocument.selection;\n            // Don't drag the editable element itself.\n            if (data.target && data.target.is('editableElement')) {\n                data.preventDefault();\n                return;\n            }\n            // TODO we could clone this node somewhere and style it to match editing view but without handles,\n            //  selection outline, WTA buttons, etc.\n            // data.dataTransfer._native.setDragImage( data.domTarget, 0, 0 );\n            // Check if this is dragstart over the widget (but not a nested editable).\n            const draggableWidget = data.target ? findDraggableWidget(data.target) : null;\n            if (draggableWidget) {\n                const modelElement = editor.editing.mapper.toModelElement(draggableWidget);\n                this._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement));\n                // Disable toolbars so they won't obscure the drop area.\n                if (editor.plugins.has('WidgetToolbarRepository')) {\n                    const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');\n                    widgetToolbarRepository.forceDisabled('dragDrop');\n                }\n            }\n            // If this was not a widget we should check if we need to drag some text content.\n            else if (!viewDocument.selection.isCollapsed) {\n                const selectedElement = viewDocument.selection.getSelectedElement();\n                if (!selectedElement || !isWidget(selectedElement)) {\n                    this._draggedRange = LiveRange.fromRange(selection.getFirstRange());\n                }\n            }\n            if (!this._draggedRange) {\n                data.preventDefault();\n                return;\n            }\n            this._draggingUid = uid();\n            const canEditAtDraggedRange = this.isEnabled && editor.model.canEditAt(this._draggedRange);\n            data.dataTransfer.effectAllowed = canEditAtDraggedRange ? 'copyMove' : 'copy';\n            data.dataTransfer.setData('application/ckeditor5-dragging-uid', this._draggingUid);\n            const draggedSelection = model.createSelection(this._draggedRange.toRange());\n            const content = editor.data.toView(model.getSelectedContent(draggedSelection));\n            viewDocument.fire('clipboardOutput', {\n                dataTransfer: data.dataTransfer,\n                content,\n                method: 'dragstart'\n            });\n            if (!canEditAtDraggedRange) {\n                this._draggedRange.detach();\n                this._draggedRange = null;\n                this._draggingUid = '';\n            }\n        }, { priority: 'low' });\n        // The handler for finalizing drag and drop. It should always be triggered after dragging completes\n        // even if it was completed in a different application.\n        // Note: This is not fired if source text node got removed while downcasting a marker.\n        this.listenTo(viewDocument, 'dragend', (evt, data) => {\n            this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == 'move');\n        }, { priority: 'low' });\n        // Dragging over the editable.\n        this.listenTo(viewDocument, 'dragenter', () => {\n            if (!this.isEnabled) {\n                return;\n            }\n            view.focus();\n        });\n        // Dragging out of the editable.\n        this.listenTo(viewDocument, 'dragleave', () => {\n            // We do not know if the mouse left the editor or just some element in it, so let us wait a few milliseconds\n            // to check if 'dragover' is not fired.\n            this._removeDropMarkerDelayed();\n        });\n        // Handler for moving dragged content over the target area.\n        this.listenTo(viewDocument, 'dragging', (evt, data) => {\n            if (!this.isEnabled) {\n                data.dataTransfer.dropEffect = 'none';\n                return;\n            }\n            this._removeDropMarkerDelayed.cancel();\n            const targetRange = findDropTargetRange(editor, data.targetRanges, data.target);\n            // Do not drop if target place is not editable.\n            if (!editor.model.canEditAt(targetRange)) {\n                data.dataTransfer.dropEffect = 'none';\n                return;\n            }\n            // If this is content being dragged from another editor, moving out of current editor instance\n            // is not possible until 'dragend' event case will be fixed.\n            if (!this._draggedRange) {\n                data.dataTransfer.dropEffect = 'copy';\n            }\n            // In Firefox it is already set and effect allowed remains the same as originally set.\n            if (!env.isGecko) {\n                if (data.dataTransfer.effectAllowed == 'copy') {\n                    data.dataTransfer.dropEffect = 'copy';\n                }\n                else if (['all', 'copyMove'].includes(data.dataTransfer.effectAllowed)) {\n                    data.dataTransfer.dropEffect = 'move';\n                }\n            }\n            /* istanbul ignore else -- @preserve */\n            if (targetRange) {\n                this._updateDropMarkerThrottled(targetRange);\n            }\n        }, { priority: 'low' });\n    }\n    /**\n     * Integration with the `clipboardInput` event.\n     */\n    _setupClipboardInputIntegration() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        // Update the event target ranges and abort dropping if dropping over itself.\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            if (data.method != 'drop') {\n                return;\n            }\n            const targetRange = findDropTargetRange(editor, data.targetRanges, data.target);\n            // The dragging markers must be removed after searching for the target range because sometimes\n            // the target lands on the marker itself.\n            this._removeDropMarker();\n            /* istanbul ignore if -- @preserve */\n            if (!targetRange || !editor.model.canEditAt(targetRange)) {\n                this._finalizeDragging(false);\n                evt.stop();\n                return;\n            }\n            // Since we cannot rely on the drag end event, we must check if the local drag range is from the current drag and drop\n            // or it is from some previous not cleared one.\n            if (this._draggedRange && this._draggingUid != data.dataTransfer.getData('application/ckeditor5-dragging-uid')) {\n                this._draggedRange.detach();\n                this._draggedRange = null;\n                this._draggingUid = '';\n            }\n            // Do not do anything if some content was dragged within the same document to the same position.\n            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n            if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {\n                this._finalizeDragging(false);\n                evt.stop();\n                return;\n            }\n            // Override the target ranges with the one adjusted to the best one for a drop.\n            data.targetRanges = [editor.editing.mapper.toViewRange(targetRange)];\n        }, { priority: 'high' });\n    }\n    /**\n     * Integration with the `contentInsertion` event of the clipboard pipeline.\n     */\n    _setupContentInsertionIntegration() {\n        const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);\n        clipboardPipeline.on('contentInsertion', (evt, data) => {\n            if (!this.isEnabled || data.method !== 'drop') {\n                return;\n            }\n            // Update the selection to the target range in the same change block to avoid selection post-fixing\n            // and to be able to clone text attributes for plain text dropping.\n            const ranges = data.targetRanges.map(viewRange => this.editor.editing.mapper.toModelRange(viewRange));\n            this.editor.model.change(writer => writer.setSelection(ranges));\n        }, { priority: 'high' });\n        clipboardPipeline.on('contentInsertion', (evt, data) => {\n            if (!this.isEnabled || data.method !== 'drop') {\n                return;\n            }\n            // Remove dragged range content, remove markers, clean after dragging.\n            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n            // Whether any content was inserted (insertion might fail if the schema is disallowing some elements\n            // (for example an image caption allows only the content of a block but not blocks themselves.\n            // Some integrations might not return valid range (i.e., table pasting).\n            const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;\n            this._finalizeDragging(isSuccess && isMove);\n        }, { priority: 'lowest' });\n    }\n    /**\n     * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.\n     */\n    _setupDraggableAttributeHandling() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        // Add the 'draggable' attribute to the widget while pressing the selection handle.\n        // This is required for widgets to be draggable. In Chrome it will enable dragging text nodes.\n        this.listenTo(viewDocument, 'mousedown', (evt, data) => {\n            // The lack of data can be caused by editor tests firing fake mouse events. This should not occur\n            // in real-life scenarios but this greatly simplifies editor tests that would otherwise fail a lot.\n            if (env.isAndroid || !data) {\n                return;\n            }\n            this._clearDraggableAttributesDelayed.cancel();\n            // Check if this is a mousedown over the widget (but not a nested editable).\n            let draggableElement = findDraggableWidget(data.target);\n            // Note: There is a limitation that if more than a widget is selected (a widget and some text)\n            // and dragging starts on the widget, then only the widget is dragged.\n            // If this was not a widget then we should check if we need to drag some text content.\n            // In Chrome set a 'draggable' attribute on closest editable to allow immediate dragging of the selected text range.\n            // In Firefox this is not needed. In Safari it makes the whole editable draggable (not just textual content).\n            // Disabled in read-only mode because draggable=\"true\" + contenteditable=\"false\" results\n            // in not firing selectionchange event ever, which makes the selection stuck in read-only mode.\n            if (env.isBlink && !draggableElement && !viewDocument.selection.isCollapsed) {\n                const selectedElement = viewDocument.selection.getSelectedElement();\n                if (!selectedElement || !isWidget(selectedElement)) {\n                    const editableElement = viewDocument.selection.editableElement;\n                    if (editableElement && !editableElement.isReadOnly) {\n                        draggableElement = editableElement;\n                    }\n                }\n            }\n            if (draggableElement) {\n                view.change(writer => {\n                    writer.setAttribute('draggable', 'true', draggableElement);\n                });\n                // Keep the reference to the model element in case the view element gets removed while dragging.\n                this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);\n            }\n        });\n        // Remove the draggable attribute in case no dragging started (only mousedown + mouseup).\n        this.listenTo(viewDocument, 'mouseup', () => {\n            if (!env.isAndroid) {\n                this._clearDraggableAttributesDelayed();\n            }\n        });\n    }\n    /**\n     * Removes the `draggable` attribute from the element that was used for dragging.\n     */\n    _clearDraggableAttributes() {\n        const editing = this.editor.editing;\n        editing.view.change(writer => {\n            // Remove 'draggable' attribute.\n            if (this._draggableElement && this._draggableElement.root.rootName != '$graveyard') {\n                writer.removeAttribute('draggable', editing.mapper.toViewElement(this._draggableElement));\n            }\n            this._draggableElement = null;\n        });\n    }\n    /**\n     * Creates downcast conversion for the drop target marker.\n     */\n    _setupDropMarker() {\n        const editor = this.editor;\n        // Drop marker conversion for hovering over widgets.\n        editor.conversion.for('editingDowncast').markerToHighlight({\n            model: 'drop-target',\n            view: {\n                classes: ['ck-clipboard-drop-target-range']\n            }\n        });\n        // Drop marker conversion for in text drop target.\n        editor.conversion.for('editingDowncast').markerToElement({\n            model: 'drop-target',\n            view: (data, { writer }) => {\n                const inText = editor.model.schema.checkChild(data.markerRange.start, '$text');\n                if (!inText) {\n                    return;\n                }\n                return writer.createUIElement('span', { class: 'ck ck-clipboard-drop-target-position' }, function (domDocument) {\n                    const domElement = this.toDomElement(domDocument);\n                    // Using word joiner to make this marker as high as text and also making text not break on marker.\n                    domElement.append('\\u2060', domDocument.createElement('span'), '\\u2060');\n                    return domElement;\n                });\n            }\n        });\n    }\n    /**\n     * Updates the drop target marker to the provided range.\n     *\n     * @param targetRange The range to set the marker to.\n     */\n    _updateDropMarker(targetRange) {\n        const editor = this.editor;\n        const markers = editor.model.markers;\n        editor.model.change(writer => {\n            if (markers.has('drop-target')) {\n                if (!markers.get('drop-target').getRange().isEqual(targetRange)) {\n                    writer.updateMarker('drop-target', { range: targetRange });\n                }\n            }\n            else {\n                writer.addMarker('drop-target', {\n                    range: targetRange,\n                    usingOperation: false,\n                    affectsData: false\n                });\n            }\n        });\n    }\n    /**\n     * Removes the drop target marker.\n     */\n    _removeDropMarker() {\n        const model = this.editor.model;\n        this._removeDropMarkerDelayed.cancel();\n        this._updateDropMarkerThrottled.cancel();\n        if (model.markers.has('drop-target')) {\n            model.change(writer => {\n                writer.removeMarker('drop-target');\n            });\n        }\n    }\n    /**\n     * Deletes the dragged content from its original range and clears the dragging state.\n     *\n     * @param moved Whether the move succeeded.\n     */\n    _finalizeDragging(moved) {\n        const editor = this.editor;\n        const model = editor.model;\n        this._removeDropMarker();\n        this._clearDraggableAttributes();\n        if (editor.plugins.has('WidgetToolbarRepository')) {\n            const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');\n            widgetToolbarRepository.clearForceDisabled('dragDrop');\n        }\n        this._draggingUid = '';\n        if (!this._draggedRange) {\n            return;\n        }\n        // Delete moved content.\n        if (moved && this.isEnabled) {\n            model.deleteContent(model.createSelection(this._draggedRange), { doNotAutoparagraph: true });\n        }\n        this._draggedRange.detach();\n        this._draggedRange = null;\n    }\n}\n/**\n * Returns fixed selection range for given position and target element.\n */\nfunction findDropTargetRange(editor, targetViewRanges, targetViewElement) {\n    const model = editor.model;\n    const mapper = editor.editing.mapper;\n    let range = null;\n    const targetViewPosition = targetViewRanges ? targetViewRanges[0].start : null;\n    // A UIElement is not a valid drop element, use parent (this could be a drop marker or any other UIElement).\n    if (targetViewElement.is('uiElement')) {\n        targetViewElement = targetViewElement.parent;\n    }\n    // Quick win if the target is a widget (but not a nested editable).\n    range = findDropTargetRangeOnWidget(editor, targetViewElement);\n    if (range) {\n        return range;\n    }\n    // The easiest part is over, now we need to move to the model space.\n    // Find target model element and position.\n    const targetModelElement = getClosestMappedModelElement(editor, targetViewElement);\n    const targetModelPosition = targetViewPosition ? mapper.toModelPosition(targetViewPosition) : null;\n    // There is no target position while hovering over an empty table cell.\n    // In Safari, target position can be empty while hovering over a widget (e.g., a page-break).\n    // Find the drop position inside the element.\n    if (!targetModelPosition) {\n        return findDropTargetRangeInElement(editor, targetModelElement);\n    }\n    // Check if target position is between blocks and adjust drop position to the next object.\n    // This is because while hovering over a root element next to a widget the target position can jump in crazy places.\n    range = findDropTargetRangeBetweenBlocks(editor, targetModelPosition, targetModelElement);\n    if (range) {\n        return range;\n    }\n    // Try fixing selection position.\n    // In Firefox, the target position lands before widgets but in other browsers it tends to land after a widget.\n    range = model.schema.getNearestSelectionRange(targetModelPosition, env.isGecko ? 'forward' : 'backward');\n    if (range) {\n        return range;\n    }\n    // There is no valid selection position inside the current limit element so find a closest object ancestor.\n    // This happens if the model position lands directly in the <table> element itself (view target element was a `<td>`\n    // so a nested editable, but view target position was directly in the `<figure>` element).\n    return findDropTargetRangeOnAncestorObject(editor, targetModelPosition.parent);\n}\n/**\n * Returns fixed selection range for a given position and a target element if it is over the widget but not over its nested editable.\n */\nfunction findDropTargetRangeOnWidget(editor, targetViewElement) {\n    const model = editor.model;\n    const mapper = editor.editing.mapper;\n    // Quick win if the target is a widget.\n    if (isWidget(targetViewElement)) {\n        return model.createRangeOn(mapper.toModelElement(targetViewElement));\n    }\n    // Check if we are deeper over a widget (but not over a nested editable).\n    if (!targetViewElement.is('editableElement')) {\n        // Find a closest ancestor that is either a widget or an editable element...\n        const ancestor = targetViewElement.findAncestor(node => isWidget(node) || node.is('editableElement'));\n        // ...and if the widget was closer then it is a drop target.\n        if (isWidget(ancestor)) {\n            return model.createRangeOn(mapper.toModelElement(ancestor));\n        }\n    }\n    return null;\n}\n/**\n * Returns fixed selection range inside a model element.\n */\nfunction findDropTargetRangeInElement(editor, targetModelElement) {\n    const model = editor.model;\n    const schema = model.schema;\n    const positionAtElementStart = model.createPositionAt(targetModelElement, 0);\n    return schema.getNearestSelectionRange(positionAtElementStart, 'forward');\n}\n/**\n * Returns fixed selection range for a given position and a target element if the drop is between blocks.\n */\nfunction findDropTargetRangeBetweenBlocks(editor, targetModelPosition, targetModelElement) {\n    const model = editor.model;\n    // Check if target is between blocks.\n    if (!model.schema.checkChild(targetModelElement, '$block')) {\n        return null;\n    }\n    // Find position between blocks.\n    const positionAtElementStart = model.createPositionAt(targetModelElement, 0);\n    // Get the common part of the path (inside the target element and the target position).\n    const commonPath = targetModelPosition.path.slice(0, positionAtElementStart.path.length);\n    // Position between the blocks.\n    const betweenBlocksPosition = model.createPositionFromPath(targetModelPosition.root, commonPath);\n    const nodeAfter = betweenBlocksPosition.nodeAfter;\n    // Adjust drop position to the next object.\n    // This is because while hovering over a root element next to a widget the target position can jump in crazy places.\n    if (nodeAfter && model.schema.isObject(nodeAfter)) {\n        return model.createRangeOn(nodeAfter);\n    }\n    return null;\n}\n/**\n * Returns a selection range on the ancestor object.\n */\nfunction findDropTargetRangeOnAncestorObject(editor, element) {\n    const model = editor.model;\n    let currentElement = element;\n    while (currentElement) {\n        if (model.schema.isObject(currentElement)) {\n            return model.createRangeOn(currentElement);\n        }\n        currentElement = currentElement.parent;\n    }\n    /* istanbul ignore next -- @preserve */\n    return null;\n}\n/**\n * Returns the closest model element for the specified view element.\n */\nfunction getClosestMappedModelElement(editor, element) {\n    const mapper = editor.editing.mapper;\n    const view = editor.editing.view;\n    const targetModelElement = mapper.toModelElement(element);\n    if (targetModelElement) {\n        return targetModelElement;\n    }\n    // Find mapped ancestor if the target is inside not mapped element (for example inline code element).\n    const viewPosition = view.createPositionBefore(element);\n    const viewElement = mapper.findMappedViewAncestor(viewPosition);\n    return mapper.toModelElement(viewElement);\n}\n/**\n * Returns the drop effect that should be a result of dragging the content.\n * This function is handling a quirk when checking the effect in the 'drop' DOM event.\n */\nfunction getFinalDropEffect(dataTransfer) {\n    if (env.isGecko) {\n        return dataTransfer.dropEffect;\n    }\n    return ['all', 'copyMove'].includes(dataTransfer.effectAllowed) ? 'move' : 'copy';\n}\n/**\n * Returns a widget element that should be dragged.\n */\nfunction findDraggableWidget(target) {\n    // This is directly an editable so not a widget for sure.\n    if (target.is('editableElement')) {\n        return null;\n    }\n    // TODO: Let's have a isWidgetSelectionHandleDomElement() helper in ckeditor5-widget utils.\n    if (target.hasClass('ck-widget__selection-handle')) {\n        return target.findAncestor(isWidget);\n    }\n    // Direct hit on a widget.\n    if (isWidget(target)) {\n        return target;\n    }\n    // Find closest ancestor that is either a widget or an editable element...\n    const ancestor = target.findAncestor(node => isWidget(node) || node.is('editableElement'));\n    // ...and if closer was the widget then enable dragging it.\n    if (isWidget(ancestor)) {\n        return ancestor;\n    }\n    return null;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/pasteplaintext\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport ClipboardObserver from './clipboardobserver';\nimport ClipboardPipeline from './clipboardpipeline';\n/**\n * The plugin detects the user's intention to paste plain text.\n *\n * For example, it detects the <kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd> keystroke.\n */\nexport default class PastePlainText extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'PastePlainText';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardPipeline];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const selection = model.document.selection;\n        let shiftPressed = false;\n        view.addObserver(ClipboardObserver);\n        this.listenTo(viewDocument, 'keydown', (evt, data) => {\n            shiftPressed = data.shiftKey;\n        });\n        editor.plugins.get(ClipboardPipeline).on('contentInsertion', (evt, data) => {\n            // Plain text can be determined based on the event flag (#7799) or auto-detection (#1006). If detected,\n            // preserve selection attributes on pasted items.\n            if (!shiftPressed && !isPlainTextFragment(data.content, model.schema)) {\n                return;\n            }\n            model.change(writer => {\n                // Formatting attributes should be preserved.\n                const textAttributes = Array.from(selection.getAttributes())\n                    .filter(([key]) => model.schema.getAttributeProperties(key).isFormatting);\n                if (!selection.isCollapsed) {\n                    model.deleteContent(selection, { doNotAutoparagraph: true });\n                }\n                // Also preserve other attributes if they survived the content deletion (because they were not fully selected).\n                // For example linkHref is not a formatting attribute but it should be preserved if pasted text was in the middle\n                // of a link.\n                textAttributes.push(...selection.getAttributes());\n                const range = writer.createRangeIn(data.content);\n                for (const item of range.getItems()) {\n                    if (item.is('$textProxy')) {\n                        writer.setAttributes(textAttributes, item);\n                    }\n                }\n            });\n        });\n    }\n}\n/**\n * Returns true if specified `documentFragment` represents a plain text.\n */\nfunction isPlainTextFragment(documentFragment, schema) {\n    if (documentFragment.childCount > 1) {\n        return false;\n    }\n    const child = documentFragment.getChild(0);\n    if (schema.isObject(child)) {\n        return false;\n    }\n    return Array.from(child.getAttributeKeys()).length == 0;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboard\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport ClipboardPipeline from './clipboardpipeline';\nimport DragDrop from './dragdrop';\nimport PastePlainText from './pasteplaintext';\n/**\n * The clipboard feature.\n *\n * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.\n *\n * This is a \"glue\" plugin which loads the following plugins:\n * * {@link module:clipboard/clipboardpipeline~ClipboardPipeline}\n * * {@link module:clipboard/dragdrop~DragDrop}\n * * {@link module:clipboard/pasteplaintext~PastePlainText}\n */\nexport default class Clipboard extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Clipboard';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardPipeline, DragDrop, PastePlainText];\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/lineview\n */\n/* istanbul ignore file -- @preserve */\nimport { View } from '@ckeditor/ckeditor5-ui';\nimport { toUnit } from '@ckeditor/ckeditor5-utils';\nconst toPx = toUnit('px');\n/**\n * The horizontal drop target line view.\n */\nexport default class LineView extends View {\n    /**\n     * @inheritDoc\n     */\n    constructor() {\n        super();\n        const bind = this.bindTemplate;\n        this.set({\n            isVisible: false,\n            left: null,\n            top: null,\n            width: null\n        });\n        this.setTemplate({\n            tag: 'div',\n            attributes: {\n                class: [\n                    'ck',\n                    'ck-clipboard-drop-target-line',\n                    bind.if('isVisible', 'ck-hidden', value => !value)\n                ],\n                style: {\n                    left: bind.to('left', left => toPx(left)),\n                    top: bind.to('top', top => toPx(top)),\n                    width: bind.to('width', width => toPx(width))\n                }\n            }\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/dragdropexperimental\n */\n/* istanbul ignore file -- @preserve */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { LiveRange, MouseObserver } from '@ckeditor/ckeditor5-engine';\nimport { Widget, isWidget } from '@ckeditor/ckeditor5-widget';\nimport { env, uid, global, createElement, DomEmitterMixin, delay } from '@ckeditor/ckeditor5-utils';\nimport ClipboardPipeline from './clipboardpipeline';\nimport ClipboardObserver from './clipboardobserver';\nimport DragDropTarget from './dragdroptarget';\nimport '../theme/clipboard.css';\n// Drag and drop events overview:\n//\n//                ┌──────────────────┐\n//                │     mousedown    │   Sets the draggable attribute.\n//                └─────────┬────────┘\n//                          │\n//                          └─────────────────────┐\n//                          │                     │\n//                          │           ┌─────────V────────┐\n//                          │           │      mouseup     │   Dragging did not start, removes the draggable attribute.\n//                          │           └──────────────────┘\n//                          │\n//                ┌─────────V────────┐   Retrieves the selected model.DocumentFragment\n//                │     dragstart    │   and converts it to view.DocumentFragment.\n//                └─────────┬────────┘\n//                          │\n//                ┌─────────V────────┐   Processes view.DocumentFragment to text/html and text/plain\n//                │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                └─────────┬────────┘\n//                          │\n//                          │   DOM dragover\n//                          ┌────────────┐\n//                          │            │\n//                ┌─────────V────────┐   │\n//                │     dragging     │   │   Updates the drop target marker.\n//                └─────────┬────────┘   │\n//                          │            │\n//            ┌─────────────└────────────┘\n//            │             │            │\n//            │   ┌─────────V────────┐   │\n//            │   │     dragleave    │   │   Removes the drop target marker.\n//            │   └─────────┬────────┘   │\n//            │             │            │\n//        ┌───│─────────────┘            │\n//        │   │             │            │\n//        │   │   ┌─────────V────────┐   │\n//        │   │   │     dragenter    │   │   Focuses the editor view.\n//        │   │   └─────────┬────────┘   │\n//        │   │             │            │\n//        │   │             └────────────┘\n//        │   │\n//        │   └─────────────┐\n//        │   │             │\n//        │   │   ┌─────────V────────┐\n//        └───┐   │       drop       │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐   Resolves the final data.targetRanges.\n//            │   │  clipboardInput  │   Aborts if dropping on dragged content.\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐\n//            │   │  clipboardInput  │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │ ┌───────────V───────────┐\n//            │ │  inputTransformation  │   (The default handler of the clipboard pipeline).\n//            │ └───────────┬───────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Updates the document selection to drop range.\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   (The default handler of the clipboard pipeline).\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Removes the content from the original range if the insertion was successful.\n//            │  └──────────┬──────────┘\n//            │             │\n//            └─────────────┐\n//                          │\n//                ┌─────────V────────┐\n//                │      dragend     │   Removes the drop marker and cleans the state.\n//                └──────────────────┘\n//\n/**\n * The drag and drop feature. It works on top of the {@link module:clipboard/clipboardpipeline~ClipboardPipeline}.\n *\n * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.\n *\n * @internal\n */\nexport default class DragDropExperimental extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * A delayed callback removing draggable attributes.\n         */\n        this._clearDraggableAttributesDelayed = delay(() => this._clearDraggableAttributes(), 40);\n        /**\n         * Whether the dragged content can be dropped only in block context.\n         */\n        // TODO handle drag from other editor instance\n        // TODO configure to use block, inline or both\n        this._blockMode = false;\n        /**\n         * DOM Emitter.\n         */\n        this._domEmitter = new (DomEmitterMixin())();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DragDropExperimental';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardPipeline, Widget, DragDropTarget];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        this._draggedRange = null;\n        this._draggingUid = '';\n        this._draggableElement = null;\n        view.addObserver(ClipboardObserver);\n        view.addObserver(MouseObserver);\n        this._setupDragging();\n        this._setupContentInsertionIntegration();\n        this._setupClipboardInputIntegration();\n        this._setupDraggableAttributeHandling();\n        this.listenTo(editor, 'change:isReadOnly', (evt, name, isReadOnly) => {\n            if (isReadOnly) {\n                this.forceDisabled('readOnlyMode');\n            }\n            else {\n                this.clearForceDisabled('readOnlyMode');\n            }\n        });\n        this.on('change:isEnabled', (evt, name, isEnabled) => {\n            if (!isEnabled) {\n                this._finalizeDragging(false);\n            }\n        });\n        if (env.isAndroid) {\n            this.forceDisabled('noAndroidSupport');\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        if (this._draggedRange) {\n            this._draggedRange.detach();\n            this._draggedRange = null;\n        }\n        if (this._previewContainer) {\n            this._previewContainer.remove();\n        }\n        this._domEmitter.stopListening();\n        this._clearDraggableAttributesDelayed.cancel();\n        return super.destroy();\n    }\n    /**\n     * Drag and drop events handling.\n     */\n    _setupDragging() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const dragDropTarget = editor.plugins.get(DragDropTarget);\n        // The handler for the drag start; it is responsible for setting data transfer object.\n        this.listenTo(viewDocument, 'dragstart', (evt, data) => {\n            // Don't drag the editable element itself.\n            if (data.target && data.target.is('editableElement')) {\n                data.preventDefault();\n                return;\n            }\n            this._prepareDraggedRange(data.target);\n            if (!this._draggedRange) {\n                data.preventDefault();\n                return;\n            }\n            this._draggingUid = uid();\n            data.dataTransfer.effectAllowed = this.isEnabled ? 'copyMove' : 'copy';\n            data.dataTransfer.setData('application/ckeditor5-dragging-uid', this._draggingUid);\n            const draggedSelection = model.createSelection(this._draggedRange.toRange());\n            const content = editor.data.toView(model.getSelectedContent(draggedSelection));\n            viewDocument.fire('clipboardOutput', {\n                dataTransfer: data.dataTransfer,\n                content,\n                method: 'dragstart'\n            });\n            this._updatePreview(data.dataTransfer);\n            data.stopPropagation();\n            if (!this.isEnabled) {\n                this._draggedRange.detach();\n                this._draggedRange = null;\n                this._draggingUid = '';\n            }\n        }, { priority: 'low' });\n        // The handler for finalizing drag and drop. It should always be triggered after dragging completes\n        // even if it was completed in a different application.\n        // Note: This is not fired if source text node got removed while downcasting a marker.\n        this.listenTo(viewDocument, 'dragend', (evt, data) => {\n            this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == 'move');\n        }, { priority: 'low' });\n        // Reset block dragging mode even if dropped outside the editable.\n        this._domEmitter.listenTo(global.document, 'dragend', () => {\n            this._blockMode = false;\n        }, { useCapture: true });\n        // Dragging over the editable.\n        this.listenTo(viewDocument, 'dragenter', () => {\n            if (!this.isEnabled) {\n                return;\n            }\n            view.focus();\n        });\n        // Dragging out of the editable.\n        this.listenTo(viewDocument, 'dragleave', () => {\n            // We do not know if the mouse left the editor or just some element in it, so let us wait a few milliseconds\n            // to check if 'dragover' is not fired.\n            dragDropTarget.removeDropMarkerDelayed();\n        });\n        // Handler for moving dragged content over the target area.\n        this.listenTo(viewDocument, 'dragging', (evt, data) => {\n            if (!this.isEnabled) {\n                data.dataTransfer.dropEffect = 'none';\n                return;\n            }\n            const { clientX, clientY } = data.domEvent;\n            dragDropTarget.updateDropMarker(data.target, data.targetRanges, clientX, clientY, this._blockMode);\n            // If this is content being dragged from another editor, moving out of current editor instance\n            // is not possible until 'dragend' event case will be fixed.\n            if (!this._draggedRange) {\n                data.dataTransfer.dropEffect = 'copy';\n            }\n            // In Firefox it is already set and effect allowed remains the same as originally set.\n            if (!env.isGecko) {\n                if (data.dataTransfer.effectAllowed == 'copy') {\n                    data.dataTransfer.dropEffect = 'copy';\n                }\n                else if (['all', 'copyMove'].includes(data.dataTransfer.effectAllowed)) {\n                    data.dataTransfer.dropEffect = 'move';\n                }\n            }\n            evt.stop();\n        }, { priority: 'low' });\n    }\n    /**\n     * Integration with the `clipboardInput` event.\n     */\n    _setupClipboardInputIntegration() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const dragDropTarget = editor.plugins.get(DragDropTarget);\n        // Update the event target ranges and abort dropping if dropping over itself.\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            if (data.method != 'drop') {\n                return;\n            }\n            const { clientX, clientY } = data.domEvent;\n            const targetRange = dragDropTarget.getFinalDropRange(data.target, data.targetRanges, clientX, clientY, this._blockMode);\n            /* istanbul ignore if -- @preserve */\n            if (!targetRange) {\n                this._finalizeDragging(false);\n                evt.stop();\n                return;\n            }\n            // Since we cannot rely on the drag end event, we must check if the local drag range is from the current drag and drop\n            // or it is from some previous not cleared one.\n            if (this._draggedRange && this._draggingUid != data.dataTransfer.getData('application/ckeditor5-dragging-uid')) {\n                this._draggedRange.detach();\n                this._draggedRange = null;\n                this._draggingUid = '';\n            }\n            // Do not do anything if some content was dragged within the same document to the same position.\n            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n            if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {\n                this._finalizeDragging(false);\n                evt.stop();\n                return;\n            }\n            // Override the target ranges with the one adjusted to the best one for a drop.\n            data.targetRanges = [editor.editing.mapper.toViewRange(targetRange)];\n        }, { priority: 'high' });\n    }\n    /**\n     * Integration with the `contentInsertion` event of the clipboard pipeline.\n     */\n    _setupContentInsertionIntegration() {\n        const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);\n        clipboardPipeline.on('contentInsertion', (evt, data) => {\n            if (!this.isEnabled || data.method !== 'drop') {\n                return;\n            }\n            // Update the selection to the target range in the same change block to avoid selection post-fixing\n            // and to be able to clone text attributes for plain text dropping.\n            const ranges = data.targetRanges.map(viewRange => this.editor.editing.mapper.toModelRange(viewRange));\n            this.editor.model.change(writer => writer.setSelection(ranges));\n        }, { priority: 'high' });\n        clipboardPipeline.on('contentInsertion', (evt, data) => {\n            if (!this.isEnabled || data.method !== 'drop') {\n                return;\n            }\n            // Remove dragged range content, remove markers, clean after dragging.\n            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n            // Whether any content was inserted (insertion might fail if the schema is disallowing some elements\n            // (for example an image caption allows only the content of a block but not blocks themselves.\n            // Some integrations might not return valid range (i.e., table pasting).\n            const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;\n            this._finalizeDragging(isSuccess && isMove);\n        }, { priority: 'lowest' });\n    }\n    /**\n     * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.\n     */\n    _setupDraggableAttributeHandling() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        // Add the 'draggable' attribute to the widget while pressing the selection handle.\n        // This is required for widgets to be draggable. In Chrome it will enable dragging text nodes.\n        this.listenTo(viewDocument, 'mousedown', (evt, data) => {\n            // The lack of data can be caused by editor tests firing fake mouse events. This should not occur\n            // in real-life scenarios but this greatly simplifies editor tests that would otherwise fail a lot.\n            if (env.isAndroid || !data) {\n                return;\n            }\n            this._clearDraggableAttributesDelayed.cancel();\n            // Check if this is a mousedown over the widget (but not a nested editable).\n            let draggableElement = findDraggableWidget(data.target);\n            // Note: There is a limitation that if more than a widget is selected (a widget and some text)\n            // and dragging starts on the widget, then only the widget is dragged.\n            // If this was not a widget then we should check if we need to drag some text content.\n            // In Chrome set a 'draggable' attribute on closest editable to allow immediate dragging of the selected text range.\n            // In Firefox this is not needed. In Safari it makes the whole editable draggable (not just textual content).\n            // Disabled in read-only mode because draggable=\"true\" + contenteditable=\"false\" results\n            // in not firing selectionchange event ever, which makes the selection stuck in read-only mode.\n            if (env.isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {\n                const selectedElement = viewDocument.selection.getSelectedElement();\n                if (!selectedElement || !isWidget(selectedElement)) {\n                    draggableElement = viewDocument.selection.editableElement;\n                }\n            }\n            if (draggableElement) {\n                view.change(writer => {\n                    writer.setAttribute('draggable', 'true', draggableElement);\n                });\n                // Keep the reference to the model element in case the view element gets removed while dragging.\n                this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);\n            }\n        });\n        // Remove the draggable attribute in case no dragging started (only mousedown + mouseup).\n        this.listenTo(viewDocument, 'mouseup', () => {\n            if (!env.isAndroid) {\n                this._clearDraggableAttributesDelayed();\n            }\n        });\n    }\n    /**\n     * Removes the `draggable` attribute from the element that was used for dragging.\n     */\n    _clearDraggableAttributes() {\n        const editing = this.editor.editing;\n        editing.view.change(writer => {\n            // Remove 'draggable' attribute.\n            if (this._draggableElement && this._draggableElement.root.rootName != '$graveyard') {\n                writer.removeAttribute('draggable', editing.mapper.toViewElement(this._draggableElement));\n            }\n            this._draggableElement = null;\n        });\n    }\n    /**\n     * Deletes the dragged content from its original range and clears the dragging state.\n     *\n     * @param moved Whether the move succeeded.\n     */\n    _finalizeDragging(moved) {\n        const editor = this.editor;\n        const model = editor.model;\n        const dragDropTarget = editor.plugins.get(DragDropTarget);\n        dragDropTarget.removeDropMarker();\n        this._clearDraggableAttributes();\n        if (editor.plugins.has('WidgetToolbarRepository')) {\n            const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');\n            widgetToolbarRepository.clearForceDisabled('dragDrop');\n        }\n        this._draggingUid = '';\n        if (this._previewContainer) {\n            this._previewContainer.remove();\n            this._previewContainer = undefined;\n        }\n        if (!this._draggedRange) {\n            return;\n        }\n        // Delete moved content.\n        if (moved && this.isEnabled) {\n            model.deleteContent(model.createSelection(this._draggedRange), { doNotAutoparagraph: true });\n        }\n        this._draggedRange.detach();\n        this._draggedRange = null;\n    }\n    /**\n     * Sets the dragged source range based on event target and document selection.\n     */\n    _prepareDraggedRange(target) {\n        const editor = this.editor;\n        const model = editor.model;\n        const selection = model.document.selection;\n        // Check if this is dragstart over the widget (but not a nested editable).\n        const draggableWidget = target ? findDraggableWidget(target) : null;\n        if (draggableWidget) {\n            const modelElement = editor.editing.mapper.toModelElement(draggableWidget);\n            this._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement));\n            this._blockMode = model.schema.isBlock(modelElement);\n            // Disable toolbars so they won't obscure the drop area.\n            if (editor.plugins.has('WidgetToolbarRepository')) {\n                const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');\n                widgetToolbarRepository.forceDisabled('dragDrop');\n            }\n        }\n        // If this was not a widget we should check if we need to drag some text content.\n        else if (!selection.isCollapsed || selection.getFirstPosition().parent.isEmpty) {\n            const blocks = Array.from(selection.getSelectedBlocks());\n            if (blocks.length > 1) {\n                this._draggedRange = LiveRange.fromRange(model.createRange(model.createPositionBefore(blocks[0]), model.createPositionAfter(blocks[blocks.length - 1])));\n                model.change(writer => writer.setSelection(this._draggedRange.toRange()));\n                this._blockMode = true;\n                // TODO block mode for dragging from outside editor? or inline? or both?\n            }\n            else if (blocks.length == 1) {\n                const draggedRange = selection.getFirstRange();\n                const blockRange = model.createRange(model.createPositionBefore(blocks[0]), model.createPositionAfter(blocks[0]));\n                if (draggedRange.start.isTouching(blockRange.start) &&\n                    draggedRange.end.isTouching(blockRange.end)) {\n                    this._draggedRange = LiveRange.fromRange(blockRange);\n                    this._blockMode = true;\n                }\n                else {\n                    this._draggedRange = LiveRange.fromRange(selection.getFirstRange());\n                    this._blockMode = false;\n                }\n            }\n        }\n    }\n    /**\n     * Updates the dragged preview image.\n     */\n    _updatePreview(dataTransfer) {\n        const view = this.editor.editing.view;\n        const editable = view.document.selection.editableElement;\n        const domEditable = view.domConverter.mapViewToDom(editable);\n        const computedStyle = global.window.getComputedStyle(domEditable);\n        if (!this._previewContainer) {\n            this._previewContainer = createElement(global.document, 'div', {\n                style: 'position: fixed; left: -999999px;'\n            });\n            global.document.body.appendChild(this._previewContainer);\n        }\n        else {\n            this._previewContainer.removeChild(this._previewContainer.firstElementChild);\n        }\n        const preview = createElement(global.document, 'div');\n        preview.className = 'ck ck-content';\n        preview.style.width = computedStyle.width;\n        preview.innerHTML = dataTransfer.getData('text/html');\n        dataTransfer.setDragImage(preview, 0, 0);\n        // TODO set x to make dragged widget stick to the mouse cursor\n        this._previewContainer.appendChild(preview);\n    }\n}\n/**\n * Returns the drop effect that should be a result of dragging the content.\n * This function is handling a quirk when checking the effect in the 'drop' DOM event.\n */\nfunction getFinalDropEffect(dataTransfer) {\n    if (env.isGecko) {\n        return dataTransfer.dropEffect;\n    }\n    return ['all', 'copyMove'].includes(dataTransfer.effectAllowed) ? 'move' : 'copy';\n}\n/**\n * Returns a widget element that should be dragged.\n */\nfunction findDraggableWidget(target) {\n    // This is directly an editable so not a widget for sure.\n    if (target.is('editableElement')) {\n        return null;\n    }\n    // TODO: Let's have a isWidgetSelectionHandleDomElement() helper in ckeditor5-widget utils.\n    if (target.hasClass('ck-widget__selection-handle')) {\n        return target.findAncestor(isWidget);\n    }\n    // Direct hit on a widget.\n    if (isWidget(target)) {\n        return target;\n    }\n    // Find closest ancestor that is either a widget or an editable element...\n    const ancestor = target.findAncestor(node => isWidget(node) || node.is('editableElement'));\n    // ...and if closer was the widget then enable dragging it.\n    if (isWidget(ancestor)) {\n        return ancestor;\n    }\n    return null;\n}\n"],
  "mappings": "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",
  "names": []
}
