import "./chunk-LTAT4F5Y.js";
import "./chunk-6LVMAMLV.js";
import {
  CKEditorError,
  ContextPlugin,
  EmitterMixin,
  ObservableMixin
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-cloud-services/src/token/token.js
var DEFAULT_OPTIONS = { autoRefresh: true };
var DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME = 36e5;
var Token = class _Token extends ObservableMixin() {
  /**
   * Creates `Token` instance.
   * Method `init` should be called after using the constructor or use `create` method instead.
   *
   * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
   * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
   */
  constructor(tokenUrlOrRefreshToken, options = {}) {
    super();
    if (!tokenUrlOrRefreshToken) {
      throw new CKEditorError("token-missing-token-url", this);
    }
    if (options.initValue) {
      this._validateTokenValue(options.initValue);
    }
    this.set("value", options.initValue);
    if (typeof tokenUrlOrRefreshToken === "function") {
      this._refresh = tokenUrlOrRefreshToken;
    } else {
      this._refresh = () => defaultRefreshToken(tokenUrlOrRefreshToken);
    }
    this._options = { ...DEFAULT_OPTIONS, ...options };
  }
  /**
   * Initializes the token.
   */
  init() {
    return new Promise((resolve, reject) => {
      if (!this.value) {
        this.refreshToken().then(resolve).catch(reject);
        return;
      }
      if (this._options.autoRefresh) {
        this._registerRefreshTokenTimeout();
      }
      resolve(this);
    });
  }
  /**
   * Refresh token method. Useful in a method form as it can be override in tests.
   */
  refreshToken() {
    return this._refresh().then((value) => {
      this._validateTokenValue(value);
      this.set("value", value);
      if (this._options.autoRefresh) {
        this._registerRefreshTokenTimeout();
      }
      return this;
    });
  }
  /**
   * Destroys token instance. Stops refreshing.
   */
  destroy() {
    clearTimeout(this._tokenRefreshTimeout);
  }
  /**
   * Checks whether the provided token follows the JSON Web Tokens (JWT) format.
   *
   * @param tokenValue The token to validate.
   */
  _validateTokenValue(tokenValue) {
    const isString = typeof tokenValue === "string";
    const isPlainString = !/^".*"$/.test(tokenValue);
    const isJWTFormat = isString && tokenValue.split(".").length === 3;
    if (!(isPlainString && isJWTFormat)) {
      throw new CKEditorError("token-not-in-jwt-format", this);
    }
  }
  /**
   * Registers a refresh token timeout for the time taken from token.
   */
  _registerRefreshTokenTimeout() {
    const tokenRefreshTimeoutTime = this._getTokenRefreshTimeoutTime();
    clearTimeout(this._tokenRefreshTimeout);
    this._tokenRefreshTimeout = setTimeout(() => {
      this.refreshToken();
    }, tokenRefreshTimeoutTime);
  }
  /**
   * Returns token refresh timeout time calculated from expire time in the token payload.
   *
   * If the token parse fails or the token payload doesn't contain, the default DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME is returned.
   */
  _getTokenRefreshTimeoutTime() {
    try {
      const [, binaryTokenPayload] = this.value.split(".");
      const { exp: tokenExpireTime } = JSON.parse(atob(binaryTokenPayload));
      if (!tokenExpireTime) {
        return DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME;
      }
      const tokenRefreshTimeoutTime = Math.floor((tokenExpireTime * 1e3 - Date.now()) / 2);
      return tokenRefreshTimeoutTime;
    } catch (err) {
      return DEFAULT_TOKEN_REFRESH_TIMEOUT_TIME;
    }
  }
  /**
   * Creates a initialized {@link module:cloud-services/token/token~Token} instance.
   *
   * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
   * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
   */
  static create(tokenUrlOrRefreshToken, options = {}) {
    const token = new _Token(tokenUrlOrRefreshToken, options);
    return token.init();
  }
};
function defaultRefreshToken(tokenUrl) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", tokenUrl);
    xhr.addEventListener("load", () => {
      const statusCode = xhr.status;
      const xhrResponse = xhr.response;
      if (statusCode < 200 || statusCode > 299) {
        return reject(new CKEditorError("token-cannot-download-new-token", null));
      }
      return resolve(xhrResponse);
    });
    xhr.addEventListener("error", () => reject(new Error("Network Error")));
    xhr.addEventListener("abort", () => reject(new Error("Abort")));
    xhr.send();
  });
}

// node_modules/@ckeditor/ckeditor5-cloud-services/src/uploadgateway/fileuploader.js
var BASE64_HEADER_REG_EXP = /^data:(\S*?);base64,/;
var FileUploader = class extends EmitterMixin() {
  /**
   * Creates `FileUploader` instance.
   *
   * @param fileOrData A blob object or a data string encoded with Base64.
   * @param token Token used for authentication.
   * @param apiAddress API address.
   */
  constructor(fileOrData, token, apiAddress) {
    super();
    if (!fileOrData) {
      throw new CKEditorError("fileuploader-missing-file", null);
    }
    if (!token) {
      throw new CKEditorError("fileuploader-missing-token", null);
    }
    if (!apiAddress) {
      throw new CKEditorError("fileuploader-missing-api-address", null);
    }
    this.file = _isBase64(fileOrData) ? _base64ToBlob(fileOrData) : fileOrData;
    this._token = token;
    this._apiAddress = apiAddress;
  }
  /**
   * Registers callback on `progress` event.
   */
  onProgress(callback) {
    this.on("progress", (event, data) => callback(data));
    return this;
  }
  /**
   * Registers callback on `error` event. Event is called once when error occurs.
   */
  onError(callback) {
    this.once("error", (event, data) => callback(data));
    return this;
  }
  /**
   * Aborts upload process.
   */
  abort() {
    this.xhr.abort();
  }
  /**
   * Sends XHR request to API.
   */
  send() {
    this._prepareRequest();
    this._attachXHRListeners();
    return this._sendRequest();
  }
  /**
   * Prepares XHR request.
   */
  _prepareRequest() {
    const xhr = new XMLHttpRequest();
    xhr.open("POST", this._apiAddress);
    xhr.setRequestHeader("Authorization", this._token.value);
    xhr.responseType = "json";
    this.xhr = xhr;
  }
  /**
   * Attaches listeners to the XHR.
   */
  _attachXHRListeners() {
    const xhr = this.xhr;
    const onError = (message) => {
      return () => this.fire("error", message);
    };
    xhr.addEventListener("error", onError("Network Error"));
    xhr.addEventListener("abort", onError("Abort"));
    if (xhr.upload) {
      xhr.upload.addEventListener("progress", (event) => {
        if (event.lengthComputable) {
          this.fire("progress", {
            total: event.total,
            uploaded: event.loaded
          });
        }
      });
    }
    xhr.addEventListener("load", () => {
      const statusCode = xhr.status;
      const xhrResponse = xhr.response;
      if (statusCode < 200 || statusCode > 299) {
        return this.fire("error", xhrResponse.message || xhrResponse.error);
      }
    });
  }
  /**
   * Sends XHR request.
   */
  _sendRequest() {
    const formData = new FormData();
    const xhr = this.xhr;
    formData.append("file", this.file);
    return new Promise((resolve, reject) => {
      xhr.addEventListener("load", () => {
        const statusCode = xhr.status;
        const xhrResponse = xhr.response;
        if (statusCode < 200 || statusCode > 299) {
          if (xhrResponse.message) {
            return reject(new CKEditorError("fileuploader-uploading-data-failed", this, { message: xhrResponse.message }));
          }
          return reject(xhrResponse.error);
        }
        return resolve(xhrResponse);
      });
      xhr.addEventListener("error", () => reject(new Error("Network Error")));
      xhr.addEventListener("abort", () => reject(new Error("Abort")));
      xhr.send(formData);
    });
  }
};
function _base64ToBlob(base64, sliceSize = 512) {
  try {
    const contentType = base64.match(BASE64_HEADER_REG_EXP)[1];
    const base64Data = atob(base64.replace(BASE64_HEADER_REG_EXP, ""));
    const byteArrays = [];
    for (let offset = 0; offset < base64Data.length; offset += sliceSize) {
      const slice = base64Data.slice(offset, offset + sliceSize);
      const byteNumbers = new Array(slice.length);
      for (let i = 0; i < slice.length; i++) {
        byteNumbers[i] = slice.charCodeAt(i);
      }
      byteArrays.push(new Uint8Array(byteNumbers));
    }
    return new Blob(byteArrays, { type: contentType });
  } catch (error) {
    throw new CKEditorError("fileuploader-decoding-image-data-error", null);
  }
}
function _isBase64(string) {
  if (typeof string !== "string") {
    return false;
  }
  const match = string.match(BASE64_HEADER_REG_EXP);
  return !!(match && match.length);
}

// node_modules/@ckeditor/ckeditor5-cloud-services/src/uploadgateway/uploadgateway.js
var UploadGateway = class {
  /**
   * Creates `UploadGateway` instance.
   *
   * @param token Token used for authentication.
   * @param apiAddress API address.
   */
  constructor(token, apiAddress) {
    if (!token) {
      throw new CKEditorError("uploadgateway-missing-token", null);
    }
    if (!apiAddress) {
      throw new CKEditorError("uploadgateway-missing-api-address", null);
    }
    this._token = token;
    this._apiAddress = apiAddress;
  }
  /**
   * Creates a {@link module:cloud-services/uploadgateway/fileuploader~FileUploader} instance that wraps
   * file upload process. The file is being sent at a time when the
   * {@link module:cloud-services/uploadgateway/fileuploader~FileUploader#send} method is called.
   *
   * ```ts
   * const token = await Token.create( 'https://token-endpoint' );
   * new UploadGateway( token, 'https://example.org' )
   * 	.upload( 'FILE' )
   * 	.onProgress( ( data ) => console.log( data ) )
   * 	.send()
   * 	.then( ( response ) => console.log( response ) );
   * ```
   *
   * @param {Blob|String} fileOrData A blob object or a data string encoded with Base64.
   * @returns {module:cloud-services/uploadgateway/fileuploader~FileUploader} Returns `FileUploader` instance.
   */
  upload(fileOrData) {
    return new FileUploader(fileOrData, this._token, this._apiAddress);
  }
};

// node_modules/@ckeditor/ckeditor5-cloud-services/src/cloudservicescore.js
var CloudServicesCore = class extends ContextPlugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CloudServicesCore";
  }
  /**
   * Creates the {@link module:cloud-services/token/token~Token} instance.
   *
   * @param tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
   * value is a function it has to match the {@link module:cloud-services/token/token~Token#refreshToken} interface.
   * @param options.initValue Initial value of the token.
   * @param options.autoRefresh Specifies whether to start the refresh automatically.
   */
  createToken(tokenUrlOrRefreshToken, options) {
    return new Token(tokenUrlOrRefreshToken, options);
  }
  /**
   * Creates the {@link module:cloud-services/uploadgateway/uploadgateway~UploadGateway} instance.
   *
   * @param token Token used for authentication.
   * @param apiAddress API address.
   */
  createUploadGateway(token, apiAddress) {
    return new UploadGateway(token, apiAddress);
  }
};

// node_modules/@ckeditor/ckeditor5-cloud-services/src/cloudservices.js
var CloudServices = class extends ContextPlugin {
  constructor() {
    super(...arguments);
    this.token = null;
    this._tokens = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CloudServices";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [CloudServicesCore];
  }
  /**
   * @inheritDoc
   */
  async init() {
    const config = this.context.config;
    const options = config.get("cloudServices") || {};
    for (const [key, value] of Object.entries(options)) {
      this[key] = value;
    }
    if (!this.tokenUrl) {
      this.token = null;
      return;
    }
    const cloudServicesCore = this.context.plugins.get("CloudServicesCore");
    this.token = await cloudServicesCore.createToken(this.tokenUrl).init();
    this._tokens.set(this.tokenUrl, this.token);
  }
  /**
   * Registers an additional authentication token URL for CKEditor Cloud Services or a callback to the token value promise. See the
   * {@link module:cloud-services/cloudservicesconfig~CloudServicesConfig#tokenUrl} for more details.
   *
   * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
   */
  async registerTokenUrl(tokenUrl) {
    if (this._tokens.has(tokenUrl)) {
      return this.getTokenFor(tokenUrl);
    }
    const cloudServicesCore = this.context.plugins.get("CloudServicesCore");
    const token = await cloudServicesCore.createToken(tokenUrl).init();
    this._tokens.set(tokenUrl, token);
    return token;
  }
  /**
   * Returns an authentication token provider previously registered by {@link #registerTokenUrl}.
   *
   * @param tokenUrl The authentication token URL for CKEditor Cloud Services or a callback to the token value promise.
   */
  getTokenFor(tokenUrl) {
    const token = this._tokens.get(tokenUrl);
    if (!token) {
      throw new CKEditorError("cloudservices-token-not-registered", this);
    }
    return token;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    for (const token of this._tokens.values()) {
      token.destroy();
    }
  }
};
export {
  CloudServices,
  CloudServicesCore
};
/*! Bundled license information:

@ckeditor/ckeditor5-cloud-services/src/token/token.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-cloud-services/src/uploadgateway/fileuploader.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-cloud-services/src/uploadgateway/uploadgateway.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-cloud-services/src/cloudservicescore.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-cloud-services/src/cloudservices.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-cloud-services/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-cloud-services/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-cloud-services.js.map
