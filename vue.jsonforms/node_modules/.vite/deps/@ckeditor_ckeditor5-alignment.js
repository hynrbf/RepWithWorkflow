import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  ButtonView,
  addToolbarToDropdown,
  createDropdown
} from "./chunk-SGTDNT4V.js";
import "./chunk-6LVMAMLV.js";
import {
  CKEditorError,
  Command,
  Plugin,
  first,
  icons,
  logWarning
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-alignment/src/utils.js
var supportedOptions = ["left", "right", "center", "justify"];
function isSupported(option) {
  return supportedOptions.includes(option);
}
function isDefault(alignment, locale) {
  if (locale.contentLanguageDirection == "rtl") {
    return alignment === "right";
  } else {
    return alignment === "left";
  }
}
function normalizeAlignmentOptions(configuredOptions) {
  const normalizedOptions = configuredOptions.map((option) => {
    let result;
    if (typeof option == "string") {
      result = { name: option };
    } else {
      result = option;
    }
    return result;
  }).filter((option) => {
    const isNameValid = supportedOptions.includes(option.name);
    if (!isNameValid) {
      logWarning("alignment-config-name-not-recognized", { option });
    }
    return isNameValid;
  });
  const classNameCount = normalizedOptions.filter((option) => Boolean(option.className)).length;
  if (classNameCount && classNameCount < normalizedOptions.length) {
    throw new CKEditorError("alignment-config-classnames-are-missing", { configuredOptions });
  }
  normalizedOptions.forEach((option, index, allOptions) => {
    const succeedingOptions = allOptions.slice(index + 1);
    const nameAlreadyExists = succeedingOptions.some((item) => item.name == option.name);
    if (nameAlreadyExists) {
      throw new CKEditorError("alignment-config-name-already-defined", { option, configuredOptions });
    }
    if (option.className) {
      const classNameAlreadyExists = succeedingOptions.some((item) => item.className == option.className);
      if (classNameAlreadyExists) {
        throw new CKEditorError("alignment-config-classname-already-defined", { option, configuredOptions });
      }
    }
  });
  return normalizedOptions;
}

// node_modules/@ckeditor/ckeditor5-alignment/src/alignmentcommand.js
var ALIGNMENT = "alignment";
var AlignmentCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const locale = editor.locale;
    const firstBlock = first(this.editor.model.document.selection.getSelectedBlocks());
    this.isEnabled = Boolean(firstBlock) && this._canBeAligned(firstBlock);
    if (this.isEnabled && firstBlock.hasAttribute("alignment")) {
      this.value = firstBlock.getAttribute("alignment");
    } else {
      this.value = locale.contentLanguageDirection === "rtl" ? "right" : "left";
    }
  }
  /**
   * Executes the command. Applies the alignment `value` to the selected blocks.
   * If no `value` is passed, the `value` is the default one or it is equal to the currently selected block's alignment attribute,
   * the command will remove the attribute from the selected blocks.
   *
   * @param options Options for the executed command.
   * @param options.value The value to apply.
   * @fires execute
   */
  execute(options = {}) {
    const editor = this.editor;
    const locale = editor.locale;
    const model = editor.model;
    const doc = model.document;
    const value = options.value;
    model.change((writer) => {
      const blocks = Array.from(doc.selection.getSelectedBlocks()).filter((block) => this._canBeAligned(block));
      const currentAlignment = blocks[0].getAttribute("alignment");
      const removeAlignment = isDefault(value, locale) || currentAlignment === value || !value;
      if (removeAlignment) {
        removeAlignmentFromSelection(blocks, writer);
      } else {
        setAlignmentOnSelection(blocks, writer, value);
      }
    });
  }
  /**
   * Checks whether a block can have alignment set.
   *
   * @param block The block to be checked.
   */
  _canBeAligned(block) {
    return this.editor.model.schema.checkAttribute(block, ALIGNMENT);
  }
};
function removeAlignmentFromSelection(blocks, writer) {
  for (const block of blocks) {
    writer.removeAttribute(ALIGNMENT, block);
  }
}
function setAlignmentOnSelection(blocks, writer, alignment) {
  for (const block of blocks) {
    writer.setAttribute(ALIGNMENT, alignment, block);
  }
}

// node_modules/@ckeditor/ckeditor5-alignment/src/alignmentediting.js
var AlignmentEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AlignmentEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("alignment", {
      options: supportedOptions.map((option) => ({ name: option }))
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const locale = editor.locale;
    const schema = editor.model.schema;
    const options = normalizeAlignmentOptions(editor.config.get("alignment.options"));
    const optionsToConvert = options.filter((option) => isSupported(option.name) && !isDefault(option.name, locale));
    const shouldUseClasses = optionsToConvert.some((option) => !!option.className);
    schema.extend("$block", { allowAttributes: "alignment" });
    editor.model.schema.setAttributeProperties("alignment", { isFormatting: true });
    if (shouldUseClasses) {
      editor.conversion.attributeToAttribute(buildClassDefinition(optionsToConvert));
    } else {
      editor.conversion.for("downcast").attributeToAttribute(buildDowncastInlineDefinition(optionsToConvert));
    }
    const upcastInlineDefinitions = buildUpcastInlineDefinitions(optionsToConvert);
    for (const definition of upcastInlineDefinitions) {
      editor.conversion.for("upcast").attributeToAttribute(definition);
    }
    const upcastCompatibilityDefinitions = buildUpcastCompatibilityDefinitions(optionsToConvert);
    for (const definition of upcastCompatibilityDefinitions) {
      editor.conversion.for("upcast").attributeToAttribute(definition);
    }
    editor.commands.add("alignment", new AlignmentCommand(editor));
  }
};
function buildDowncastInlineDefinition(options) {
  const view = {};
  for (const { name } of options) {
    view[name] = {
      key: "style",
      value: {
        "text-align": name
      }
    };
  }
  const definition = {
    model: {
      key: "alignment",
      values: options.map((option) => option.name)
    },
    view
  };
  return definition;
}
function buildUpcastInlineDefinitions(options) {
  const definitions = [];
  for (const { name } of options) {
    definitions.push({
      view: {
        key: "style",
        value: {
          "text-align": name
        }
      },
      model: {
        key: "alignment",
        value: name
      }
    });
  }
  return definitions;
}
function buildUpcastCompatibilityDefinitions(options) {
  const definitions = [];
  for (const { name } of options) {
    definitions.push({
      view: {
        key: "align",
        value: name
      },
      model: {
        key: "alignment",
        value: name
      }
    });
  }
  return definitions;
}
function buildClassDefinition(options) {
  const view = {};
  for (const option of options) {
    view[option.name] = {
      key: "class",
      value: option.className
    };
  }
  const definition = {
    model: {
      key: "alignment",
      values: options.map((option) => option.name)
    },
    view
  };
  return definition;
}

// node_modules/@ckeditor/ckeditor5-alignment/src/alignmentui.js
var iconsMap = /* @__PURE__ */ new Map([
  ["left", icons.alignLeft],
  ["right", icons.alignRight],
  ["center", icons.alignCenter],
  ["justify", icons.alignJustify]
]);
var AlignmentUI = class extends Plugin {
  /**
   * Returns the localized option titles provided by the plugin.
   *
   * The following localized titles corresponding with
   * {@link module:alignment/alignmentconfig~AlignmentConfig#options} are available:
   *
   * * `'left'`,
   * * `'right'`,
   * * `'center'`,
   * * `'justify'`.
   *
   * @readonly
   */
  get localizedOptionTitles() {
    const t = this.editor.t;
    return {
      "left": t("Align left"),
      "right": t("Align right"),
      "center": t("Align center"),
      "justify": t("Justify")
    };
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AlignmentUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const componentFactory = editor.ui.componentFactory;
    const t = editor.t;
    const options = normalizeAlignmentOptions(editor.config.get("alignment.options"));
    options.map((option) => option.name).filter(isSupported).forEach((option) => this._addButton(option));
    componentFactory.add("alignment", (locale) => {
      const dropdownView = createDropdown(locale);
      addToolbarToDropdown(dropdownView, () => options.map((option) => componentFactory.create(`alignment:${option.name}`)), {
        enableActiveItemFocusOnDropdownOpen: true,
        isVertical: true,
        ariaLabel: t("Text alignment toolbar")
      });
      dropdownView.buttonView.set({
        label: t("Text alignment"),
        tooltip: true
      });
      dropdownView.extendTemplate({
        attributes: {
          class: "ck-alignment-dropdown"
        }
      });
      const defaultIcon = locale.contentLanguageDirection === "rtl" ? iconsMap.get("right") : iconsMap.get("left");
      const command = editor.commands.get("alignment");
      dropdownView.buttonView.bind("icon").to(command, "value", (value) => iconsMap.get(value) || defaultIcon);
      dropdownView.bind("isEnabled").to(command, "isEnabled");
      this.listenTo(dropdownView, "execute", () => {
        editor.editing.view.focus();
      });
      return dropdownView;
    });
  }
  /**
   * Helper method for initializing the button and linking it with an appropriate command.
   *
   * @param option The name of the alignment option for which the button is added.
   */
  _addButton(option) {
    const editor = this.editor;
    editor.ui.componentFactory.add(`alignment:${option}`, (locale) => {
      const command = editor.commands.get("alignment");
      const buttonView = new ButtonView(locale);
      buttonView.set({
        label: this.localizedOptionTitles[option],
        icon: iconsMap.get(option),
        tooltip: true,
        isToggleable: true
      });
      buttonView.bind("isEnabled").to(command);
      buttonView.bind("isOn").to(command, "value", (value) => value === option);
      this.listenTo(buttonView, "execute", () => {
        editor.execute("alignment", { value: option });
        editor.editing.view.focus();
      });
      return buttonView;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-alignment/src/alignment.js
var Alignment = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [AlignmentEditing, AlignmentUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Alignment";
  }
};
export {
  Alignment,
  AlignmentEditing,
  AlignmentUI
};
/*! Bundled license information:

@ckeditor/ckeditor5-alignment/src/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-alignment/src/alignmentcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-alignment/src/alignmentediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-alignment/src/alignmentui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-alignment/src/alignment.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-alignment/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-alignment/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-alignment.js.map
