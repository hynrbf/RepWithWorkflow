import "./chunk-DEIZSOIF.js";
import "./chunk-U6D4LCQC.js";
import {
  Enter
} from "./chunk-GGCPNJOL.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  ButtonView,
  FocusCycler,
  LabeledFieldView,
  SplitButtonView,
  SwitchButtonView,
  View,
  ViewCollection,
  addKeyboardHandlingForGrid,
  createDropdown,
  createLabeledInputNumber,
  focusChildOnDropdownOpen
} from "./chunk-SGTDNT4V.js";
import "./chunk-W3CRWNYM.js";
import {
  Delete
} from "./chunk-4MFML76R.js";
import "./chunk-6LVMAMLV.js";
import {
  CKEditorError,
  Command,
  FocusTracker,
  KeystrokeHandler,
  Plugin,
  TreeWalker,
  UpcastWriter,
  createElement,
  first,
  getCode,
  getFillerOffset,
  getLocalizedArrowKeyCodeDirection,
  global_default,
  parseKeystroke,
  toArray,
  uid
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/utils/listwalker.js
var ListWalker = class {
  /**
   * Creates a document list iterator.
   *
   * @param startElement The start list item block element.
   * @param options.direction The iterating direction.
   * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
   * @param options.sameAttributes Additional attributes that must be the same for each block.
   * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
   * in the result.
   * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
   * in the result.
   * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
   * in the result.
   */
  constructor(startElement, options) {
    this._startElement = startElement;
    this._referenceIndent = startElement.getAttribute("listIndent");
    this._isForward = options.direction == "forward";
    this._includeSelf = !!options.includeSelf;
    this._sameAttributes = toArray(options.sameAttributes || []);
    this._sameIndent = !!options.sameIndent;
    this._lowerIndent = !!options.lowerIndent;
    this._higherIndent = !!options.higherIndent;
  }
  /**
   * Performs only first step of iteration and returns the result.
   *
   * @param startElement The start list item block element.
   * @param options.direction The iterating direction.
   * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
   * @param options.sameAttributes Additional attributes that must be the same for each block.
   * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
   * in the result.
   * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
   * in the result.
   * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
   * in the result.
   */
  static first(startElement, options) {
    const walker = new this(startElement, options);
    const iterator = walker[Symbol.iterator]();
    return first(iterator);
  }
  /**
   * Iterable interface.
   */
  *[Symbol.iterator]() {
    const nestedItems = [];
    for (const { node } of iterateSiblingListBlocks(this._getStartNode(), this._isForward ? "forward" : "backward")) {
      const indent = node.getAttribute("listIndent");
      if (indent < this._referenceIndent) {
        if (!this._lowerIndent) {
          break;
        }
        this._referenceIndent = indent;
      } else if (indent > this._referenceIndent) {
        if (!this._higherIndent) {
          continue;
        }
        if (!this._isForward) {
          nestedItems.push(node);
          continue;
        }
      } else {
        if (!this._sameIndent) {
          if (this._higherIndent) {
            if (nestedItems.length) {
              yield* nestedItems;
              nestedItems.length = 0;
            }
            break;
          }
          continue;
        }
        if (this._sameAttributes.some((attr) => node.getAttribute(attr) !== this._startElement.getAttribute(attr))) {
          break;
        }
      }
      if (nestedItems.length) {
        yield* nestedItems;
        nestedItems.length = 0;
      }
      yield node;
    }
  }
  /**
   * Returns the model element to start iterating.
   */
  _getStartNode() {
    if (this._includeSelf) {
      return this._startElement;
    }
    return this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling;
  }
};
function* iterateSiblingListBlocks(node, direction = "forward") {
  const isForward = direction == "forward";
  let previous = null;
  while (isListItemBlock(node)) {
    yield { node, previous };
    previous = node;
    node = isForward ? node.nextSibling : node.previousSibling;
  }
}
var ListBlocksIterable = class {
  /**
   * @param listHead The head element of a list.
   */
  constructor(listHead) {
    this._listHead = listHead;
  }
  /**
   * List blocks iterator.
   *
   * Iterates over all blocks of a list.
   */
  [Symbol.iterator]() {
    return iterateSiblingListBlocks(this._listHead, "forward");
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/utils/model.js
var ListItemUid = class {
  /**
   * Returns the next ID.
   *
   * @internal
   */
  /* istanbul ignore next: static function definition -- @preserve */
  static next() {
    return uid();
  }
};
function isListItemBlock(node) {
  return !!node && node.is("element") && node.hasAttribute("listItemId");
}
function getAllListItemBlocks(listItem, options = {}) {
  return [
    ...getListItemBlocks(listItem, { ...options, direction: "backward" }),
    ...getListItemBlocks(listItem, { ...options, direction: "forward" })
  ];
}
function getListItemBlocks(listItem, options = {}) {
  const isForward = options.direction == "forward";
  const items = Array.from(new ListWalker(listItem, {
    ...options,
    includeSelf: isForward,
    sameIndent: true,
    sameAttributes: "listItemId"
  }));
  return isForward ? items : items.reverse();
}
function getNestedListBlocks(listItem) {
  return Array.from(new ListWalker(listItem, {
    direction: "forward",
    higherIndent: true
  }));
}
function getListItems(listItem) {
  const backwardBlocks = new ListWalker(listItem, {
    sameIndent: true,
    sameAttributes: "listType"
  });
  const forwardBlocks = new ListWalker(listItem, {
    sameIndent: true,
    sameAttributes: "listType",
    includeSelf: true,
    direction: "forward"
  });
  return [
    ...Array.from(backwardBlocks).reverse(),
    ...forwardBlocks
  ];
}
function isFirstBlockOfListItem(listBlock) {
  const previousSibling = ListWalker.first(listBlock, {
    sameIndent: true,
    sameAttributes: "listItemId"
  });
  if (!previousSibling) {
    return true;
  }
  return false;
}
function isLastBlockOfListItem(listBlock) {
  const nextSibling = ListWalker.first(listBlock, {
    direction: "forward",
    sameIndent: true,
    sameAttributes: "listItemId"
  });
  if (!nextSibling) {
    return true;
  }
  return false;
}
function expandListBlocksToCompleteItems(blocks, options = {}) {
  blocks = toArray(blocks);
  const higherIndent = options.withNested !== false;
  const allBlocks = /* @__PURE__ */ new Set();
  for (const block of blocks) {
    for (const itemBlock of getAllListItemBlocks(block, { higherIndent })) {
      allBlocks.add(itemBlock);
    }
  }
  return sortBlocks(allBlocks);
}
function expandListBlocksToCompleteList(blocks) {
  blocks = toArray(blocks);
  const allBlocks = /* @__PURE__ */ new Set();
  for (const block of blocks) {
    for (const itemBlock of getListItems(block)) {
      allBlocks.add(itemBlock);
    }
  }
  return sortBlocks(allBlocks);
}
function splitListItemBefore(listBlock, writer) {
  const blocks = getListItemBlocks(listBlock, { direction: "forward" });
  const id = ListItemUid.next();
  for (const block of blocks) {
    writer.setAttribute("listItemId", id, block);
  }
  return blocks;
}
function mergeListItemBefore(listBlock, parentBlock, writer) {
  const attributes = {};
  for (const [key, value] of parentBlock.getAttributes()) {
    if (key.startsWith("list")) {
      attributes[key] = value;
    }
  }
  const blocks = getListItemBlocks(listBlock, { direction: "forward" });
  for (const block of blocks) {
    writer.setAttributes(attributes, block);
  }
  return blocks;
}
function indentBlocks(blocks, writer, { expand, indentBy = 1 } = {}) {
  blocks = toArray(blocks);
  const allBlocks = expand ? expandListBlocksToCompleteItems(blocks) : blocks;
  for (const block of allBlocks) {
    const blockIndent = block.getAttribute("listIndent") + indentBy;
    if (blockIndent < 0) {
      removeListAttributes(block, writer);
    } else {
      writer.setAttribute("listIndent", blockIndent, block);
    }
  }
  return allBlocks;
}
function outdentBlocksWithMerge(blocks, writer) {
  blocks = toArray(blocks);
  const allBlocks = expandListBlocksToCompleteItems(blocks);
  const visited = /* @__PURE__ */ new Set();
  const referenceIndent = Math.min(...allBlocks.map((block) => block.getAttribute("listIndent")));
  const parentBlocks = /* @__PURE__ */ new Map();
  for (const block of allBlocks) {
    parentBlocks.set(block, ListWalker.first(block, { lowerIndent: true }));
  }
  for (const block of allBlocks) {
    if (visited.has(block)) {
      continue;
    }
    visited.add(block);
    const blockIndent = block.getAttribute("listIndent") - 1;
    if (blockIndent < 0) {
      removeListAttributes(block, writer);
      continue;
    }
    if (block.getAttribute("listIndent") == referenceIndent) {
      const mergedBlocks = mergeListItemIfNotLast(block, parentBlocks.get(block), writer);
      for (const mergedBlock of mergedBlocks) {
        visited.add(mergedBlock);
      }
      if (mergedBlocks.length) {
        continue;
      }
    }
    writer.setAttribute("listIndent", blockIndent, block);
  }
  return sortBlocks(visited);
}
function removeListAttributes(blocks, writer) {
  blocks = toArray(blocks);
  for (const block of blocks) {
    for (const attributeKey2 of block.getAttributeKeys()) {
      if (attributeKey2.startsWith("list")) {
        writer.removeAttribute(attributeKey2, block);
      }
    }
  }
  return blocks;
}
function isSingleListItem(blocks) {
  if (!blocks.length) {
    return false;
  }
  const firstItemId = blocks[0].getAttribute("listItemId");
  if (!firstItemId) {
    return false;
  }
  return !blocks.some((item) => item.getAttribute("listItemId") != firstItemId);
}
function outdentFollowingItems(lastBlock, writer) {
  const changedBlocks = [];
  let currentIndent = Number.POSITIVE_INFINITY;
  for (const { node } of iterateSiblingListBlocks(lastBlock.nextSibling, "forward")) {
    const indent = node.getAttribute("listIndent");
    if (indent == 0) {
      break;
    }
    if (indent < currentIndent) {
      currentIndent = indent;
    }
    const newIndent = indent - currentIndent;
    writer.setAttribute("listIndent", newIndent, node);
    changedBlocks.push(node);
  }
  return changedBlocks;
}
function sortBlocks(blocks) {
  return Array.from(blocks).filter((block) => block.root.rootName !== "$graveyard").sort((a, b) => a.index - b.index);
}
function getSelectedBlockObject(model) {
  const selectedElement = model.document.selection.getSelectedElement();
  if (!selectedElement) {
    return null;
  }
  if (model.schema.isObject(selectedElement) && model.schema.isBlock(selectedElement)) {
    return selectedElement;
  }
  return null;
}
function mergeListItemIfNotLast(block, parentBlock, writer) {
  const parentItemBlocks = getListItemBlocks(parentBlock, { direction: "forward" });
  if (parentItemBlocks.pop().index > block.index) {
    return mergeListItemBefore(block, parentBlock, writer);
  }
  return [];
}

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/documentlistindentcommand.js
var DocumentListIndentCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param indentDirection The direction of indent. If it is equal to `backward`, the command
   * will outdent a list item.
   */
  constructor(editor, indentDirection) {
    super(editor);
    this._direction = indentDirection;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
   *
   * @fires execute
   * @fires afterExecute
   */
  execute() {
    const model = this.editor.model;
    const blocks = getSelectedListBlocks(model.document.selection);
    model.change((writer) => {
      const changedBlocks = [];
      if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
        if (this._direction == "forward") {
          changedBlocks.push(...indentBlocks(blocks, writer));
        }
        changedBlocks.push(...splitListItemBefore(blocks[0], writer));
      } else {
        if (this._direction == "forward") {
          changedBlocks.push(...indentBlocks(blocks, writer, { expand: true }));
        } else {
          changedBlocks.push(...outdentBlocksWithMerge(blocks, writer));
        }
      }
      for (const block of changedBlocks) {
        if (!block.hasAttribute("listType")) {
          continue;
        }
        const previousItemBlock = ListWalker.first(block, { sameIndent: true });
        if (previousItemBlock) {
          writer.setAttribute("listType", previousItemBlock.getAttribute("listType"), block);
        }
      }
      this._fireAfterExecute(changedBlocks);
    });
  }
  /**
   * Fires the `afterExecute` event.
   *
   * @param changedBlocks The changed list elements.
   */
  _fireAfterExecute(changedBlocks) {
    this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    let blocks = getSelectedListBlocks(this.editor.model.document.selection);
    let firstBlock = blocks[0];
    if (!firstBlock) {
      return false;
    }
    if (this._direction == "backward") {
      return true;
    }
    if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
      return true;
    }
    blocks = expandListBlocksToCompleteItems(blocks);
    firstBlock = blocks[0];
    const siblingItem = ListWalker.first(firstBlock, { sameIndent: true });
    if (!siblingItem) {
      return false;
    }
    if (siblingItem.getAttribute("listType") == firstBlock.getAttribute("listType")) {
      return true;
    }
    return false;
  }
};
function getSelectedListBlocks(selection) {
  const blocks = Array.from(selection.getSelectedBlocks());
  const firstNonListBlockIndex = blocks.findIndex((block) => !isListItemBlock(block));
  if (firstNonListBlockIndex != -1) {
    blocks.length = firstNonListBlockIndex;
  }
  return blocks;
}

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/documentlistcommand.js
var DocumentListCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param type List type that will be handled by this command.
   */
  constructor(editor, type) {
    super(editor);
    this.type = type;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the list command.
   *
   * @fires execute
   * @fires afterExecute
   * @param options Command options.
   * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
   * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements
   * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    const selectedBlockObject = getSelectedBlockObject(model);
    const blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block) => model.schema.checkAttribute(block, "listType"));
    const turnOff = options.forceValue !== void 0 ? !options.forceValue : this.value;
    model.change((writer) => {
      if (turnOff) {
        const lastBlock = blocks[blocks.length - 1];
        const itemBlocks = getListItemBlocks(lastBlock, { direction: "forward" });
        const changedBlocks = [];
        if (itemBlocks.length > 1) {
          changedBlocks.push(...splitListItemBefore(itemBlocks[1], writer));
        }
        changedBlocks.push(...removeListAttributes(blocks, writer));
        changedBlocks.push(...outdentFollowingItems(lastBlock, writer));
        this._fireAfterExecute(changedBlocks);
      } else if ((selectedBlockObject || document2.selection.isCollapsed) && isListItemBlock(blocks[0])) {
        const changedBlocks = getListItems(selectedBlockObject || blocks[0]);
        for (const block of changedBlocks) {
          writer.setAttribute("listType", this.type, block);
        }
        this._fireAfterExecute(changedBlocks);
      } else {
        const changedBlocks = [];
        for (const block of blocks) {
          if (!block.hasAttribute("listType")) {
            writer.setAttributes({
              listIndent: 0,
              listItemId: ListItemUid.next(),
              listType: this.type
            }, block);
            changedBlocks.push(block);
          } else {
            for (const node of expandListBlocksToCompleteItems(block, { withNested: false })) {
              if (node.getAttribute("listType") != this.type) {
                writer.setAttribute("listType", this.type, node);
                changedBlocks.push(node);
              }
            }
          }
        }
        this._fireAfterExecute(changedBlocks);
      }
    });
  }
  /**
   * Fires the `afterExecute` event.
   *
   * @param changedBlocks The changed list elements.
   */
  _fireAfterExecute(changedBlocks) {
    this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const selection = this.editor.model.document.selection;
    const blocks = Array.from(selection.getSelectedBlocks());
    if (!blocks.length) {
      return false;
    }
    for (const block of blocks) {
      if (block.getAttribute("listType") != this.type) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const selection = this.editor.model.document.selection;
    const schema = this.editor.model.schema;
    const blocks = Array.from(selection.getSelectedBlocks());
    if (!blocks.length) {
      return false;
    }
    if (this.value) {
      return true;
    }
    for (const block of blocks) {
      if (schema.checkAttribute(block, "listType")) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/documentlistmergecommand.js
var DocumentListMergeCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param direction Whether list item should be merged before or after the selected block.
   */
  constructor(editor, direction) {
    super(editor);
    this._direction = direction;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Merges list blocks together (depending on the {@link #constructor}'s `direction` parameter).
   *
   * @fires execute
   * @fires afterExecute
   * @param options Command options.
   * @param options.shouldMergeOnBlocksContentLevel When set `true`, merging will be performed together
   * with {@link module:engine/model/model~Model#deleteContent} to get rid of the inline content in the selection or take advantage
   * of the heuristics in `deleteContent()` that helps convert lists into paragraphs in certain cases.
   */
  execute({ shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel2 = false } = {}) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const changedBlocks = [];
    model.change((writer) => {
      const { firstElement, lastElement } = this._getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel2);
      const firstIndent = firstElement.getAttribute("listIndent") || 0;
      const lastIndent = lastElement.getAttribute("listIndent");
      const lastElementId = lastElement.getAttribute("listItemId");
      if (firstIndent != lastIndent) {
        const nestedLastElementBlocks = getNestedListBlocks(lastElement);
        changedBlocks.push(...indentBlocks([lastElement, ...nestedLastElementBlocks], writer, {
          indentBy: firstIndent - lastIndent,
          // If outdenting, the entire sub-tree that follows must be included.
          expand: firstIndent < lastIndent
        }));
      }
      if (shouldMergeOnBlocksContentLevel2) {
        let sel = selection;
        if (selection.isCollapsed) {
          sel = writer.createSelection(writer.createRange(writer.createPositionAt(firstElement, "end"), writer.createPositionAt(lastElement, 0)));
        }
        model.deleteContent(sel, { doNotResetEntireContent: selection.isCollapsed });
        const lastElementAfterDelete = sel.getLastPosition().parent;
        const nextSibling = lastElementAfterDelete.nextSibling;
        changedBlocks.push(lastElementAfterDelete);
        if (nextSibling && nextSibling !== lastElement && nextSibling.getAttribute("listItemId") == lastElementId) {
          changedBlocks.push(...mergeListItemBefore(nextSibling, lastElementAfterDelete, writer));
        }
      } else {
        changedBlocks.push(...mergeListItemBefore(lastElement, firstElement, writer));
      }
      this._fireAfterExecute(changedBlocks);
    });
  }
  /**
   * Fires the `afterExecute` event.
   *
   * @param changedBlocks The changed list elements.
   */
  _fireAfterExecute(changedBlocks) {
    this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedBlockObject = getSelectedBlockObject(model);
    if (selection.isCollapsed || selectedBlockObject) {
      const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
      if (!isListItemBlock(positionParent)) {
        return false;
      }
      const siblingNode = this._direction == "backward" ? positionParent.previousSibling : positionParent.nextSibling;
      if (!siblingNode) {
        return false;
      }
      if (isSingleListItem([positionParent, siblingNode])) {
        return false;
      }
    } else {
      const lastPosition = selection.getLastPosition();
      const firstPosition = selection.getFirstPosition();
      if (lastPosition.parent === firstPosition.parent) {
        return false;
      }
      if (!isListItemBlock(lastPosition.parent)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns the boundary elements the merge should be executed for. These are not necessarily selection's first
   * and last position parents but sometimes sibling or even further blocks depending on the context.
   *
   * @param selection The selection the merge is executed for.
   * @param shouldMergeOnBlocksContentLevel When `true`, merge is performed together with
   * {@link module:engine/model/model~Model#deleteContent} to remove the inline content within the selection.
   */
  _getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel2) {
    const model = this.editor.model;
    const selectedBlockObject = getSelectedBlockObject(model);
    let firstElement, lastElement;
    if (selection.isCollapsed || selectedBlockObject) {
      const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
      const isFirstBlock = isFirstBlockOfListItem(positionParent);
      if (this._direction == "backward") {
        lastElement = positionParent;
        if (isFirstBlock && !shouldMergeOnBlocksContentLevel2) {
          firstElement = ListWalker.first(positionParent, { sameIndent: true, lowerIndent: true });
        } else {
          firstElement = positionParent.previousSibling;
        }
      } else {
        firstElement = positionParent;
        lastElement = positionParent.nextSibling;
      }
    } else {
      firstElement = selection.getFirstPosition().parent;
      lastElement = selection.getLastPosition().parent;
    }
    return {
      firstElement,
      lastElement
    };
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/documentlistsplitcommand.js
var DocumentListSplitCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param direction Whether list item should be split before or after the selected block.
   */
  constructor(editor, direction) {
    super(editor);
    this._direction = direction;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Splits the list item at the selection.
   *
   * @fires execute
   * @fires afterExecute
   */
  execute() {
    const editor = this.editor;
    editor.model.change((writer) => {
      const changedBlocks = splitListItemBefore(this._getStartBlock(), writer);
      this._fireAfterExecute(changedBlocks);
    });
  }
  /**
   * Fires the `afterExecute` event.
   *
   * @param changedBlocks The changed list elements.
   */
  _fireAfterExecute(changedBlocks) {
    this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const selection = this.editor.model.document.selection;
    const block = this._getStartBlock();
    return selection.isCollapsed && isListItemBlock(block) && !isFirstBlockOfListItem(block);
  }
  /**
   * Returns the model element that is the main focus of the command (according to the current selection and command direction).
   */
  _getStartBlock() {
    const doc = this.editor.model.document;
    const positionParent = doc.selection.getFirstPosition().parent;
    return this._direction == "before" ? positionParent : positionParent.nextSibling;
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/documentlistutils.js
var DocumentListUtils = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DocumentListUtils";
  }
  /**
   * Expands the given list of selected blocks to include all the items of the lists they're in.
   *
   * @param blocks The list of selected blocks.
   */
  expandListBlocksToCompleteList(blocks) {
    return expandListBlocksToCompleteList(blocks);
  }
  /**
   * Check if the given block is the first in the list item.
   *
   * @param listBlock The list block element.
   */
  isFirstBlockOfListItem(listBlock) {
    return isFirstBlockOfListItem(listBlock);
  }
  /**
   * Returns true if the given model node is a list item block.
   *
   * @param node A model node.
   */
  isListItemBlock(node) {
    return isListItemBlock(node);
  }
  /**
   * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.
   *
   * @param blocks The list of selected blocks.
   * @param options.withNested Whether should include nested list items.
   */
  expandListBlocksToCompleteItems(blocks, options = {}) {
    return expandListBlocksToCompleteItems(blocks, options);
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/utils/view.js
function isListView(viewElement) {
  return viewElement.is("element", "ol") || viewElement.is("element", "ul");
}
function isListItemView(viewElement) {
  return viewElement.is("element", "li");
}
function getIndent(listItem) {
  let indent = 0;
  let parent = listItem.parent;
  while (parent) {
    if (isListItemView(parent)) {
      indent++;
    } else {
      const previousSibling = parent.previousSibling;
      if (previousSibling && isListItemView(previousSibling)) {
        indent++;
      }
    }
    parent = parent.parent;
  }
  return indent;
}
function createListElement(writer, indent, type, id = getViewElementIdForListType(type, indent)) {
  return writer.createAttributeElement(getViewElementNameForListType(type), null, {
    priority: 2 * indent / 100 - 100,
    id
  });
}
function createListItemElement(writer, indent, id) {
  return writer.createAttributeElement("li", null, {
    priority: (2 * indent + 1) / 100 - 100,
    id
  });
}
function getViewElementNameForListType(type) {
  return type == "numbered" ? "ol" : "ul";
}
function getViewElementIdForListType(type, indent) {
  return `list-${type}-${indent}`;
}

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/utils/postfixers.js
function findAndAddListHeadToMap(position, itemToListHead) {
  const previousNode = position.nodeBefore;
  if (!isListItemBlock(previousNode)) {
    const item = position.nodeAfter;
    if (isListItemBlock(item)) {
      itemToListHead.set(item, item);
    }
  } else {
    let listHead = previousNode;
    for (const { node } of iterateSiblingListBlocks(listHead, "backward")) {
      listHead = node;
      if (itemToListHead.has(listHead)) {
        return;
      }
    }
    itemToListHead.set(previousNode, listHead);
  }
}
function fixListIndents(listNodes, writer) {
  let maxIndent = 0;
  let prevIndent = -1;
  let fixBy = null;
  let applied = false;
  for (const { node } of listNodes) {
    const itemIndent = node.getAttribute("listIndent");
    if (itemIndent > maxIndent) {
      let newIndent;
      if (fixBy === null) {
        fixBy = itemIndent - maxIndent;
        newIndent = maxIndent;
      } else {
        if (fixBy > itemIndent) {
          fixBy = itemIndent;
        }
        newIndent = itemIndent - fixBy;
      }
      if (newIndent > prevIndent + 1) {
        newIndent = prevIndent + 1;
      }
      writer.setAttribute("listIndent", newIndent, node);
      applied = true;
      prevIndent = newIndent;
    } else {
      fixBy = null;
      maxIndent = itemIndent + 1;
      prevIndent = itemIndent;
    }
  }
  return applied;
}
function fixListItemIds(listNodes, seenIds, writer) {
  const visited = /* @__PURE__ */ new Set();
  let applied = false;
  for (const { node } of listNodes) {
    if (visited.has(node)) {
      continue;
    }
    let listType = node.getAttribute("listType");
    let listItemId = node.getAttribute("listItemId");
    if (seenIds.has(listItemId)) {
      listItemId = ListItemUid.next();
    }
    seenIds.add(listItemId);
    for (const block of getListItemBlocks(node, { direction: "forward" })) {
      visited.add(block);
      if (block.getAttribute("listType") != listType) {
        listItemId = ListItemUid.next();
        listType = block.getAttribute("listType");
      }
      if (block.getAttribute("listItemId") != listItemId) {
        writer.setAttribute("listItemId", listItemId, block);
        applied = true;
      }
    }
  }
  return applied;
}

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/converters.js
function listItemUpcastConverter() {
  return (evt, data, conversionApi) => {
    const { writer, schema } = conversionApi;
    if (!data.modelRange) {
      return;
    }
    const items = Array.from(data.modelRange.getItems({ shallow: true })).filter((item) => schema.checkAttribute(item, "listItemId"));
    if (!items.length) {
      return;
    }
    const attributes = {
      listItemId: ListItemUid.next(),
      listIndent: getIndent(data.viewItem),
      listType: data.viewItem.parent && data.viewItem.parent.is("element", "ol") ? "numbered" : "bulleted"
    };
    for (const item of items) {
      if (!isListItemBlock(item)) {
        writer.setAttributes(attributes, item);
      }
    }
    if (items.length > 1) {
      if (items[1].getAttribute("listItemId") != attributes.listItemId) {
        conversionApi.keepEmptyElement(items[0]);
      }
    }
  };
}
function listUpcastCleanList() {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.test(data.viewItem, { name: true })) {
      return;
    }
    const viewWriter = new UpcastWriter(data.viewItem.document);
    for (const child of Array.from(data.viewItem.getChildren())) {
      if (!isListItemView(child) && !isListView(child)) {
        viewWriter.remove(child);
      }
    }
  };
}
function reconvertItemsOnDataChange(model, editing, attributeNames, documentListEditing) {
  return () => {
    const changes = model.document.differ.getChanges();
    const itemsToRefresh = [];
    const itemToListHead = /* @__PURE__ */ new Map();
    const changedItems = /* @__PURE__ */ new Set();
    for (const entry of changes) {
      if (entry.type == "insert" && entry.name != "$text") {
        findAndAddListHeadToMap(entry.position, itemToListHead);
        if (!entry.attributes.has("listItemId")) {
          findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);
        } else {
          changedItems.add(entry.position.nodeAfter);
        }
      } else if (entry.type == "remove" && entry.attributes.has("listItemId")) {
        findAndAddListHeadToMap(entry.position, itemToListHead);
      } else if (entry.type == "attribute") {
        const item = entry.range.start.nodeAfter;
        if (attributeNames.includes(entry.attributeKey)) {
          findAndAddListHeadToMap(entry.range.start, itemToListHead);
          if (entry.attributeNewValue === null) {
            findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);
            if (doesItemParagraphRequiresRefresh(item)) {
              itemsToRefresh.push(item);
            }
          } else {
            changedItems.add(item);
          }
        } else if (isListItemBlock(item)) {
          if (doesItemParagraphRequiresRefresh(item)) {
            itemsToRefresh.push(item);
          }
        }
      }
    }
    for (const listHead of itemToListHead.values()) {
      itemsToRefresh.push(...collectListItemsToRefresh(listHead, changedItems));
    }
    for (const item of new Set(itemsToRefresh)) {
      editing.reconvertItem(item);
    }
  };
  function collectListItemsToRefresh(listHead, changedItems) {
    const itemsToRefresh = [];
    const visited = /* @__PURE__ */ new Set();
    const stack = [];
    for (const { node, previous } of iterateSiblingListBlocks(listHead, "forward")) {
      if (visited.has(node)) {
        continue;
      }
      const itemIndent = node.getAttribute("listIndent");
      if (previous && itemIndent < previous.getAttribute("listIndent")) {
        stack.length = itemIndent + 1;
      }
      stack[itemIndent] = Object.fromEntries(Array.from(node.getAttributes()).filter(([key]) => attributeNames.includes(key)));
      const blocks = getListItemBlocks(node, { direction: "forward" });
      for (const block of blocks) {
        visited.add(block);
        if (doesItemParagraphRequiresRefresh(block, blocks)) {
          itemsToRefresh.push(block);
        } else if (doesItemWrappingRequiresRefresh(block, stack, changedItems)) {
          itemsToRefresh.push(block);
        }
      }
    }
    return itemsToRefresh;
  }
  function doesItemParagraphRequiresRefresh(item, blocks) {
    if (!item.is("element", "paragraph")) {
      return false;
    }
    const viewElement = editing.mapper.toViewElement(item);
    if (!viewElement) {
      return false;
    }
    const useBogus = shouldUseBogusParagraph(item, attributeNames, blocks);
    if (useBogus && viewElement.is("element", "p")) {
      return true;
    } else if (!useBogus && viewElement.is("element", "span")) {
      return true;
    }
    return false;
  }
  function doesItemWrappingRequiresRefresh(item, stack, changedItems) {
    if (changedItems.has(item)) {
      return false;
    }
    const viewElement = editing.mapper.toViewElement(item);
    let indent = stack.length - 1;
    for (let element = viewElement.parent; !element.is("editableElement"); element = element.parent) {
      const isListItemElement = isListItemView(element);
      const isListElement = isListView(element);
      if (!isListElement && !isListItemElement) {
        continue;
      }
      const eventName = `checkAttributes:${isListItemElement ? "item" : "list"}`;
      const needsRefresh = documentListEditing.fire(eventName, {
        viewElement: element,
        modelAttributes: stack[indent]
      });
      if (needsRefresh) {
        break;
      }
      if (isListElement) {
        indent--;
        if (indent < 0) {
          return false;
        }
      }
    }
    return true;
  }
}
function listItemDowncastConverter(attributeNames, strategies, model) {
  const consumer = createAttributesConsumer(attributeNames);
  return (evt, data, conversionApi) => {
    const { writer, mapper, consumable } = conversionApi;
    const listItem = data.item;
    if (!attributeNames.includes(data.attributeKey)) {
      return;
    }
    if (!consumer(listItem, consumable)) {
      return;
    }
    const viewElement = findMappedViewElement(listItem, mapper, model);
    unwrapListItemBlock(viewElement, writer);
    wrapListItemBlock(listItem, writer.createRangeOn(viewElement), strategies, writer);
  };
}
function bogusParagraphCreator(attributeNames, { dataPipeline } = {}) {
  return (modelElement, { writer }) => {
    if (!shouldUseBogusParagraph(modelElement, attributeNames)) {
      return null;
    }
    if (!dataPipeline) {
      return writer.createContainerElement("span", { class: "ck-list-bogus-paragraph" });
    }
    const viewElement = writer.createContainerElement("p");
    writer.setCustomProperty("dataPipeline:transparentRendering", true, viewElement);
    return viewElement;
  };
}
function findMappedViewElement(element, mapper, model) {
  const modelRange = model.createRangeOn(element);
  const viewRange = mapper.toViewRange(modelRange).getTrimmed();
  return viewRange.getContainedElement();
}
function unwrapListItemBlock(viewElement, viewWriter) {
  let attributeElement = viewElement.parent;
  while (attributeElement.is("attributeElement") && ["ul", "ol", "li"].includes(attributeElement.name)) {
    const parentElement = attributeElement.parent;
    viewWriter.unwrap(viewWriter.createRangeOn(viewElement), attributeElement);
    attributeElement = parentElement;
  }
}
function wrapListItemBlock(listItem, viewRange, strategies, writer) {
  if (!listItem.hasAttribute("listIndent")) {
    return;
  }
  const listItemIndent = listItem.getAttribute("listIndent");
  let currentListItem = listItem;
  for (let indent = listItemIndent; indent >= 0; indent--) {
    const listItemViewElement = createListItemElement(writer, indent, currentListItem.getAttribute("listItemId"));
    const listViewElement = createListElement(writer, indent, currentListItem.getAttribute("listType"));
    for (const strategy of strategies) {
      if (currentListItem.hasAttribute(strategy.attributeName)) {
        strategy.setAttributeOnDowncast(writer, currentListItem.getAttribute(strategy.attributeName), strategy.scope == "list" ? listViewElement : listItemViewElement);
      }
    }
    viewRange = writer.wrap(viewRange, listItemViewElement);
    viewRange = writer.wrap(viewRange, listViewElement);
    if (indent == 0) {
      break;
    }
    currentListItem = ListWalker.first(currentListItem, { lowerIndent: true });
    if (!currentListItem) {
      break;
    }
  }
}
function createAttributesConsumer(attributeNames) {
  return (node, consumable) => {
    const events = [];
    for (const attributeName of attributeNames) {
      if (node.hasAttribute(attributeName)) {
        events.push(`attribute:${attributeName}`);
      }
    }
    if (!events.every((event) => consumable.test(node, event) !== false)) {
      return false;
    }
    events.forEach((event) => consumable.consume(node, event));
    return true;
  };
}
function shouldUseBogusParagraph(item, attributeNames, blocks = getAllListItemBlocks(item)) {
  if (!isListItemBlock(item)) {
    return false;
  }
  for (const attributeKey2 of item.getAttributeKeys()) {
    if (attributeKey2.startsWith("selection:")) {
      continue;
    }
    if (!attributeNames.includes(attributeKey2)) {
      return false;
    }
  }
  return blocks.length < 2;
}

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/documentlistediting.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/documentlist.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/list.css";
var LIST_BASE_ATTRIBUTES = ["listType", "listIndent", "listItemId"];
var DocumentListEditing = class extends Plugin {
  constructor() {
    super(...arguments);
    this._downcastStrategies = [];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DocumentListEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Enter, Delete, DocumentListUtils];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    if (editor.plugins.has("ListEditing")) {
      throw new CKEditorError("document-list-feature-conflict", this, { conflictPlugin: "ListEditing" });
    }
    model.schema.extend("$container", { allowAttributes: LIST_BASE_ATTRIBUTES });
    model.schema.extend("$block", { allowAttributes: LIST_BASE_ATTRIBUTES });
    model.schema.extend("$blockObject", { allowAttributes: LIST_BASE_ATTRIBUTES });
    for (const attribute of LIST_BASE_ATTRIBUTES) {
      model.schema.setAttributeProperties(attribute, {
        copyOnReplace: true
      });
    }
    editor.commands.add("numberedList", new DocumentListCommand(editor, "numbered"));
    editor.commands.add("bulletedList", new DocumentListCommand(editor, "bulleted"));
    editor.commands.add("indentList", new DocumentListIndentCommand(editor, "forward"));
    editor.commands.add("outdentList", new DocumentListIndentCommand(editor, "backward"));
    editor.commands.add("mergeListItemBackward", new DocumentListMergeCommand(editor, "backward"));
    editor.commands.add("mergeListItemForward", new DocumentListMergeCommand(editor, "forward"));
    editor.commands.add("splitListItemBefore", new DocumentListSplitCommand(editor, "before"));
    editor.commands.add("splitListItemAfter", new DocumentListSplitCommand(editor, "after"));
    this._setupDeleteIntegration();
    this._setupEnterIntegration();
    this._setupTabIntegration();
    this._setupClipboardIntegration();
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const editor = this.editor;
    const commands = editor.commands;
    const indent = commands.get("indent");
    const outdent = commands.get("outdent");
    if (indent) {
      indent.registerChildCommand(commands.get("indentList"), { priority: "high" });
    }
    if (outdent) {
      outdent.registerChildCommand(commands.get("outdentList"), { priority: "lowest" });
    }
    this._setupModelPostFixing();
    this._setupConversion();
  }
  /**
   * Registers a downcast strategy.
   *
   * **Note**: Strategies must be registered in the `Plugin#init()` phase so that it can be applied
   * in the `DocumentListEditing#afterInit()`.
   *
   * @param strategy The downcast strategy to register.
   */
  registerDowncastStrategy(strategy) {
    this._downcastStrategies.push(strategy);
  }
  /**
   * Returns list of model attribute names that should affect downcast conversion.
   */
  _getListAttributeNames() {
    return [
      ...LIST_BASE_ATTRIBUTES,
      ...this._downcastStrategies.map((strategy) => strategy.attributeName)
    ];
  }
  /**
   * Attaches the listener to the {@link module:engine/view/document~Document#event:delete} event and handles backspace/delete
   * keys in and around document lists.
   */
  _setupDeleteIntegration() {
    const editor = this.editor;
    const mergeBackwardCommand = editor.commands.get("mergeListItemBackward");
    const mergeForwardCommand = editor.commands.get("mergeListItemForward");
    this.listenTo(editor.editing.view.document, "delete", (evt, data) => {
      const selection = editor.model.document.selection;
      if (getSelectedBlockObject(editor.model)) {
        return;
      }
      editor.model.change(() => {
        const firstPosition = selection.getFirstPosition();
        if (selection.isCollapsed && data.direction == "backward") {
          if (!firstPosition.isAtStart) {
            return;
          }
          const positionParent = firstPosition.parent;
          if (!isListItemBlock(positionParent)) {
            return;
          }
          const previousBlock = ListWalker.first(positionParent, {
            sameAttributes: "listType",
            sameIndent: true
          });
          if (!previousBlock && positionParent.getAttribute("listIndent") === 0) {
            if (!isLastBlockOfListItem(positionParent)) {
              editor.execute("splitListItemAfter");
            }
            editor.execute("outdentList");
          } else {
            if (!mergeBackwardCommand.isEnabled) {
              return;
            }
            mergeBackwardCommand.execute({
              shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, "backward")
            });
          }
          data.preventDefault();
          evt.stop();
        } else {
          if (selection.isCollapsed && !selection.getLastPosition().isAtEnd) {
            return;
          }
          if (!mergeForwardCommand.isEnabled) {
            return;
          }
          mergeForwardCommand.execute({
            shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, "forward")
          });
          data.preventDefault();
          evt.stop();
        }
      });
    }, { context: "li" });
  }
  /**
   * Attaches a listener to the {@link module:engine/view/document~Document#event:enter} event and handles enter key press
   * in document lists.
   */
  _setupEnterIntegration() {
    const editor = this.editor;
    const model = editor.model;
    const commands = editor.commands;
    const enterCommand = commands.get("enter");
    this.listenTo(editor.editing.view.document, "enter", (evt, data) => {
      const doc = model.document;
      const positionParent = doc.selection.getFirstPosition().parent;
      if (doc.selection.isCollapsed && isListItemBlock(positionParent) && positionParent.isEmpty && !data.isSoft) {
        const isFirstBlock = isFirstBlockOfListItem(positionParent);
        const isLastBlock = isLastBlockOfListItem(positionParent);
        if (isFirstBlock && isLastBlock) {
          editor.execute("outdentList");
          data.preventDefault();
          evt.stop();
        } else if (isFirstBlock && !isLastBlock) {
          editor.execute("splitListItemAfter");
          data.preventDefault();
          evt.stop();
        } else if (isLastBlock) {
          editor.execute("splitListItemBefore");
          data.preventDefault();
          evt.stop();
        }
      }
    }, { context: "li" });
    this.listenTo(enterCommand, "afterExecute", () => {
      const splitCommand = commands.get("splitListItemBefore");
      splitCommand.refresh();
      if (!splitCommand.isEnabled) {
        return;
      }
      const doc = editor.model.document;
      const positionParent = doc.selection.getLastPosition().parent;
      const listItemBlocks = getAllListItemBlocks(positionParent);
      if (listItemBlocks.length === 2) {
        splitCommand.execute();
      }
    });
  }
  /**
   * Attaches a listener to the {@link module:engine/view/document~Document#event:tab} event and handles tab key and tab+shift keys
   * presses in document lists.
   */
  _setupTabIntegration() {
    const editor = this.editor;
    this.listenTo(editor.editing.view.document, "tab", (evt, data) => {
      const commandName = data.shiftKey ? "outdentList" : "indentList";
      const command = this.editor.commands.get(commandName);
      if (command.isEnabled) {
        editor.execute(commandName);
        data.stopPropagation();
        data.preventDefault();
        evt.stop();
      }
    }, { context: "li" });
  }
  /**
   * Registers the conversion helpers for the document-list feature.
   */
  _setupConversion() {
    const editor = this.editor;
    const model = editor.model;
    const attributeNames = this._getListAttributeNames();
    editor.conversion.for("upcast").elementToElement({ view: "li", model: "paragraph" }).add((dispatcher) => {
      dispatcher.on("element:li", listItemUpcastConverter());
      dispatcher.on("element:ul", listUpcastCleanList(), { priority: "high" });
      dispatcher.on("element:ol", listUpcastCleanList(), { priority: "high" });
    });
    editor.conversion.for("editingDowncast").elementToElement({
      model: "paragraph",
      view: bogusParagraphCreator(attributeNames),
      converterPriority: "high"
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "paragraph",
      view: bogusParagraphCreator(attributeNames, { dataPipeline: true }),
      converterPriority: "high"
    });
    editor.conversion.for("downcast").add((dispatcher) => {
      dispatcher.on("attribute", listItemDowncastConverter(attributeNames, this._downcastStrategies, model));
    });
    this.listenTo(model.document, "change:data", reconvertItemsOnDataChange(model, editor.editing, attributeNames, this), { priority: "high" });
    this.on("checkAttributes:item", (evt, { viewElement, modelAttributes }) => {
      if (viewElement.id != modelAttributes.listItemId) {
        evt.return = true;
        evt.stop();
      }
    });
    this.on("checkAttributes:list", (evt, { viewElement, modelAttributes }) => {
      if (viewElement.name != getViewElementNameForListType(modelAttributes.listType) || viewElement.id != getViewElementIdForListType(modelAttributes.listType, modelAttributes.listIndent)) {
        evt.return = true;
        evt.stop();
      }
    });
  }
  /**
   * Registers model post-fixers.
   */
  _setupModelPostFixing() {
    const model = this.editor.model;
    const attributeNames = this._getListAttributeNames();
    model.document.registerPostFixer((writer) => modelChangePostFixer(model, writer, attributeNames, this));
    this.on("postFixer", (evt, { listNodes, writer }) => {
      evt.return = fixListIndents(listNodes, writer) || evt.return;
    }, { priority: "high" });
    this.on("postFixer", (evt, { listNodes, writer, seenIds }) => {
      evt.return = fixListItemIds(listNodes, seenIds, writer) || evt.return;
    }, { priority: "high" });
  }
  /**
   * Integrates the feature with the clipboard via {@link module:engine/model/model~Model#insertContent} and
   * {@link module:engine/model/model~Model#getSelectedContent}.
   */
  _setupClipboardIntegration() {
    const model = this.editor.model;
    this.listenTo(model, "insertContent", createModelIndentPasteFixer(model), { priority: "high" });
    this.listenTo(model, "getSelectedContent", (evt, [selection]) => {
      const isSingleListItemSelected = isSingleListItem(Array.from(selection.getSelectedBlocks()));
      if (isSingleListItemSelected) {
        model.change((writer) => removeListAttributes(Array.from(evt.return.getChildren()), writer));
      }
    });
  }
};
function modelChangePostFixer(model, writer, attributeNames, documentListEditing) {
  const changes = model.document.differ.getChanges();
  const itemToListHead = /* @__PURE__ */ new Map();
  let applied = false;
  for (const entry of changes) {
    if (entry.type == "insert" && entry.name != "$text") {
      const item = entry.position.nodeAfter;
      if (!model.schema.checkAttribute(item, "listItemId")) {
        for (const attributeName of Array.from(item.getAttributeKeys())) {
          if (attributeNames.includes(attributeName)) {
            writer.removeAttribute(attributeName, item);
            applied = true;
          }
        }
      }
      findAndAddListHeadToMap(entry.position, itemToListHead);
      if (!entry.attributes.has("listItemId")) {
        findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);
      }
      for (const { item: innerItem, previousPosition } of model.createRangeIn(item)) {
        if (isListItemBlock(innerItem)) {
          findAndAddListHeadToMap(previousPosition, itemToListHead);
        }
      }
    } else if (entry.type == "remove") {
      findAndAddListHeadToMap(entry.position, itemToListHead);
    } else if (entry.type == "attribute" && attributeNames.includes(entry.attributeKey)) {
      findAndAddListHeadToMap(entry.range.start, itemToListHead);
      if (entry.attributeNewValue === null) {
        findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);
      }
    }
  }
  const seenIds = /* @__PURE__ */ new Set();
  for (const listHead of itemToListHead.values()) {
    applied = documentListEditing.fire("postFixer", {
      listNodes: new ListBlocksIterable(listHead),
      listHead,
      writer,
      seenIds
    }) || applied;
  }
  return applied;
}
function createModelIndentPasteFixer(model) {
  return (evt, [content, selectable]) => {
    const item = content.is("documentFragment") ? content.getChild(0) : content;
    if (!isListItemBlock(item)) {
      return;
    }
    let selection;
    if (!selectable) {
      selection = model.document.selection;
    } else {
      selection = model.createSelection(selectable);
    }
    const pos = selection.getFirstPosition();
    let refItem = null;
    if (isListItemBlock(pos.parent)) {
      refItem = pos.parent;
    } else if (isListItemBlock(pos.nodeBefore)) {
      refItem = pos.nodeBefore;
    }
    if (!refItem) {
      return;
    }
    const indentChange = refItem.getAttribute("listIndent") - item.getAttribute("listIndent");
    if (indentChange <= 0) {
      return;
    }
    model.change((writer) => {
      for (const { node } of iterateSiblingListBlocks(item, "forward")) {
        writer.setAttribute("listIndent", node.getAttribute("listIndent") + indentChange, node);
      }
    });
  };
}
function shouldMergeOnBlocksContentLevel(model, direction) {
  const selection = model.document.selection;
  if (!selection.isCollapsed) {
    return !getSelectedBlockObject(model);
  }
  if (direction === "forward") {
    return true;
  }
  const firstPosition = selection.getFirstPosition();
  const positionParent = firstPosition.parent;
  const previousSibling = positionParent.previousSibling;
  if (model.schema.isObject(previousSibling)) {
    return false;
  }
  if (previousSibling.isEmpty) {
    return true;
  }
  return isSingleListItem([positionParent, previousSibling]);
}

// node_modules/@ckeditor/ckeditor5-list/src/list/utils.js
function createViewListItemElement(writer) {
  const viewItem = writer.createContainerElement("li");
  viewItem.getFillerOffset = getListItemFillerOffset;
  return viewItem;
}
function generateLiInUl(modelItem, conversionApi) {
  const mapper = conversionApi.mapper;
  const viewWriter = conversionApi.writer;
  const listType = modelItem.getAttribute("listType") == "numbered" ? "ol" : "ul";
  const viewItem = createViewListItemElement(viewWriter);
  const viewList = viewWriter.createContainerElement(listType, null);
  viewWriter.insert(viewWriter.createPositionAt(viewList, 0), viewItem);
  mapper.bindElements(modelItem, viewItem);
  return viewItem;
}
function injectViewList(modelItem, injectedItem, conversionApi, model) {
  const injectedList = injectedItem.parent;
  const mapper = conversionApi.mapper;
  const viewWriter = conversionApi.writer;
  let insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem));
  const refItem = getSiblingListItem(modelItem.previousSibling, {
    sameIndent: true,
    smallerIndent: true,
    listIndent: modelItem.getAttribute("listIndent")
  });
  const prevItem = modelItem.previousSibling;
  if (refItem && refItem.getAttribute("listIndent") == modelItem.getAttribute("listIndent")) {
    const viewItem = mapper.toViewElement(refItem);
    insertPosition = viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));
  } else {
    if (prevItem && prevItem.name == "listItem") {
      insertPosition = mapper.toViewPosition(model.createPositionAt(prevItem, "end"));
      const mappedViewAncestor = mapper.findMappedViewAncestor(insertPosition);
      const nestedList = findNestedList(mappedViewAncestor);
      if (nestedList) {
        insertPosition = viewWriter.createPositionBefore(nestedList);
      } else {
        insertPosition = viewWriter.createPositionAt(mappedViewAncestor, "end");
      }
    } else {
      insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem));
    }
  }
  insertPosition = positionAfterUiElements(insertPosition);
  viewWriter.insert(insertPosition, injectedList);
  if (prevItem && prevItem.name == "listItem") {
    const prevView = mapper.toViewElement(prevItem);
    const walkerBoundaries = viewWriter.createRange(viewWriter.createPositionAt(prevView, 0), insertPosition);
    const walker = walkerBoundaries.getWalker({ ignoreElementEnd: true });
    for (const value of walker) {
      if (value.item.is("element", "li")) {
        const breakPosition = viewWriter.breakContainer(viewWriter.createPositionBefore(value.item));
        const viewList = value.item.parent;
        const targetPosition = viewWriter.createPositionAt(injectedItem, "end");
        mergeViewLists(viewWriter, targetPosition.nodeBefore, targetPosition.nodeAfter);
        viewWriter.move(viewWriter.createRangeOn(viewList), targetPosition);
        walker._position = breakPosition;
      }
    }
  } else {
    const nextViewList = injectedList.nextSibling;
    if (nextViewList && (nextViewList.is("element", "ul") || nextViewList.is("element", "ol"))) {
      let lastSubChild = null;
      for (const child of nextViewList.getChildren()) {
        const modelChild = mapper.toModelElement(child);
        if (modelChild && modelChild.getAttribute("listIndent") > modelItem.getAttribute("listIndent")) {
          lastSubChild = child;
        } else {
          break;
        }
      }
      if (lastSubChild) {
        viewWriter.breakContainer(viewWriter.createPositionAfter(lastSubChild));
        viewWriter.move(viewWriter.createRangeOn(lastSubChild.parent), viewWriter.createPositionAt(injectedItem, "end"));
      }
    }
  }
  mergeViewLists(viewWriter, injectedList, injectedList.nextSibling);
  mergeViewLists(viewWriter, injectedList.previousSibling, injectedList);
}
function mergeViewLists(viewWriter, firstList, secondList) {
  if (!firstList || !secondList || firstList.name != "ul" && firstList.name != "ol") {
    return null;
  }
  if (firstList.name != secondList.name || firstList.getAttribute("class") !== secondList.getAttribute("class")) {
    return null;
  }
  return viewWriter.mergeContainers(viewWriter.createPositionAfter(firstList));
}
function positionAfterUiElements(viewPosition) {
  return viewPosition.getLastMatchingPosition((value) => value.item.is("uiElement"));
}
function getSiblingListItem(modelItem, options) {
  const sameIndent = !!options.sameIndent;
  const smallerIndent = !!options.smallerIndent;
  const indent = options.listIndent;
  let item = modelItem;
  while (item && item.name == "listItem") {
    const itemIndent = item.getAttribute("listIndent");
    if (sameIndent && indent == itemIndent || smallerIndent && indent > itemIndent) {
      return item;
    }
    if (options.direction === "forward") {
      item = item.nextSibling;
    } else {
      item = item.previousSibling;
    }
  }
  return null;
}
function createUIComponent(editor, commandName, label, icon) {
  editor.ui.componentFactory.add(commandName, (locale) => {
    const command = editor.commands.get(commandName);
    const buttonView = new ButtonView(locale);
    buttonView.set({
      label,
      icon,
      tooltip: true,
      isToggleable: true
    });
    buttonView.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
    buttonView.on("execute", () => {
      editor.execute(commandName);
      editor.editing.view.focus();
    });
    return buttonView;
  });
}
function findNestedList(viewElement) {
  for (const node of viewElement.getChildren()) {
    if (node.name == "ul" || node.name == "ol") {
      return node;
    }
  }
  return null;
}
function getSiblingNodes(position, direction) {
  const items = [];
  const listItem = position.parent;
  const walkerOptions = {
    ignoreElementEnd: false,
    startPosition: position,
    shallow: true,
    direction
  };
  const limitIndent = listItem.getAttribute("listIndent");
  const nodes = [...new TreeWalker(walkerOptions)].filter((value) => value.item.is("element")).map((value) => value.item);
  for (const element of nodes) {
    if (!element.is("element", "listItem")) {
      break;
    }
    if (element.getAttribute("listIndent") < limitIndent) {
      break;
    }
    if (element.getAttribute("listIndent") > limitIndent) {
      continue;
    }
    if (element.getAttribute("listType") !== listItem.getAttribute("listType")) {
      break;
    }
    if (element.getAttribute("listStyle") !== listItem.getAttribute("listStyle")) {
      break;
    }
    if (element.getAttribute("listReversed") !== listItem.getAttribute("listReversed")) {
      break;
    }
    if (element.getAttribute("listStart") !== listItem.getAttribute("listStart")) {
      break;
    }
    if (direction === "backward") {
      items.unshift(element);
    } else {
      items.push(element);
    }
  }
  return items;
}
function getSelectedListItems(model) {
  const document2 = model.document;
  let listItems = [...document2.selection.getSelectedBlocks()].filter((element) => element.is("element", "listItem")).map((element) => {
    const position = model.change((writer) => writer.createPositionAt(element, 0));
    return [
      ...getSiblingNodes(position, "backward"),
      ...getSiblingNodes(position, "forward")
    ];
  }).flat();
  listItems = [...new Set(listItems)];
  return listItems;
}
var BULLETED_LIST_STYLE_TYPES = ["disc", "circle", "square"];
var NUMBERED_LIST_STYLE_TYPES = [
  "decimal",
  "decimal-leading-zero",
  "lower-roman",
  "upper-roman",
  "lower-latin",
  "upper-latin"
];
function getListTypeFromListStyleType(listStyleType) {
  if (BULLETED_LIST_STYLE_TYPES.includes(listStyleType)) {
    return "bulleted";
  }
  if (NUMBERED_LIST_STYLE_TYPES.includes(listStyleType)) {
    return "numbered";
  }
  return null;
}
function getListItemFillerOffset() {
  const hasOnlyLists = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
  if (this.isEmpty || hasOnlyLists) {
    return 0;
  }
  return getFillerOffset.call(this);
}

// node_modules/@ckeditor/ckeditor5-list/src/list/listui.js
import numberedListIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/numberedlist.svg";
import bulletedListIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/bulletedlist.svg";
var ListUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const t = this.editor.t;
    createUIComponent(this.editor, "numberedList", t("Numbered List"), numberedListIcon);
    createUIComponent(this.editor, "bulletedList", t("Bulleted List"), bulletedListIcon);
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlist.js
var DocumentList = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [DocumentListEditing, ListUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DocumentList";
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlist/adjacentlistssupport.js
var AdjacentListsSupport = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AdjacentListsSupport";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    model.schema.register("listSeparator", {
      allowWhere: "$block",
      isBlock: true
    });
    editor.conversion.for("upcast").add((dispatcher) => {
      dispatcher.on("element:ol", listSeparatorUpcastConverter());
      dispatcher.on("element:ul", listSeparatorUpcastConverter());
    }).elementToElement({
      model: "listSeparator",
      view: "ck-list-separator"
    });
    editor.conversion.for("editingDowncast").elementToElement({
      model: "listSeparator",
      view: {
        name: "div",
        classes: ["ck-list-separator", "ck-hidden"]
      }
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "listSeparator",
      view: (modelElement, conversionApi) => {
        const viewElement = conversionApi.writer.createContainerElement("ck-list-separator");
        conversionApi.writer.setCustomProperty("dataPipeline:transparentRendering", true, viewElement);
        viewElement.getFillerOffset = () => null;
        return viewElement;
      }
    });
  }
};
function listSeparatorUpcastConverter() {
  return (evt, data, conversionApi) => {
    const element = data.viewItem;
    const nextSibling = element.nextSibling;
    if (!nextSibling) {
      return;
    }
    if (element.name !== nextSibling.name) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    const writer = conversionApi.writer;
    const modelElement = writer.createElement("listSeparator");
    if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {
      return;
    }
    const parts = conversionApi.getSplitParts(modelElement);
    data.modelRange = writer.createRange(data.modelRange.start, writer.createPositionAfter(parts[parts.length - 1]));
    conversionApi.updateConversionResult(modelElement, data);
  };
}

// node_modules/@ckeditor/ckeditor5-list/src/documentlistproperties/documentliststartcommand.js
var DocumentListStartCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const value = this._getValue();
    this.value = value;
    this.isEnabled = value != null;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.startIndex The list start index.
   */
  execute({ startIndex = 1 } = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    let blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block) => isListItemBlock(block) && block.getAttribute("listType") == "numbered");
    blocks = expandListBlocksToCompleteList(blocks);
    model.change((writer) => {
      for (const block of blocks) {
        writer.setAttribute("listStart", startIndex >= 0 ? startIndex : 1, block);
      }
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const model = this.editor.model;
    const document2 = model.document;
    const block = first(document2.selection.getSelectedBlocks());
    if (block && isListItemBlock(block) && block.getAttribute("listType") == "numbered") {
      return block.getAttribute("listStart");
    }
    return null;
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlistproperties/utils/style.js
var LIST_STYLE_TO_LIST_TYPE = {};
var LIST_STYLE_TO_TYPE_ATTRIBUTE = {};
var TYPE_ATTRIBUTE_TO_LIST_STYLE = {};
var LIST_STYLE_TYPES = [
  { listStyle: "disc", typeAttribute: "disc", listType: "bulleted" },
  { listStyle: "circle", typeAttribute: "circle", listType: "bulleted" },
  { listStyle: "square", typeAttribute: "square", listType: "bulleted" },
  { listStyle: "decimal", typeAttribute: "1", listType: "numbered" },
  { listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered" },
  { listStyle: "lower-roman", typeAttribute: "i", listType: "numbered" },
  { listStyle: "upper-roman", typeAttribute: "I", listType: "numbered" },
  { listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered" },
  { listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered" },
  { listStyle: "lower-latin", typeAttribute: "a", listType: "numbered" },
  { listStyle: "upper-latin", typeAttribute: "A", listType: "numbered" }
];
for (const { listStyle, typeAttribute, listType } of LIST_STYLE_TYPES) {
  LIST_STYLE_TO_LIST_TYPE[listStyle] = listType;
  LIST_STYLE_TO_TYPE_ATTRIBUTE[listStyle] = typeAttribute;
  if (typeAttribute) {
    TYPE_ATTRIBUTE_TO_LIST_STYLE[typeAttribute] = listStyle;
  }
}
function getAllSupportedStyleTypes() {
  return LIST_STYLE_TYPES.map((x) => x.listStyle);
}
function getListTypeFromListStyleType2(listStyleType) {
  return LIST_STYLE_TO_LIST_TYPE[listStyleType] || null;
}
function getListStyleTypeFromTypeAttribute(value) {
  return TYPE_ATTRIBUTE_TO_LIST_STYLE[value] || null;
}
function getTypeAttributeFromListStyleType(value) {
  return LIST_STYLE_TO_TYPE_ATTRIBUTE[value] || null;
}

// node_modules/@ckeditor/ckeditor5-list/src/documentlistproperties/documentliststylecommand.js
var DocumentListStyleCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param defaultType The list type that will be used by default if the value was not specified during
   * the command execution.
   * @param supportedTypes The list of supported style types by this command.
   */
  constructor(editor, defaultType, supportedTypes) {
    super(editor);
    this.defaultType = defaultType;
    this._supportedTypes = supportedTypes;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.type The type of the list style, e.g. `'disc'` or `'square'`. If `null` is specified, the default
   * style will be applied.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    model.change((writer) => {
      this._tryToConvertItemsToList(options);
      let blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block) => block.hasAttribute("listType"));
      if (!blocks.length) {
        return;
      }
      blocks = expandListBlocksToCompleteList(blocks);
      for (const block of blocks) {
        writer.setAttribute("listStyle", options.type || this.defaultType, block);
      }
    });
  }
  /**
   * Checks if the given style type is supported by this plugin.
   */
  isStyleTypeSupported(value) {
    if (!this._supportedTypes) {
      return true;
    }
    return this._supportedTypes.includes(value);
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const listItem = first(this.editor.model.document.selection.getSelectedBlocks());
    if (isListItemBlock(listItem)) {
      return listItem.getAttribute("listStyle");
    }
    return null;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const editor = this.editor;
    const numberedList = editor.commands.get("numberedList");
    const bulletedList = editor.commands.get("bulletedList");
    return numberedList.isEnabled || bulletedList.isEnabled;
  }
  /**
   * Check if the provided list style is valid. Also change the selection to a list if it's not set yet.
   *
   * @param options.type The type of the list style. If `null` is specified, the function does nothing.
  */
  _tryToConvertItemsToList(options) {
    if (!options.type) {
      return;
    }
    const listType = getListTypeFromListStyleType2(options.type);
    if (!listType) {
      return;
    }
    const editor = this.editor;
    const commandName = `${listType}List`;
    const command = editor.commands.get(commandName);
    if (!command.value) {
      editor.execute(commandName);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlistproperties/documentlistreversedcommand.js
var DocumentListReversedCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const value = this._getValue();
    this.value = value;
    this.isEnabled = value != null;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.reversed Whether the list should be reversed.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    let blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block) => isListItemBlock(block) && block.getAttribute("listType") == "numbered");
    blocks = expandListBlocksToCompleteList(blocks);
    model.change((writer) => {
      for (const block of blocks) {
        writer.setAttribute("listReversed", !!options.reversed, block);
      }
    });
  }
  /**
   * Checks the command's {@link #value}.
   */
  _getValue() {
    const model = this.editor.model;
    const document2 = model.document;
    const block = first(document2.selection.getSelectedBlocks());
    if (isListItemBlock(block) && block.getAttribute("listType") == "numbered") {
      return block.getAttribute("listReversed");
    }
    return null;
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlistproperties/converters.js
function listPropertiesUpcastConverter(strategy) {
  return (evt, data, conversionApi) => {
    const { writer, schema, consumable } = conversionApi;
    if (consumable.test(data.viewItem, strategy.viewConsumables) === false) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    let applied = false;
    for (const item of data.modelRange.getItems({ shallow: true })) {
      if (!schema.checkAttribute(item, strategy.attributeName)) {
        continue;
      }
      if (!strategy.appliesToListItem(item)) {
        continue;
      }
      if (item.hasAttribute(strategy.attributeName)) {
        continue;
      }
      writer.setAttribute(strategy.attributeName, strategy.getAttributeOnUpcast(data.viewItem), item);
      applied = true;
    }
    if (applied) {
      consumable.consume(data.viewItem, strategy.viewConsumables);
    }
  };
}

// node_modules/@ckeditor/ckeditor5-list/src/documentlistproperties/documentlistpropertiesutils.js
var DocumentListPropertiesUtils = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DocumentListPropertiesUtils";
  }
  /**
   * Gets all the style types supported by given list type.
   */
  getAllSupportedStyleTypes() {
    return getAllSupportedStyleTypes();
  }
  /**
   * Checks whether the given list-style-type is supported by numbered or bulleted list.
   */
  getListTypeFromListStyleType(listStyleType) {
    return getListTypeFromListStyleType2(listStyleType);
  }
  /**
   * Converts `type` attribute of `<ul>` or `<ol>` elements to `list-style-type` equivalent.
   */
  getListStyleTypeFromTypeAttribute(value) {
    return getListStyleTypeFromTypeAttribute(value);
  }
  /**
   * Converts `list-style-type` style to `type` attribute of `<ul>` or `<ol>` elements.
   */
  getTypeAttributeFromListStyleType(value) {
    return getTypeAttributeFromListStyleType(value);
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/documentlistproperties/documentlistpropertiesediting.js
var DEFAULT_LIST_TYPE = "default";
var DocumentListPropertiesEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [DocumentListEditing, DocumentListPropertiesUtils];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DocumentListPropertiesEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("list", {
      properties: {
        styles: true,
        startIndex: false,
        reversed: false
      }
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const documentListEditing = editor.plugins.get(DocumentListEditing);
    const enabledProperties = editor.config.get("list.properties");
    const strategies = createAttributeStrategies(enabledProperties);
    for (const strategy of strategies) {
      strategy.addCommand(editor);
      model.schema.extend("$container", { allowAttributes: strategy.attributeName });
      model.schema.extend("$block", { allowAttributes: strategy.attributeName });
      model.schema.extend("$blockObject", { allowAttributes: strategy.attributeName });
      documentListEditing.registerDowncastStrategy({
        scope: "list",
        attributeName: strategy.attributeName,
        setAttributeOnDowncast(writer, attributeValue, viewElement) {
          strategy.setAttributeOnDowncast(writer, attributeValue, viewElement);
        }
      });
    }
    editor.conversion.for("upcast").add((dispatcher) => {
      for (const strategy of strategies) {
        dispatcher.on("element:ol", listPropertiesUpcastConverter(strategy));
        dispatcher.on("element:ul", listPropertiesUpcastConverter(strategy));
      }
    });
    documentListEditing.on("checkAttributes:list", (evt, { viewElement, modelAttributes }) => {
      for (const strategy of strategies) {
        if (strategy.getAttributeOnUpcast(viewElement) != modelAttributes[strategy.attributeName]) {
          evt.return = true;
          evt.stop();
        }
      }
    });
    this.listenTo(editor.commands.get("indentList"), "afterExecute", (evt, changedBlocks) => {
      model.change((writer) => {
        for (const node of changedBlocks) {
          for (const strategy of strategies) {
            if (strategy.appliesToListItem(node)) {
              writer.setAttribute(strategy.attributeName, strategy.defaultValue, node);
            }
          }
        }
      });
    });
    documentListEditing.on("postFixer", (evt, { listNodes, writer }) => {
      for (const { node } of listNodes) {
        for (const strategy of strategies) {
          if (strategy.hasValidAttribute(node)) {
            continue;
          }
          if (strategy.appliesToListItem(node)) {
            writer.setAttribute(strategy.attributeName, strategy.defaultValue, node);
          } else {
            writer.removeAttribute(strategy.attributeName, node);
          }
          evt.return = true;
        }
      }
    });
    documentListEditing.on("postFixer", (evt, { listNodes, writer }) => {
      const previousNodesByIndent = [];
      for (const { node, previous } of listNodes) {
        if (!previous) {
          continue;
        }
        const nodeIndent = node.getAttribute("listIndent");
        const previousNodeIndent = previous.getAttribute("listIndent");
        let previousNodeInList = null;
        if (nodeIndent > previousNodeIndent) {
          previousNodesByIndent[previousNodeIndent] = previous;
        } else if (nodeIndent < previousNodeIndent) {
          previousNodeInList = previousNodesByIndent[nodeIndent];
          previousNodesByIndent.length = nodeIndent;
        } else {
          previousNodeInList = previous;
        }
        if (!previousNodeInList) {
          continue;
        }
        if (previousNodeInList.getAttribute("listType") != node.getAttribute("listType")) {
          continue;
        }
        for (const strategy of strategies) {
          const { attributeName } = strategy;
          if (!strategy.appliesToListItem(node)) {
            continue;
          }
          const value = previousNodeInList.getAttribute(attributeName);
          if (node.getAttribute(attributeName) != value) {
            writer.setAttribute(attributeName, value, node);
            evt.return = true;
          }
        }
      }
    });
  }
};
function createAttributeStrategies(enabledProperties) {
  const strategies = [];
  if (enabledProperties.styles) {
    const useAttribute = typeof enabledProperties.styles == "object" && enabledProperties.styles.useAttribute;
    strategies.push({
      attributeName: "listStyle",
      defaultValue: DEFAULT_LIST_TYPE,
      viewConsumables: { styles: "list-style-type" },
      addCommand(editor) {
        let supportedTypes = getAllSupportedStyleTypes();
        if (useAttribute) {
          supportedTypes = supportedTypes.filter((styleType) => !!getTypeAttributeFromListStyleType(styleType));
        }
        editor.commands.add("listStyle", new DocumentListStyleCommand(editor, DEFAULT_LIST_TYPE, supportedTypes));
      },
      appliesToListItem() {
        return true;
      },
      hasValidAttribute(item) {
        if (!item.hasAttribute("listStyle")) {
          return false;
        }
        const value = item.getAttribute("listStyle");
        if (value == DEFAULT_LIST_TYPE) {
          return true;
        }
        return getListTypeFromListStyleType2(value) == item.getAttribute("listType");
      },
      setAttributeOnDowncast(writer, listStyle, element) {
        if (listStyle && listStyle !== DEFAULT_LIST_TYPE) {
          if (useAttribute) {
            const value = getTypeAttributeFromListStyleType(listStyle);
            if (value) {
              writer.setAttribute("type", value, element);
              return;
            }
          } else {
            writer.setStyle("list-style-type", listStyle, element);
            return;
          }
        }
        writer.removeStyle("list-style-type", element);
        writer.removeAttribute("type", element);
      },
      getAttributeOnUpcast(listParent) {
        const style = listParent.getStyle("list-style-type");
        if (style) {
          return style;
        }
        const attribute = listParent.getAttribute("type");
        if (attribute) {
          return getListStyleTypeFromTypeAttribute(attribute);
        }
        return DEFAULT_LIST_TYPE;
      }
    });
  }
  if (enabledProperties.reversed) {
    strategies.push({
      attributeName: "listReversed",
      defaultValue: false,
      viewConsumables: { attributes: "reversed" },
      addCommand(editor) {
        editor.commands.add("listReversed", new DocumentListReversedCommand(editor));
      },
      appliesToListItem(item) {
        return item.getAttribute("listType") == "numbered";
      },
      hasValidAttribute(item) {
        return this.appliesToListItem(item) == item.hasAttribute("listReversed");
      },
      setAttributeOnDowncast(writer, listReversed, element) {
        if (listReversed) {
          writer.setAttribute("reversed", "reversed", element);
        } else {
          writer.removeAttribute("reversed", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        return listParent.hasAttribute("reversed");
      }
    });
  }
  if (enabledProperties.startIndex) {
    strategies.push({
      attributeName: "listStart",
      defaultValue: 1,
      viewConsumables: { attributes: "start" },
      addCommand(editor) {
        editor.commands.add("listStart", new DocumentListStartCommand(editor));
      },
      appliesToListItem(item) {
        return item.getAttribute("listType") == "numbered";
      },
      hasValidAttribute(item) {
        return this.appliesToListItem(item) == item.hasAttribute("listStart");
      },
      setAttributeOnDowncast(writer, listStart, element) {
        if (listStart == 0 || listStart > 1) {
          writer.setAttribute("start", listStart, element);
        } else {
          writer.removeAttribute("start", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        const startAttributeValue = listParent.getAttribute("start");
        return startAttributeValue >= 0 ? startAttributeValue : 1;
      }
    });
  }
  return strategies;
}

// node_modules/@ckeditor/ckeditor5-list/src/listproperties/ui/collapsibleview.js
import dropdownArrowIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/collapsible.css";
var CollapsibleView = class extends View {
  /**
   * Creates an instance of the collapsible view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param childViews An optional array of initial child views to be inserted into the collapsible.
   */
  constructor(locale, childViews) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isCollapsed", false);
    this.set("label", "");
    this.buttonView = this._createButtonView();
    this.children = this.createCollection();
    this.set("_collapsibleAriaLabelUid", void 0);
    if (childViews) {
      this.children.addMany(childViews);
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-collapsible",
          bind.if("isCollapsed", "ck-collapsible_collapsed")
        ]
      },
      children: [
        this.buttonView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-collapsible__children"
            ],
            role: "region",
            hidden: bind.if("isCollapsed", "hidden"),
            "aria-labelledby": bind.to("_collapsibleAriaLabelUid")
          },
          children: this.children
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id;
  }
  /**
   * Creates the main {@link #buttonView} of the collapsible.
   */
  _createButtonView() {
    const buttonView = new ButtonView(this.locale);
    const bind = buttonView.bindTemplate;
    buttonView.set({
      withText: true,
      icon: dropdownArrowIcon
    });
    buttonView.extendTemplate({
      attributes: {
        "aria-expanded": bind.to("isOn", (value) => String(value))
      }
    });
    buttonView.bind("label").to(this);
    buttonView.bind("isOn").to(this, "isCollapsed", (isCollapsed) => !isCollapsed);
    buttonView.on("execute", () => {
      this.isCollapsed = !this.isCollapsed;
    });
    return buttonView;
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/listproperties/ui/listpropertiesview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/listproperties.css";
var ListPropertiesView = class extends View {
  /**
   * Creates an instance of the list properties view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param options Options of the view.
   * @param options.enabledProperties An object containing the configuration of enabled list property names.
   * Allows conditional rendering the sub-components of the properties view.
   * @param options.styleButtonViews A list of style buttons to be rendered
   * inside the styles grid. The grid will not be rendered when `enabledProperties` does not include the `'styles'` key.
   * @param options.styleGridAriaLabel An assistive technologies label set on the grid of styles (if the grid is rendered).
   */
  constructor(locale, { enabledProperties, styleButtonViews, styleGridAriaLabel }) {
    super(locale);
    this.stylesView = null;
    this.additionalPropertiesCollapsibleView = null;
    this.startIndexFieldView = null;
    this.reversedSwitchButtonView = null;
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.focusables = new ViewCollection();
    const elementCssClasses = [
      "ck",
      "ck-list-properties"
    ];
    this.children = this.createCollection();
    this.focusCycler = new FocusCycler({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate #children backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate #children forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    });
    if (enabledProperties.styles) {
      this.stylesView = this._createStylesView(styleButtonViews, styleGridAriaLabel);
      this.children.add(this.stylesView);
    } else {
      elementCssClasses.push("ck-list-properties_without-styles");
    }
    if (enabledProperties.startIndex || enabledProperties.reversed) {
      this._addNumberedListPropertyViews(enabledProperties);
      elementCssClasses.push("ck-list-properties_with-numbered-properties");
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: elementCssClasses
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    if (this.stylesView) {
      this.focusables.add(this.stylesView);
      this.focusTracker.add(this.stylesView.element);
      if (this.startIndexFieldView || this.reversedSwitchButtonView) {
        this.focusables.add(this.children.last.buttonView);
        this.focusTracker.add(this.children.last.buttonView.element);
      }
      for (const item of this.stylesView.children) {
        this.stylesView.focusTracker.add(item.element);
      }
      addKeyboardHandlingForGrid({
        keystrokeHandler: this.stylesView.keystrokes,
        focusTracker: this.stylesView.focusTracker,
        gridItems: this.stylesView.children,
        // Note: The styles view has a different number of columns depending on whether the other properties
        // are enabled in the dropdown or not (https://github.com/ckeditor/ckeditor5/issues/12340)
        numberOfColumns: () => global_default.window.getComputedStyle(this.stylesView.element).getPropertyValue("grid-template-columns").split(" ").length,
        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
      });
    }
    if (this.startIndexFieldView) {
      this.focusables.add(this.startIndexFieldView);
      this.focusTracker.add(this.startIndexFieldView.element);
      const stopPropagation = (data) => data.stopPropagation();
      this.keystrokes.set("arrowright", stopPropagation);
      this.keystrokes.set("arrowleft", stopPropagation);
      this.keystrokes.set("arrowup", stopPropagation);
      this.keystrokes.set("arrowdown", stopPropagation);
    }
    if (this.reversedSwitchButtonView) {
      this.focusables.add(this.reversedSwitchButtonView);
      this.focusTracker.add(this.reversedSwitchButtonView.element);
    }
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  focus() {
    this.focusCycler.focusFirst();
  }
  /**
   * @inheritDoc
   */
  focusLast() {
    this.focusCycler.focusLast();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Creates the list styles grid.
   *
   * @param styleButtons Buttons to be placed in the grid.
   * @param styleGridAriaLabel The assistive technology label of the grid.
   */
  _createStylesView(styleButtons, styleGridAriaLabel) {
    const stylesView = new View(this.locale);
    stylesView.children = stylesView.createCollection();
    stylesView.children.addMany(styleButtons);
    stylesView.setTemplate({
      tag: "div",
      attributes: {
        "aria-label": styleGridAriaLabel,
        class: [
          "ck",
          "ck-list-styles-list"
        ]
      },
      children: stylesView.children
    });
    stylesView.children.delegate("execute").to(this);
    stylesView.focus = function() {
      this.children.first.focus();
    };
    stylesView.focusTracker = new FocusTracker();
    stylesView.keystrokes = new KeystrokeHandler();
    stylesView.render();
    stylesView.keystrokes.listenTo(stylesView.element);
    return stylesView;
  }
  /**
   * Renders {@link #startIndexFieldView} and/or {@link #reversedSwitchButtonView} depending on the configuration of the properties view.
   *
   * @param enabledProperties An object containing the configuration of enabled list property names
   * (see {@link #constructor}).
   */
  _addNumberedListPropertyViews(enabledProperties) {
    const t = this.locale.t;
    const numberedPropertyViews = [];
    if (enabledProperties.startIndex) {
      this.startIndexFieldView = this._createStartIndexField();
      numberedPropertyViews.push(this.startIndexFieldView);
    }
    if (enabledProperties.reversed) {
      this.reversedSwitchButtonView = this._createReversedSwitchButton();
      numberedPropertyViews.push(this.reversedSwitchButtonView);
    }
    if (enabledProperties.styles) {
      this.additionalPropertiesCollapsibleView = new CollapsibleView(this.locale, numberedPropertyViews);
      this.additionalPropertiesCollapsibleView.set({
        label: t("List properties"),
        isCollapsed: true
      });
      this.additionalPropertiesCollapsibleView.buttonView.bind("isEnabled").toMany(numberedPropertyViews, "isEnabled", (...areEnabled) => areEnabled.some((isEnabled) => isEnabled));
      this.additionalPropertiesCollapsibleView.buttonView.on("change:isEnabled", (evt, data, isEnabled) => {
        if (!isEnabled) {
          this.additionalPropertiesCollapsibleView.isCollapsed = true;
        }
      });
      this.children.add(this.additionalPropertiesCollapsibleView);
    } else {
      this.children.addMany(numberedPropertyViews);
    }
  }
  /**
   * Creates the list start index labeled field.
   */
  _createStartIndexField() {
    const t = this.locale.t;
    const startIndexFieldView = new LabeledFieldView(this.locale, createLabeledInputNumber);
    startIndexFieldView.set({
      label: t("Start at"),
      class: "ck-numbered-list-properties__start-index"
    });
    startIndexFieldView.fieldView.set({
      min: 0,
      step: 1,
      value: 1,
      inputMode: "numeric"
    });
    startIndexFieldView.fieldView.on("input", () => {
      const inputElement = startIndexFieldView.fieldView.element;
      const startIndex = inputElement.valueAsNumber;
      if (Number.isNaN(startIndex)) {
        return;
      }
      if (!inputElement.checkValidity()) {
        startIndexFieldView.errorText = t("Start index must be greater than 0.");
      } else {
        this.fire("listStart", { startIndex });
      }
    });
    return startIndexFieldView;
  }
  /**
   * Creates the reversed list switch button.
   */
  _createReversedSwitchButton() {
    const t = this.locale.t;
    const reversedButtonView = new SwitchButtonView(this.locale);
    reversedButtonView.set({
      withText: true,
      label: t("Reversed order"),
      class: "ck-numbered-list-properties__reversed-order"
    });
    reversedButtonView.delegate("execute").to(this, "listReversed");
    return reversedButtonView;
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/listproperties/listpropertiesui.js
import bulletedListIcon2 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/bulletedlist.svg";
import numberedListIcon2 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/numberedlist.svg";
import listStyleDiscIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/liststyledisc.svg";
import listStyleCircleIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/liststylecircle.svg";
import listStyleSquareIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/liststylesquare.svg";
import listStyleDecimalIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/liststyledecimal.svg";
import listStyleDecimalWithLeadingZeroIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/liststyledecimalleadingzero.svg";
import listStyleLowerRomanIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/liststylelowerroman.svg";
import listStyleUpperRomanIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/liststyleupperroman.svg";
import listStyleLowerLatinIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/liststylelowerlatin.svg";
import listStyleUpperLatinIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/liststyleupperlatin.svg";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css";
var ListPropertiesUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListPropertiesUI";
  }
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    const enabledProperties = editor.config.get("list.properties");
    if (enabledProperties.styles) {
      editor.ui.componentFactory.add("bulletedList", getDropdownViewCreator({
        editor,
        parentCommandName: "bulletedList",
        buttonLabel: t("Bulleted List"),
        buttonIcon: bulletedListIcon2,
        styleGridAriaLabel: t("Bulleted list styles toolbar"),
        styleDefinitions: [
          {
            label: t("Toggle the disc list style"),
            tooltip: t("Disc"),
            type: "disc",
            icon: listStyleDiscIcon
          },
          {
            label: t("Toggle the circle list style"),
            tooltip: t("Circle"),
            type: "circle",
            icon: listStyleCircleIcon
          },
          {
            label: t("Toggle the square list style"),
            tooltip: t("Square"),
            type: "square",
            icon: listStyleSquareIcon
          }
        ]
      }));
    }
    if (enabledProperties.styles || enabledProperties.startIndex || enabledProperties.reversed) {
      editor.ui.componentFactory.add("numberedList", getDropdownViewCreator({
        editor,
        parentCommandName: "numberedList",
        buttonLabel: t("Numbered List"),
        buttonIcon: numberedListIcon2,
        styleGridAriaLabel: t("Numbered list styles toolbar"),
        styleDefinitions: [
          {
            label: t("Toggle the decimal list style"),
            tooltip: t("Decimal"),
            type: "decimal",
            icon: listStyleDecimalIcon
          },
          {
            label: t("Toggle the decimal with leading zero list style"),
            tooltip: t("Decimal with leading zero"),
            type: "decimal-leading-zero",
            icon: listStyleDecimalWithLeadingZeroIcon
          },
          {
            label: t("Toggle the lower–roman list style"),
            tooltip: t("Lower–roman"),
            type: "lower-roman",
            icon: listStyleLowerRomanIcon
          },
          {
            label: t("Toggle the upper–roman list style"),
            tooltip: t("Upper-roman"),
            type: "upper-roman",
            icon: listStyleUpperRomanIcon
          },
          {
            label: t("Toggle the lower–latin list style"),
            tooltip: t("Lower-latin"),
            type: "lower-latin",
            icon: listStyleLowerLatinIcon
          },
          {
            label: t("Toggle the upper–latin list style"),
            tooltip: t("Upper-latin"),
            type: "upper-latin",
            icon: listStyleUpperLatinIcon
          }
        ]
      }));
    }
  }
};
function getDropdownViewCreator({ editor, parentCommandName, buttonLabel, buttonIcon, styleGridAriaLabel, styleDefinitions }) {
  const parentCommand = editor.commands.get(parentCommandName);
  return (locale) => {
    const dropdownView = createDropdown(locale, SplitButtonView);
    const mainButtonView = dropdownView.buttonView;
    dropdownView.bind("isEnabled").to(parentCommand);
    dropdownView.class = "ck-list-styles-dropdown";
    mainButtonView.on("execute", () => {
      editor.execute(parentCommandName);
      editor.editing.view.focus();
    });
    mainButtonView.set({
      label: buttonLabel,
      icon: buttonIcon,
      tooltip: true,
      isToggleable: true
    });
    mainButtonView.bind("isOn").to(parentCommand, "value", (value) => !!value);
    dropdownView.once("change:isOpen", () => {
      const listPropertiesView = createListPropertiesView({
        editor,
        dropdownView,
        parentCommandName,
        styleGridAriaLabel,
        styleDefinitions
      });
      dropdownView.panelView.children.add(listPropertiesView);
    });
    dropdownView.on("execute", () => {
      editor.editing.view.focus();
    });
    return dropdownView;
  };
}
function getStyleButtonCreator({ editor, listStyleCommand, parentCommandName }) {
  const locale = editor.locale;
  const parentCommand = editor.commands.get(parentCommandName);
  return ({ label, type, icon, tooltip }) => {
    const button = new ButtonView(locale);
    button.set({ label, icon, tooltip });
    listStyleCommand.on("change:value", () => {
      button.isOn = listStyleCommand.value === type;
    });
    button.on("execute", () => {
      if (parentCommand.value) {
        if (listStyleCommand.value !== type) {
          editor.execute("listStyle", { type });
        } else {
          editor.execute("listStyle", { type: listStyleCommand.defaultType });
        }
      } else {
        editor.model.change(() => {
          editor.execute("listStyle", { type });
        });
      }
    });
    return button;
  };
}
function createListPropertiesView({ editor, dropdownView, parentCommandName, styleDefinitions, styleGridAriaLabel }) {
  const locale = editor.locale;
  const enabledProperties = editor.config.get("list.properties");
  let styleButtonViews = null;
  if (parentCommandName != "numberedList") {
    enabledProperties.startIndex = false;
    enabledProperties.reversed = false;
  }
  if (enabledProperties.styles) {
    const listStyleCommand = editor.commands.get("listStyle");
    const styleButtonCreator = getStyleButtonCreator({
      editor,
      parentCommandName,
      listStyleCommand
    });
    const isStyleTypeSupported = typeof listStyleCommand.isStyleTypeSupported == "function" ? (styleDefinition) => listStyleCommand.isStyleTypeSupported(styleDefinition.type) : () => true;
    styleButtonViews = styleDefinitions.filter(isStyleTypeSupported).map(styleButtonCreator);
  }
  const listPropertiesView = new ListPropertiesView(locale, {
    styleGridAriaLabel,
    enabledProperties,
    styleButtonViews
  });
  if (enabledProperties.styles) {
    focusChildOnDropdownOpen(dropdownView, () => {
      return listPropertiesView.stylesView.children.find((child) => child.isOn);
    });
  }
  if (enabledProperties.startIndex) {
    const listStartCommand = editor.commands.get("listStart");
    listPropertiesView.startIndexFieldView.bind("isEnabled").to(listStartCommand);
    listPropertiesView.startIndexFieldView.fieldView.bind("value").to(listStartCommand);
    listPropertiesView.on("listStart", (evt, data) => editor.execute("listStart", data));
  }
  if (enabledProperties.reversed) {
    const listReversedCommand = editor.commands.get("listReversed");
    listPropertiesView.reversedSwitchButtonView.bind("isEnabled").to(listReversedCommand);
    listPropertiesView.reversedSwitchButtonView.bind("isOn").to(listReversedCommand, "value", (value) => !!value);
    listPropertiesView.on("listReversed", () => {
      const isReversed = listReversedCommand.value;
      editor.execute("listReversed", { reversed: !isReversed });
    });
  }
  listPropertiesView.delegate("execute").to(dropdownView);
  return listPropertiesView;
}

// node_modules/@ckeditor/ckeditor5-list/src/documentlistproperties.js
var DocumentListProperties = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [DocumentListPropertiesEditing, ListPropertiesUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DocumentListProperties";
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/list/indentcommand.js
var IndentCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param indentDirection The direction of indent. If it is equal to `backward`, the command will outdent a list item.
   */
  constructor(editor, indentDirection) {
    super(editor);
    this._indentBy = indentDirection == "forward" ? 1 : -1;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
   *
   * @fires execute
   */
  execute() {
    const model = this.editor.model;
    const doc = model.document;
    let itemsToChange = Array.from(doc.selection.getSelectedBlocks());
    model.change((writer) => {
      const lastItem = itemsToChange[itemsToChange.length - 1];
      let next = lastItem.nextSibling;
      while (next && next.name == "listItem" && next.getAttribute("listIndent") > lastItem.getAttribute("listIndent")) {
        itemsToChange.push(next);
        next = next.nextSibling;
      }
      if (this._indentBy < 0) {
        itemsToChange = itemsToChange.reverse();
      }
      for (const item of itemsToChange) {
        const indent = item.getAttribute("listIndent") + this._indentBy;
        if (indent < 0) {
          writer.rename(item, "paragraph");
        } else {
          writer.setAttribute("listIndent", indent, item);
        }
      }
      this.fire("_executeCleanup", itemsToChange);
    });
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const listItem = first(this.editor.model.document.selection.getSelectedBlocks());
    if (!listItem || !listItem.is("element", "listItem")) {
      return false;
    }
    if (this._indentBy > 0) {
      const indent = listItem.getAttribute("listIndent");
      const type = listItem.getAttribute("listType");
      let prev = listItem.previousSibling;
      while (prev && prev.is("element", "listItem") && prev.getAttribute("listIndent") >= indent) {
        if (prev.getAttribute("listIndent") == indent) {
          return prev.getAttribute("listType") == type;
        }
        prev = prev.previousSibling;
      }
      return false;
    }
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/list/listcommand.js
var ListCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param type List type that will be handled by this command.
   */
  constructor(editor, type) {
    super(editor);
    this.type = type;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the list command.
   *
   * @fires execute
   * @param options Command options.
   * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
   * selected items and potentially the neighbor elements to the proper list items. If set to `false`, it will convert selected elements
   * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const document2 = model.document;
    const blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block) => checkCanBecomeListItem(block, model.schema));
    const turnOff = options.forceValue !== void 0 ? !options.forceValue : this.value;
    model.change((writer) => {
      if (turnOff) {
        let next = blocks[blocks.length - 1].nextSibling;
        let currentIndent = Number.POSITIVE_INFINITY;
        let changes = [];
        while (next && next.name == "listItem" && next.getAttribute("listIndent") !== 0) {
          const indent = next.getAttribute("listIndent");
          if (indent < currentIndent) {
            currentIndent = indent;
          }
          const newIndent = indent - currentIndent;
          changes.push({ element: next, listIndent: newIndent });
          next = next.nextSibling;
        }
        changes = changes.reverse();
        for (const item of changes) {
          writer.setAttribute("listIndent", item.listIndent, item.element);
        }
      }
      if (!turnOff) {
        let lowestIndent = Number.POSITIVE_INFINITY;
        for (const item of blocks) {
          if (item.is("element", "listItem") && item.getAttribute("listIndent") < lowestIndent) {
            lowestIndent = item.getAttribute("listIndent");
          }
        }
        lowestIndent = lowestIndent === 0 ? 1 : lowestIndent;
        _fixType(blocks, true, lowestIndent);
        _fixType(blocks, false, lowestIndent);
      }
      for (const element of blocks.reverse()) {
        if (turnOff && element.name == "listItem") {
          writer.rename(element, "paragraph");
        } else if (!turnOff && element.name != "listItem") {
          writer.setAttributes({ listType: this.type, listIndent: 0 }, element);
          writer.rename(element, "listItem");
        } else if (!turnOff && element.name == "listItem" && element.getAttribute("listType") != this.type) {
          writer.setAttribute("listType", this.type, element);
        }
      }
      this.fire("_executeCleanup", blocks);
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const listItem = first(this.editor.model.document.selection.getSelectedBlocks());
    return !!listItem && listItem.is("element", "listItem") && listItem.getAttribute("listType") == this.type;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    if (this.value) {
      return true;
    }
    const selection = this.editor.model.document.selection;
    const schema = this.editor.model.schema;
    const firstBlock = first(selection.getSelectedBlocks());
    if (!firstBlock) {
      return false;
    }
    return checkCanBecomeListItem(firstBlock, schema);
  }
};
function _fixType(blocks, isBackward, lowestIndent) {
  const startingItem = isBackward ? blocks[0] : blocks[blocks.length - 1];
  if (startingItem.is("element", "listItem")) {
    let item = startingItem[isBackward ? "previousSibling" : "nextSibling"];
    let currentIndent = startingItem.getAttribute("listIndent");
    while (item && item.is("element", "listItem") && item.getAttribute("listIndent") >= lowestIndent) {
      if (currentIndent > item.getAttribute("listIndent")) {
        currentIndent = item.getAttribute("listIndent");
      }
      if (item.getAttribute("listIndent") == currentIndent) {
        blocks[isBackward ? "unshift" : "push"](item);
      }
      item = item[isBackward ? "previousSibling" : "nextSibling"];
    }
  }
}
function checkCanBecomeListItem(block, schema) {
  return schema.checkChild(block.parent, "listItem") && !schema.isObject(block);
}

// node_modules/@ckeditor/ckeditor5-list/src/list/listutils.js
var ListUtils = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListUtils";
  }
  /**
   * Checks whether the given list-style-type is supported by numbered or bulleted list.
   */
  getListTypeFromListStyleType(listStyleType) {
    return getListTypeFromListStyleType(listStyleType);
  }
  /**
   * Returns an array with all `listItem` elements in the model selection.
   *
   * It returns all the items even if only a part of the list is selected, including items that belong to nested lists.
   * If no list is selected, it returns an empty array.
   * The order of the elements is not specified.
   */
  getSelectedListItems(model) {
    return getSelectedListItems(model);
  }
  /**
   * Returns an array with all `listItem` elements that represent the same list.
   *
   * It means that values of `listIndent`, `listType`, `listStyle`, `listReversed` and `listStart` for all items are equal.
   *
   * Additionally, if the `position` is inside a list item, that list item will be returned as well.
   *
   * @param position Starting position.
   * @param direction Walking direction.
   */
  getSiblingNodes(position, direction) {
    return getSiblingNodes(position, direction);
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/list/converters.js
function modelViewInsertion(model) {
  return (evt, data, conversionApi) => {
    const consumable = conversionApi.consumable;
    if (!consumable.test(data.item, "insert") || !consumable.test(data.item, "attribute:listType") || !consumable.test(data.item, "attribute:listIndent")) {
      return;
    }
    consumable.consume(data.item, "insert");
    consumable.consume(data.item, "attribute:listType");
    consumable.consume(data.item, "attribute:listIndent");
    const modelItem = data.item;
    const viewItem = generateLiInUl(modelItem, conversionApi);
    injectViewList(modelItem, viewItem, conversionApi, model);
  };
}
function modelViewRemove(model) {
  return (evt, data, conversionApi) => {
    const viewPosition = conversionApi.mapper.toViewPosition(data.position);
    const viewStart = viewPosition.getLastMatchingPosition((value) => !value.item.is("element", "li"));
    const viewItem = viewStart.nodeAfter;
    const viewWriter = conversionApi.writer;
    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));
    const viewList = viewItem.parent;
    const viewListPrev = viewList.previousSibling;
    const removeRange = viewWriter.createRangeOn(viewList);
    const removed = viewWriter.remove(removeRange);
    if (viewListPrev && viewListPrev.nextSibling) {
      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);
    }
    const modelItem = conversionApi.mapper.toModelElement(viewItem);
    hoistNestedLists(modelItem.getAttribute("listIndent") + 1, data.position, removeRange.start, viewItem, conversionApi, model);
    for (const child of viewWriter.createRangeIn(removed).getItems()) {
      conversionApi.mapper.unbindViewElement(child);
    }
    evt.stop();
  };
}
var modelViewChangeType = (evt, data, conversionApi) => {
  if (!conversionApi.consumable.test(data.item, evt.name)) {
    return;
  }
  const viewItem = conversionApi.mapper.toViewElement(data.item);
  const viewWriter = conversionApi.writer;
  viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
  viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));
  const viewList = viewItem.parent;
  const listName = data.attributeNewValue == "numbered" ? "ol" : "ul";
  viewWriter.rename(listName, viewList);
};
var modelViewMergeAfterChangeType = (evt, data, conversionApi) => {
  conversionApi.consumable.consume(data.item, evt.name);
  const viewItem = conversionApi.mapper.toViewElement(data.item);
  const viewList = viewItem.parent;
  const viewWriter = conversionApi.writer;
  mergeViewLists(viewWriter, viewList, viewList.nextSibling);
  mergeViewLists(viewWriter, viewList.previousSibling, viewList);
};
function modelViewChangeIndent(model) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, "attribute:listIndent")) {
      return;
    }
    const viewItem = conversionApi.mapper.toViewElement(data.item);
    const viewWriter = conversionApi.writer;
    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));
    const viewList = viewItem.parent;
    const viewListPrev = viewList.previousSibling;
    const removeRange = viewWriter.createRangeOn(viewList);
    viewWriter.remove(removeRange);
    if (viewListPrev && viewListPrev.nextSibling) {
      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);
    }
    hoistNestedLists(data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model);
    injectViewList(data.item, viewItem, conversionApi, model);
    for (const child of data.item.getChildren()) {
      conversionApi.consumable.consume(child, "insert");
    }
  };
}
var modelViewSplitOnInsert = (evt, data, conversionApi) => {
  if (!conversionApi.consumable.test(data.item, evt.name)) {
    return;
  }
  if (data.item.name != "listItem") {
    let viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    const viewWriter = conversionApi.writer;
    const lists = [];
    while (viewPosition.parent.name == "ul" || viewPosition.parent.name == "ol") {
      viewPosition = viewWriter.breakContainer(viewPosition);
      if (viewPosition.parent.name != "li") {
        break;
      }
      const removeStart = viewPosition;
      const removeEnd = viewWriter.createPositionAt(viewPosition.parent, "end");
      if (!removeStart.isEqual(removeEnd)) {
        const removed = viewWriter.remove(viewWriter.createRange(removeStart, removeEnd));
        lists.push(removed);
      }
      viewPosition = viewWriter.createPositionAfter(viewPosition.parent);
    }
    if (lists.length > 0) {
      for (let i = 0; i < lists.length; i++) {
        const previousList = viewPosition.nodeBefore;
        const insertedRange = viewWriter.insert(viewPosition, lists[i]);
        viewPosition = insertedRange.end;
        if (i > 0) {
          const mergePos = mergeViewLists(viewWriter, previousList, previousList.nextSibling);
          if (mergePos && mergePos.parent == previousList) {
            viewPosition.offset--;
          }
        }
      }
      mergeViewLists(viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter);
    }
  }
};
var modelViewMergeAfter = (evt, data, conversionApi) => {
  const viewPosition = conversionApi.mapper.toViewPosition(data.position);
  const viewItemPrev = viewPosition.nodeBefore;
  const viewItemNext = viewPosition.nodeAfter;
  mergeViewLists(conversionApi.writer, viewItemPrev, viewItemNext);
};
var viewModelConverter = (evt, data, conversionApi) => {
  if (conversionApi.consumable.consume(data.viewItem, { name: true })) {
    const writer = conversionApi.writer;
    const listItem = writer.createElement("listItem");
    const indent = getIndent2(data.viewItem);
    writer.setAttribute("listIndent", indent, listItem);
    const type = data.viewItem.parent && data.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
    writer.setAttribute("listType", type, listItem);
    if (!conversionApi.safeInsert(listItem, data.modelCursor)) {
      return;
    }
    const nextPosition = viewToModelListItemChildrenConverter(listItem, data.viewItem.getChildren(), conversionApi);
    data.modelRange = writer.createRange(data.modelCursor, nextPosition);
    conversionApi.updateConversionResult(listItem, data);
  }
};
var cleanList = (evt, data, conversionApi) => {
  if (conversionApi.consumable.test(data.viewItem, { name: true })) {
    const children = Array.from(data.viewItem.getChildren());
    for (const child of children) {
      const isWrongElement = !(child.is("element", "li") || isList(child));
      if (isWrongElement) {
        child._remove();
      }
    }
  }
};
var cleanListItem = (evt, data, conversionApi) => {
  if (conversionApi.consumable.test(data.viewItem, { name: true })) {
    if (data.viewItem.childCount === 0) {
      return;
    }
    const children = [...data.viewItem.getChildren()];
    let foundList = false;
    for (const child of children) {
      if (foundList && !isList(child)) {
        child._remove();
      }
      if (isList(child)) {
        foundList = true;
      }
    }
  }
};
function modelToViewPosition(view) {
  return (evt, data) => {
    if (data.isPhantom) {
      return;
    }
    const modelItem = data.modelPosition.nodeBefore;
    if (modelItem && modelItem.is("element", "listItem")) {
      const viewItem = data.mapper.toViewElement(modelItem);
      const topmostViewList = viewItem.getAncestors().find(isList);
      const walker = view.createPositionAt(viewItem, 0).getWalker();
      for (const value of walker) {
        if (value.type == "elementStart" && value.item.is("element", "li")) {
          data.viewPosition = value.previousPosition;
          break;
        } else if (value.type == "elementEnd" && value.item == topmostViewList) {
          data.viewPosition = value.nextPosition;
          break;
        }
      }
    }
  };
}
function viewToModelPosition(model) {
  return (evt, data) => {
    const viewPos = data.viewPosition;
    const viewParent = viewPos.parent;
    const mapper = data.mapper;
    if (viewParent.name == "ul" || viewParent.name == "ol") {
      if (!viewPos.isAtEnd) {
        const modelNode = mapper.toModelElement(viewPos.nodeAfter);
        data.modelPosition = model.createPositionBefore(modelNode);
      } else {
        const modelNode = mapper.toModelElement(viewPos.nodeBefore);
        const modelLength = mapper.getModelLength(viewPos.nodeBefore);
        data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);
      }
      evt.stop();
    } else if (viewParent.name == "li" && viewPos.nodeBefore && (viewPos.nodeBefore.name == "ul" || viewPos.nodeBefore.name == "ol")) {
      const modelNode = mapper.toModelElement(viewParent);
      let modelLength = 1;
      let viewList = viewPos.nodeBefore;
      while (viewList && isList(viewList)) {
        modelLength += mapper.getModelLength(viewList);
        viewList = viewList.previousSibling;
      }
      data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);
      evt.stop();
    }
  };
}
function modelChangePostFixer2(model, writer) {
  const changes = model.document.differ.getChanges();
  const itemToListHead = /* @__PURE__ */ new Map();
  let applied = false;
  for (const entry of changes) {
    if (entry.type == "insert" && entry.name == "listItem") {
      _addListToFix(entry.position);
    } else if (entry.type == "insert" && entry.name != "listItem") {
      if (entry.name != "$text") {
        const item = entry.position.nodeAfter;
        if (item.hasAttribute("listIndent")) {
          writer.removeAttribute("listIndent", item);
          applied = true;
        }
        if (item.hasAttribute("listType")) {
          writer.removeAttribute("listType", item);
          applied = true;
        }
        if (item.hasAttribute("listStyle")) {
          writer.removeAttribute("listStyle", item);
          applied = true;
        }
        if (item.hasAttribute("listReversed")) {
          writer.removeAttribute("listReversed", item);
          applied = true;
        }
        if (item.hasAttribute("listStart")) {
          writer.removeAttribute("listStart", item);
          applied = true;
        }
        for (const innerItem of Array.from(model.createRangeIn(item)).filter((e) => e.item.is("element", "listItem"))) {
          _addListToFix(innerItem.previousPosition);
        }
      }
      const posAfter = entry.position.getShiftedBy(entry.length);
      _addListToFix(posAfter);
    } else if (entry.type == "remove" && entry.name == "listItem") {
      _addListToFix(entry.position);
    } else if (entry.type == "attribute" && entry.attributeKey == "listIndent") {
      _addListToFix(entry.range.start);
    } else if (entry.type == "attribute" && entry.attributeKey == "listType") {
      _addListToFix(entry.range.start);
    }
  }
  for (const listHead of itemToListHead.values()) {
    _fixListIndents(listHead);
    _fixListTypes(listHead);
  }
  return applied;
  function _addListToFix(position) {
    const previousNode = position.nodeBefore;
    if (!previousNode || !previousNode.is("element", "listItem")) {
      const item = position.nodeAfter;
      if (item && item.is("element", "listItem")) {
        itemToListHead.set(item, item);
      }
    } else {
      let listHead = previousNode;
      if (itemToListHead.has(listHead)) {
        return;
      }
      for (let previousSibling = listHead.previousSibling; previousSibling && previousSibling.is("element", "listItem"); previousSibling = listHead.previousSibling) {
        listHead = previousSibling;
        if (itemToListHead.has(listHead)) {
          return;
        }
      }
      itemToListHead.set(previousNode, listHead);
    }
  }
  function _fixListIndents(item) {
    let maxIndent = 0;
    let fixBy = null;
    while (item && item.is("element", "listItem")) {
      const itemIndent = item.getAttribute("listIndent");
      if (itemIndent > maxIndent) {
        let newIndent;
        if (fixBy === null) {
          fixBy = itemIndent - maxIndent;
          newIndent = maxIndent;
        } else {
          if (fixBy > itemIndent) {
            fixBy = itemIndent;
          }
          newIndent = itemIndent - fixBy;
        }
        writer.setAttribute("listIndent", newIndent, item);
        applied = true;
      } else {
        fixBy = null;
        maxIndent = item.getAttribute("listIndent") + 1;
      }
      item = item.nextSibling;
    }
  }
  function _fixListTypes(item) {
    let typesStack = [];
    let prev = null;
    while (item && item.is("element", "listItem")) {
      const itemIndent = item.getAttribute("listIndent");
      if (prev && prev.getAttribute("listIndent") > itemIndent) {
        typesStack = typesStack.slice(0, itemIndent + 1);
      }
      if (itemIndent != 0) {
        if (typesStack[itemIndent]) {
          const type = typesStack[itemIndent];
          if (item.getAttribute("listType") != type) {
            writer.setAttribute("listType", type, item);
            applied = true;
          }
        } else {
          typesStack[itemIndent] = item.getAttribute("listType");
        }
      }
      prev = item;
      item = item.nextSibling;
    }
  }
}
var modelIndentPasteFixer = function(evt, [content, selectable]) {
  const model = this;
  let item = content.is("documentFragment") ? content.getChild(0) : content;
  let selection;
  if (!selectable) {
    selection = model.document.selection;
  } else {
    selection = model.createSelection(selectable);
  }
  if (item && item.is("element", "listItem")) {
    const pos = selection.getFirstPosition();
    let refItem = null;
    if (pos.parent.is("element", "listItem")) {
      refItem = pos.parent;
    } else if (pos.nodeBefore && pos.nodeBefore.is("element", "listItem")) {
      refItem = pos.nodeBefore;
    }
    if (refItem) {
      const indentChange = refItem.getAttribute("listIndent");
      if (indentChange > 0) {
        while (item && item.is("element", "listItem")) {
          item._setAttribute("listIndent", item.getAttribute("listIndent") + indentChange);
          item = item.nextSibling;
        }
      }
    }
  }
};
function viewToModelListItemChildrenConverter(listItemModel, viewChildren, conversionApi) {
  const { writer, schema } = conversionApi;
  let nextPosition = writer.createPositionAfter(listItemModel);
  for (const child of viewChildren) {
    if (child.name == "ul" || child.name == "ol") {
      nextPosition = conversionApi.convertItem(child, nextPosition).modelCursor;
    } else {
      const result = conversionApi.convertItem(child, writer.createPositionAt(listItemModel, "end"));
      const convertedChild = result.modelRange.start.nodeAfter;
      const wasSplit = convertedChild && convertedChild.is("element") && !schema.checkChild(listItemModel, convertedChild.name);
      if (wasSplit) {
        if (result.modelCursor.parent.is("element", "listItem")) {
          listItemModel = result.modelCursor.parent;
        } else {
          listItemModel = findNextListItem(result.modelCursor);
        }
        nextPosition = writer.createPositionAfter(listItemModel);
      }
    }
  }
  return nextPosition;
}
function findNextListItem(startPosition) {
  const treeWalker = new TreeWalker({ startPosition });
  let value;
  do {
    value = treeWalker.next();
  } while (!value.value.item.is("element", "listItem"));
  return value.value.item;
}
function hoistNestedLists(nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model) {
  const prevModelItem = getSiblingListItem(modelRemoveStartPosition.nodeBefore, {
    sameIndent: true,
    smallerIndent: true,
    listIndent: nextIndent
  });
  const mapper = conversionApi.mapper;
  const viewWriter = conversionApi.writer;
  const prevIndent = prevModelItem ? prevModelItem.getAttribute("listIndent") : null;
  let insertPosition;
  if (!prevModelItem) {
    insertPosition = viewRemoveStartPosition;
  } else if (prevIndent == nextIndent) {
    const prevViewList = mapper.toViewElement(prevModelItem).parent;
    insertPosition = viewWriter.createPositionAfter(prevViewList);
  } else {
    const modelPosition = model.createPositionAt(prevModelItem, "end");
    insertPosition = mapper.toViewPosition(modelPosition);
  }
  insertPosition = positionAfterUiElements(insertPosition);
  for (const child of [...viewRemovedItem.getChildren()]) {
    if (isList(child)) {
      insertPosition = viewWriter.move(viewWriter.createRangeOn(child), insertPosition).end;
      mergeViewLists(viewWriter, child, child.nextSibling);
      mergeViewLists(viewWriter, child.previousSibling, child);
    }
  }
}
function isList(viewElement) {
  return viewElement.is("element", "ol") || viewElement.is("element", "ul");
}
function getIndent2(listItem) {
  let indent = 0;
  let parent = listItem.parent;
  while (parent) {
    if (parent.is("element", "li")) {
      indent++;
    } else {
      const previousSibling = parent.previousSibling;
      if (previousSibling && previousSibling.is("element", "li")) {
        indent++;
      }
    }
    parent = parent.parent;
  }
  return indent;
}

// node_modules/@ckeditor/ckeditor5-list/src/list/listediting.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/list.css";
var ListEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Enter, Delete, ListUtils];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    editor.model.schema.register("listItem", {
      inheritAllFrom: "$block",
      allowAttributes: ["listType", "listIndent"]
    });
    const data = editor.data;
    const editing = editor.editing;
    editor.model.document.registerPostFixer((writer) => modelChangePostFixer2(editor.model, writer));
    editing.mapper.registerViewToModelLength("li", getViewListItemLength);
    data.mapper.registerViewToModelLength("li", getViewListItemLength);
    editing.mapper.on("modelToViewPosition", modelToViewPosition(editing.view));
    editing.mapper.on("viewToModelPosition", viewToModelPosition(editor.model));
    data.mapper.on("modelToViewPosition", modelToViewPosition(editing.view));
    editor.conversion.for("editingDowncast").add((dispatcher) => {
      dispatcher.on("insert", modelViewSplitOnInsert, { priority: "high" });
      dispatcher.on("insert:listItem", modelViewInsertion(editor.model));
      dispatcher.on("attribute:listType:listItem", modelViewChangeType, { priority: "high" });
      dispatcher.on("attribute:listType:listItem", modelViewMergeAfterChangeType, { priority: "low" });
      dispatcher.on("attribute:listIndent:listItem", modelViewChangeIndent(editor.model));
      dispatcher.on("remove:listItem", modelViewRemove(editor.model));
      dispatcher.on("remove", modelViewMergeAfter, { priority: "low" });
    });
    editor.conversion.for("dataDowncast").add((dispatcher) => {
      dispatcher.on("insert", modelViewSplitOnInsert, { priority: "high" });
      dispatcher.on("insert:listItem", modelViewInsertion(editor.model));
    });
    editor.conversion.for("upcast").add((dispatcher) => {
      dispatcher.on("element:ul", cleanList, { priority: "high" });
      dispatcher.on("element:ol", cleanList, { priority: "high" });
      dispatcher.on("element:li", cleanListItem, { priority: "high" });
      dispatcher.on("element:li", viewModelConverter);
    });
    editor.model.on("insertContent", modelIndentPasteFixer, { priority: "high" });
    editor.commands.add("numberedList", new ListCommand(editor, "numbered"));
    editor.commands.add("bulletedList", new ListCommand(editor, "bulleted"));
    editor.commands.add("indentList", new IndentCommand(editor, "forward"));
    editor.commands.add("outdentList", new IndentCommand(editor, "backward"));
    const viewDocument = editing.view.document;
    this.listenTo(viewDocument, "enter", (evt, data2) => {
      const doc = this.editor.model.document;
      const positionParent = doc.selection.getLastPosition().parent;
      if (doc.selection.isCollapsed && positionParent.name == "listItem" && positionParent.isEmpty) {
        this.editor.execute("outdentList");
        data2.preventDefault();
        evt.stop();
      }
    }, { context: "li" });
    this.listenTo(viewDocument, "delete", (evt, data2) => {
      if (data2.direction !== "backward") {
        return;
      }
      const selection = this.editor.model.document.selection;
      if (!selection.isCollapsed) {
        return;
      }
      const firstPosition = selection.getFirstPosition();
      if (!firstPosition.isAtStart) {
        return;
      }
      const positionParent = firstPosition.parent;
      if (positionParent.name !== "listItem") {
        return;
      }
      const previousIsAListItem = positionParent.previousSibling && positionParent.previousSibling.name === "listItem";
      if (previousIsAListItem) {
        return;
      }
      this.editor.execute("outdentList");
      data2.preventDefault();
      evt.stop();
    }, { context: "li" });
    this.listenTo(editor.editing.view.document, "tab", (evt, data2) => {
      const commandName = data2.shiftKey ? "outdentList" : "indentList";
      const command = this.editor.commands.get(commandName);
      if (command.isEnabled) {
        editor.execute(commandName);
        data2.stopPropagation();
        data2.preventDefault();
        evt.stop();
      }
    }, { context: "li" });
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const commands = this.editor.commands;
    const indent = commands.get("indent");
    const outdent = commands.get("outdent");
    if (indent) {
      indent.registerChildCommand(commands.get("indentList"));
    }
    if (outdent) {
      outdent.registerChildCommand(commands.get("outdentList"));
    }
  }
};
function getViewListItemLength(element) {
  let length = 1;
  for (const child of element.getChildren()) {
    if (child.name == "ul" || child.name == "ol") {
      for (const item of child.getChildren()) {
        length += getViewListItemLength(item);
      }
    }
  }
  return length;
}

// node_modules/@ckeditor/ckeditor5-list/src/list.js
var List = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ListEditing, ListUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "List";
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/listproperties/liststylecommand.js
var ListStyleCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor The editor instance.
   * @param defaultType The list type that will be used by default if the value was not specified during
   * the command execution.
   */
  constructor(editor, defaultType) {
    super(editor);
    this.defaultType = defaultType;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.type The type of the list style, e.g. `'disc'` or `'square'`. If `null` is specified, the default
   * style will be applied.
   */
  execute(options = {}) {
    this._tryToConvertItemsToList(options);
    const model = this.editor.model;
    const listItems = getSelectedListItems(model);
    if (!listItems.length) {
      return;
    }
    model.change((writer) => {
      for (const item of listItems) {
        writer.setAttribute("listStyle", options.type || this.defaultType, item);
      }
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const listItem = this.editor.model.document.selection.getFirstPosition().parent;
    if (listItem && listItem.is("element", "listItem")) {
      return listItem.getAttribute("listStyle");
    }
    return null;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    const editor = this.editor;
    const numberedList = editor.commands.get("numberedList");
    const bulletedList = editor.commands.get("bulletedList");
    return numberedList.isEnabled || bulletedList.isEnabled;
  }
  /**
   * Checks if the provided list style is valid. Also changes the selection to a list if it's not set yet.
   *
   * @param The type of the list style. If `null` is specified, the function does nothing.
  */
  _tryToConvertItemsToList(options) {
    if (!options.type) {
      return;
    }
    const listType = getListTypeFromListStyleType(options.type);
    if (!listType) {
      return;
    }
    const editor = this.editor;
    const commandName = `${listType}List`;
    const command = editor.commands.get(commandName);
    if (!command.value) {
      editor.execute(commandName);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/listproperties/listreversedcommand.js
var ListReversedCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const value = this._getValue();
    this.value = value;
    this.isEnabled = value != null;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.reversed Whether the list should be reversed.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const listItems = getSelectedListItems(model).filter((item) => item.getAttribute("listType") == "numbered");
    model.change((writer) => {
      for (const item of listItems) {
        writer.setAttribute("listReversed", !!options.reversed, item);
      }
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const listItem = this.editor.model.document.selection.getFirstPosition().parent;
    if (listItem && listItem.is("element", "listItem") && listItem.getAttribute("listType") == "numbered") {
      return listItem.getAttribute("listReversed");
    }
    return null;
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/listproperties/liststartcommand.js
var ListStartCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const value = this._getValue();
    this.value = value;
    this.isEnabled = value != null;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.startIndex The list start index.
   */
  execute({ startIndex = 1 } = {}) {
    const model = this.editor.model;
    const listItems = getSelectedListItems(model).filter((item) => item.getAttribute("listType") == "numbered");
    model.change((writer) => {
      for (const item of listItems) {
        writer.setAttribute("listStart", startIndex >= 0 ? startIndex : 1, item);
      }
    });
  }
  /**
   * Checks the command's {@link #value}.
   *
   * @returns The current value.
   */
  _getValue() {
    const listItem = this.editor.model.document.selection.getFirstPosition().parent;
    if (listItem && listItem.is("element", "listItem") && listItem.getAttribute("listType") == "numbered") {
      return listItem.getAttribute("listStart");
    }
    return null;
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/listproperties/listpropertiesediting.js
var DEFAULT_LIST_TYPE2 = "default";
var ListPropertiesEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ListEditing];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListPropertiesEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("list", {
      properties: {
        styles: true,
        startIndex: false,
        reversed: false
      }
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const enabledProperties = editor.config.get("list.properties");
    const strategies = createAttributeStrategies2(enabledProperties);
    model.schema.extend("listItem", {
      allowAttributes: strategies.map((s) => s.attributeName)
    });
    for (const strategy of strategies) {
      strategy.addCommand(editor);
    }
    this.listenTo(editor.commands.get("indentList"), "_executeCleanup", fixListAfterIndentListCommand(editor, strategies));
    this.listenTo(editor.commands.get("outdentList"), "_executeCleanup", fixListAfterOutdentListCommand(editor, strategies));
    this.listenTo(editor.commands.get("bulletedList"), "_executeCleanup", restoreDefaultListStyle(editor));
    this.listenTo(editor.commands.get("numberedList"), "_executeCleanup", restoreDefaultListStyle(editor));
    model.document.registerPostFixer(fixListAttributesOnListItemElements(editor, strategies));
    editor.conversion.for("upcast").add(upcastListItemAttributes(strategies));
    editor.conversion.for("downcast").add(downcastListItemAttributes(strategies));
    this._mergeListAttributesWhileMergingLists(strategies);
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const editor = this.editor;
    if (editor.commands.get("todoList")) {
      editor.model.document.registerPostFixer(removeListItemAttributesFromTodoList(editor));
    }
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether two lists will be merged into a single
   * one after deleting the content.
   *
   * The purpose of this action is to adjust the `listStyle`, `listReversed` and `listStart` values
   * for the list that was merged.
   *
   * Consider the following model's content:
   *
   * ```xml
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 1</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 2</listItem>
   * <paragraph>[A paragraph.]</paragraph>
   * <listItem listIndent="0" listType="bulleted" listStyle="circle">UL List item 1</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="circle">UL List item 2</listItem>
   * ```
   *
   * After removing the paragraph element, the second list will be merged into the first one.
   * We want to inherit the `listStyle` attribute for the second list from the first one.
   *
   * ```xml
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 1</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 2</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 1</listItem>
   * <listItem listIndent="0" listType="bulleted" listStyle="square">UL List item 2</listItem>
   * ```
   *
   * See https://github.com/ckeditor/ckeditor5/issues/7879.
   *
   * @param attributeStrategies Strategies for the enabled attributes.
   */
  _mergeListAttributesWhileMergingLists(attributeStrategies) {
    const editor = this.editor;
    const model = editor.model;
    let firstMostOuterItem;
    this.listenTo(model, "deleteContent", (evt, [selection]) => {
      const firstPosition = selection.getFirstPosition();
      const lastPosition = selection.getLastPosition();
      if (firstPosition.parent === lastPosition.parent) {
        return;
      }
      if (!firstPosition.parent.is("element", "listItem")) {
        return;
      }
      const nextSibling = lastPosition.parent.nextSibling;
      if (!nextSibling || !nextSibling.is("element", "listItem")) {
        return;
      }
      const mostOuterItemList = getSiblingListItem(firstPosition.parent, {
        sameIndent: true,
        listIndent: nextSibling.getAttribute("listIndent")
      });
      if (!mostOuterItemList) {
        return;
      }
      if (mostOuterItemList.getAttribute("listType") === nextSibling.getAttribute("listType")) {
        firstMostOuterItem = mostOuterItemList;
      }
    }, { priority: "high" });
    this.listenTo(model, "deleteContent", () => {
      if (!firstMostOuterItem) {
        return;
      }
      model.change((writer) => {
        const secondListMostOuterItem = getSiblingListItem(firstMostOuterItem.nextSibling, {
          sameIndent: true,
          listIndent: firstMostOuterItem.getAttribute("listIndent"),
          direction: "forward"
        });
        if (!secondListMostOuterItem) {
          firstMostOuterItem = null;
          return;
        }
        const items = [
          secondListMostOuterItem,
          ...getSiblingNodes(writer.createPositionAt(secondListMostOuterItem, 0), "forward")
        ];
        for (const listItem of items) {
          for (const strategy of attributeStrategies) {
            if (strategy.appliesToListItem(listItem)) {
              const attributeName = strategy.attributeName;
              const value = firstMostOuterItem.getAttribute(attributeName);
              writer.setAttribute(attributeName, value, listItem);
            }
          }
        }
      });
      firstMostOuterItem = null;
    }, { priority: "low" });
  }
};
function createAttributeStrategies2(enabledProperties) {
  const strategies = [];
  if (enabledProperties.styles) {
    strategies.push({
      attributeName: "listStyle",
      defaultValue: DEFAULT_LIST_TYPE2,
      addCommand(editor) {
        editor.commands.add("listStyle", new ListStyleCommand(editor, DEFAULT_LIST_TYPE2));
      },
      appliesToListItem() {
        return true;
      },
      setAttributeOnDowncast(writer, listStyle, element) {
        if (listStyle && listStyle !== DEFAULT_LIST_TYPE2) {
          writer.setStyle("list-style-type", listStyle, element);
        } else {
          writer.removeStyle("list-style-type", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        return listParent.getStyle("list-style-type") || DEFAULT_LIST_TYPE2;
      }
    });
  }
  if (enabledProperties.reversed) {
    strategies.push({
      attributeName: "listReversed",
      defaultValue: false,
      addCommand(editor) {
        editor.commands.add("listReversed", new ListReversedCommand(editor));
      },
      appliesToListItem(item) {
        return item.getAttribute("listType") == "numbered";
      },
      setAttributeOnDowncast(writer, listReversed, element) {
        if (listReversed) {
          writer.setAttribute("reversed", "reversed", element);
        } else {
          writer.removeAttribute("reversed", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        return listParent.hasAttribute("reversed");
      }
    });
  }
  if (enabledProperties.startIndex) {
    strategies.push({
      attributeName: "listStart",
      defaultValue: 1,
      addCommand(editor) {
        editor.commands.add("listStart", new ListStartCommand(editor));
      },
      appliesToListItem(item) {
        return item.getAttribute("listType") == "numbered";
      },
      setAttributeOnDowncast(writer, listStart, element) {
        if (listStart == 0 || listStart > 1) {
          writer.setAttribute("start", listStart, element);
        } else {
          writer.removeAttribute("start", element);
        }
      },
      getAttributeOnUpcast(listParent) {
        const startAttributeValue = listParent.getAttribute("start");
        return startAttributeValue >= 0 ? startAttributeValue : 1;
      }
    });
  }
  return strategies;
}
function upcastListItemAttributes(attributeStrategies) {
  return (dispatcher) => {
    dispatcher.on("element:li", (evt, data, conversionApi) => {
      if (!data.modelRange) {
        return;
      }
      const listParent = data.viewItem.parent;
      const listItem = data.modelRange.start.nodeAfter || data.modelRange.end.nodeBefore;
      for (const strategy of attributeStrategies) {
        if (strategy.appliesToListItem(listItem)) {
          const listStyle = strategy.getAttributeOnUpcast(listParent);
          conversionApi.writer.setAttribute(strategy.attributeName, listStyle, listItem);
        }
      }
    }, { priority: "low" });
  };
}
function downcastListItemAttributes(attributeStrategies) {
  return (dispatcher) => {
    for (const strategy of attributeStrategies) {
      dispatcher.on(`attribute:${strategy.attributeName}:listItem`, (evt, data, conversionApi) => {
        const viewWriter = conversionApi.writer;
        const currentElement = data.item;
        const previousElement = getSiblingListItem(currentElement.previousSibling, {
          sameIndent: true,
          listIndent: currentElement.getAttribute("listIndent"),
          direction: "backward"
        });
        const viewItem = conversionApi.mapper.toViewElement(currentElement);
        if (!areRepresentingSameList(currentElement, previousElement)) {
          viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
        }
        strategy.setAttributeOnDowncast(viewWriter, data.attributeNewValue, viewItem.parent);
      }, { priority: "low" });
    }
  };
  function areRepresentingSameList(listItem1, listItem2) {
    return listItem2 && listItem1.getAttribute("listType") === listItem2.getAttribute("listType") && listItem1.getAttribute("listIndent") === listItem2.getAttribute("listIndent") && listItem1.getAttribute("listStyle") === listItem2.getAttribute("listStyle") && listItem1.getAttribute("listReversed") === listItem2.getAttribute("listReversed") && listItem1.getAttribute("listStart") === listItem2.getAttribute("listStart");
  }
}
function fixListAfterIndentListCommand(editor, attributeStrategies) {
  return (evt, changedItems) => {
    const root = changedItems[0];
    const rootIndent = root.getAttribute("listIndent");
    const itemsToUpdate = changedItems.filter((item) => item.getAttribute("listIndent") === rootIndent);
    let previousSibling = null;
    if (root.previousSibling.getAttribute("listIndent") + 1 !== rootIndent) {
      previousSibling = getSiblingListItem(root.previousSibling, {
        sameIndent: true,
        direction: "backward",
        listIndent: rootIndent
      });
    }
    editor.model.change((writer) => {
      for (const item of itemsToUpdate) {
        for (const strategy of attributeStrategies) {
          if (strategy.appliesToListItem(item)) {
            const valueToSet = previousSibling == null ? strategy.defaultValue : previousSibling.getAttribute(strategy.attributeName);
            writer.setAttribute(strategy.attributeName, valueToSet, item);
          }
        }
      }
    });
  };
}
function fixListAfterOutdentListCommand(editor, attributeStrategies) {
  return (evt, changedItems) => {
    changedItems = changedItems.reverse().filter((item) => item.is("element", "listItem"));
    if (!changedItems.length) {
      return;
    }
    const indent = changedItems[0].getAttribute("listIndent");
    const listType = changedItems[0].getAttribute("listType");
    let listItem = changedItems[0].previousSibling;
    if (listItem.is("element", "listItem")) {
      while (listItem.getAttribute("listIndent") !== indent) {
        listItem = listItem.previousSibling;
      }
    } else {
      listItem = null;
    }
    if (!listItem) {
      listItem = changedItems[changedItems.length - 1].nextSibling;
    }
    if (!listItem || !listItem.is("element", "listItem")) {
      return;
    }
    if (listItem.getAttribute("listType") !== listType) {
      return;
    }
    editor.model.change((writer) => {
      const itemsToUpdate = changedItems.filter((item) => item.getAttribute("listIndent") === indent);
      for (const item of itemsToUpdate) {
        for (const strategy of attributeStrategies) {
          if (strategy.appliesToListItem(item)) {
            const attributeName = strategy.attributeName;
            const valueToSet = listItem.getAttribute(attributeName);
            writer.setAttribute(attributeName, valueToSet, item);
          }
        }
      }
    });
  };
}
function fixListAttributesOnListItemElements(editor, attributeStrategies) {
  return (writer) => {
    let wasFixed = false;
    const insertedListItems = getChangedListItems(editor.model.document.differ.getChanges()).filter((item) => {
      return item.getAttribute("listType") !== "todo";
    });
    if (!insertedListItems.length) {
      return wasFixed;
    }
    let existingListItem = insertedListItems[insertedListItems.length - 1].nextSibling;
    if (!existingListItem || !existingListItem.is("element", "listItem")) {
      existingListItem = insertedListItems[0].previousSibling;
      if (existingListItem) {
        const indent = insertedListItems[0].getAttribute("listIndent");
        while (existingListItem.is("element", "listItem") && existingListItem.getAttribute("listIndent") !== indent) {
          existingListItem = existingListItem.previousSibling;
          if (!existingListItem) {
            break;
          }
        }
      }
    }
    for (const strategy of attributeStrategies) {
      const attributeName = strategy.attributeName;
      for (const item of insertedListItems) {
        if (!strategy.appliesToListItem(item)) {
          writer.removeAttribute(attributeName, item);
          continue;
        }
        if (!item.hasAttribute(attributeName)) {
          if (shouldInheritListType(existingListItem, item, strategy)) {
            writer.setAttribute(attributeName, existingListItem.getAttribute(attributeName), item);
          } else {
            writer.setAttribute(attributeName, strategy.defaultValue, item);
          }
          wasFixed = true;
        } else {
          const previousSibling = item.previousSibling;
          if (shouldInheritListTypeFromPreviousItem(previousSibling, item, strategy.attributeName)) {
            writer.setAttribute(attributeName, previousSibling.getAttribute(attributeName), item);
            wasFixed = true;
          }
        }
      }
    }
    return wasFixed;
  };
}
function shouldInheritListType(baseItem, itemToChange, attributeStrategy) {
  if (!baseItem) {
    return false;
  }
  const baseListAttribute = baseItem.getAttribute(attributeStrategy.attributeName);
  if (!baseListAttribute) {
    return false;
  }
  if (baseListAttribute == attributeStrategy.defaultValue) {
    return false;
  }
  if (baseItem.getAttribute("listType") !== itemToChange.getAttribute("listType")) {
    return false;
  }
  return true;
}
function shouldInheritListTypeFromPreviousItem(previousItem, itemToChange, attributeName) {
  if (!previousItem || !previousItem.is("element", "listItem")) {
    return false;
  }
  if (itemToChange.getAttribute("listType") !== previousItem.getAttribute("listType")) {
    return false;
  }
  const previousItemIndent = previousItem.getAttribute("listIndent");
  if (previousItemIndent < 1 || previousItemIndent !== itemToChange.getAttribute("listIndent")) {
    return false;
  }
  const previousItemListAttribute = previousItem.getAttribute(attributeName);
  if (!previousItemListAttribute || previousItemListAttribute === itemToChange.getAttribute(attributeName)) {
    return false;
  }
  return true;
}
function removeListItemAttributesFromTodoList(editor) {
  return (writer) => {
    const todoListItems = getChangedListItems(editor.model.document.differ.getChanges()).filter((item) => {
      return item.getAttribute("listType") === "todo" && (item.hasAttribute("listStyle") || item.hasAttribute("listReversed") || item.hasAttribute("listStart"));
    });
    if (!todoListItems.length) {
      return false;
    }
    for (const item of todoListItems) {
      writer.removeAttribute("listStyle", item);
      writer.removeAttribute("listReversed", item);
      writer.removeAttribute("listStart", item);
    }
    return true;
  };
}
function restoreDefaultListStyle(editor) {
  return (evt, changedItems) => {
    changedItems = changedItems.filter((item) => item.is("element", "listItem"));
    editor.model.change((writer) => {
      for (const item of changedItems) {
        writer.removeAttribute("listStyle", item);
      }
    });
  };
}
function getChangedListItems(changes) {
  const items = [];
  for (const change of changes) {
    const item = getItemFromChange(change);
    if (item && item.is("element", "listItem")) {
      items.push(item);
    }
  }
  return items;
}
function getItemFromChange(change) {
  if (change.type === "attribute") {
    return change.range.start.nodeAfter;
  }
  if (change.type === "insert") {
    return change.position.nodeAfter;
  }
  return null;
}

// node_modules/@ckeditor/ckeditor5-list/src/listproperties.js
var ListProperties = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ListPropertiesEditing, ListPropertiesUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ListProperties";
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/todolist/checktodolistcommand.js
var attributeKey = "todoListChecked";
var CheckTodoListCommand = class extends Command {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._selectedElements = [];
    this.on("execute", () => {
      this.refresh();
    }, { priority: "highest" });
  }
  /**
   * Updates the command's {@link #value} and {@link #isEnabled} properties based on the current selection.
   */
  refresh() {
    this._selectedElements = this._getSelectedItems();
    this.value = this._selectedElements.every((element) => !!element.getAttribute(attributeKey));
    this.isEnabled = !!this._selectedElements.length;
  }
  /**
   * Gets all to-do list items selected by the {@link module:engine/model/selection~Selection}.
   */
  _getSelectedItems() {
    const model = this.editor.model;
    const schema = model.schema;
    const selectionRange = model.document.selection.getFirstRange();
    const startElement = selectionRange.start.parent;
    const elements = [];
    if (schema.checkAttribute(startElement, attributeKey)) {
      elements.push(startElement);
    }
    for (const item of selectionRange.getItems()) {
      if (schema.checkAttribute(item, attributeKey) && !elements.includes(item)) {
        elements.push(item);
      }
    }
    return elements;
  }
  /**
   * Executes the command.
   *
   * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply
   * the attribute. Otherwise, the command will remove the attribute. If not set, the command will look for its current
   * value to decide what it should do.
   */
  execute(options = {}) {
    this.editor.model.change((writer) => {
      for (const element of this._selectedElements) {
        const value = options.forceValue === void 0 ? !this.value : options.forceValue;
        if (value) {
          writer.setAttribute(attributeKey, true, element);
        } else {
          writer.removeAttribute(attributeKey, element);
        }
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/todolist/todolistconverters.js
function modelViewInsertion2(model, onCheckboxChecked) {
  return (evt, data, conversionApi) => {
    const consumable = conversionApi.consumable;
    if (!consumable.test(data.item, "insert") || !consumable.test(data.item, "attribute:listType") || !consumable.test(data.item, "attribute:listIndent")) {
      return;
    }
    if (data.item.getAttribute("listType") != "todo") {
      return;
    }
    const modelItem = data.item;
    consumable.consume(modelItem, "insert");
    consumable.consume(modelItem, "attribute:listType");
    consumable.consume(modelItem, "attribute:listIndent");
    consumable.consume(modelItem, "attribute:todoListChecked");
    const viewWriter = conversionApi.writer;
    const viewItem = generateLiInUl(modelItem, conversionApi);
    const isChecked = !!modelItem.getAttribute("todoListChecked");
    const checkmarkElement = createCheckmarkElement(modelItem, viewWriter, isChecked, onCheckboxChecked);
    const span = viewWriter.createContainerElement("span", {
      class: "todo-list__label__description"
    });
    viewWriter.addClass("todo-list", viewItem.parent);
    viewWriter.insert(viewWriter.createPositionAt(viewItem, 0), checkmarkElement);
    viewWriter.insert(viewWriter.createPositionAfter(checkmarkElement), span);
    injectViewList(modelItem, viewItem, conversionApi, model);
  };
}
function dataModelViewInsertion(model) {
  return (evt, data, conversionApi) => {
    const consumable = conversionApi.consumable;
    if (!consumable.test(data.item, "insert") || !consumable.test(data.item, "attribute:listType") || !consumable.test(data.item, "attribute:listIndent")) {
      return;
    }
    if (data.item.getAttribute("listType") != "todo") {
      return;
    }
    const modelItem = data.item;
    consumable.consume(modelItem, "insert");
    consumable.consume(modelItem, "attribute:listType");
    consumable.consume(modelItem, "attribute:listIndent");
    consumable.consume(modelItem, "attribute:todoListChecked");
    const viewWriter = conversionApi.writer;
    const viewItem = generateLiInUl(modelItem, conversionApi);
    viewWriter.addClass("todo-list", viewItem.parent);
    const label = viewWriter.createContainerElement("label", {
      class: "todo-list__label"
    });
    const checkbox = viewWriter.createEmptyElement("input", {
      type: "checkbox",
      disabled: "disabled"
    });
    const span = viewWriter.createContainerElement("span", {
      class: "todo-list__label__description"
    });
    if (modelItem.getAttribute("todoListChecked")) {
      viewWriter.setAttribute("checked", "checked", checkbox);
    }
    viewWriter.insert(viewWriter.createPositionAt(viewItem, 0), label);
    viewWriter.insert(viewWriter.createPositionAt(label, 0), checkbox);
    viewWriter.insert(viewWriter.createPositionAfter(checkbox), span);
    injectViewList(modelItem, viewItem, conversionApi, model);
  };
}
var dataViewModelCheckmarkInsertion = (evt, data, conversionApi) => {
  const modelCursor = data.modelCursor;
  const modelItem = modelCursor.parent;
  const viewItem = data.viewItem;
  if (viewItem.getAttribute("type") != "checkbox" || modelItem.name != "listItem" || !modelCursor.isAtStart) {
    return;
  }
  if (!conversionApi.consumable.consume(viewItem, { name: true })) {
    return;
  }
  const writer = conversionApi.writer;
  writer.setAttribute("listType", "todo", modelItem);
  if (data.viewItem.hasAttribute("checked")) {
    writer.setAttribute("todoListChecked", true, modelItem);
  }
  data.modelRange = writer.createRange(modelCursor);
};
function modelViewChangeType2(onCheckedChange, view) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewItem = conversionApi.mapper.toViewElement(data.item);
    const viewWriter = conversionApi.writer;
    const labelElement = findLabel(viewItem, view);
    if (data.attributeNewValue == "todo") {
      const isChecked = !!data.item.getAttribute("todoListChecked");
      const checkmarkElement = createCheckmarkElement(data.item, viewWriter, isChecked, onCheckedChange);
      const span = viewWriter.createContainerElement("span", {
        class: "todo-list__label__description"
      });
      const itemRange = viewWriter.createRangeIn(viewItem);
      const nestedList = findNestedList(viewItem);
      const descriptionStart = positionAfterUiElements(itemRange.start);
      const descriptionEnd = nestedList ? viewWriter.createPositionBefore(nestedList) : itemRange.end;
      const descriptionRange = viewWriter.createRange(descriptionStart, descriptionEnd);
      viewWriter.addClass("todo-list", viewItem.parent);
      viewWriter.move(descriptionRange, viewWriter.createPositionAt(span, 0));
      viewWriter.insert(viewWriter.createPositionAt(viewItem, 0), checkmarkElement);
      viewWriter.insert(viewWriter.createPositionAfter(checkmarkElement), span);
    } else if (data.attributeOldValue == "todo") {
      const descriptionSpan = findDescription(viewItem, view);
      viewWriter.removeClass("todo-list", viewItem.parent);
      viewWriter.remove(labelElement);
      viewWriter.move(viewWriter.createRangeIn(descriptionSpan), viewWriter.createPositionBefore(descriptionSpan));
      viewWriter.remove(descriptionSpan);
    }
  };
}
function modelViewChangeChecked(onCheckedChange) {
  return (evt, data, conversionApi) => {
    if (data.item.getAttribute("listType") != "todo") {
      return;
    }
    if (!conversionApi.consumable.consume(data.item, "attribute:todoListChecked")) {
      return;
    }
    const { mapper, writer: viewWriter } = conversionApi;
    const isChecked = !!data.item.getAttribute("todoListChecked");
    const viewItem = mapper.toViewElement(data.item);
    const oldCheckmarkElement = viewItem.getChild(0);
    const newCheckmarkElement = createCheckmarkElement(data.item, viewWriter, isChecked, onCheckedChange);
    viewWriter.insert(viewWriter.createPositionAfter(oldCheckmarkElement), newCheckmarkElement);
    viewWriter.remove(oldCheckmarkElement);
  };
}
function mapModelToViewPosition(view) {
  return (evt, data) => {
    const modelPosition = data.modelPosition;
    const parent = modelPosition.parent;
    if (!parent.is("element", "listItem") || parent.getAttribute("listType") != "todo") {
      return;
    }
    const viewLi = data.mapper.toViewElement(parent);
    const descSpan = findDescription(viewLi, view);
    if (descSpan) {
      data.viewPosition = data.mapper.findPositionIn(descSpan, modelPosition.offset);
    }
  };
}
function createCheckmarkElement(modelItem, viewWriter, isChecked, onChange) {
  const uiElement = viewWriter.createUIElement("label", {
    class: "todo-list__label",
    contenteditable: false
  }, function(domDocument) {
    const checkbox = createElement(document, "input", { type: "checkbox", tabindex: "-1" });
    if (isChecked) {
      checkbox.setAttribute("checked", "checked");
    }
    checkbox.addEventListener("change", () => onChange(modelItem));
    const domElement = this.toDomElement(domDocument);
    domElement.appendChild(checkbox);
    return domElement;
  });
  return uiElement;
}
function findLabel(viewItem, view) {
  const range = view.createRangeIn(viewItem);
  for (const value of range) {
    if (value.item.is("uiElement", "label")) {
      return value.item;
    }
  }
}
function findDescription(viewItem, view) {
  const range = view.createRangeIn(viewItem);
  for (const value of range) {
    if (value.item.is("containerElement", "span") && value.item.hasClass("todo-list__label__description")) {
      return value.item;
    }
  }
}

// node_modules/@ckeditor/ckeditor5-list/src/todolist/todolistediting.js
var ITEM_TOGGLE_KEYSTROKE = parseKeystroke("Ctrl+Enter");
var TodoListEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TodoListEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ListEditing];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const { editing, data, model } = editor;
    model.schema.extend("listItem", {
      allowAttributes: ["todoListChecked"]
    });
    model.schema.addAttributeCheck((context, attributeName) => {
      const item = context.last;
      if (attributeName == "todoListChecked" && item.name == "listItem" && item.getAttribute("listType") != "todo") {
        return false;
      }
    });
    editor.commands.add("todoList", new ListCommand(editor, "todo"));
    const checkTodoListCommand = new CheckTodoListCommand(editor);
    editor.commands.add("checkTodoList", checkTodoListCommand);
    editor.commands.add("todoListCheck", checkTodoListCommand);
    data.downcastDispatcher.on("insert:listItem", dataModelViewInsertion(model), { priority: "high" });
    data.upcastDispatcher.on("element:input", dataViewModelCheckmarkInsertion, { priority: "high" });
    editing.downcastDispatcher.on("insert:listItem", modelViewInsertion2(model, (listItem) => this._handleCheckmarkChange(listItem)), { priority: "high" });
    editing.downcastDispatcher.on("attribute:listType:listItem", modelViewChangeType2((listItem) => this._handleCheckmarkChange(listItem), editing.view));
    editing.downcastDispatcher.on("attribute:todoListChecked:listItem", modelViewChangeChecked((listItem) => this._handleCheckmarkChange(listItem)));
    editing.mapper.on("modelToViewPosition", mapModelToViewPosition(editing.view));
    data.mapper.on("modelToViewPosition", mapModelToViewPosition(editing.view));
    this.listenTo(editing.view.document, "arrowKey", jumpOverCheckmarkOnSideArrowKeyPress(model, editor.locale), { context: "li" });
    this.listenTo(editing.view.document, "keydown", (evt, data2) => {
      if (getCode(data2) === ITEM_TOGGLE_KEYSTROKE) {
        editor.execute("checkTodoList");
        evt.stop();
      }
    }, { priority: "high" });
    const listItemsToFix = /* @__PURE__ */ new Set();
    this.listenTo(model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (operation.type == "rename" && operation.oldName == "listItem") {
        const item = operation.position.nodeAfter;
        if (item.hasAttribute("todoListChecked")) {
          listItemsToFix.add(item);
        }
      } else if (operation.type == "changeAttribute" && operation.key == "listType" && operation.oldValue === "todo") {
        for (const item of operation.range.getItems()) {
          if (item.hasAttribute("todoListChecked") && item.getAttribute("listType") !== "todo") {
            listItemsToFix.add(item);
          }
        }
      }
    });
    model.document.registerPostFixer((writer) => {
      let hasChanged = false;
      for (const listItem of listItemsToFix) {
        writer.removeAttribute("todoListChecked", listItem);
        hasChanged = true;
      }
      listItemsToFix.clear();
      return hasChanged;
    });
  }
  /**
   * Handles the checkbox element change, moves the selection to the corresponding model item to make it possible
   * to toggle the `todoListChecked` attribute using the command, and restores the selection position.
   *
   * Some say it's a hack :) Moving the selection only for executing the command on a certain node and restoring it after,
   * is not a clear solution. We need to design an API for using commands beyond the selection range.
   * See https://github.com/ckeditor/ckeditor5/issues/1954.
   */
  _handleCheckmarkChange(listItem) {
    const editor = this.editor;
    const model = editor.model;
    const previousSelectionRanges = Array.from(model.document.selection.getRanges());
    model.change((writer) => {
      writer.setSelection(listItem, "end");
      editor.execute("checkTodoList");
      writer.setSelection(previousSelectionRanges);
    });
  }
};
function jumpOverCheckmarkOnSideArrowKeyPress(model, locale) {
  return (eventInfo, domEventData) => {
    const direction = getLocalizedArrowKeyCodeDirection(domEventData.keyCode, locale.contentLanguageDirection);
    if (direction != "left") {
      return;
    }
    const schema = model.schema;
    const selection = model.document.selection;
    if (!selection.isCollapsed) {
      return;
    }
    const position = selection.getFirstPosition();
    const parent = position.parent;
    if (parent.name === "listItem" && parent.getAttribute("listType") == "todo" && position.isAtStart) {
      const newRange = schema.getNearestSelectionRange(model.createPositionBefore(parent), "backward");
      if (newRange) {
        model.change((writer) => writer.setSelection(newRange));
      }
      domEventData.preventDefault();
      domEventData.stopPropagation();
      eventInfo.stop();
    }
  };
}

// node_modules/@ckeditor/ckeditor5-list/src/todolist/todolistui.js
import todoListIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/icons/todolist.svg";
var TodoListUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TodoListUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const t = this.editor.t;
    createUIComponent(this.editor, "todoList", t("To-do List"), todoListIcon);
  }
};

// node_modules/@ckeditor/ckeditor5-list/src/todolist.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-list/theme/todolist.css";
var TodoList = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TodoListEditing, TodoListUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TodoList";
  }
};
export {
  AdjacentListsSupport,
  DocumentList,
  DocumentListEditing,
  DocumentListIndentCommand,
  DocumentListProperties,
  DocumentListPropertiesEditing,
  DocumentListPropertiesUtils,
  DocumentListUtils,
  IndentCommand,
  List,
  ListEditing,
  ListProperties,
  ListPropertiesEditing,
  ListPropertiesUI,
  ListUI,
  ListUtils,
  TodoList,
  TodoListEditing,
  TodoListUI
};
/*! Bundled license information:

@ckeditor/ckeditor5-list/src/documentlist/utils/listwalker.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/utils/model.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/documentlistindentcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/documentlistcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/documentlistmergecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/documentlistsplitcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/documentlistutils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/utils/view.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/utils/postfixers.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/converters.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/documentlistediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/list/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/list/listui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlist/adjacentlistssupport.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlistproperties/documentliststartcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlistproperties/utils/style.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlistproperties/documentliststylecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlistproperties/documentlistreversedcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlistproperties/converters.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlistproperties/documentlistpropertiesutils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlistproperties/documentlistpropertiesediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/listproperties/ui/collapsibleview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/listproperties/ui/listpropertiesview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/listproperties/listpropertiesui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/documentlistproperties.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/list/indentcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/list/listcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/list/listutils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/list/converters.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/list/listediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/list.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/listproperties/liststylecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/listproperties/listreversedcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/listproperties/liststartcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/listproperties/listpropertiesediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/listproperties.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/todolist/checktodolistcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/todolist/todolistconverters.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/todolist/todolistediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/todolist/todolistui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/todolist.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-list/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-list.js.map
