import "./chunk-DEIZSOIF.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  ColorSelectorView,
  Model,
  addListToDropdown,
  createDropdown,
  focusChildOnDropdownOpen,
  getLocalizedColorOptions,
  normalizeColorOptions
} from "./chunk-SGTDNT4V.js";
import "./chunk-6LVMAMLV.js";
import {
  CKEditorError,
  Collection,
  Command,
  Plugin,
  addBackgroundRules,
  isLength,
  isPercentage
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-font/src/fontcommand.js
var FontCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor Editor instance.
   * @param attributeKey The name of a model attribute on which this command operates.
   */
  constructor(editor, attributeKey) {
    super(editor);
    this.attributeKey = attributeKey;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.value = doc.selection.getAttribute(this.attributeKey);
    this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
  }
  /**
   * Executes the command. Applies the `value` of the {@link #attributeKey} to the selection.
   * If no `value` is passed, it removes the attribute from the selection.
   *
   * @param options Options for the executed command.
   * @param options.value The value to apply.
   * @fires execute
   */
  execute(options = {}) {
    const model = this.editor.model;
    const document = model.document;
    const selection = document.selection;
    const value = options.value;
    const batch = options.batch;
    const updateAttribute = (writer) => {
      if (selection.isCollapsed) {
        if (value) {
          writer.setSelectionAttribute(this.attributeKey, value);
        } else {
          writer.removeSelectionAttribute(this.attributeKey);
        }
      } else {
        const ranges = model.schema.getValidRanges(selection.getRanges(), this.attributeKey);
        for (const range of ranges) {
          if (value) {
            writer.setAttribute(this.attributeKey, value, range);
          } else {
            writer.removeAttribute(this.attributeKey, range);
          }
        }
      }
    };
    if (batch) {
      model.enqueueChange(batch, (writer) => {
        updateAttribute(writer);
      });
    } else {
      model.change((writer) => {
        updateAttribute(writer);
      });
    }
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/utils.js
var FONT_SIZE = "fontSize";
var FONT_FAMILY = "fontFamily";
var FONT_COLOR = "fontColor";
var FONT_BACKGROUND_COLOR = "fontBackgroundColor";
function buildDefinition(modelAttributeKey, options) {
  const definition = {
    model: {
      key: modelAttributeKey,
      values: []
    },
    view: {},
    upcastAlso: {}
  };
  for (const option of options) {
    definition.model.values.push(option.model);
    definition.view[option.model] = option.view;
    if (option.upcastAlso) {
      definition.upcastAlso[option.model] = option.upcastAlso;
    }
  }
  return definition;
}
function renderUpcastAttribute(styleAttr) {
  return (viewElement) => normalizeColorCode(viewElement.getStyle(styleAttr));
}
function renderDowncastElement(styleAttr) {
  return (modelAttributeValue, { writer }) => writer.createAttributeElement("span", {
    style: `${styleAttr}:${modelAttributeValue}`
  }, { priority: 7 });
}
function addColorSelectorToDropdown({ dropdownView, colors, columns, removeButtonLabel, colorPickerLabel, documentColorsLabel, documentColorsCount, colorPickerViewConfig }) {
  const locale = dropdownView.locale;
  const colorSelectorView = new ColorSelectorView(locale, {
    colors,
    columns,
    removeButtonLabel,
    colorPickerLabel,
    documentColorsLabel,
    documentColorsCount,
    colorPickerViewConfig
  });
  dropdownView.colorSelectorView = colorSelectorView;
  dropdownView.panelView.children.add(colorSelectorView);
  return colorSelectorView;
}
function normalizeColorCode(value) {
  return value.replace(/\s/g, "");
}

// node_modules/@ckeditor/ckeditor5-font/src/fontfamily/fontfamilycommand.js
var FontFamilyCommand = class extends FontCommand {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor, FONT_FAMILY);
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontfamily/utils.js
function normalizeOptions(configuredOptions) {
  return configuredOptions.map(getOptionDefinition).filter((option) => option !== void 0);
}
function getOptionDefinition(option) {
  if (typeof option === "object") {
    return option;
  }
  if (option === "default") {
    return {
      title: "Default",
      model: void 0
    };
  }
  if (typeof option !== "string") {
    return void 0;
  }
  return generateFontPreset(option);
}
function generateFontPreset(fontDefinition) {
  const fontNames = fontDefinition.replace(/"|'/g, "").split(",");
  const firstFontName = fontNames[0];
  const cssFontNames = fontNames.map(normalizeFontNameForCSS).join(", ");
  return {
    title: firstFontName,
    model: cssFontNames,
    view: {
      name: "span",
      styles: {
        "font-family": cssFontNames
      },
      priority: 7
    }
  };
}
function normalizeFontNameForCSS(fontName) {
  fontName = fontName.trim();
  if (fontName.indexOf(" ") > 0) {
    fontName = `'${fontName}'`;
  }
  return fontName;
}

// node_modules/@ckeditor/ckeditor5-font/src/fontfamily/fontfamilyediting.js
var FontFamilyEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontFamilyEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define(FONT_FAMILY, {
      options: [
        "default",
        "Arial, Helvetica, sans-serif",
        "Courier New, Courier, monospace",
        "Georgia, serif",
        "Lucida Sans Unicode, Lucida Grande, sans-serif",
        "Tahoma, Geneva, sans-serif",
        "Times New Roman, Times, serif",
        "Trebuchet MS, Helvetica, sans-serif",
        "Verdana, Geneva, sans-serif"
      ],
      supportAllValues: false
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", { allowAttributes: FONT_FAMILY });
    editor.model.schema.setAttributeProperties(FONT_FAMILY, {
      isFormatting: true,
      copyOnEnter: true
    });
    const options = normalizeOptions(editor.config.get("fontFamily.options")).filter((item) => item.model);
    const definition = buildDefinition(FONT_FAMILY, options);
    if (editor.config.get("fontFamily.supportAllValues")) {
      this._prepareAnyValueConverters();
      this._prepareCompatibilityConverter();
    } else {
      editor.conversion.attributeToElement(definition);
    }
    editor.commands.add(FONT_FAMILY, new FontFamilyCommand(editor));
  }
  /**
   * These converters enable keeping any value found as `style="font-family: *"` as a value of an attribute on a text even
   * if it is not defined in the plugin configuration.
   */
  _prepareAnyValueConverters() {
    const editor = this.editor;
    editor.conversion.for("downcast").attributeToElement({
      model: FONT_FAMILY,
      view: (attributeValue, { writer }) => {
        return writer.createAttributeElement("span", { style: "font-family:" + attributeValue }, { priority: 7 });
      }
    });
    editor.conversion.for("upcast").elementToAttribute({
      model: {
        key: FONT_FAMILY,
        value: (viewElement) => viewElement.getStyle("font-family")
      },
      view: {
        name: "span",
        styles: {
          "font-family": /.*/
        }
      }
    });
  }
  /**
   * Adds support for legacy `<font face="..">` formatting.
   */
  _prepareCompatibilityConverter() {
    const editor = this.editor;
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "font",
        attributes: {
          "face": /.*/
        }
      },
      model: {
        key: FONT_FAMILY,
        value: (viewElement) => viewElement.getAttribute("face")
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontfamily/fontfamilyui.js
import fontFamilyIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-font/theme/icons/font-family.svg";
var FontFamilyUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontFamilyUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const options = this._getLocalizedOptions();
    const command = editor.commands.get(FONT_FAMILY);
    const accessibleLabel = t("Font Family");
    editor.ui.componentFactory.add(FONT_FAMILY, (locale) => {
      const dropdownView = createDropdown(locale);
      addListToDropdown(dropdownView, () => _prepareListOptions(options, command), {
        role: "menu",
        ariaLabel: accessibleLabel
      });
      dropdownView.buttonView.set({
        label: accessibleLabel,
        icon: fontFamilyIcon,
        tooltip: true
      });
      dropdownView.extendTemplate({
        attributes: {
          class: "ck-font-family-dropdown"
        }
      });
      dropdownView.bind("isEnabled").to(command);
      this.listenTo(dropdownView, "execute", (evt) => {
        editor.execute(evt.source.commandName, { value: evt.source.commandParam });
        editor.editing.view.focus();
      });
      return dropdownView;
    });
  }
  /**
   * Returns options as defined in `config.fontFamily.options` but processed to account for
   * editor localization, i.e. to display {@link module:font/fontconfig~FontFamilyOption}
   * in the correct language.
   *
   * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
   * when the user configuration is defined because the editor does not exist yet.
   */
  _getLocalizedOptions() {
    const editor = this.editor;
    const t = editor.t;
    const options = normalizeOptions(editor.config.get(FONT_FAMILY).options);
    return options.map((option) => {
      if (option.title === "Default") {
        option.title = t("Default");
      }
      return option;
    });
  }
};
function _prepareListOptions(options, command) {
  const itemDefinitions = new Collection();
  for (const option of options) {
    const def = {
      type: "button",
      model: new Model({
        commandName: FONT_FAMILY,
        commandParam: option.model,
        label: option.title,
        role: "menuitemradio",
        withText: true
      })
    };
    def.model.bind("isOn").to(command, "value", (value) => {
      if (value === option.model) {
        return true;
      }
      if (!value || !option.model) {
        return false;
      }
      return value.split(",")[0].replace(/'/g, "").toLowerCase() === option.model.toLowerCase();
    });
    if (option.view && typeof option.view !== "string" && option.view.styles) {
      def.model.set("labelStyle", `font-family: ${option.view.styles["font-family"]}`);
    }
    itemDefinitions.add(def);
  }
  return itemDefinitions;
}

// node_modules/@ckeditor/ckeditor5-font/src/fontfamily.js
var FontFamily = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [FontFamilyEditing, FontFamilyUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontFamily";
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontsize/fontsizecommand.js
var FontSizeCommand = class extends FontCommand {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor, FONT_SIZE);
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontsize/utils.js
function normalizeOptions2(configuredOptions) {
  return configuredOptions.map((item) => getOptionDefinition2(item)).filter((option) => option !== void 0);
}
var namedPresets = {
  get tiny() {
    return {
      title: "Tiny",
      model: "tiny",
      view: {
        name: "span",
        classes: "text-tiny",
        priority: 7
      }
    };
  },
  get small() {
    return {
      title: "Small",
      model: "small",
      view: {
        name: "span",
        classes: "text-small",
        priority: 7
      }
    };
  },
  get big() {
    return {
      title: "Big",
      model: "big",
      view: {
        name: "span",
        classes: "text-big",
        priority: 7
      }
    };
  },
  get huge() {
    return {
      title: "Huge",
      model: "huge",
      view: {
        name: "span",
        classes: "text-huge",
        priority: 7
      }
    };
  }
};
function getOptionDefinition2(option) {
  if (typeof option === "number") {
    option = String(option);
  }
  if (typeof option === "object" && isFullItemDefinition(option)) {
    return attachPriority(option);
  }
  const preset = findPreset(option);
  if (preset) {
    return attachPriority(preset);
  }
  if (option === "default") {
    return {
      model: void 0,
      title: "Default"
    };
  }
  if (isNumericalDefinition(option)) {
    return void 0;
  }
  return generatePixelPreset(option);
}
function generatePixelPreset(definition) {
  if (typeof definition === "string") {
    definition = {
      title: definition,
      model: `${parseFloat(definition)}px`
    };
  }
  definition.view = {
    name: "span",
    styles: {
      "font-size": definition.model
    }
  };
  return attachPriority(definition);
}
function attachPriority(definition) {
  if (definition.view && typeof definition.view !== "string" && !definition.view.priority) {
    definition.view.priority = 7;
  }
  return definition;
}
function findPreset(definition) {
  return typeof definition === "string" ? namedPresets[definition] : namedPresets[definition.model];
}
function isFullItemDefinition(definition) {
  return definition.title && definition.model && definition.view;
}
function isNumericalDefinition(definition) {
  let numberValue;
  if (typeof definition === "object") {
    if (!definition.model) {
      throw new CKEditorError("font-size-invalid-definition", null, definition);
    } else {
      numberValue = parseFloat(definition.model);
    }
  } else {
    numberValue = parseFloat(definition);
  }
  return isNaN(numberValue);
}

// node_modules/@ckeditor/ckeditor5-font/src/fontsize/fontsizeediting.js
var styleFontSize = [
  "x-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large"
];
var FontSizeEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontSizeEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define(FONT_SIZE, {
      options: [
        "tiny",
        "small",
        "default",
        "big",
        "huge"
      ],
      supportAllValues: false
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", { allowAttributes: FONT_SIZE });
    editor.model.schema.setAttributeProperties(FONT_SIZE, {
      isFormatting: true,
      copyOnEnter: true
    });
    const supportAllValues = editor.config.get("fontSize.supportAllValues");
    const options = normalizeOptions2(this.editor.config.get("fontSize.options")).filter((item) => item.model);
    const definition = buildDefinition(FONT_SIZE, options);
    if (supportAllValues) {
      this._prepareAnyValueConverters(definition);
      this._prepareCompatibilityConverter();
    } else {
      editor.conversion.attributeToElement(definition);
    }
    editor.commands.add(FONT_SIZE, new FontSizeCommand(editor));
  }
  /**
   * These converters enable keeping any value found as `style="font-size: *"` as a value of an attribute on a text even
   * if it is not defined in the plugin configuration.
   *
   * @param definition Converter definition out of input data.
   */
  _prepareAnyValueConverters(definition) {
    const editor = this.editor;
    const presets = definition.model.values.filter((value) => {
      return !isLength(String(value)) && !isPercentage(String(value));
    });
    if (presets.length) {
      throw new CKEditorError("font-size-invalid-use-of-named-presets", null, { presets });
    }
    editor.conversion.for("downcast").attributeToElement({
      model: FONT_SIZE,
      view: (attributeValue, { writer }) => {
        if (!attributeValue) {
          return;
        }
        return writer.createAttributeElement("span", { style: "font-size:" + attributeValue }, { priority: 7 });
      }
    });
    editor.conversion.for("upcast").elementToAttribute({
      model: {
        key: FONT_SIZE,
        value: (viewElement) => viewElement.getStyle("font-size")
      },
      view: {
        name: "span",
        styles: {
          "font-size": /.*/
        }
      }
    });
  }
  /**
   * Adds support for legacy `<font size="..">` formatting.
   */
  _prepareCompatibilityConverter() {
    const editor = this.editor;
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "font",
        attributes: {
          // Documentation mentions sizes from 1 to 7. To handle old content we support all values
          // up to 999 but clamp it to the valid range. Why 999? It should cover accidental values
          // similar to percentage, e.g. 100%, 200% which could be the usual mistake for font size.
          "size": /^[+-]?\d{1,3}$/
        }
      },
      model: {
        key: FONT_SIZE,
        value: (viewElement) => {
          const value = viewElement.getAttribute("size");
          const isRelative = value[0] === "-" || value[0] === "+";
          let size = parseInt(value, 10);
          if (isRelative) {
            size = 3 + size;
          }
          const maxSize = styleFontSize.length - 1;
          const clampedSize = Math.min(Math.max(size, 0), maxSize);
          return styleFontSize[clampedSize];
        }
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontsize/fontsizeui.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-font/theme/fontsize.css";
import fontSizeIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-font/theme/icons/font-size.svg";
var FontSizeUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontSizeUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const options = this._getLocalizedOptions();
    const command = editor.commands.get(FONT_SIZE);
    const accessibleLabel = t("Font Size");
    editor.ui.componentFactory.add(FONT_SIZE, (locale) => {
      const dropdownView = createDropdown(locale);
      addListToDropdown(dropdownView, () => _prepareListOptions2(options, command), {
        role: "menu",
        ariaLabel: accessibleLabel
      });
      dropdownView.buttonView.set({
        label: accessibleLabel,
        icon: fontSizeIcon,
        tooltip: true
      });
      dropdownView.extendTemplate({
        attributes: {
          class: [
            "ck-font-size-dropdown"
          ]
        }
      });
      dropdownView.bind("isEnabled").to(command);
      this.listenTo(dropdownView, "execute", (evt) => {
        editor.execute(evt.source.commandName, { value: evt.source.commandParam });
        editor.editing.view.focus();
      });
      return dropdownView;
    });
  }
  /**
   * Returns options as defined in `config.fontSize.options` but processed to account for
   * editor localization, i.e. to display {@link module:font/fontconfig~FontSizeOption}
   * in the correct language.
   *
   * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
   * when the user configuration is defined because the editor does not exist yet.
   */
  _getLocalizedOptions() {
    const editor = this.editor;
    const t = editor.t;
    const localizedTitles = {
      Default: t("Default"),
      Tiny: t("Tiny"),
      Small: t("Small"),
      Big: t("Big"),
      Huge: t("Huge")
    };
    const options = normalizeOptions2(editor.config.get(FONT_SIZE).options);
    return options.map((option) => {
      const title = localizedTitles[option.title];
      if (title && title != option.title) {
        option = Object.assign({}, option, { title });
      }
      return option;
    });
  }
};
function _prepareListOptions2(options, command) {
  const itemDefinitions = new Collection();
  for (const option of options) {
    const def = {
      type: "button",
      model: new Model({
        commandName: FONT_SIZE,
        commandParam: option.model,
        label: option.title,
        class: "ck-fontsize-option",
        role: "menuitemradio",
        withText: true
      })
    };
    if (option.view && typeof option.view !== "string") {
      if (option.view.styles) {
        def.model.set("labelStyle", `font-size:${option.view.styles["font-size"]}`);
      }
      if (option.view.classes) {
        def.model.set("class", `${def.model.class} ${option.view.classes}`);
      }
    }
    def.model.bind("isOn").to(command, "value", (value) => value === option.model);
    itemDefinitions.add(def);
  }
  return itemDefinitions;
}

// node_modules/@ckeditor/ckeditor5-font/src/fontsize.js
var FontSize = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [FontSizeEditing, FontSizeUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontSize";
  }
  /**
   * Normalizes and translates the {@link module:font/fontconfig~FontSizeConfig#options configuration options}
   * to the {@link module:font/fontconfig~FontSizeOption} format.
   *
   * @param configuredOptions An array of options taken from the configuration.
   */
  normalizeSizeOptions(options) {
    return normalizeOptions2(options);
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontcolor/fontcolorcommand.js
var FontColorCommand = class extends FontCommand {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor, FONT_COLOR);
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontcolor/fontcolorediting.js
var FontColorEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontColorEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define(FONT_COLOR, {
      colors: [
        {
          color: "hsl(0, 0%, 0%)",
          label: "Black"
        },
        {
          color: "hsl(0, 0%, 30%)",
          label: "Dim grey"
        },
        {
          color: "hsl(0, 0%, 60%)",
          label: "Grey"
        },
        {
          color: "hsl(0, 0%, 90%)",
          label: "Light grey"
        },
        {
          color: "hsl(0, 0%, 100%)",
          label: "White",
          hasBorder: true
        },
        {
          color: "hsl(0, 75%, 60%)",
          label: "Red"
        },
        {
          color: "hsl(30, 75%, 60%)",
          label: "Orange"
        },
        {
          color: "hsl(60, 75%, 60%)",
          label: "Yellow"
        },
        {
          color: "hsl(90, 75%, 60%)",
          label: "Light green"
        },
        {
          color: "hsl(120, 75%, 60%)",
          label: "Green"
        },
        {
          color: "hsl(150, 75%, 60%)",
          label: "Aquamarine"
        },
        {
          color: "hsl(180, 75%, 60%)",
          label: "Turquoise"
        },
        {
          color: "hsl(210, 75%, 60%)",
          label: "Light blue"
        },
        {
          color: "hsl(240, 75%, 60%)",
          label: "Blue"
        },
        {
          color: "hsl(270, 75%, 60%)",
          label: "Purple"
        }
      ],
      columns: 5
    });
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "span",
        styles: {
          "color": /[\s\S]+/
        }
      },
      model: {
        key: FONT_COLOR,
        value: renderUpcastAttribute("color")
      }
    });
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "font",
        attributes: {
          "color": /^#?\w+$/
        }
      },
      model: {
        key: FONT_COLOR,
        value: (viewElement) => viewElement.getAttribute("color")
      }
    });
    editor.conversion.for("downcast").attributeToElement({
      model: FONT_COLOR,
      view: renderDowncastElement("color")
    });
    editor.commands.add(FONT_COLOR, new FontColorCommand(editor));
    editor.model.schema.extend("$text", { allowAttributes: FONT_COLOR });
    editor.model.schema.setAttributeProperties(FONT_COLOR, {
      isFormatting: true,
      copyOnEnter: true
    });
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/ui/colorui.js
var ColorUI = class extends Plugin {
  /**
   * Creates a plugin which introduces a dropdown with a pre–configured
   * {@link module:ui/colorselector/colorselectorview~ColorSelectorView}.
   *
   * @param config The configuration object.
   * @param config.commandName The name of the command which will be executed when a color tile is clicked.
   * @param config.componentName The name of the dropdown in the {@link module:ui/componentfactory~ComponentFactory}
   * and the configuration scope name in `editor.config`.
   * @param config.icon The SVG icon used by the dropdown.
   * @param config.dropdownLabel The label used by the dropdown.
   */
  constructor(editor, { commandName, componentName, icon, dropdownLabel }) {
    super(editor);
    this.commandName = commandName;
    this.componentName = componentName;
    this.icon = icon;
    this.dropdownLabel = dropdownLabel;
    this.columns = editor.config.get(`${this.componentName}.columns`);
    this.colorSelectorView = void 0;
  }
  /**
  * @inheritDoc
  */
  init() {
    const editor = this.editor;
    const locale = editor.locale;
    const t = locale.t;
    const command = editor.commands.get(this.commandName);
    const componentConfig = editor.config.get(this.componentName);
    const colorsConfig = normalizeColorOptions(componentConfig.colors);
    const localizedColors = getLocalizedColorOptions(locale, colorsConfig);
    const documentColorsCount = componentConfig.documentColors;
    const hasColorPicker = componentConfig.colorPicker !== false;
    editor.ui.componentFactory.add(this.componentName, (locale2) => {
      const dropdownView = createDropdown(locale2);
      let dropdownContentRendered = false;
      this.colorSelectorView = addColorSelectorToDropdown({
        dropdownView,
        colors: localizedColors.map((option) => ({
          label: option.label,
          color: option.model,
          options: {
            hasBorder: option.hasBorder
          }
        })),
        columns: this.columns,
        removeButtonLabel: t("Remove color"),
        colorPickerLabel: t("Color picker"),
        documentColorsLabel: documentColorsCount !== 0 ? t("Document colors") : "",
        documentColorsCount: documentColorsCount === void 0 ? this.columns : documentColorsCount,
        colorPickerViewConfig: hasColorPicker ? componentConfig.colorPicker || {} : false
      });
      this.colorSelectorView.bind("selectedColor").to(command, "value");
      dropdownView.buttonView.set({
        label: this.dropdownLabel,
        icon: this.icon,
        tooltip: true
      });
      dropdownView.extendTemplate({
        attributes: {
          class: "ck-color-ui-dropdown"
        }
      });
      dropdownView.bind("isEnabled").to(command);
      this.colorSelectorView.on("execute", (evt, data) => {
        if (dropdownView.isOpen) {
          editor.execute(this.commandName, {
            value: data.value,
            batch: this._undoStepBatch
          });
        }
        if (data.source !== "colorPicker") {
          editor.editing.view.focus();
        }
        if (data.source === "colorPickerSaveButton") {
          dropdownView.isOpen = false;
        }
      });
      this.colorSelectorView.on("colorPicker:show", () => {
        this._undoStepBatch = editor.model.createBatch();
      });
      this.colorSelectorView.on("colorPicker:cancel", () => {
        if (this._undoStepBatch.operations.length) {
          dropdownView.isOpen = false;
          editor.execute("undo", this._undoStepBatch);
        }
        editor.editing.view.focus();
      });
      dropdownView.on("change:isOpen", (evt, name, isVisible) => {
        if (!dropdownContentRendered) {
          dropdownContentRendered = true;
          dropdownView.colorSelectorView.appendUI();
        }
        if (isVisible) {
          if (documentColorsCount !== 0) {
            this.colorSelectorView.updateDocumentColors(editor.model, this.componentName);
          }
          this.colorSelectorView.updateSelectedColors();
          this.colorSelectorView.showColorGridsFragment();
        }
      });
      focusChildOnDropdownOpen(dropdownView, () => dropdownView.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find((item) => item.isOn));
      return dropdownView;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontcolor/fontcolorui.js
import fontColorIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-font/theme/icons/font-color.svg";
var FontColorUI = class extends ColorUI {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    const t = editor.locale.t;
    super(editor, {
      commandName: FONT_COLOR,
      componentName: FONT_COLOR,
      icon: fontColorIcon,
      dropdownLabel: t("Font Color")
    });
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontColorUI";
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontcolor.js
var FontColor = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [FontColorEditing, FontColorUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontColor";
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontbackgroundcolor/fontbackgroundcolorcommand.js
var FontBackgroundColorCommand = class extends FontCommand {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor, FONT_BACKGROUND_COLOR);
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontbackgroundcolor/fontbackgroundcolorediting.js
var FontBackgroundColorEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontBackgroundColorEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define(FONT_BACKGROUND_COLOR, {
      colors: [
        {
          color: "hsl(0, 0%, 0%)",
          label: "Black"
        },
        {
          color: "hsl(0, 0%, 30%)",
          label: "Dim grey"
        },
        {
          color: "hsl(0, 0%, 60%)",
          label: "Grey"
        },
        {
          color: "hsl(0, 0%, 90%)",
          label: "Light grey"
        },
        {
          color: "hsl(0, 0%, 100%)",
          label: "White",
          hasBorder: true
        },
        {
          color: "hsl(0, 75%, 60%)",
          label: "Red"
        },
        {
          color: "hsl(30, 75%, 60%)",
          label: "Orange"
        },
        {
          color: "hsl(60, 75%, 60%)",
          label: "Yellow"
        },
        {
          color: "hsl(90, 75%, 60%)",
          label: "Light green"
        },
        {
          color: "hsl(120, 75%, 60%)",
          label: "Green"
        },
        {
          color: "hsl(150, 75%, 60%)",
          label: "Aquamarine"
        },
        {
          color: "hsl(180, 75%, 60%)",
          label: "Turquoise"
        },
        {
          color: "hsl(210, 75%, 60%)",
          label: "Light blue"
        },
        {
          color: "hsl(240, 75%, 60%)",
          label: "Blue"
        },
        {
          color: "hsl(270, 75%, 60%)",
          label: "Purple"
        }
      ],
      columns: 5
    });
    editor.data.addStyleProcessorRules(addBackgroundRules);
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "span",
        styles: {
          "background-color": /[\s\S]+/
        }
      },
      model: {
        key: FONT_BACKGROUND_COLOR,
        value: renderUpcastAttribute("background-color")
      }
    });
    editor.conversion.for("downcast").attributeToElement({
      model: FONT_BACKGROUND_COLOR,
      view: renderDowncastElement("background-color")
    });
    editor.commands.add(FONT_BACKGROUND_COLOR, new FontBackgroundColorCommand(editor));
    editor.model.schema.extend("$text", { allowAttributes: FONT_BACKGROUND_COLOR });
    editor.model.schema.setAttributeProperties(FONT_BACKGROUND_COLOR, {
      isFormatting: true,
      copyOnEnter: true
    });
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontbackgroundcolor/fontbackgroundcolorui.js
import fontBackgroundColorIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-font/theme/icons/font-background.svg";
var FontBackgroundColorUI = class extends ColorUI {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    const t = editor.locale.t;
    super(editor, {
      commandName: FONT_BACKGROUND_COLOR,
      componentName: FONT_BACKGROUND_COLOR,
      icon: fontBackgroundColorIcon,
      dropdownLabel: t("Font Background Color")
    });
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontBackgroundColorUI";
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/fontbackgroundcolor.js
var FontBackgroundColor = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [FontBackgroundColorEditing, FontBackgroundColorUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "FontBackgroundColor";
  }
};

// node_modules/@ckeditor/ckeditor5-font/src/font.js
var Font = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [FontFamily, FontSize, FontColor, FontBackgroundColor];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Font";
  }
};
export {
  Font,
  FontBackgroundColor,
  FontBackgroundColorEditing,
  FontBackgroundColorUI,
  FontColor,
  FontColorEditing,
  FontColorUI,
  FontFamily,
  FontFamilyEditing,
  FontFamilyUI,
  FontSize,
  FontSizeEditing,
  FontSizeUI
};
/*! Bundled license information:

@ckeditor/ckeditor5-font/src/fontcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontfamily/fontfamilycommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontfamily/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontfamily/fontfamilyediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontfamily/fontfamilyui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontfamily.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontsize/fontsizecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontsize/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontsize/fontsizeediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontsize/fontsizeui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontsize.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontcolor/fontcolorcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontcolor/fontcolorediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/ui/colorui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontcolor/fontcolorui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontcolor.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontbackgroundcolor/fontbackgroundcolorcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontbackgroundcolor/fontbackgroundcolorediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontbackgroundcolor/fontbackgroundcolorui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/fontbackgroundcolor.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/font.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-font/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-font.js.map
