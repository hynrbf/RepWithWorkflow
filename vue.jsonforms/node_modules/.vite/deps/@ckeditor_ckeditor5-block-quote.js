import "./chunk-U6D4LCQC.js";
import {
  Enter
} from "./chunk-GGCPNJOL.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  ButtonView
} from "./chunk-SGTDNT4V.js";
import "./chunk-W3CRWNYM.js";
import {
  Delete
} from "./chunk-4MFML76R.js";
import "./chunk-6LVMAMLV.js";
import {
  Command,
  Plugin,
  first,
  icons
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-block-quote/src/blockquotecommand.js
var BlockQuoteCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
   * Executes the command. When the command {@link #value is on}, all top-most block quotes within
   * the selection will be removed. If it is off, all selected blocks will be wrapped with
   * a block quote.
   *
   * @fires execute
   * @param options Command options.
   * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a block quote,
   * otherwise the command will remove the block quote. If not set, the command will act basing on its current value.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const schema = model.schema;
    const selection = model.document.selection;
    const blocks = Array.from(selection.getSelectedBlocks());
    const value = options.forceValue === void 0 ? !this.value : options.forceValue;
    model.change((writer) => {
      if (!value) {
        this._removeQuote(writer, blocks.filter(findQuote));
      } else {
        const blocksToQuote = blocks.filter((block) => {
          return findQuote(block) || checkCanBeQuoted(schema, block);
        });
        this._applyQuote(writer, blocksToQuote);
      }
    });
  }
  /**
   * Checks the command's {@link #value}.
   */
  _getValue() {
    const selection = this.editor.model.document.selection;
    const firstBlock = first(selection.getSelectedBlocks());
    return !!(firstBlock && findQuote(firstBlock));
  }
  /**
   * Checks whether the command can be enabled in the current context.
   *
   * @returns Whether the command should be enabled.
   */
  _checkEnabled() {
    if (this.value) {
      return true;
    }
    const selection = this.editor.model.document.selection;
    const schema = this.editor.model.schema;
    const firstBlock = first(selection.getSelectedBlocks());
    if (!firstBlock) {
      return false;
    }
    return checkCanBeQuoted(schema, firstBlock);
  }
  /**
   * Removes the quote from given blocks.
   *
   * If blocks which are supposed to be "unquoted" are in the middle of a quote,
   * start it or end it, then the quote will be split (if needed) and the blocks
   * will be moved out of it, so other quoted blocks remained quoted.
   */
  _removeQuote(writer, blocks) {
    getRangesOfBlockGroups(writer, blocks).reverse().forEach((groupRange) => {
      if (groupRange.start.isAtStart && groupRange.end.isAtEnd) {
        writer.unwrap(groupRange.start.parent);
        return;
      }
      if (groupRange.start.isAtStart) {
        const positionBefore = writer.createPositionBefore(groupRange.start.parent);
        writer.move(groupRange, positionBefore);
        return;
      }
      if (!groupRange.end.isAtEnd) {
        writer.split(groupRange.end);
      }
      const positionAfter = writer.createPositionAfter(groupRange.end.parent);
      writer.move(groupRange, positionAfter);
    });
  }
  /**
   * Applies the quote to given blocks.
   */
  _applyQuote(writer, blocks) {
    const quotesToMerge = [];
    getRangesOfBlockGroups(writer, blocks).reverse().forEach((groupRange) => {
      let quote = findQuote(groupRange.start);
      if (!quote) {
        quote = writer.createElement("blockQuote");
        writer.wrap(groupRange, quote);
      }
      quotesToMerge.push(quote);
    });
    quotesToMerge.reverse().reduce((currentQuote, nextQuote) => {
      if (currentQuote.nextSibling == nextQuote) {
        writer.merge(writer.createPositionAfter(currentQuote));
        return currentQuote;
      }
      return nextQuote;
    });
  }
};
function findQuote(elementOrPosition) {
  return elementOrPosition.parent.name == "blockQuote" ? elementOrPosition.parent : null;
}
function getRangesOfBlockGroups(writer, blocks) {
  let startPosition;
  let i = 0;
  const ranges = [];
  while (i < blocks.length) {
    const block = blocks[i];
    const nextBlock = blocks[i + 1];
    if (!startPosition) {
      startPosition = writer.createPositionBefore(block);
    }
    if (!nextBlock || block.nextSibling != nextBlock) {
      ranges.push(writer.createRange(startPosition, writer.createPositionAfter(block)));
      startPosition = null;
    }
    i++;
  }
  return ranges;
}
function checkCanBeQuoted(schema, block) {
  const isBQAllowed = schema.checkChild(block.parent, "blockQuote");
  const isBlockAllowedInBQ = schema.checkChild(["$root", "blockQuote"], block);
  return isBQAllowed && isBlockAllowedInBQ;
}

// node_modules/@ckeditor/ckeditor5-block-quote/src/blockquoteediting.js
var BlockQuoteEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BlockQuoteEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Enter, Delete];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    editor.commands.add("blockQuote", new BlockQuoteCommand(editor));
    schema.register("blockQuote", {
      inheritAllFrom: "$container"
    });
    editor.conversion.elementToElement({ model: "blockQuote", view: "blockquote" });
    editor.model.document.registerPostFixer((writer) => {
      const changes = editor.model.document.differ.getChanges();
      for (const entry of changes) {
        if (entry.type == "insert") {
          const element = entry.position.nodeAfter;
          if (!element) {
            continue;
          }
          if (element.is("element", "blockQuote") && element.isEmpty) {
            writer.remove(element);
            return true;
          } else if (element.is("element", "blockQuote") && !schema.checkChild(entry.position, element)) {
            writer.unwrap(element);
            return true;
          } else if (element.is("element")) {
            const range = writer.createRangeIn(element);
            for (const child of range.getItems()) {
              if (child.is("element", "blockQuote") && !schema.checkChild(writer.createPositionBefore(child), child)) {
                writer.unwrap(child);
                return true;
              }
            }
          }
        } else if (entry.type == "remove") {
          const parent = entry.position.parent;
          if (parent.is("element", "blockQuote") && parent.isEmpty) {
            writer.remove(parent);
            return true;
          }
        }
      }
      return false;
    });
    const viewDocument = this.editor.editing.view.document;
    const selection = editor.model.document.selection;
    const blockQuoteCommand = editor.commands.get("blockQuote");
    this.listenTo(viewDocument, "enter", (evt, data) => {
      if (!selection.isCollapsed || !blockQuoteCommand.value) {
        return;
      }
      const positionParent = selection.getLastPosition().parent;
      if (positionParent.isEmpty) {
        editor.execute("blockQuote");
        editor.editing.view.scrollToTheSelection();
        data.preventDefault();
        evt.stop();
      }
    }, { context: "blockquote" });
    this.listenTo(viewDocument, "delete", (evt, data) => {
      if (data.direction != "backward" || !selection.isCollapsed || !blockQuoteCommand.value) {
        return;
      }
      const positionParent = selection.getLastPosition().parent;
      if (positionParent.isEmpty && !positionParent.previousSibling) {
        editor.execute("blockQuote");
        editor.editing.view.scrollToTheSelection();
        data.preventDefault();
        evt.stop();
      }
    }, { context: "blockquote" });
  }
};

// node_modules/@ckeditor/ckeditor5-block-quote/src/blockquoteui.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css";
var BlockQuoteUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BlockQuoteUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("blockQuote", (locale) => {
      const command = editor.commands.get("blockQuote");
      const buttonView = new ButtonView(locale);
      buttonView.set({
        label: t("Block quote"),
        icon: icons.quote,
        tooltip: true,
        isToggleable: true
      });
      buttonView.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
      this.listenTo(buttonView, "execute", () => {
        editor.execute("blockQuote");
        editor.editing.view.focus();
      });
      return buttonView;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-block-quote/src/blockquote.js
var BlockQuote = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [BlockQuoteEditing, BlockQuoteUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "BlockQuote";
  }
};
export {
  BlockQuote,
  BlockQuoteEditing,
  BlockQuoteUI
};
/*! Bundled license information:

@ckeditor/ckeditor5-block-quote/src/blockquotecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-block-quote/src/blockquoteediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-block-quote/src/blockquoteui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-block-quote/src/blockquote.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-block-quote/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-block-quote/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-block-quote.js.map
