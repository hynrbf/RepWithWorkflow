import {
  saveAs
} from "./chunk-PU4UKSZF.js";
import {
  validatePackage
} from "./chunk-XE2WGC36.js";
import {
  Deflate,
  Inflate
} from "./chunk-RFYN2QK2.js";
import "./chunk-NCGOQWHX.js";
import "./chunk-4NBGFDBU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@progress/kendo-ooxml/dist/es/services/template-service.js
var current = {
  compile: function(template) {
    return template;
  }
};
var TemplateService = function TemplateService2() {
};
TemplateService.register = function register(userImplementation) {
  current = userImplementation;
};
TemplateService.compile = function compile(template) {
  return current.compile(template);
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-ooxml/dist/es/utils/getter.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache = {};
var UNDEFINED = "undefined";
getterCache[UNDEFINED] = function(obj) {
  return obj;
};
function getter(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  var fields = [];
  field.replace(FIELD_REGEX, function(match, index, indexAccessor, field2) {
    fields.push(typeof index !== UNDEFINED ? index : indexAccessor || field2);
  });
  getterCache[field] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-ooxml/dist/es/utils/map.js
function map(array, func) {
  return array.reduce(function(result, el, i) {
    var val = func(el, i);
    if (val != null) {
      result.push(val);
    }
    return result;
  }, []);
}

// node_modules/@progress/kendo-ooxml/dist/es/excel-exporter.js
function defaultGroupHeaderTemplate(data) {
  return data.title + ": " + data.value;
}
function createArray(length, callback) {
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    result.push(callback(idx));
  }
  return result;
}
function defaultItemId(item) {
  return item.id;
}
var ExcelExporter = function ExcelExporter2(options) {
  options.columns = this._trimColumns(options.columns || []);
  this.allColumns = map(this._leafColumns(options.columns || []), this._prepareColumn);
  this.columns = this._visibleColumns(this.allColumns);
  this.options = options;
  this.data = options.data || [];
  this.aggregates = options.aggregates || {};
  this.groups = [].concat(options.groups || []);
  this.hasGroups = this.groups.length > 0;
  this.hierarchy = options.hierarchy;
  this.hasGroupHeaderColumn = this.columns.some(function(column) {
    return column.groupHeaderColumnTemplate;
  });
  this.collapsible = this.options.collapsible;
};
ExcelExporter.prototype.workbook = function workbook() {
  var workbook2 = {
    sheets: [{
      columns: this._columns(),
      rows: this.hierarchy ? this._hierarchyRows() : this._rows(),
      freezePane: this._freezePane(),
      filter: this._filter()
    }]
  };
  return workbook2;
};
ExcelExporter.prototype._trimColumns = function _trimColumns(columns) {
  var this$1 = this;
  return columns.filter(function(column) {
    var result = Boolean(column.field);
    if (!result && column.columns) {
      result = this$1._trimColumns(column.columns).length > 0;
    }
    return result;
  });
};
ExcelExporter.prototype._leafColumns = function _leafColumns(columns) {
  var this$1 = this;
  var result = [];
  for (var idx = 0; idx < columns.length; idx++) {
    if (!columns[idx].columns) {
      result.push(columns[idx]);
    } else {
      result = result.concat(this$1._leafColumns(columns[idx].columns));
    }
  }
  return result;
};
ExcelExporter.prototype._prepareColumn = function _prepareColumn(column) {
  if (!column.field) {
    return null;
  }
  var value = function(dataItem) {
    return getter(column.field, true)(dataItem);
  };
  var values = null;
  if (column.values) {
    values = {};
    column.values.forEach(function(item) {
      values[item.value] = item.text;
    });
    value = function(dataItem) {
      return values[getter(column.field, true)(dataItem)];
    };
  }
  return Object.assign({}, column, {
    value,
    values,
    groupHeaderTemplate: column.groupHeaderTemplate ? template_service_default.compile(column.groupHeaderTemplate) : defaultGroupHeaderTemplate,
    groupHeaderColumnTemplate: column.groupHeaderColumnTemplate ? template_service_default.compile(column.groupHeaderColumnTemplate) : null,
    groupFooterTemplate: column.groupFooterTemplate ? template_service_default.compile(column.groupFooterTemplate) : null,
    footerTemplate: column.footerTemplate ? template_service_default.compile(column.footerTemplate) : null
  });
};
ExcelExporter.prototype._filter = function _filter() {
  if (!this.options.filterable) {
    return null;
  }
  var depth = this._depth();
  return {
    from: depth,
    to: depth + this.columns.length - 1
  };
};
ExcelExporter.prototype._createPaddingCells = function _createPaddingCells(length) {
  var this$1 = this;
  return createArray(length, function() {
    return Object.assign({
      background: "#dfdfdf",
      color: "#333"
    }, this$1.options.paddingCellOptions);
  });
};
ExcelExporter.prototype._dataRow = function _dataRow(dataItem, level, depth) {
  var this$1 = this;
  var cells = this._createPaddingCells(level);
  if (this.hasGroups && depth && dataItem.items) {
    cells = cells.concat(this._groupHeaderCells(dataItem, level, depth));
    var rows = this._dataRows(dataItem.items, level + 1);
    rows.unshift({
      type: "group-header",
      cells,
      level: this.collapsible ? level : null
    });
    return rows.concat(this._footer(dataItem, level));
  }
  var dataCells = [];
  for (var cellIdx = 0; cellIdx < this.columns.length; cellIdx++) {
    dataCells[cellIdx] = this$1._cell(dataItem, this$1.columns[cellIdx]);
  }
  if (this.hierarchy) {
    dataCells[0].colSpan = depth - level + 1;
  }
  return [{
    type: "data",
    cells: cells.concat(dataCells),
    level: this.collapsible ? level : null
  }];
};
ExcelExporter.prototype._groupHeaderCells = function _groupHeaderCells(dataItem, level, depth) {
  var cells = [];
  var column = this.allColumns.filter(function(column2) {
    return column2.field === dataItem.field;
  })[0] || {};
  var title = column && column.title ? column.title : dataItem.field;
  var template = column ? column.groupHeaderTemplate || column.groupHeaderColumnTemplate : null;
  var group = Object.assign({
    title,
    field: dataItem.field,
    value: column && column.values ? column.values[dataItem.value] : dataItem.value,
    aggregates: dataItem.aggregates,
    items: dataItem.items
  }, dataItem.aggregates[dataItem.field]);
  var value = template ? template(group) : title + ": " + dataItem.value;
  cells.push(Object.assign({
    value,
    background: "#dfdfdf",
    color: "#333",
    colSpan: (this.hasGroupHeaderColumn ? 1 : this.columns.length) + depth - level
  }, column.groupHeaderCellOptions));
  if (this.hasGroupHeaderColumn) {
    this.columns.forEach(function(column2, index) {
      if (index > 0) {
        cells.push(Object.assign({
          background: "#dfdfdf",
          color: "#333",
          value: column2.groupHeaderColumnTemplate ? column2.groupHeaderColumnTemplate(Object.assign({ group }, group, dataItem.aggregates[column2.field])) : void 0
        }, column2.groupHeaderCellOptions));
      }
    });
  }
  return cells;
};
ExcelExporter.prototype._dataRows = function _dataRows(dataItems, level) {
  var this$1 = this;
  var depth = this._depth();
  var rows = [];
  for (var idx = 0; idx < dataItems.length; idx++) {
    rows.push.apply(rows, this$1._dataRow(dataItems[idx], level, depth));
  }
  return rows;
};
ExcelExporter.prototype._hierarchyRows = function _hierarchyRows() {
  var this$1 = this;
  var depth = this._depth();
  var data = this.data;
  var itemLevel = this.hierarchy.itemLevel;
  var itemId = this.hierarchy.itemId || defaultItemId;
  var hasFooter = this._hasFooterTemplate();
  var rows = [];
  var parents = [];
  var previousLevel = 0;
  var previousItemId;
  if (!hasFooter) {
    this.collapsible = false;
  }
  for (var idx = 0; idx < data.length; idx++) {
    var item = data[idx];
    var level = itemLevel(item, idx);
    if (hasFooter) {
      if (level > previousLevel) {
        parents.push({ id: previousItemId, level: previousLevel });
      } else if (level < previousLevel) {
        rows.push.apply(rows, this$1._hierarchyFooterRows(parents, level, depth));
      }
      previousLevel = level;
      previousItemId = itemId(item, idx);
    }
    rows.push.apply(rows, this$1._dataRow(item, level + 1, depth));
  }
  if (hasFooter) {
    rows.push.apply(rows, this._hierarchyFooterRows(parents, 0, depth));
    var rootAggregate = data.length ? this.aggregates[data[0].parentId] : {};
    rows.push(this._hierarchyFooter(rootAggregate, 0, depth));
  }
  this._prependHeaderRows(rows);
  return rows;
};
ExcelExporter.prototype._hierarchyFooterRows = function _hierarchyFooterRows(parents, currentLevel, depth) {
  var this$1 = this;
  var rows = [];
  while (parents.length && parents[parents.length - 1].level >= currentLevel) {
    var parent = parents.pop();
    rows.push(this$1._hierarchyFooter(this$1.aggregates[parent.id], parent.level + 1, depth));
  }
  return rows;
};
ExcelExporter.prototype._hasFooterTemplate = function _hasFooterTemplate() {
  var columns = this.columns;
  for (var idx = 0; idx < columns.length; idx++) {
    if (columns[idx].footerTemplate) {
      return true;
    }
  }
};
ExcelExporter.prototype._hierarchyFooter = function _hierarchyFooter(aggregates, level, depth) {
  var cells = this.columns.map(function(column, index) {
    var colSpan = index ? 1 : depth - level + 1;
    if (column.footerTemplate) {
      var fieldAggregates = (aggregates || {})[column.field];
      return Object.assign({
        background: "#dfdfdf",
        color: "#333",
        colSpan,
        value: column.footerTemplate(Object.assign({ aggregates }, fieldAggregates))
      }, column.footerCellOptions);
    }
    return Object.assign({
      background: "#dfdfdf",
      color: "#333",
      colSpan
    }, column.footerCellOptions);
  });
  return {
    type: "footer",
    cells: this._createPaddingCells(level).concat(cells),
    level: this.collapsible ? level : null
  };
};
ExcelExporter.prototype._footer = function _footer(dataItem, level) {
  var rows = [];
  var footer = this.columns.some(function(column) {
    return column.groupFooterTemplate;
  });
  var templateData, group;
  if (footer) {
    group = {
      group: {
        items: dataItem.items,
        field: dataItem.field,
        value: dataItem.value
      }
    };
    templateData = {};
    Object.keys(dataItem.aggregates).forEach(function(key) {
      templateData[key] = Object.assign({}, dataItem.aggregates[key], group);
    });
  }
  var cells = this.columns.map(function(column) {
    if (column.groupFooterTemplate) {
      var data = Object.assign({}, templateData, dataItem.aggregates[column.field], group);
      return Object.assign({
        background: "#dfdfdf",
        color: "#333",
        value: column.groupFooterTemplate(data)
      }, column.groupFooterCellOptions);
    }
    return Object.assign({
      background: "#dfdfdf",
      color: "#333"
    }, column.groupFooterCellOptions);
  });
  if (footer) {
    rows.push({
      type: "group-footer",
      cells: this._createPaddingCells(this.groups.length).concat(cells),
      level: this.collapsible ? level : null
    });
  }
  return rows;
};
ExcelExporter.prototype._isColumnVisible = function _isColumnVisible(column) {
  return this._visibleColumns([column]).length > 0 && (column.field || column.columns);
};
ExcelExporter.prototype._visibleColumns = function _visibleColumns(columns) {
  var this$1 = this;
  return columns.filter(function(column) {
    var exportable = column.exportable;
    if (typeof exportable === "object") {
      exportable = column.exportable.excel;
    }
    var visibleInExport = !column.hidden && exportable !== false;
    var visibleInExportOnly = column.hidden && exportable === true;
    var visible = visibleInExport || visibleInExportOnly;
    if (visible && column.columns) {
      visible = this$1._visibleColumns(column.columns).length > 0;
    }
    return visible;
  });
};
ExcelExporter.prototype._headerRow = function _headerRow(row, groups) {
  var this$1 = this;
  var headers = row.cells.map(function(cell) {
    return Object.assign(cell, {
      colSpan: cell.colSpan > 1 ? cell.colSpan : 1,
      rowSpan: row.rowSpan > 1 && !cell.colSpan ? row.rowSpan : 1
    });
  });
  if (this.hierarchy && headers[0].firstCell) {
    headers[0].colSpan += this._depth();
  }
  return {
    type: "header",
    cells: createArray(groups.length, function() {
      return Object.assign({
        background: "#7a7a7a",
        color: "#fff"
      }, this$1.options.headerPaddingCellOptions);
    }).concat(headers)
  };
};
ExcelExporter.prototype._prependHeaderRows = function _prependHeaderRows(rows) {
  var this$1 = this;
  var groups = this.groups;
  var headerRows = [{ rowSpan: 1, cells: [], index: 0 }];
  this._prepareHeaderRows(headerRows, this.options.columns);
  for (var idx = headerRows.length - 1; idx >= 0; idx--) {
    rows.unshift(this$1._headerRow(headerRows[idx], groups));
  }
};
ExcelExporter.prototype._prepareHeaderRows = function _prepareHeaderRows(rows, columns, parentCell, parentRow) {
  var this$1 = this;
  var row = parentRow || rows[rows.length - 1];
  var childRow = rows[row.index + 1];
  var totalColSpan = 0;
  for (var idx = 0; idx < columns.length; idx++) {
    var column = columns[idx];
    if (this$1._isColumnVisible(column)) {
      var cell = Object.assign({
        background: "#7a7a7a",
        color: "#fff",
        value: column.title || column.field,
        colSpan: 0,
        firstCell: idx === 0 && (!parentCell || parentCell.firstCell)
      }, column.headerCellOptions);
      row.cells.push(cell);
      if (column.columns && column.columns.length) {
        if (!childRow) {
          childRow = { rowSpan: 0, cells: [], index: rows.length };
          rows.push(childRow);
        }
        cell.colSpan = this$1._trimColumns(this$1._visibleColumns(column.columns)).length;
        this$1._prepareHeaderRows(rows, column.columns, cell, childRow);
        totalColSpan += cell.colSpan - 1;
        row.rowSpan = rows.length - row.index;
      }
    }
  }
  if (parentCell) {
    parentCell.colSpan += totalColSpan;
  }
};
ExcelExporter.prototype._rows = function _rows() {
  var this$1 = this;
  var rows = this._dataRows(this.data, 0);
  if (this.columns.length) {
    this._prependHeaderRows(rows);
    var footer = false;
    var cells = this.columns.map(function(column) {
      if (column.footerTemplate) {
        footer = true;
        return Object.assign({
          background: "#dfdfdf",
          color: "#333",
          value: column.footerTemplate(Object.assign({}, this$1.aggregates, this$1.aggregates[column.field]))
        }, column.footerCellOptions);
      }
      return Object.assign({
        background: "#dfdfdf",
        color: "#333"
      }, column.footerCellOptions);
    });
    if (footer) {
      rows.push({
        type: "footer",
        cells: this._createPaddingCells(this.groups.length).concat(cells)
      });
    }
  }
  return rows;
};
ExcelExporter.prototype._headerDepth = function _headerDepth(columns) {
  var this$1 = this;
  var result = 1;
  var max = 0;
  for (var idx = 0; idx < columns.length; idx++) {
    if (columns[idx].columns) {
      var temp = this$1._headerDepth(columns[idx].columns);
      if (temp > max) {
        max = temp;
      }
    }
  }
  return result + max;
};
ExcelExporter.prototype._freezePane = function _freezePane() {
  var columns = this._visibleColumns(this.options.columns || []);
  var colSplit = this._visibleColumns(this._trimColumns(this._leafColumns(columns.filter(function(column) {
    return column.locked;
  })))).length;
  return {
    rowSplit: this._headerDepth(columns),
    colSplit: colSplit ? colSplit + this.groups.length : 0
  };
};
ExcelExporter.prototype._cell = function _cell(dataItem, column) {
  return Object.assign({
    value: column.value(dataItem)
  }, column.cellOptions);
};
ExcelExporter.prototype._depth = function _depth() {
  var depth = 0;
  if (this.hierarchy) {
    depth = this.hierarchy.depth;
  } else {
    depth = this.groups.length;
  }
  return depth;
};
ExcelExporter.prototype._columns = function _columns() {
  var depth = this._depth();
  var columns = createArray(depth, function() {
    return { width: 20 };
  });
  return columns.concat(this.columns.map(function(column) {
    return {
      width: parseInt(column.width, 10),
      autoWidth: column.width ? false : true
    };
  }));
};
var excel_exporter_default = ExcelExporter;

// node_modules/@progress/kendo-ooxml/dist/es/services/intl-service.js
var current2 = {
  toString: function(value) {
    return value;
  }
};
var IntlService = function IntlService2() {
};
IntlService.register = function register2(userImplementation) {
  current2 = userImplementation;
};
IntlService.toString = function toString(value, format) {
  return current2.toString(value, format);
};
var intl_service_default = IntlService;

// node_modules/@progress/jszip-esm/dist/jszip-esm5.js
var external = {
  Promise
};
var support = {
  base64: true,
  array: true,
  string: true,
  nodebuffer: false,
  nodestream: false,
  get arraybuffer() {
    return typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  },
  // Returns true if JSZip can read/generate Uint8Array, false otherwise.
  get uint8array() {
    return typeof Uint8Array !== "undefined";
  },
  get blob() {
    return blob();
  }
};
var blob = function() {
  var supported;
  if (typeof ArrayBuffer === "undefined") {
    supported = false;
  } else {
    var buffer = new ArrayBuffer(0);
    try {
      supported = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e) {
      supported = false;
    }
  }
  blob = function() {
    return supported;
  };
  return supported;
};
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var encode = function(input) {
  var output = [];
  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  var i = 0, len = input.length, remainingBytes = len;
  var isArray = typeof input !== "string";
  while (i < input.length) {
    remainingBytes = len - i;
    if (!isArray) {
      chr1 = input.charCodeAt(i++);
      chr2 = i < len ? input.charCodeAt(i++) : 0;
      chr3 = i < len ? input.charCodeAt(i++) : 0;
    } else {
      chr1 = input[i++];
      chr2 = i < len ? input[i++] : 0;
      chr3 = i < len ? input[i++] : 0;
    }
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
    enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
    output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
  }
  return output.join("");
};
var decode = function(input) {
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0, resultIndex = 0;
  var dataUrlPrefix = "data:";
  if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
    throw new Error("Invalid base64 input, it looks like a data url.");
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var totalLength = input.length * 3 / 4;
  if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
    totalLength--;
  }
  if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
    totalLength--;
  }
  if (totalLength % 1 !== 0) {
    throw new Error("Invalid base64 input, bad content length.");
  }
  var output;
  if (support.uint8array) {
    output = new Uint8Array(totalLength | 0);
  } else {
    output = new Array(totalLength | 0);
  }
  while (i < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i++));
    enc2 = _keyStr.indexOf(input.charAt(i++));
    enc3 = _keyStr.indexOf(input.charAt(i++));
    enc4 = _keyStr.indexOf(input.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output[resultIndex++] = chr1;
    if (enc3 !== 64) {
      output[resultIndex++] = chr2;
    }
    if (enc4 !== 64) {
      output[resultIndex++] = chr3;
    }
  }
  return output;
};
function string2binary(str) {
  var result = null;
  if (support.uint8array) {
    result = new Uint8Array(str.length);
  } else {
    result = new Array(str.length);
  }
  return stringToArrayLike(str, result);
}
var newBlob = function(part, type) {
  checkSupport("blob");
  return new Blob([part], {
    type
  });
};
function identity(input) {
  return input;
}
function stringToArrayLike(str, array) {
  for (var i = 0; i < str.length; ++i) {
    array[i] = str.charCodeAt(i) & 255;
  }
  return array;
}
function stringifyByChunk(array, type, chunk) {
  var result = [], k = 0, len = array.length;
  if (len <= chunk) {
    return String.fromCharCode.apply(null, array);
  }
  while (k < len) {
    if (type === "array") {
      result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
    } else {
      result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
    }
    k += chunk;
  }
  return result.join("");
}
function stringifyByChar(array) {
  var resultStr = "";
  for (var i = 0; i < array.length; i++) {
    resultStr += String.fromCharCode(array[i]);
  }
  return resultStr;
}
var fromCharCodeSupportsTypedArrays = function() {
  var supported;
  try {
    supported = support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
  } catch (e) {
    supported = false;
  }
  fromCharCodeSupportsTypedArrays = function() {
    return supported;
  };
  return supported;
};
function arrayLikeToString(array) {
  var chunk = 65536, type = getTypeOf(array), canUseApply = true;
  if (type === "uint8array") {
    canUseApply = fromCharCodeSupportsTypedArrays();
  }
  if (canUseApply) {
    while (chunk > 1) {
      try {
        return stringifyByChunk(array, type, chunk);
      } catch (e) {
        chunk = Math.floor(chunk / 2);
      }
    }
  }
  return stringifyByChar(array);
}
var applyFromCharCode = arrayLikeToString;
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
  for (var i = 0; i < arrayFrom.length; i++) {
    arrayTo[i] = arrayFrom[i];
  }
  return arrayTo;
}
var transform = {
  // string to ?
  "string": {
    "string": identity,
    "array": function(input) {
      return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
      return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
      return stringToArrayLike(input, new Uint8Array(input.length));
    }
  },
  // array to ?
  "array": {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
      return new Uint8Array(input).buffer;
    },
    "uint8array": function(input) {
      return new Uint8Array(input);
    }
  },
  // arraybuffer to ?
  "arraybuffer": {
    "string": function(input) {
      return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
      return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
      return new Uint8Array(input);
    }
  },
  // uint8array to ?
  "uint8array": {
    "string": arrayLikeToString,
    "array": function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
      return input.buffer;
    },
    "uint8array": identity
  }
};
var transformTo = function(outputType, input) {
  if (!input) {
    input = "";
  }
  if (!outputType) {
    return input;
  }
  checkSupport(outputType);
  var inputType = getTypeOf(input);
  var result = transform[inputType][outputType](input);
  return result;
};
var getTypeOf = function(input) {
  if (typeof input === "string") {
    return "string";
  }
  if (Object.prototype.toString.call(input) === "[object Array]") {
    return "array";
  }
  if (support.uint8array && input instanceof Uint8Array) {
    return "uint8array";
  }
  if (support.arraybuffer && input instanceof ArrayBuffer) {
    return "arraybuffer";
  }
};
var checkSupport = function(type) {
  var supported = support[type.toLowerCase()];
  if (!supported) {
    throw new Error(type + " is not supported by this platform");
  }
};
var MAX_VALUE_16BITS = 65535;
var MAX_VALUE_32BITS = -1;
var pretty = function(str) {
  var res = "", code, i;
  for (i = 0; i < (str || "").length; i++) {
    code = str.charCodeAt(i);
    res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
  }
  return res;
};
var delay = function(callback, args, self) {
  setTimeout(function() {
    callback.apply(self || null, args || []);
  }, 0);
};
var extend = function() {
  var arguments$1 = arguments;
  var result = {}, i, attr;
  for (i = 0; i < arguments.length; i++) {
    for (attr in arguments[i]) {
      if (Object.hasOwnProperty.call(arguments$1[i], attr) && typeof result[attr] === "undefined") {
        result[attr] = arguments$1[i][attr];
      }
    }
  }
  return result;
};
var prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
  var promise = external.Promise.resolve(inputData).then(function(data) {
    var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
    if (isBlob && typeof FileReader !== "undefined") {
      return new external.Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.onerror = function(e) {
          reject(e.target.error);
        };
        reader.readAsArrayBuffer(data);
      });
    } else {
      return data;
    }
  });
  return promise.then(function(data) {
    var dataType = getTypeOf(data);
    if (!dataType) {
      return external.Promise.reject(
        new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
      );
    }
    if (dataType === "arraybuffer") {
      data = transformTo("uint8array", data);
    } else if (dataType === "string") {
      if (isBase64) {
        data = decode(data);
      } else if (isBinary) {
        if (isOptimizedBinaryString !== true) {
          data = string2binary(data);
        }
      }
    }
    return data;
  });
};
var GenericWorker = function GenericWorker2(name) {
  this.name = name || "default";
  this.streamInfo = {};
  this.generatedError = null;
  this.extraStreamInfo = {};
  this.isPaused = true;
  this.isFinished = false;
  this.isLocked = false;
  this._listeners = {
    "data": [],
    "end": [],
    "error": []
  };
  this.previous = null;
};
GenericWorker.prototype.push = function push(chunk) {
  this.emit("data", chunk);
};
GenericWorker.prototype.end = function end() {
  if (this.isFinished) {
    return false;
  }
  this.flush();
  try {
    this.emit("end");
    this.cleanUp();
    this.isFinished = true;
  } catch (e) {
    this.emit("error", e);
  }
  return true;
};
GenericWorker.prototype.error = function error(e) {
  if (this.isFinished) {
    return false;
  }
  if (this.isPaused) {
    this.generatedError = e;
  } else {
    this.isFinished = true;
    this.emit("error", e);
    if (this.previous) {
      this.previous.error(e);
    }
    this.cleanUp();
  }
  return true;
};
GenericWorker.prototype.on = function on(name, listener) {
  this._listeners[name].push(listener);
  return this;
};
GenericWorker.prototype.cleanUp = function cleanUp() {
  this.streamInfo = this.generatedError = this.extraStreamInfo = null;
  this._listeners = [];
};
GenericWorker.prototype.emit = function emit(name, arg) {
  if (this._listeners[name]) {
    for (var i = 0; i < this._listeners[name].length; i++) {
      this._listeners[name][i].call(this, arg);
    }
  }
};
GenericWorker.prototype.pipe = function pipe(next) {
  return next.registerPrevious(this);
};
GenericWorker.prototype.registerPrevious = function registerPrevious(previous) {
  if (this.isLocked) {
    throw new Error("The stream '" + this + "' has already been used.");
  }
  this.streamInfo = previous.streamInfo;
  this.mergeStreamInfo();
  this.previous = previous;
  var self = this;
  previous.on("data", function(chunk) {
    self.processChunk(chunk);
  });
  previous.on("end", function() {
    self.end();
  });
  previous.on("error", function(e) {
    self.error(e);
  });
  return this;
};
GenericWorker.prototype.pause = function pause() {
  if (this.isPaused || this.isFinished) {
    return false;
  }
  this.isPaused = true;
  if (this.previous) {
    this.previous.pause();
  }
  return true;
};
GenericWorker.prototype.resume = function resume() {
  if (!this.isPaused || this.isFinished) {
    return false;
  }
  this.isPaused = false;
  var withError = false;
  if (this.generatedError) {
    this.error(this.generatedError);
    withError = true;
  }
  if (this.previous) {
    this.previous.resume();
  }
  return !withError;
};
GenericWorker.prototype.flush = function flush() {
};
GenericWorker.prototype.processChunk = function processChunk(chunk) {
  this.push(chunk);
};
GenericWorker.prototype.withStreamInfo = function withStreamInfo(key, value) {
  this.extraStreamInfo[key] = value;
  this.mergeStreamInfo();
  return this;
};
GenericWorker.prototype.mergeStreamInfo = function mergeStreamInfo() {
  for (var key in this.extraStreamInfo) {
    if (!this.extraStreamInfo.hasOwnProperty(key)) {
      continue;
    }
    this.streamInfo[key] = this.extraStreamInfo[key];
  }
};
GenericWorker.prototype.lock = function lock() {
  if (this.isLocked) {
    throw new Error("The stream '" + this + "' has already been used.");
  }
  this.isLocked = true;
  if (this.previous) {
    this.previous.lock();
  }
};
GenericWorker.prototype.toString = function toString2() {
  var me = "Worker " + this.name;
  if (this.previous) {
    return this.previous + " -> " + me;
  } else {
    return me;
  }
};
var utf8len = function(c) {
  var _utf8len = new Array(256);
  for (var i = 0; i < 256; i++) {
    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  utf8len = function(c2) {
    return _utf8len[c2];
  };
  return _utf8len[c];
};
var string2buf = function(str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  if (support.uint8array) {
    buf = new Uint8Array(buf_len);
  } else {
    buf = new Array(buf_len);
  }
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var utf8border = function(buf, max) {
  var pos;
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + utf8len(buf[pos]) > max ? pos : max;
};
var buf2string = function(buf) {
  var i, out, c, c_len;
  var len = buf.length;
  var utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    c_len = utf8len(c);
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  if (utf16buf.length !== out) {
    if (utf16buf.subarray) {
      utf16buf = utf16buf.subarray(0, out);
    } else {
      utf16buf.length = out;
    }
  }
  return applyFromCharCode(utf16buf);
};
var utf8encode = function utf8encode2(str) {
  return string2buf(str);
};
var utf8decode = function utf8decode2(buf) {
  buf = transformTo(support.uint8array ? "uint8array" : "array", buf);
  return buf2string(buf);
};
var Utf8DecodeWorker = function(GenericWorker3) {
  function Utf8DecodeWorker2() {
    GenericWorker3.call(this, "utf-8 decode");
    this.leftOver = null;
  }
  if (GenericWorker3)
    Utf8DecodeWorker2.__proto__ = GenericWorker3;
  Utf8DecodeWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  Utf8DecodeWorker2.prototype.constructor = Utf8DecodeWorker2;
  Utf8DecodeWorker2.prototype.processChunk = function processChunk2(chunk) {
    var data = transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
    if (this.leftOver && this.leftOver.length) {
      if (support.uint8array) {
        var previousData = data;
        data = new Uint8Array(previousData.length + this.leftOver.length);
        data.set(this.leftOver, 0);
        data.set(previousData, this.leftOver.length);
      } else {
        data = this.leftOver.concat(data);
      }
      this.leftOver = null;
    }
    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
      if (support.uint8array) {
        usableData = data.subarray(0, nextBoundary);
        this.leftOver = data.subarray(nextBoundary, data.length);
      } else {
        usableData = data.slice(0, nextBoundary);
        this.leftOver = data.slice(nextBoundary, data.length);
      }
    }
    this.push({
      data: utf8decode(usableData),
      meta: chunk.meta
    });
  };
  Utf8DecodeWorker2.prototype.flush = function flush2() {
    if (this.leftOver && this.leftOver.length) {
      this.push({
        data: utf8decode(this.leftOver),
        meta: {}
      });
      this.leftOver = null;
    }
  };
  return Utf8DecodeWorker2;
}(GenericWorker);
var Utf8EncodeWorker = function(GenericWorker3) {
  function Utf8EncodeWorker2() {
    GenericWorker3.call(this, "utf-8 encode");
  }
  if (GenericWorker3)
    Utf8EncodeWorker2.__proto__ = GenericWorker3;
  Utf8EncodeWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  Utf8EncodeWorker2.prototype.constructor = Utf8EncodeWorker2;
  Utf8EncodeWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.push({
      data: utf8encode(chunk.data),
      meta: chunk.meta
    });
  };
  return Utf8EncodeWorker2;
}(GenericWorker);
var ConvertWorker = function(GenericWorker3) {
  function ConvertWorker2(destType) {
    GenericWorker3.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  if (GenericWorker3)
    ConvertWorker2.__proto__ = GenericWorker3;
  ConvertWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  ConvertWorker2.prototype.constructor = ConvertWorker2;
  ConvertWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.push({
      data: transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  return ConvertWorker2;
}(GenericWorker);
function transformZipOutput(type, content, mimeType) {
  switch (type) {
    case "blob":
      return newBlob(transformTo("arraybuffer", content), mimeType);
    case "base64":
      return encode(content);
    default:
      return transformTo(type, content);
  }
}
function concat(type, dataArray) {
  var i, index = 0, res = null, totalLength = 0;
  for (i = 0; i < dataArray.length; i++) {
    totalLength += dataArray[i].length;
  }
  switch (type) {
    case "string":
      return dataArray.join("");
    case "array":
      return Array.prototype.concat.apply([], dataArray);
    case "uint8array":
      res = new Uint8Array(totalLength);
      for (i = 0; i < dataArray.length; i++) {
        res.set(dataArray[i], index);
        index += dataArray[i].length;
      }
      return res;
    default:
      throw new Error("concat : unsupported type '" + type + "'");
  }
}
function accumulate(helper, updateCallback) {
  return new external.Promise(function(resolve, reject) {
    var dataArray = [];
    var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
    helper.on("data", function(data, meta) {
      dataArray.push(data);
      if (updateCallback) {
        updateCallback(meta);
      }
    }).on("error", function(err) {
      dataArray = [];
      reject(err);
    }).on("end", function() {
      try {
        var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
        resolve(result);
      } catch (e) {
        reject(e);
      }
      dataArray = [];
    }).resume();
  });
}
var StreamHelper = function StreamHelper2(worker, outputType, mimeType) {
  var internalType = outputType;
  switch (outputType) {
    case "blob":
    case "arraybuffer":
      internalType = "uint8array";
      break;
    case "base64":
      internalType = "string";
      break;
  }
  try {
    this._internalType = internalType;
    this._outputType = outputType;
    this._mimeType = mimeType;
    checkSupport(internalType);
    this._worker = worker.pipe(new ConvertWorker(internalType));
    worker.lock();
  } catch (e) {
    this._worker = new GenericWorker("error");
    this._worker.error(e);
  }
};
StreamHelper.prototype.accumulate = function accumulate$1(updateCb) {
  return accumulate(this, updateCb);
};
StreamHelper.prototype.on = function on2(evt, fn) {
  var self = this;
  if (evt === "data") {
    this._worker.on(evt, function(chunk) {
      fn.call(self, chunk.data, chunk.meta);
    });
  } else {
    this._worker.on(evt, function() {
      delay(fn, arguments, self);
    });
  }
  return this;
};
StreamHelper.prototype.resume = function resume2() {
  delay(this._worker.resume, [], this._worker);
  return this;
};
StreamHelper.prototype.pause = function pause2() {
  this._worker.pause();
  return this;
};
var base64 = false;
var binary = false;
var dir = false;
var createFolders = true;
var date = null;
var compression = null;
var compressionOptions = null;
var comment = null;
var unixPermissions = null;
var dosPermissions = null;
var defaults = Object.freeze({
  __proto__: null,
  base64,
  binary,
  dir,
  createFolders,
  date,
  compression,
  compressionOptions,
  comment,
  unixPermissions,
  dosPermissions
});
var DEFAULT_BLOCK_SIZE = 16 * 1024;
var DataWorker = function(GenericWorker3) {
  function DataWorker2(dataP) {
    GenericWorker3.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data) {
      self.dataIsReady = true;
      self.data = data;
      self.max = data && data.length || 0;
      self.type = getTypeOf(data);
      if (!self.isPaused) {
        self._tickAndRepeat();
      }
    }, function(e) {
      self.error(e);
    });
  }
  if (GenericWorker3)
    DataWorker2.__proto__ = GenericWorker3;
  DataWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  DataWorker2.prototype.constructor = DataWorker2;
  DataWorker2.prototype.cleanUp = function cleanUp2() {
    GenericWorker3.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker2.prototype.resume = function resume3() {
    if (!GenericWorker3.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      delay(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker2.prototype._tickAndRepeat = function _tickAndRepeat() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      delay(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker2.prototype._tick = function _tick() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  return DataWorker2;
}(GenericWorker);
var DataLengthProbe = function(GenericWorker3) {
  function DataLengthProbe2(propName) {
    GenericWorker3.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  if (GenericWorker3)
    DataLengthProbe2.__proto__ = GenericWorker3;
  DataLengthProbe2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  DataLengthProbe2.prototype.constructor = DataLengthProbe2;
  DataLengthProbe2.prototype.processChunk = function processChunk2(chunk) {
    if (chunk) {
      var length = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker3.prototype.processChunk.call(this, chunk);
  };
  return DataLengthProbe2;
}(GenericWorker);
var makeTable = function() {
  var table = [];
  for (var n = 0; n < 256; n++) {
    var c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  makeTable = function() {
    return table;
  };
  return table;
};
function crc32(crc, buf, len, pos) {
  var t = makeTable();
  var end2 = pos + len;
  crc = crc ^ -1;
  for (var i = pos; i < end2; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
function crc32str(crc, str, len, pos) {
  var t = makeTable();
  var end2 = pos + len;
  crc = crc ^ -1;
  for (var i = pos; i < end2; i++) {
    crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
  }
  return crc ^ -1;
}
function crc32wrapper(input, crc) {
  if (typeof input === "undefined" || !input.length) {
    return 0;
  }
  var isArray = getTypeOf(input) !== "string";
  if (isArray) {
    return crc32(crc | 0, input, input.length, 0);
  } else {
    return crc32str(crc | 0, input, input.length, 0);
  }
}
var Crc32Probe = function(GenericWorker3) {
  function Crc32Probe2() {
    GenericWorker3.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  if (GenericWorker3)
    Crc32Probe2.__proto__ = GenericWorker3;
  Crc32Probe2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  Crc32Probe2.prototype.constructor = Crc32Probe2;
  Crc32Probe2.prototype.processChunk = function processChunk2(chunk) {
    this.streamInfo.crc32 = crc32wrapper(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  return Crc32Probe2;
}(GenericWorker);
var CompressedObject = function CompressedObject2(compressedSize, uncompressedSize, crc322, compression2, data) {
  this.compressedSize = compressedSize;
  this.uncompressedSize = uncompressedSize;
  this.crc32 = crc322;
  this.compression = compression2;
  this.compressedContent = data;
};
CompressedObject.prototype.getContentWorker = function getContentWorker() {
  var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
  var that = this;
  worker.on("end", function() {
    if (this.streamInfo["data_length"] !== that.uncompressedSize) {
      throw new Error("Bug : uncompressed data size mismatch");
    }
  });
  return worker;
};
CompressedObject.prototype.getCompressedWorker = function getCompressedWorker() {
  return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
};
CompressedObject.createWorkerFrom = function createWorkerFrom(uncompressedWorker, compression2, compressionOptions2) {
  return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression2.compressWorker(compressionOptions2)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression2);
};
var ZipObject = function ZipObject2(name, data, options) {
  this.name = name;
  this.dir = options.dir;
  this.date = options.date;
  this.comment = options.comment;
  this.unixPermissions = options.unixPermissions;
  this.dosPermissions = options.dosPermissions;
  this._data = data;
  this._dataBinary = options.binary;
  this.options = {
    compression: options.compression,
    compressionOptions: options.compressionOptions
  };
};
ZipObject.prototype.internalStream = function internalStream(type) {
  var result = null, outputType = "string";
  try {
    if (!type) {
      throw new Error("No output type specified.");
    }
    outputType = type.toLowerCase();
    var askUnicodeString = outputType === "string" || outputType === "text";
    if (outputType === "binarystring" || outputType === "text") {
      outputType = "string";
    }
    result = this._decompressWorker();
    var isUnicodeString = !this._dataBinary;
    if (isUnicodeString && !askUnicodeString) {
      result = result.pipe(new Utf8EncodeWorker());
    }
    if (!isUnicodeString && askUnicodeString) {
      result = result.pipe(new Utf8DecodeWorker());
    }
  } catch (e) {
    result = new GenericWorker("error");
    result.error(e);
  }
  return new StreamHelper(result, outputType, "");
};
ZipObject.prototype.async = function async(type, onUpdate) {
  return this.internalStream(type).accumulate(onUpdate);
};
ZipObject.prototype._compressWorker = function _compressWorker(compression2, compressionOptions2) {
  if (this._data instanceof CompressedObject && this._data.compression.magic === compression2.magic) {
    return this._data.getCompressedWorker();
  } else {
    var result = this._decompressWorker();
    if (!this._dataBinary) {
      result = result.pipe(new Utf8EncodeWorker());
    }
    return CompressedObject.createWorkerFrom(result, compression2, compressionOptions2);
  }
};
ZipObject.prototype._decompressWorker = function _decompressWorker() {
  if (this._data instanceof CompressedObject) {
    return this._data.getContentWorker();
  } else if (this._data instanceof GenericWorker) {
    return this._data;
  } else {
    return new DataWorker(this._data);
  }
};
var arrayType = function() {
  var useTypedArray = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var resolved = useTypedArray ? "uint8array" : "array";
  arrayType = function() {
    return resolved;
  };
};
var FlateWorker = function(GenericWorker3) {
  function FlateWorker2(action, options) {
    GenericWorker3.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    this.meta = {};
  }
  if (GenericWorker3)
    FlateWorker2.__proto__ = GenericWorker3;
  FlateWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  FlateWorker2.prototype.constructor = FlateWorker2;
  FlateWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(transformTo(arrayType(), chunk.data), false);
  };
  FlateWorker2.prototype.flush = function flush2() {
    GenericWorker3.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker2.prototype.cleanUp = function cleanUp2() {
    GenericWorker3.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker2.prototype._createPako = function _createPako() {
    var this$1$1 = this;
    var params = {
      raw: true,
      level: this._pakoOptions.level || -1
      // default compression
    };
    this._pako = this._pakoAction === "Deflate" ? new Deflate(params) : new Inflate(params);
    this._pako.onData = function(data) {
      this$1$1.push({
        data,
        meta: this$1$1.meta
      });
    };
  };
  return FlateWorker2;
}(GenericWorker);
var DEFLATE = {
  magic: "\b\0",
  compressWorker: function(compressionOptions2) {
    return new FlateWorker("Deflate", compressionOptions2);
  },
  uncompressWorker: function() {
    return new FlateWorker("Inflate", {});
  }
};
var STORE = {
  magic: "\0\0",
  compressWorker: function() {
    return new GenericWorker("STORE compression");
  },
  uncompressWorker: function() {
    return new GenericWorker("STORE decompression");
  }
};
var compressions = {
  STORE,
  DEFLATE
};
var LOCAL_FILE_HEADER = "PK";
var CENTRAL_FILE_HEADER = "PK";
var CENTRAL_DIRECTORY_END = "PK";
var ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
var ZIP64_CENTRAL_DIRECTORY_END = "PK";
var DATA_DESCRIPTOR = "PK\x07\b";
var decToHex = function(dec, bytes) {
  var hex = "", i;
  for (i = 0; i < bytes; i++) {
    hex += String.fromCharCode(dec & 255);
    dec = dec >>> 8;
  }
  return hex;
};
var generateUnixExternalFileAttr = function(unixPermissions2, isDir) {
  var result = unixPermissions2;
  if (!unixPermissions2) {
    result = isDir ? 16893 : 33204;
  }
  return (result & 65535) << 16;
};
var generateDosExternalFileAttr = function(dosPermissions2, isDir) {
  return (dosPermissions2 || 0) & 63;
};
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
  var file2 = streamInfo["file"], compression2 = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8encode, encodedFileName = transformTo("string", encodeFileName(file2.name)), utfEncodedFileName = transformTo("string", utf8encode(file2.name)), comment2 = file2.comment, encodedComment = transformTo("string", encodeFileName(comment2)), utfEncodedComment = transformTo("string", utf8encode(comment2)), useUTF8ForFileName = utfEncodedFileName.length !== file2.name.length, useUTF8ForComment = utfEncodedComment.length !== comment2.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir2 = file2.dir, date2 = file2.date;
  var dataInfo = {
    crc32: 0,
    compressedSize: 0,
    uncompressedSize: 0
  };
  if (!streamedContent || streamingEnded) {
    dataInfo.crc32 = streamInfo["crc32"];
    dataInfo.compressedSize = streamInfo["compressedSize"];
    dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
  }
  var bitflag = 0;
  if (streamedContent) {
    bitflag |= 8;
  }
  if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
    bitflag |= 2048;
  }
  var extFileAttr = 0;
  var versionMadeBy = 0;
  if (dir2) {
    extFileAttr |= 16;
  }
  if (platform === "UNIX") {
    versionMadeBy = 798;
    extFileAttr |= generateUnixExternalFileAttr(file2.unixPermissions, dir2);
  } else {
    versionMadeBy = 20;
    extFileAttr |= generateDosExternalFileAttr(file2.dosPermissions);
  }
  dosTime = date2.getUTCHours();
  dosTime = dosTime << 6;
  dosTime = dosTime | date2.getUTCMinutes();
  dosTime = dosTime << 5;
  dosTime = dosTime | date2.getUTCSeconds() / 2;
  dosDate = date2.getUTCFullYear() - 1980;
  dosDate = dosDate << 4;
  dosDate = dosDate | date2.getUTCMonth() + 1;
  dosDate = dosDate << 5;
  dosDate = dosDate | date2.getUTCDate();
  if (useUTF8ForFileName) {
    unicodePathExtraField = // Version
    decToHex(1, 1) + // NameCRC32
    decToHex(crc32wrapper(encodedFileName), 4) + // UnicodeName
    utfEncodedFileName;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "up" + // size
    decToHex(unicodePathExtraField.length, 2) + // content
    unicodePathExtraField;
  }
  if (useUTF8ForComment) {
    unicodeCommentExtraField = // Version
    decToHex(1, 1) + // CommentCRC32
    decToHex(crc32wrapper(encodedComment), 4) + // UnicodeName
    utfEncodedComment;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "uc" + // size
    decToHex(unicodeCommentExtraField.length, 2) + // content
    unicodeCommentExtraField;
  }
  var header = "";
  header += "\n\0";
  header += decToHex(bitflag, 2);
  header += compression2.magic;
  header += decToHex(dosTime, 2);
  header += decToHex(dosDate, 2);
  header += decToHex(dataInfo.crc32, 4);
  header += decToHex(dataInfo.compressedSize, 4);
  header += decToHex(dataInfo.uncompressedSize, 4);
  header += decToHex(encodedFileName.length, 2);
  header += decToHex(extraFields.length, 2);
  var fileRecord = LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
  var dirRecord = CENTRAL_FILE_HEADER + // version made by (00: DOS)
  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
  header + // file comment length
  decToHex(encodedComment.length, 2) + // disk number start
  "\0\0\0\0" + // external file attributes
  decToHex(extFileAttr, 4) + // relative offset of local header
  decToHex(offset, 4) + // file name
  encodedFileName + // extra field
  extraFields + // file comment
  encodedComment;
  return {
    fileRecord,
    dirRecord
  };
};
var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment2, encodeFileName) {
  var dirEnd = "";
  var encodedComment = transformTo("string", encodeFileName(comment2));
  dirEnd = CENTRAL_DIRECTORY_END + // number of this disk
  "\0\0\0\0" + // total number of entries in the central directory on this disk
  decToHex(entriesCount, 2) + // total number of entries in the central directory
  decToHex(entriesCount, 2) + // size of the central directory   4 bytes
  decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
  decToHex(localDirLength, 4) + // .ZIP file comment length
  decToHex(encodedComment.length, 2) + // .ZIP file comment
  encodedComment;
  return dirEnd;
};
var generateDataDescriptors = function(streamInfo) {
  var descriptor = "";
  descriptor = DATA_DESCRIPTOR + // crc-32                          4 bytes
  decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
  decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
  decToHex(streamInfo["uncompressedSize"], 4);
  return descriptor;
};
var ZipFileWorker = function(GenericWorker3) {
  function ZipFileWorker2(streamFiles, comment2, platform, encodeFileName) {
    GenericWorker3.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment2;
    this.zipPlatform = platform;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  if (GenericWorker3)
    ZipFileWorker2.__proto__ = GenericWorker3;
  ZipFileWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  ZipFileWorker2.prototype.constructor = ZipFileWorker2;
  ZipFileWorker2.prototype.push = function push2(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker3.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker2.prototype.openedSource = function openedSource(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker2.prototype.closedSource = function closedSource(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker2.prototype.flush = function flush2() {
    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
      this.push({
        data: this.dirRecords[i],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker2.prototype.prepareNextSource = function prepareNextSource() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker2.prototype.registerPrevious = function registerPrevious2(previous) {
    this._sources.push(previous);
    var self = this;
    previous.on("data", function(chunk) {
      self.processChunk(chunk);
    });
    previous.on("end", function() {
      self.closedSource(self.previous.streamInfo);
      if (self._sources.length) {
        self.prepareNextSource();
      } else {
        self.end();
      }
    });
    previous.on("error", function(e) {
      self.error(e);
    });
    return this;
  };
  ZipFileWorker2.prototype.resume = function resume3() {
    if (!GenericWorker3.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker2.prototype.error = function error2(e) {
    var sources = this._sources;
    if (!GenericWorker3.prototype.error.call(this, e)) {
      return false;
    }
    for (var i = 0; i < sources.length; i++) {
      try {
        sources[i].error(e);
      } catch (e$1) {
      }
    }
    return true;
  };
  ZipFileWorker2.prototype.lock = function lock2() {
    GenericWorker3.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
      sources[i].lock();
    }
  };
  return ZipFileWorker2;
}(GenericWorker);
var getCompression = function(fileCompression, zipCompression) {
  var compressionName = fileCompression || zipCompression;
  var compression2 = compressions[compressionName];
  if (!compression2) {
    throw new Error(compressionName + " is not a valid compression method !");
  }
  return compression2;
};
var generateWorker = function(zip, options, comment2) {
  var zipFileWorker = new ZipFileWorker(options.streamFiles, comment2, options.platform, options.encodeFileName);
  var entriesCount = 0;
  try {
    zip.forEach(function(relativePath, file2) {
      entriesCount++;
      var compression2 = getCompression(file2.options.compression, options.compression);
      var compressionOptions2 = file2.options.compressionOptions || options.compressionOptions || {};
      var dir2 = file2.dir, date2 = file2.date;
      file2._compressWorker(compression2, compressionOptions2).withStreamInfo("file", {
        name: relativePath,
        dir: dir2,
        date: date2,
        comment: file2.comment || "",
        unixPermissions: file2.unixPermissions,
        dosPermissions: file2.dosPermissions
      }).pipe(zipFileWorker);
    });
    zipFileWorker.entriesCount = entriesCount;
  } catch (e) {
    zipFileWorker.error(e);
  }
  return zipFileWorker;
};
var DataReader = function DataReader2(data) {
  this.data = data;
  this.length = data.length;
  this.index = 0;
  this.zero = 0;
};
DataReader.prototype.checkOffset = function checkOffset(offset) {
  this.checkIndex(this.index + offset);
};
DataReader.prototype.checkIndex = function checkIndex(newIndex) {
  if (this.length < this.zero + newIndex || newIndex < 0) {
    throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
  }
};
DataReader.prototype.setIndex = function setIndex(newIndex) {
  this.checkIndex(newIndex);
  this.index = newIndex;
};
DataReader.prototype.skip = function skip(n) {
  this.setIndex(this.index + n);
};
DataReader.prototype.byteAt = function byteAt(i) {
};
DataReader.prototype.readInt = function readInt(size) {
  var result = 0, i;
  this.checkOffset(size);
  for (i = this.index + size - 1; i >= this.index; i--) {
    result = (result << 8) + this.byteAt(i);
  }
  this.index += size;
  return result;
};
DataReader.prototype.readString = function readString(size) {
  return transformTo("string", this.readData(size));
};
DataReader.prototype.readData = function readData(size) {
};
DataReader.prototype.lastIndexOfSignature = function lastIndexOfSignature(sig) {
};
DataReader.prototype.readAndCheckSignature = function readAndCheckSignature(sig) {
};
DataReader.prototype.readDate = function readDate() {
  var dostime = this.readInt(4);
  return new Date(Date.UTC(
    (dostime >> 25 & 127) + 1980,
    // year
    (dostime >> 21 & 15) - 1,
    // month
    dostime >> 16 & 31,
    // day
    dostime >> 11 & 31,
    // hour
    dostime >> 5 & 63,
    // minute
    (dostime & 31) << 1
  ));
};
var ArrayReader = function(DataReader3) {
  function ArrayReader2(data) {
    DataReader3.call(this, data);
    for (var i = 0; i < this.data.length; i++) {
      data[i] = data[i] & 255;
    }
  }
  if (DataReader3)
    ArrayReader2.__proto__ = DataReader3;
  ArrayReader2.prototype = Object.create(DataReader3 && DataReader3.prototype);
  ArrayReader2.prototype.constructor = ArrayReader2;
  ArrayReader2.prototype.byteAt = function byteAt2(i) {
    return this.data[this.zero + i];
  };
  ArrayReader2.prototype.lastIndexOfSignature = function lastIndexOfSignature2(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
      if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
        return i - this.zero;
      }
    }
    return -1;
  };
  ArrayReader2.prototype.readAndCheckSignature = function readAndCheckSignature2(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    if (size === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return ArrayReader2;
}(DataReader);
var StringReader = function(DataReader3) {
  function StringReader2(data) {
    DataReader3.call(this, data);
  }
  if (DataReader3)
    StringReader2.__proto__ = DataReader3;
  StringReader2.prototype = Object.create(DataReader3 && DataReader3.prototype);
  StringReader2.prototype.constructor = StringReader2;
  StringReader2.prototype.byteAt = function byteAt2(i) {
    return this.data.charCodeAt(this.zero + i);
  };
  StringReader2.prototype.lastIndexOfSignature = function lastIndexOfSignature2(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader2.prototype.readAndCheckSignature = function readAndCheckSignature2(sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return StringReader2;
}(DataReader);
var Uint8ArrayReader = function(ArrayReader2) {
  function Uint8ArrayReader2(data) {
    ArrayReader2.call(this, data);
  }
  if (ArrayReader2)
    Uint8ArrayReader2.__proto__ = ArrayReader2;
  Uint8ArrayReader2.prototype = Object.create(ArrayReader2 && ArrayReader2.prototype);
  Uint8ArrayReader2.prototype.constructor = Uint8ArrayReader2;
  Uint8ArrayReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    if (size === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return Uint8ArrayReader2;
}(ArrayReader);
function readerFor(data) {
  var type = getTypeOf(data);
  checkSupport(type);
  if (type === "string" && !support.uint8array) {
    return new StringReader(data);
  }
  if (support.uint8array) {
    return new Uint8ArrayReader(transformTo("uint8array", data));
  }
  return new ArrayReader(transformTo("array", data));
}
var MADE_BY_DOS = 0;
var MADE_BY_UNIX = 3;
var findCompression = function(compressionMethod) {
  for (var method in compressions) {
    if (!compressions.hasOwnProperty(method)) {
      continue;
    }
    if (compressions[method].magic === compressionMethod) {
      return compressions[method];
    }
  }
  return null;
};
var ZipEntry = function ZipEntry2(options, loadOptions) {
  this.options = options;
  this.loadOptions = loadOptions;
};
ZipEntry.prototype.isEncrypted = function isEncrypted() {
  return (this.bitFlag & 1) === 1;
};
ZipEntry.prototype.useUTF8 = function useUTF8() {
  return (this.bitFlag & 2048) === 2048;
};
ZipEntry.prototype.readLocalPart = function readLocalPart(reader) {
  var compression2, localExtraFieldsLength;
  reader.skip(22);
  this.fileNameLength = reader.readInt(2);
  localExtraFieldsLength = reader.readInt(2);
  this.fileName = reader.readData(this.fileNameLength);
  reader.skip(localExtraFieldsLength);
  if (this.compressedSize === -1 || this.uncompressedSize === -1) {
    throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
  }
  compression2 = findCompression(this.compressionMethod);
  if (compression2 === null) {
    throw new Error("Corrupted zip : compression " + pretty(this.compressionMethod) + " unknown (inner file : " + transformTo("string", this.fileName) + ")");
  }
  this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression2, reader.readData(this.compressedSize));
};
ZipEntry.prototype.readCentralPart = function readCentralPart(reader) {
  this.versionMadeBy = reader.readInt(2);
  reader.skip(2);
  this.bitFlag = reader.readInt(2);
  this.compressionMethod = reader.readString(2);
  this.date = reader.readDate();
  this.crc32 = reader.readInt(4);
  this.compressedSize = reader.readInt(4);
  this.uncompressedSize = reader.readInt(4);
  var fileNameLength = reader.readInt(2);
  this.extraFieldsLength = reader.readInt(2);
  this.fileCommentLength = reader.readInt(2);
  this.diskNumberStart = reader.readInt(2);
  this.internalFileAttributes = reader.readInt(2);
  this.externalFileAttributes = reader.readInt(4);
  this.localHeaderOffset = reader.readInt(4);
  if (this.isEncrypted()) {
    throw new Error("Encrypted zip are not supported");
  }
  reader.skip(fileNameLength);
  this.readExtraFields(reader);
  this.parseZIP64ExtraField(reader);
  this.fileComment = reader.readData(this.fileCommentLength);
};
ZipEntry.prototype.processAttributes = function processAttributes() {
  this.unixPermissions = null;
  this.dosPermissions = null;
  var madeBy = this.versionMadeBy >> 8;
  this.dir = this.externalFileAttributes & 16 ? true : false;
  if (madeBy === MADE_BY_DOS) {
    this.dosPermissions = this.externalFileAttributes & 63;
  }
  if (madeBy === MADE_BY_UNIX) {
    this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
  }
  if (!this.dir && this.fileNameStr.slice(-1) === "/") {
    this.dir = true;
  }
};
ZipEntry.prototype.parseZIP64ExtraField = function parseZIP64ExtraField(reader) {
  if (!this.extraFields[1]) {
    return;
  }
  var extraReader = readerFor(this.extraFields[1].value);
  if (this.uncompressedSize === MAX_VALUE_32BITS) {
    this.uncompressedSize = extraReader.readInt(8);
  }
  if (this.compressedSize === MAX_VALUE_32BITS) {
    this.compressedSize = extraReader.readInt(8);
  }
  if (this.localHeaderOffset === MAX_VALUE_32BITS) {
    this.localHeaderOffset = extraReader.readInt(8);
  }
  if (this.diskNumberStart === MAX_VALUE_32BITS) {
    this.diskNumberStart = extraReader.readInt(4);
  }
};
ZipEntry.prototype.readExtraFields = function readExtraFields(reader) {
  var end2 = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
  if (!this.extraFields) {
    this.extraFields = {};
  }
  while (reader.index < end2) {
    extraFieldId = reader.readInt(2);
    extraFieldLength = reader.readInt(2);
    extraFieldValue = reader.readData(extraFieldLength);
    this.extraFields[extraFieldId] = {
      id: extraFieldId,
      length: extraFieldLength,
      value: extraFieldValue
    };
  }
};
ZipEntry.prototype.handleUTF8 = function handleUTF8() {
  var decodeParamType = support.uint8array ? "uint8array" : "array";
  if (this.useUTF8()) {
    this.fileNameStr = utf8decode(this.fileName);
    this.fileCommentStr = utf8decode(this.fileComment);
  } else {
    var upath = this.findExtraFieldUnicodePath();
    if (upath !== null) {
      this.fileNameStr = upath;
    } else {
      var fileNameByteArray = transformTo(decodeParamType, this.fileName);
      this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
    }
    var ucomment = this.findExtraFieldUnicodeComment();
    if (ucomment !== null) {
      this.fileCommentStr = ucomment;
    } else {
      var commentByteArray = transformTo(decodeParamType, this.fileComment);
      this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
    }
  }
};
ZipEntry.prototype.findExtraFieldUnicodePath = function findExtraFieldUnicodePath() {
  var upathField = this.extraFields[28789];
  if (upathField) {
    var extraReader = readerFor(upathField.value);
    if (extraReader.readInt(1) !== 1) {
      return null;
    }
    if (crc32wrapper(this.fileName) !== extraReader.readInt(4)) {
      return null;
    }
    return utf8decode(extraReader.readData(upathField.length - 5));
  }
  return null;
};
ZipEntry.prototype.findExtraFieldUnicodeComment = function findExtraFieldUnicodeComment() {
  var ucommentField = this.extraFields[25461];
  if (ucommentField) {
    var extraReader = readerFor(ucommentField.value);
    if (extraReader.readInt(1) !== 1) {
      return null;
    }
    if (crc32wrapper(this.fileComment) !== extraReader.readInt(4)) {
      return null;
    }
    return utf8decode(extraReader.readData(ucommentField.length - 5));
  }
  return null;
};
var ZipEntries = function ZipEntries2(loadOptions) {
  this.files = [];
  this.loadOptions = loadOptions;
};
ZipEntries.prototype.checkSignature = function checkSignature(expectedSignature) {
  if (!this.reader.readAndCheckSignature(expectedSignature)) {
    this.reader.index -= 4;
    var signature = this.reader.readString(4);
    throw new Error("Corrupted zip or bug: unexpected signature (" + pretty(signature) + ", expected " + pretty(expectedSignature) + ")");
  }
};
ZipEntries.prototype.isSignature = function isSignature(askedIndex, expectedSignature) {
  var currentIndex = this.reader.index;
  this.reader.setIndex(askedIndex);
  var signature = this.reader.readString(4);
  var result = signature === expectedSignature;
  this.reader.setIndex(currentIndex);
  return result;
};
ZipEntries.prototype.readBlockEndOfCentral = function readBlockEndOfCentral() {
  this.diskNumber = this.reader.readInt(2);
  this.diskWithCentralDirStart = this.reader.readInt(2);
  this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
  this.centralDirRecords = this.reader.readInt(2);
  this.centralDirSize = this.reader.readInt(4);
  this.centralDirOffset = this.reader.readInt(4);
  this.zipCommentLength = this.reader.readInt(2);
  var zipComment = this.reader.readData(this.zipCommentLength);
  var decodeParamType = support.uint8array ? "uint8array" : "array";
  var decodeContent = transformTo(decodeParamType, zipComment);
  this.zipComment = this.loadOptions.decodeFileName(decodeContent);
};
ZipEntries.prototype.readBlockZip64EndOfCentral = function readBlockZip64EndOfCentral() {
  this.zip64EndOfCentralSize = this.reader.readInt(8);
  this.reader.skip(4);
  this.diskNumber = this.reader.readInt(4);
  this.diskWithCentralDirStart = this.reader.readInt(4);
  this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
  this.centralDirRecords = this.reader.readInt(8);
  this.centralDirSize = this.reader.readInt(8);
  this.centralDirOffset = this.reader.readInt(8);
  this.zip64ExtensibleData = {};
  var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
  while (index < extraDataSize) {
    extraFieldId = this.reader.readInt(2);
    extraFieldLength = this.reader.readInt(4);
    extraFieldValue = this.reader.readData(extraFieldLength);
    this.zip64ExtensibleData[extraFieldId] = {
      id: extraFieldId,
      length: extraFieldLength,
      value: extraFieldValue
    };
  }
};
ZipEntries.prototype.readBlockZip64EndOfCentralLocator = function readBlockZip64EndOfCentralLocator() {
  this.diskWithZip64CentralDirStart = this.reader.readInt(4);
  this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
  this.disksCount = this.reader.readInt(4);
  if (this.disksCount > 1) {
    throw new Error("Multi-volumes zip are not supported");
  }
};
ZipEntries.prototype.readLocalFiles = function readLocalFiles() {
  var i, file2;
  for (i = 0; i < this.files.length; i++) {
    file2 = this.files[i];
    this.reader.setIndex(file2.localHeaderOffset);
    this.checkSignature(LOCAL_FILE_HEADER);
    file2.readLocalPart(this.reader);
    file2.handleUTF8();
    file2.processAttributes();
  }
};
ZipEntries.prototype.readCentralDir = function readCentralDir() {
  var file2;
  this.reader.setIndex(this.centralDirOffset);
  while (this.reader.readAndCheckSignature(CENTRAL_FILE_HEADER)) {
    file2 = new ZipEntry({
      zip64: this.zip64
    }, this.loadOptions);
    file2.readCentralPart(this.reader);
    this.files.push(file2);
  }
  if (this.centralDirRecords !== this.files.length) {
    if (this.centralDirRecords !== 0 && this.files.length === 0) {
      throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
    }
  }
};
ZipEntries.prototype.readEndOfCentral = function readEndOfCentral() {
  var offset = this.reader.lastIndexOfSignature(CENTRAL_DIRECTORY_END);
  if (offset < 0) {
    var isGarbage = !this.isSignature(0, LOCAL_FILE_HEADER);
    if (isGarbage) {
      throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
    } else {
      throw new Error("Corrupted zip: can't find end of central directory");
    }
  }
  this.reader.setIndex(offset);
  var endOfCentralDirOffset = offset;
  this.checkSignature(CENTRAL_DIRECTORY_END);
  this.readBlockEndOfCentral();
  if (this.diskNumber === MAX_VALUE_16BITS || this.diskWithCentralDirStart === MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === MAX_VALUE_16BITS || this.centralDirRecords === MAX_VALUE_16BITS || this.centralDirSize === MAX_VALUE_32BITS || this.centralDirOffset === MAX_VALUE_32BITS) {
    this.zip64 = true;
    offset = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);
    if (offset < 0) {
      throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
    }
    this.reader.setIndex(offset);
    this.checkSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);
    this.readBlockZip64EndOfCentralLocator();
    if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, ZIP64_CENTRAL_DIRECTORY_END)) {
      this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_END);
      if (this.relativeOffsetEndOfZip64CentralDir < 0) {
        throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
      }
    }
    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
    this.checkSignature(ZIP64_CENTRAL_DIRECTORY_END);
    this.readBlockZip64EndOfCentral();
  }
  var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
  if (this.zip64) {
    expectedEndOfCentralDirOffset += 20;
    expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
  }
  var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
  if (extraBytes > 0) {
    if (this.isSignature(endOfCentralDirOffset, CENTRAL_FILE_HEADER))
      ;
    else {
      this.reader.zero = extraBytes;
    }
  } else if (extraBytes < 0) {
    throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
  }
};
ZipEntries.prototype.prepareReader = function prepareReader(data) {
  this.reader = readerFor(data);
};
ZipEntries.prototype.load = function load(data) {
  this.prepareReader(data);
  this.readEndOfCentral();
  this.readCentralDir();
  this.readLocalFiles();
};
function checkEntryCRC32(zipEntry) {
  return new external.Promise(function(resolve, reject) {
    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function(e) {
      reject(e);
    }).on("end", function() {
      if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
        reject(new Error("Corrupted zip : CRC32 mismatch"));
      } else {
        resolve();
      }
    }).resume();
  });
}
function load2(data, options) {
  var zip = this;
  options = extend(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8decode
  });
  return prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data2);
    return zipEntries;
  }).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
    if (options.checkCRC32) {
      for (var i = 0; i < files.length; i++) {
        promises.push(checkEntryCRC32(files[i]));
      }
    }
    return external.Promise.all(promises);
  }).then(function addFiles(results) {
    var zipEntries = results.shift();
    var files = zipEntries.files;
    for (var i = 0; i < files.length; i++) {
      var input = files[i];
      zip.file(input.fileNameStr, input.decompressed, {
        binary: true,
        optimizedBinaryString: true,
        date: input.date,
        dir: input.dir,
        comment: input.fileCommentStr.length ? input.fileCommentStr : null,
        unixPermissions: input.unixPermissions,
        dosPermissions: input.dosPermissions,
        createFolders: options.createFolders
      });
    }
    if (zipEntries.zipComment.length) {
      zip.comment = zipEntries.zipComment;
    }
    return zip;
  });
}
var fileAdd = function(name, data, originalOptions) {
  var dataType = getTypeOf(data), parent;
  var o = extend(originalOptions || {}, defaults);
  o.date = o.date || /* @__PURE__ */ new Date();
  if (o.compression !== null) {
    o.compression = o.compression.toUpperCase();
  }
  if (typeof o.unixPermissions === "string") {
    o.unixPermissions = parseInt(o.unixPermissions, 8);
  }
  if (o.unixPermissions && o.unixPermissions & 16384) {
    o.dir = true;
  }
  if (o.dosPermissions && o.dosPermissions & 16) {
    o.dir = true;
  }
  if (o.dir) {
    name = forceTrailingSlash(name);
  }
  if (o.createFolders && (parent = parentFolder(name))) {
    folderAdd.call(this, parent, true);
  }
  var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
  if (!originalOptions || typeof originalOptions.binary === "undefined") {
    o.binary = !isUnicodeString;
  }
  var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
  if (isCompressedEmpty || o.dir || !data || data.length === 0) {
    o.base64 = false;
    o.binary = true;
    data = "";
    o.compression = "STORE";
    dataType = "string";
  }
  var zipObjectContent = null;
  if (data instanceof CompressedObject || data instanceof GenericWorker) {
    zipObjectContent = data;
  } else {
    zipObjectContent = prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
  }
  var object = new ZipObject(name, zipObjectContent, o);
  this.files[name] = object;
};
var parentFolder = function(path) {
  if (path.slice(-1) === "/") {
    path = path.substring(0, path.length - 1);
  }
  var lastSlash = path.lastIndexOf("/");
  return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};
var forceTrailingSlash = function(path) {
  if (path.slice(-1) !== "/") {
    path += "/";
  }
  return path;
};
var folderAdd = function(name, createFolders$1) {
  createFolders$1 = typeof createFolders$1 !== "undefined" ? createFolders$1 : createFolders;
  name = forceTrailingSlash(name);
  if (!this.files[name]) {
    fileAdd.call(this, name, null, {
      dir: true,
      createFolders: createFolders$1
    });
  }
  return this.files[name];
};
function isRegExp(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
}
var JSZip = function JSZip2() {
  if (arguments.length) {
    throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
  }
  this.files = /* @__PURE__ */ Object.create(null);
  this.comment = null;
  this.root = "";
  this.clone = function() {
    var newObj = new JSZip2();
    for (var i in this) {
      if (typeof this[i] !== "function") {
        newObj[i] = this[i];
      }
    }
    return newObj;
  };
};
var staticAccessors = { support: { configurable: true }, defaults: { configurable: true }, version: { configurable: true }, external: { configurable: true } };
JSZip.prototype.load = function load3() {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};
JSZip.prototype.forEach = function forEach(cb) {
  var filename, relativePath, file2;
  for (filename in this.files) {
    file2 = this.files[filename];
    relativePath = filename.slice(this.root.length, filename.length);
    if (relativePath && filename.slice(0, this.root.length) === this.root) {
      cb(relativePath, file2);
    }
  }
};
JSZip.prototype.filter = function filter(search) {
  var result = [];
  this.forEach(function(relativePath, entry) {
    if (search(relativePath, entry)) {
      result.push(entry);
    }
  });
  return result;
};
JSZip.prototype.file = function file(name, data, o) {
  if (arguments.length === 1) {
    if (isRegExp(name)) {
      var regexp = name;
      return this.filter(function(relativePath, file2) {
        return !file2.dir && regexp.test(relativePath);
      });
    } else {
      var obj = this.files[this.root + name];
      if (obj && !obj.dir) {
        return obj;
      } else {
        return null;
      }
    }
  } else {
    name = this.root + name;
    fileAdd.call(this, name, data, o);
  }
  return this;
};
JSZip.prototype.folder = function folder(arg) {
  if (!arg) {
    return this;
  }
  if (isRegExp(arg)) {
    return this.filter(function(relativePath, file2) {
      return file2.dir && arg.test(relativePath);
    });
  }
  var name = this.root + arg;
  var newFolder = folderAdd.call(this, name);
  var ret = this.clone();
  ret.root = newFolder.name;
  return ret;
};
JSZip.prototype.remove = function remove(name) {
  name = this.root + name;
  var file2 = this.files[name];
  if (!file2) {
    if (name.slice(-1) !== "/") {
      name += "/";
    }
    file2 = this.files[name];
  }
  if (file2 && !file2.dir) {
    delete this.files[name];
  } else {
    var kids = this.filter(function(relativePath, file3) {
      return file3.name.slice(0, name.length) === name;
    });
    for (var i = 0; i < kids.length; i++) {
      delete this.files[kids[i].name];
    }
  }
  return this;
};
JSZip.prototype.generate = function generate(options) {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};
JSZip.prototype.generateInternalStream = function generateInternalStream(options) {
  var worker, opts = {};
  try {
    opts = extend(options || {}, {
      streamFiles: false,
      compression: "STORE",
      compressionOptions: null,
      type: "",
      platform: "DOS",
      comment: null,
      mimeType: "application/zip",
      encodeFileName: utf8encode
    });
    opts.type = opts.type.toLowerCase();
    opts.compression = opts.compression.toUpperCase();
    if (opts.type === "binarystring") {
      opts.type = "string";
    }
    if (!opts.type) {
      throw new Error("No output type specified.");
    }
    checkSupport(opts.type);
    if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
      opts.platform = "UNIX";
    }
    if (opts.platform === "win32") {
      opts.platform = "DOS";
    }
    var comment2 = opts.comment || this.comment || "";
    worker = generateWorker(this, opts, comment2);
  } catch (e) {
    worker = new GenericWorker("error");
    worker.error(e);
  }
  return new StreamHelper(worker, opts.type || "string", opts.mimeType);
};
JSZip.prototype.generateAsync = function generateAsync(options, onUpdate) {
  return this.generateInternalStream(options).accumulate(onUpdate);
};
JSZip.prototype.loadAsync = function loadAsync(data, options) {
  return load2.apply(this, [data, options]);
};
JSZip.loadAsync = function loadAsync2(content, options) {
  return new JSZip().loadAsync(content, options);
};
staticAccessors.support.get = function() {
  return support;
};
staticAccessors.defaults.get = function() {
  return defaults;
};
staticAccessors.version.get = function() {
  return "3.2.2-esm";
};
staticAccessors.external.get = function() {
  return external;
};
Object.defineProperties(JSZip, staticAccessors);

// node_modules/@progress/kendo-ooxml/dist/es/utils/create-zip.js
function createZip() {
  return new JSZip();
}

// node_modules/@progress/kendo-ooxml/dist/es/utils/time.js
function dateToJulianDays(y, m, d) {
  return (1461 * (y + 4800 + ((m - 13) / 12 | 0)) / 4 | 0) + (367 * (m - 1 - 12 * ((m - 13) / 12 | 0)) / 12 | 0) - (3 * ((y + 4900 + ((m - 13) / 12 | 0)) / 100 | 0) / 4 | 0) + d - 32075;
}
var BASE_DATE = dateToJulianDays(1900, 0, -1);
function packDate(year, month, date2) {
  return dateToJulianDays(year, month, date2) - BASE_DATE;
}
function packTime(hh, mm, ss, ms) {
  return (hh + (mm + (ss + ms / 1e3) / 60) / 60) / 24;
}
function dateToSerial(date2) {
  var time = packTime(
    date2.getHours(),
    date2.getMinutes(),
    date2.getSeconds(),
    date2.getMilliseconds()
  );
  var serial = packDate(
    date2.getFullYear(),
    date2.getMonth(),
    date2.getDate()
  );
  return serial < 0 ? serial - 1 + time : serial + time;
}

// node_modules/@progress/kendo-ooxml/dist/es/ooxml.js
var MIME_TYPE = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
var DATA_URL_PREFIX = "data:" + MIME_TYPE + ";base64,";
var DATA_URL_OPTIONS = { compression: "DEFLATE", type: "base64" };
var BLOB_OPTIONS = { compression: "DEFLATE", type: "blob" };
var ARRAYBUFFER_OPTIONS = { compression: "DEFLATE", type: "arraybuffer" };
function toDataURI(content) {
  return DATA_URL_PREFIX + content;
}
function indexOf(thing, array) {
  return array.indexOf(thing);
}
var parseJSON = JSON.parse.bind(JSON);
function ESC(val) {
  return String(val).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\'/g, "&#39;");
}
function repeat(count, func) {
  var str = "";
  for (var i = 0; i < count; ++i) {
    str += func(i);
  }
  return str;
}
function foreach(arr, func) {
  var str = "";
  if (arr != null) {
    if (Array.isArray(arr)) {
      for (var i = 0; i < arr.length; ++i) {
        str += func(arr[i], i);
      }
    } else if (typeof arr == "object") {
      Object.keys(arr).forEach(function(key, i2) {
        str += func(arr[key], key, i2);
      });
    }
  }
  return str;
}
var XMLHEAD = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r';
var RELS = XMLHEAD + '\n            <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n               <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>\n               <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>\n               <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>\n            </Relationships>';
var CORE = function(ref2) {
  var creator = ref2.creator;
  var lastModifiedBy = ref2.lastModifiedBy;
  var created = ref2.created;
  var modified = ref2.modified;
  return XMLHEAD + '\n <cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"\n   xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/"\n   xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n   <dc:creator>' + ESC(creator) + "</dc:creator>\n   <cp:lastModifiedBy>" + ESC(lastModifiedBy) + '</cp:lastModifiedBy>\n   <dcterms:created xsi:type="dcterms:W3CDTF">' + ESC(created) + '</dcterms:created>\n   <dcterms:modified xsi:type="dcterms:W3CDTF">' + ESC(modified) + "</dcterms:modified>\n</cp:coreProperties>";
};
var APP = function(ref2) {
  var sheets = ref2.sheets;
  return XMLHEAD + '\n<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">\n  <Application>Microsoft Excel</Application>\n  <DocSecurity>0</DocSecurity>\n  <ScaleCrop>false</ScaleCrop>\n  <HeadingPairs>\n    <vt:vector size="2" baseType="variant">\n      <vt:variant>\n        <vt:lpstr>Worksheets</vt:lpstr>\n      </vt:variant>\n      <vt:variant>\n        <vt:i4>' + sheets.length + '</vt:i4>\n      </vt:variant>\n    </vt:vector>\n  </HeadingPairs>\n  <TitlesOfParts>\n    <vt:vector size="' + sheets.length + '" baseType="lpstr">' + foreach(
    sheets,
    function(sheet, i) {
      return sheet.options.title ? "<vt:lpstr>" + ESC(sheet.options.title) + "</vt:lpstr>" : "<vt:lpstr>Sheet" + (i + 1) + "</vt:lpstr>";
    }
  ) + "</vt:vector>\n  </TitlesOfParts>\n  <LinksUpToDate>false</LinksUpToDate>\n  <SharedDoc>false</SharedDoc>\n  <HyperlinksChanged>false</HyperlinksChanged>\n  <AppVersion>14.0300</AppVersion>\n</Properties>";
};
var CONTENT_TYPES = function(ref2) {
  var sheetCount = ref2.sheetCount;
  var commentFiles = ref2.commentFiles;
  var drawingFiles = ref2.drawingFiles;
  return XMLHEAD + '\n<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">\n  <Default Extension="png" ContentType="image/png"/>\n  <Default Extension="gif" ContentType="image/gif"/>\n  <Default Extension="jpg" ContentType="image/jpeg"/>\n  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />\n  <Default Extension="xml" ContentType="application/xml" />\n  <Default Extension="vml" ContentType="application/vnd.openxmlformats-officedocument.vmlDrawing"/>\n  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" />\n  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>\n  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>\n  ' + repeat(sheetCount, function(idx) {
    return '<Override PartName="/xl/worksheets/sheet' + (idx + 1) + '.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />';
  }) + "\n  " + foreach(commentFiles, function(filename) {
    return '<Override PartName="/xl/' + filename + '" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"/>';
  }) + "\n  " + foreach(drawingFiles, function(filename) {
    return '<Override PartName="/xl/drawings/' + filename + '" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/>';
  }) + '\n  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml" />\n  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" />\n</Types>';
};
var WORKBOOK = function(ref2) {
  var sheets = ref2.sheets;
  var filterNames = ref2.filterNames;
  var userNames = ref2.userNames;
  return XMLHEAD + '\n<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">\n  <fileVersion appName="xl" lastEdited="5" lowestEdited="5" rupBuild="9303" />\n  <workbookPr defaultThemeVersion="124226" />\n  <bookViews>\n    <workbookView xWindow="240" yWindow="45" windowWidth="18195" windowHeight="7995" />\n  </bookViews>\n  <sheets>\n  ' + foreach(sheets, function(ref3, i) {
    var options = ref3.options;
    var name = options.name || options.title || "Sheet" + (i + 1);
    var state = options.state || "visible";
    return '<sheet name="' + ESC(name) + '" state="' + state + '" sheetId="' + (i + 1) + '" r:id="rId' + (i + 1) + '" />';
  }) + "\n  </sheets>\n  " + (filterNames.length || userNames.length ? "\n    <definedNames>\n      " + foreach(filterNames, function(f) {
    return '\n         <definedName name="_xlnm._FilterDatabase" hidden="1" localSheetId="' + f.localSheetId + '">' + ESC(quoteSheet(f.name)) + "!" + ESC(f.from) + ":" + ESC(f.to) + "</definedName>";
  }) + "\n      " + foreach(userNames, function(f) {
    return '\n         <definedName name="' + f.name + '" hidden="' + (f.hidden ? 1 : 0) + '" ' + (f.localSheetId != null ? 'localSheetId="' + f.localSheetId + '"' : "") + ">" + ESC(f.value) + "</definedName>";
  }) + "\n    </definedNames>" : "") + '\n  <calcPr fullCalcOnLoad="1" calcId="145621" />\n</workbook>';
};
var WORKSHEET = function(ref$1) {
  var frozenColumns = ref$1.frozenColumns;
  var frozenRows = ref$1.frozenRows;
  var columns = ref$1.columns;
  var defaults2 = ref$1.defaults;
  var data = ref$1.data;
  var index = ref$1.index;
  var mergeCells = ref$1.mergeCells;
  var autoFilter = ref$1.autoFilter;
  var filter2 = ref$1.filter;
  var showGridLines = ref$1.showGridLines;
  var hyperlinks = ref$1.hyperlinks;
  var validations = ref$1.validations;
  var defaultCellStyleId = ref$1.defaultCellStyleId;
  var rtl = ref$1.rtl;
  var legacyDrawing2 = ref$1.legacyDrawing;
  var drawing = ref$1.drawing;
  var lastRow = ref$1.lastRow;
  var lastCol = ref$1.lastCol;
  var hasDisabledCells = ref$1.hasDisabledCells;
  return XMLHEAD + '\n<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" mc:Ignorable="x14ac">\n   ' + (lastRow && lastCol ? '<dimension ref="A1:' + ref(lastRow - 1, lastCol - 1) + '" />' : "") + "\n\n   <sheetViews>\n     <sheetView " + (rtl ? 'rightToLeft="1"' : "") + " " + (index === 0 ? 'tabSelected="1"' : "") + ' workbookViewId="0" ' + (showGridLines === false ? 'showGridLines="0"' : "") + ">\n     " + (frozenRows || frozenColumns ? '\n       <pane state="frozen"\n         ' + (frozenColumns ? 'xSplit="' + frozenColumns + '"' : "") + "\n         " + (frozenRows ? 'ySplit="' + frozenRows + '"' : "") + '\n         topLeftCell="' + (String.fromCharCode(65 + (frozenColumns || 0)) + ((frozenRows || 0) + 1)) + '"\n       />' : "") + '\n     </sheetView>\n   </sheetViews>\n\n   <sheetFormatPr x14ac:dyDescent="0.25" ' + (!defaults2.skipCustomHeight ? 'customHeight="1"' : "") + ' defaultRowHeight="' + (defaults2.rowHeight ? defaults2.rowHeight * 0.75 : 15) + '"\n     ' + (defaults2.columnWidth ? 'defaultColWidth="' + toWidth(defaults2.columnWidth) + '"' : "") + " />\n\n   " + (defaultCellStyleId != null || columns && columns.length > 0 ? "\n     <cols>\n       " + (!columns || !columns.length ? '\n         <col min="1" max="16384" style="' + defaultCellStyleId + '"\n              ' + (defaults2.columnWidth ? 'width="' + toWidth(defaults2.columnWidth) + '"' : "") + " /> " : "") + "\n       " + foreach(columns, function(column, ci) {
    var columnIndex = typeof column.index === "number" ? column.index + 1 : ci + 1;
    if (column.width === 0) {
      return "<col " + (defaultCellStyleId != null ? 'style="' + defaultCellStyleId + '"' : "") + '\n                        min="' + columnIndex + '" max="' + columnIndex + '" hidden="1" customWidth="1" />';
    }
    return "<col " + (defaultCellStyleId != null ? 'style="' + defaultCellStyleId + '"' : "") + '\n                      min="' + columnIndex + '" max="' + columnIndex + '" customWidth="1"\n                      ' + (column.autoWidth ? 'width="' + (column.width * 7 + 5) / 7 * 256 / 256 + '" bestFit="1"' : 'width="' + toWidth(column.width) + '"') + " />";
  }) + "\n     </cols>" : "") + "\n\n   <sheetData>\n     " + foreach(data, function(row, ri) {
    var rowIndex = typeof row.index === "number" ? row.index + 1 : ri + 1;
    return '\n         <row r="' + rowIndex + '" x14ac:dyDescent="0.25"\n              ' + (row.level ? 'outlineLevel="' + row.level + '"' : "") + "\n              " + (row.height === 0 ? 'hidden="1"' : row.height ? 'ht="' + toHeight(row.height) + '" customHeight="1"' : "") + ">\n           " + foreach(row.data, function(cell) {
      return '\n             <c r="' + cell.ref + '" ' + (cell.style ? 's="' + cell.style + '"' : "") + " " + (cell.type ? 't="' + cell.type + '"' : "") + ">\n               " + (cell.formula != null ? writeFormula(cell.formula) : "") + "\n               " + (cell.value != null ? "<v>" + ESC(cell.value) + "</v>" : "") + "\n             </c>";
    }) + "\n         </row>\n       ";
  }) + "\n   </sheetData>\n\n   " + (hasDisabledCells ? '<sheetProtection sheet="1" objects="1" scenarios="1"/>' : "") + "\n\n   " + (autoFilter ? '<autoFilter ref="' + autoFilter.from + ":" + autoFilter.to + '"/>' : filter2 ? spreadsheetFilters(filter2) : "") + "\n\n   " + (mergeCells.length ? '\n     <mergeCells count="' + mergeCells.length + '">\n       ' + foreach(mergeCells, function(ref2) {
    return '<mergeCell ref="' + ref2 + '"/>';
  }) + "\n     </mergeCells>" : "") + "\n\n   " + (validations.length ? "\n     <dataValidations>\n       " + foreach(validations, function(val) {
    return '\n         <dataValidation sqref="' + val.sqref.join(" ") + '"\n                         showErrorMessage="' + val.showErrorMessage + '"\n                         type="' + ESC(val.type) + '"\n                         ' + (val.type !== "list" ? 'operator="' + ESC(val.operator) + '"' : "") + '\n                         allowBlank="' + val.allowBlank + '"\n                         showDropDown="' + val.showDropDown + '"\n                         ' + (val.error ? 'error="' + ESC(val.error) + '"' : "") + "\n                         " + (val.errorTitle ? 'errorTitle="' + ESC(val.errorTitle) + '"' : "") + ">\n           " + (val.formula1 ? "<formula1>" + ESC(val.formula1) + "</formula1>" : "") + "\n           " + (val.formula2 ? "<formula2>" + ESC(val.formula2) + "</formula2>" : "") + "\n         </dataValidation>";
  }) + "\n     </dataValidations>" : "") + "\n\n   " + (hyperlinks.length ? "\n     <hyperlinks>\n       " + foreach(hyperlinks, function(link) {
    return '\n         <hyperlink ref="' + link.ref + '" r:id="' + link.rId + '"/>';
  }) + "\n     </hyperlinks>" : "") + '\n\n   <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />\n   ' + (drawing ? '<drawing r:id="' + drawing + '"/>' : "") + "\n   " + (legacyDrawing2 ? '<legacyDrawing r:id="' + legacyDrawing2 + '"/>' : "") + "\n</worksheet>";
};
var WORKBOOK_RELS = function(ref2) {
  var count = ref2.count;
  return XMLHEAD + '\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n  ' + repeat(count, function(idx) {
    return '\n    <Relationship Id="rId' + (idx + 1) + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet' + (idx + 1) + '.xml" />';
  }) + '\n  <Relationship Id="rId' + (count + 1) + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml" />\n  <Relationship Id="rId' + (count + 2) + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />\n</Relationships>';
};
var WORKSHEET_RELS = function(ref2) {
  var hyperlinks = ref2.hyperlinks;
  var comments = ref2.comments;
  var sheetIndex = ref2.sheetIndex;
  var drawings = ref2.drawings;
  return XMLHEAD + '\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n  ' + foreach(hyperlinks, function(link) {
    return '\n    <Relationship Id="' + link.rId + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink" Target="' + ESC(link.target) + '" TargetMode="External" />';
  }) + "\n  " + (!comments.length ? "" : '\n    <Relationship Id="comment' + sheetIndex + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments" Target="../comments' + sheetIndex + '.xml"/>\n    <Relationship Id="vml' + sheetIndex + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing" Target="../drawings/vmlDrawing' + sheetIndex + '.vml"/>') + "\n  " + (!drawings.length ? "" : '\n    <Relationship Id="drw' + sheetIndex + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing" Target="../drawings/drawing' + sheetIndex + '.xml"/>') + "\n</Relationships>";
};
var COMMENTS_XML = function(ref2) {
  var comments = ref2.comments;
  return XMLHEAD + '\n<comments xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">\n  <authors>\n    <author></author>\n  </authors>\n  <commentList>\n    ' + foreach(comments, function(comment2) {
    return '\n      <comment ref="' + comment2.ref + '" authorId="0">\n        <text>\n          <r>\n            <rPr>\n              <sz val="8"/>\n              <color indexed="81"/>\n              <rFont val="Tahoma"/>\n              <charset val="1"/>\n            </rPr>\n            <t>' + ESC(comment2.text) + "</t>\n          </r>\n        </text>\n      </comment>";
  }) + "\n  </commentList>\n</comments>";
};
var LEGACY_DRAWING = function(ref2) {
  var comments = ref2.comments;
  return '<xml xmlns:v="urn:schemas-microsoft-com:vml"\n     xmlns:o="urn:schemas-microsoft-com:office:office"\n     xmlns:x="urn:schemas-microsoft-com:office:excel">\n  <v:shapetype coordsize="21600,21600" id="_x0000_t202" path="m,l,21600r21600,l21600,xe">\n    <v:stroke joinstyle="miter"/>\n    <v:path gradientshapeok="t" o:connecttype="rect"/>\n  </v:shapetype>\n  ' + foreach(comments, function(comment2) {
    return '\n    <v:shape type="#_x0000_t202" style="visibility: hidden" fillcolor="#ffffe1" o:insetmode="auto">\n      <v:shadow on="t" color="black" obscured="t"/>\n      <x:ClientData ObjectType="Note">\n        <x:MoveWithCells/>\n        <x:SizeWithCells/>\n        <x:Anchor>' + comment2.anchor + "</x:Anchor>\n        <x:AutoFill>False</x:AutoFill>\n        <x:Row>" + comment2.row + "</x:Row>\n        <x:Column>" + comment2.col + "</x:Column>\n      </x:ClientData>\n    </v:shape>";
  }) + "\n</xml>";
};
var DRAWINGS_XML = function(drawings) {
  return XMLHEAD + '\n<xdr:wsDr xmlns:xdr="http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing"\n          xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"\n          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">\n  ' + foreach(drawings, function(drawing, index) {
    return '\n    <xdr:oneCellAnchor editAs="oneCell">\n      <xdr:from>\n        <xdr:col>' + drawing.col + "</xdr:col>\n        <xdr:colOff>" + drawing.colOffset + "</xdr:colOff>\n        <xdr:row>" + drawing.row + "</xdr:row>\n        <xdr:rowOff>" + drawing.rowOffset + '</xdr:rowOff>\n      </xdr:from>\n      <xdr:ext cx="' + drawing.width + '" cy="' + drawing.height + '" />\n      <xdr:pic>\n        <xdr:nvPicPr>\n          <xdr:cNvPr id="' + (index + 1) + '" name="Picture ' + (index + 1) + '"/>\n          <xdr:cNvPicPr/>\n        </xdr:nvPicPr>\n        <xdr:blipFill>\n          <a:blip r:embed="' + drawing.imageId + '"/>\n          <a:stretch>\n            <a:fillRect/>\n          </a:stretch>\n        </xdr:blipFill>\n        <xdr:spPr>\n          <a:prstGeom prst="rect">\n            <a:avLst/>\n          </a:prstGeom>\n        </xdr:spPr>\n      </xdr:pic>\n      <xdr:clientData/>\n    </xdr:oneCellAnchor>';
  }) + "\n</xdr:wsDr>";
};
var DRAWINGS_RELS_XML = function(rels) {
  return XMLHEAD + '\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n  ' + foreach(rels, function(rel) {
    return '\n    <Relationship Id="' + rel.rId + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="' + rel.target + '"/>';
  }) + "\n</Relationships>";
};
var SHARED_STRINGS = function(ref2) {
  var count = ref2.count;
  var uniqueCount = ref2.uniqueCount;
  var indexes = ref2.indexes;
  return XMLHEAD + '\n<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">\n  ' + foreach(Object.keys(indexes), function(index) {
    return '\n    <si><t xml:space="preserve">' + ESC(index.substring(1)) + "</t></si>";
  }) + "\n</sst>";
};
var STYLES = function(ref2) {
  var formats = ref2.formats;
  var fonts = ref2.fonts;
  var fills = ref2.fills;
  var borders = ref2.borders;
  var styles = ref2.styles;
  return XMLHEAD + '\n<styleSheet\n    xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"\n    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"\n    mc:Ignorable="x14ac"\n    xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">\n  <numFmts count="' + formats.length + '">\n  ' + foreach(formats, function(format, fi) {
    return '\n    <numFmt formatCode="' + ESC(format.format) + '" numFmtId="' + (165 + fi) + '" />';
  }) + '\n  </numFmts>\n  <fonts count="' + (fonts.length + 1) + '" x14ac:knownFonts="1">\n    <font>\n       <sz val="11" />\n       <color theme="1" />\n       <name val="Calibri" />\n       <family val="2" />\n       <scheme val="minor" />\n    </font>\n    ' + foreach(fonts, function(font) {
    return "\n    <font>\n      " + (font.bold ? "<b/>" : "") + "\n      " + (font.italic ? "<i/>" : "") + "\n      " + (font.underline ? "<u/>" : "") + '\n      <sz val="' + (font.fontSize || 11) + '" />\n      ' + (font.color ? '<color rgb="' + ESC(font.color) + '" />' : '<color theme="1" />') + "\n      " + (font.fontFamily ? '\n        <name val="' + ESC(font.fontFamily) + '" />\n        <family val="2" />\n      ' : '\n        <name val="Calibri" />\n        <family val="2" />\n        <scheme val="minor" />\n      ') + "\n    </font>";
  }) + '\n  </fonts>\n  <fills count="' + (fills.length + 2) + '">\n      <fill><patternFill patternType="none"/></fill>\n      <fill><patternFill patternType="gray125"/></fill>\n    ' + foreach(fills, function(fill) {
    return "\n      " + (fill.background ? '\n        <fill>\n          <patternFill patternType="solid">\n              <fgColor rgb="' + ESC(fill.background) + '"/>\n          </patternFill>\n        </fill>\n      ' : "");
  }) + '\n  </fills>\n  <borders count="' + (borders.length + 1) + '">\n    <border><left/><right/><top/><bottom/><diagonal/></border>\n    ' + foreach(borders, borderTemplate) + '\n  </borders>\n  <cellStyleXfs count="1">\n    <xf borderId="0" fillId="0" fontId="0" />\n  </cellStyleXfs>\n  <cellXfs count="' + (styles.length + 1) + '">\n    <xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" />\n    ' + foreach(styles, function(style) {
    return '\n      <xf xfId="0"\n          ' + (style.fontId ? 'fontId="' + style.fontId + '" applyFont="1"' : "") + "\n          " + (style.fillId ? 'fillId="' + style.fillId + '" applyFill="1"' : "") + "\n          " + (style.numFmtId ? 'numFmtId="' + style.numFmtId + '" applyNumberFormat="1"' : "") + "\n          " + (style.textAlign || style.verticalAlign || style.wrap ? 'applyAlignment="1"' : "") + "\n          " + (style.borderId ? 'borderId="' + style.borderId + '" applyBorder="1"' : "") + "\n          " + (style.disabled != null ? 'applyProtection="1"' : "") + ">\n        " + (style.textAlign || style.verticalAlign || style.wrap ? "\n        <alignment\n          " + (style.textAlign ? 'horizontal="' + ESC(style.textAlign) + '"' : "") + "\n          " + (style.verticalAlign ? 'vertical="' + ESC(style.verticalAlign) + '"' : "") + "\n          " + (style.indent ? 'indent="' + ESC(style.indent) + '"' : "") + "\n          " + (style.wrap ? 'wrapText="1"' : "") + " />\n        " : "") + "\n        " + (style.disabled != null ? '\n        <protection locked="' + (style.disabled ? 1 : 0) + '" />\n        ' : "") + "\n      </xf>\n    ";
  }) + '\n  </cellXfs>\n  <cellStyles count="1">\n    <cellStyle name="Normal" xfId="0" builtinId="0"/>\n  </cellStyles>\n  <dxfs count="0" />\n  <tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleMedium9" />\n</styleSheet>';
};
function writeFormula(formula) {
  if (typeof formula == "string") {
    return "<f>" + ESC(formula) + "</f>";
  }
  return '<f t="array" ref="' + formula.ref + '">' + ESC(formula.src) + "</f>";
}
function numChar(colIndex) {
  var letter = Math.floor(colIndex / 26) - 1;
  return (letter >= 0 ? numChar(letter) : "") + String.fromCharCode(65 + colIndex % 26);
}
function ref(rowIndex, colIndex) {
  return numChar(colIndex) + (rowIndex + 1);
}
function $ref(rowIndex, colIndex) {
  return "$" + numChar(colIndex) + "$" + (rowIndex + 1);
}
function filterRowIndex(options) {
  var frozenRows = options.frozenRows || (options.freezePane || {}).rowSplit || 1;
  return frozenRows - 1;
}
function toWidth(px) {
  var maximumDigitWidth = 7;
  return px / maximumDigitWidth - Math.floor(128 / maximumDigitWidth) / 256;
}
function toHeight(px) {
  return px * 0.75;
}
function stripFunnyChars(value) {
  return String(value).replace(/[\x00-\x09\x0B\x0C\x0E-\x1F]/g, "").replace(/\r?\n/g, "\r\n");
}
var Worksheet = function Worksheet2(options, sharedStrings, styles, borders) {
  this.options = options;
  this._strings = sharedStrings;
  this._styles = styles;
  this._borders = borders;
  this._validations = {};
  this._comments = [];
  this._drawings = options.drawings || [];
  this._hyperlinks = (this.options.hyperlinks || []).map(
    function(link, i) {
      return Object.assign({}, link, { rId: "link" + i });
    }
  );
};
Worksheet.prototype.relsToXML = function relsToXML() {
  var hyperlinks = this._hyperlinks;
  var comments = this._comments;
  var drawings = this._drawings;
  if (hyperlinks.length || comments.length || drawings.length) {
    return WORKSHEET_RELS({
      hyperlinks,
      comments,
      sheetIndex: this.options.sheetIndex,
      drawings
    });
  }
};
Worksheet.prototype.toXML = function toXML(index) {
  var this$1 = this;
  var mergeCells = this.options.mergedCells || [];
  var rows = this.options.rows || [];
  var data = inflate(rows, mergeCells);
  this._readCells(data);
  var autoFilter = this.options.filter;
  var filter2;
  if (autoFilter && typeof autoFilter.from === "number" && typeof autoFilter.to === "number") {
    autoFilter = {
      from: ref(filterRowIndex(this.options), autoFilter.from),
      to: ref(filterRowIndex(this.options), autoFilter.to)
    };
  } else if (autoFilter && autoFilter.ref && autoFilter.columns) {
    filter2 = autoFilter;
    autoFilter = null;
  }
  var validations = [];
  for (var i in this$1._validations) {
    if (Object.prototype.hasOwnProperty.call(this$1._validations, i)) {
      validations.push(this$1._validations[i]);
    }
  }
  var defaultCellStyleId = null;
  var defaultCellStyle = this.options.defaultCellStyle;
  if (this._hasDisabledCells) {
    if (!defaultCellStyle) {
      defaultCellStyle = { disabled: false };
    } else {
      defaultCellStyle = Object.assign({ disabled: false }, defaultCellStyle);
    }
  }
  if (defaultCellStyle) {
    defaultCellStyleId = this._lookupStyle(defaultCellStyle);
  }
  var freezePane = this.options.freezePane || {};
  var defaults2 = this.options.defaults || {};
  var lastRow = this.options.rows ? this._getLastRow() : 1;
  var lastCol = this.options.rows ? this._getLastCol() : 1;
  return WORKSHEET({
    frozenColumns: this.options.frozenColumns || freezePane.colSplit,
    frozenRows: this.options.frozenRows || freezePane.rowSplit,
    columns: this.options.columns,
    defaults: defaults2,
    data,
    index,
    mergeCells,
    autoFilter,
    filter: filter2,
    showGridLines: this.options.showGridLines,
    hyperlinks: this._hyperlinks,
    validations,
    defaultCellStyleId,
    rtl: this.options.rtl !== void 0 ? this.options.rtl : defaults2.rtl,
    legacyDrawing: this._comments.length ? "vml" + this.options.sheetIndex : null,
    drawing: this._drawings.length ? "drw" + this.options.sheetIndex : null,
    lastRow,
    lastCol,
    hasDisabledCells: this._hasDisabledCells
  });
};
Worksheet.prototype.commentsXML = function commentsXML() {
  if (this._comments.length) {
    return COMMENTS_XML({ comments: this._comments });
  }
};
Worksheet.prototype.drawingsXML = function drawingsXML(images) {
  if (this._drawings.length) {
    var rels = {};
    var main = this._drawings.map(function(drw) {
      var ref2 = parseRef(drw.topLeftCell);
      var img = rels[drw.image];
      if (!img) {
        img = rels[drw.image] = {
          rId: "img" + drw.image,
          target: images[drw.image].target
        };
      }
      return {
        col: ref2.col,
        colOffset: pixelsToExcel(drw.offsetX),
        row: ref2.row,
        rowOffset: pixelsToExcel(drw.offsetY),
        width: pixelsToExcel(drw.width),
        height: pixelsToExcel(drw.height),
        imageId: img.rId
      };
    });
    return {
      main: DRAWINGS_XML(main),
      rels: DRAWINGS_RELS_XML(rels)
    };
  }
};
Worksheet.prototype.legacyDrawing = function legacyDrawing() {
  if (this._comments.length) {
    return LEGACY_DRAWING({ comments: this._comments });
  }
};
Worksheet.prototype._lookupString = function _lookupString(value) {
  var key = "$" + value;
  var index = this._strings.indexes[key];
  var result;
  if (index !== void 0) {
    result = index;
  } else {
    result = this._strings.indexes[key] = this._strings.uniqueCount;
    this._strings.uniqueCount++;
  }
  this._strings.count++;
  return result;
};
Worksheet.prototype._lookupStyle = function _lookupStyle(style) {
  var json = JSON.stringify(style);
  if (json === "{}") {
    return 0;
  }
  var index = indexOf(json, this._styles);
  if (index < 0) {
    index = this._styles.push(json) - 1;
  }
  return index + 1;
};
Worksheet.prototype._lookupBorder = function _lookupBorder(border) {
  var json = JSON.stringify(border);
  if (json === "{}") {
    return;
  }
  var index = indexOf(json, this._borders);
  if (index < 0) {
    index = this._borders.push(json) - 1;
  }
  return index + 1;
};
Worksheet.prototype._readCells = function _readCells(rowData) {
  var this$1 = this;
  for (var i = 0; i < rowData.length; i++) {
    var row = rowData[i];
    var cells = row.cells;
    row.data = [];
    for (var j = 0; j < cells.length; j++) {
      var cellData = this$1._cell(cells[j], row.index, j);
      if (cellData) {
        row.data.push(cellData);
      }
    }
  }
};
Worksheet.prototype._cell = function _cell2(data, rowIndex, cellIndex) {
  var this$1 = this;
  if (!data || data === EMPTY_CELL) {
    return null;
  }
  var value = data.value;
  var border = {};
  if (data.borderLeft) {
    border.left = data.borderLeft;
  }
  if (data.borderRight) {
    border.right = data.borderRight;
  }
  if (data.borderTop) {
    border.top = data.borderTop;
  }
  if (data.borderBottom) {
    border.bottom = data.borderBottom;
  }
  if (data.dBorders) {
    border.diagonal = data.dBorders;
  }
  border = this._lookupBorder(border);
  var defStyle = this.options.defaultCellStyle || {};
  var style = { borderId: border };
  (function(add) {
    add("color");
    add("background");
    add("bold");
    add("italic");
    add("underline");
    if (!add("fontFamily")) {
      add("fontName", "fontFamily");
    }
    add("fontSize");
    add("format");
    if (!add("textAlign")) {
      add("hAlign", "textAlign");
    }
    if (!add("verticalAlign")) {
      add("vAlign", "verticalAlign");
    }
    add("wrap");
    add("indent");
    if (!add("disabled")) {
      if (add("enable")) {
        style.disabled = !style.enable;
        delete style.enable;
      }
    }
    if (style.disabled) {
      this$1._hasDisabledCells = true;
    }
  })(function(prop, target) {
    var val = data[prop];
    if (val === void 0) {
      val = defStyle[prop];
    }
    if (val !== void 0) {
      style[target || prop] = val;
      return true;
    }
  });
  var columns = this.options.columns || [];
  var column = columns[cellIndex];
  var type = typeof value;
  if (column && column.autoWidth && (!data.colSpan || data.colSpan === 1)) {
    var displayValue = value;
    if (type === "number") {
      displayValue = intl_service_default.toString(value, data.format);
    }
    column.width = Math.max(column.width || 0, String(displayValue).length);
  }
  if (type === "string") {
    value = stripFunnyChars(value);
    value = this._lookupString(value);
    type = "s";
  } else if (type === "number") {
    type = "n";
  } else if (type === "boolean") {
    type = "b";
    value = Number(value);
  } else if (value && value.getTime) {
    type = null;
    value = dateToSerial(value);
    if (!style.format) {
      style.format = "mm-dd-yy";
    }
  } else {
    type = null;
    value = null;
  }
  style = this._lookupStyle(style);
  var cellName = ref(rowIndex, cellIndex);
  if (data.validation) {
    this._addValidation(data.validation, cellName);
  }
  if (data.comment) {
    var anchor = [
      cellIndex + 1,
      // start column
      15,
      // start column offset
      rowIndex,
      // start row
      10,
      // start row offset
      cellIndex + 3,
      // end column
      15,
      // end column offset
      rowIndex + 3,
      // end row
      4
      // end row offset
    ];
    this._comments.push({
      ref: cellName,
      text: data.comment,
      row: rowIndex,
      col: cellIndex,
      anchor: anchor.join(", ")
    });
  }
  return {
    value,
    formula: data.formula,
    type,
    style,
    ref: cellName
  };
};
Worksheet.prototype._addValidation = function _addValidation(v, ref2) {
  var tmp = {
    showErrorMessage: v.type === "reject" ? 1 : 0,
    formula1: v.from,
    formula2: v.to,
    type: MAP_EXCEL_TYPE[v.dataType] || v.dataType,
    operator: MAP_EXCEL_OPERATOR[v.comparerType] || v.comparerType,
    allowBlank: v.allowNulls ? 1 : 0,
    showDropDown: v.showButton ? 0 : 1,
    // LOL, Excel!
    error: v.messageTemplate,
    errorTitle: v.titleTemplate
  };
  var json = JSON.stringify(tmp);
  if (!this._validations[json]) {
    this._validations[json] = tmp;
    tmp.sqref = [];
  }
  this._validations[json].sqref.push(ref2);
};
Worksheet.prototype._getLastRow = function _getLastRow() {
  return countData(this.options.rows);
};
Worksheet.prototype._getLastCol = function _getLastCol() {
  var last = 0;
  this.options.rows.forEach(function(row) {
    if (row.cells) {
      last = Math.max(last, countData(row.cells));
    }
  });
  return last;
};
function countData(data) {
  var last = data.length;
  data.forEach(function(el) {
    if (el.index && el.index >= last) {
      last = el.index + 1;
    }
  });
  return last;
}
var MAP_EXCEL_OPERATOR = {
  // includes only what differs; key is our operator, value is Excel
  // operator.
  greaterThanOrEqualTo: "greaterThanOrEqual",
  lessThanOrEqualTo: "lessThanOrEqual"
};
var MAP_EXCEL_TYPE = {
  // eslint-disable-next-line id-denylist
  number: "decimal"
};
var defaultFormats = {
  "General": 0,
  "0": 1,
  "0.00": 2,
  "#,##0": 3,
  "#,##0.00": 4,
  "0%": 9,
  "0.00%": 10,
  "0.00E+00": 11,
  "# ?/?": 12,
  "# ??/??": 13,
  "mm-dd-yy": 14,
  "d-mmm-yy": 15,
  "d-mmm": 16,
  "mmm-yy": 17,
  "h:mm AM/PM": 18,
  "h:mm:ss AM/PM": 19,
  "h:mm": 20,
  "h:mm:ss": 21,
  "m/d/yy h:mm": 22,
  "#,##0 ;(#,##0)": 37,
  "#,##0 ;[Red](#,##0)": 38,
  "#,##0.00;(#,##0.00)": 39,
  "#,##0.00;[Red](#,##0.00)": 40,
  "mm:ss": 45,
  "[h]:mm:ss": 46,
  "mmss.0": 47,
  "##0.0E+0": 48,
  "@": 49,
  "[$-404]e/m/d": 27,
  "m/d/yy": 30,
  "t0": 59,
  "t0.00": 60,
  "t#,##0": 61,
  "t#,##0.00": 62,
  "t0%": 67,
  "t0.00%": 68,
  "t# ?/?": 69,
  "t# ??/??": 70
};
function maybeRGB(value) {
  function hex(val) {
    var x = parseInt(val, 10).toString(16);
    return x.length < 2 ? "0" + x : x;
  }
  var m = /^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-9.]+)\s*)?\)/i.exec(value.trim());
  if (m) {
    var opacity = (m[4] ? parseFloat(m[4]) : 1) * 255 | 0;
    return "#" + hex(opacity) + hex(m[1]) + hex(m[2]) + hex(m[3]);
  }
  return value;
}
function convertColor(value) {
  var color = maybeRGB(value);
  if (color.length < 6) {
    color = color.replace(/(\w)/g, function($0, $1) {
      return $1 + $1;
    });
  }
  color = color.substring(1).toUpperCase();
  if (color.length < 8) {
    color = "FF" + color;
  }
  return color;
}
var Workbook = function Workbook2(options) {
  var this$1 = this;
  this.options = options || {};
  this._strings = {
    indexes: {},
    count: 0,
    uniqueCount: 0
  };
  this._styles = [];
  this._borders = [];
  this._images = this.options.images;
  this._imgId = 0;
  this._sheets = map(this.options.sheets || [], function(options2, i) {
    options2.defaults = this$1.options;
    options2.sheetIndex = i + 1;
    return new Worksheet(options2, this$1._strings, this$1._styles, this$1._borders);
  });
};
Workbook.prototype.imageFilename = function imageFilename(mimeType) {
  var id = ++this._imgId;
  switch (mimeType) {
    case "image/jpg":
    case "image/jpeg":
      return "image" + id + ".jpg";
    case "image/png":
      return "image" + id + ".png";
    case "image/gif":
      return "image" + id + ".gif";
    default:
      return "image" + id + ".bin";
  }
};
Workbook.prototype.toZIP = function toZIP() {
  var this$1 = this;
  var zip = createZip();
  var docProps = zip.folder("docProps");
  docProps.file("core.xml", CORE({
    creator: this.options.creator || "Kendo UI",
    lastModifiedBy: this.options.creator || "Kendo UI",
    created: this.options.date || (/* @__PURE__ */ new Date()).toJSON(),
    modified: this.options.date || (/* @__PURE__ */ new Date()).toJSON()
  }));
  var sheetCount = this._sheets.length;
  docProps.file("app.xml", APP({ sheets: this._sheets }));
  var rels = zip.folder("_rels");
  rels.file(".rels", RELS);
  var xl = zip.folder("xl");
  var xlRels = xl.folder("_rels");
  xlRels.file("workbook.xml.rels", WORKBOOK_RELS({ count: sheetCount }));
  if (this._images) {
    var media = xl.folder("media");
    Object.keys(this._images).forEach(function(id) {
      var img = this$1._images[id];
      var filename = this$1.imageFilename(img.type);
      media.file(filename, img.data);
      img.target = "../media/" + filename;
    });
  }
  var sheetIds = {};
  xl.file("workbook.xml", WORKBOOK({
    sheets: this._sheets,
    filterNames: map(this._sheets, function(sheet2, index) {
      var options = sheet2.options;
      var sheetName2 = options.name || options.title || "Sheet" + (index + 1);
      sheetIds[sheetName2.toLowerCase()] = index;
      var filter2 = options.filter;
      if (filter2) {
        if (filter2.ref) {
          var a = filter2.ref.split(":");
          var from = parseRef(a[0]);
          var to = parseRef(a[1]);
          return {
            localSheetId: index,
            name: sheetName2,
            from: $ref(from.row, from.col),
            to: $ref(to.row, to.col)
          };
        } else if (typeof filter2.from !== "undefined" && typeof filter2.to !== "undefined") {
          return {
            localSheetId: index,
            name: sheetName2,
            from: $ref(filterRowIndex(options), filter2.from),
            to: $ref(filterRowIndex(options), filter2.to)
          };
        }
      }
    }),
    userNames: map(this.options.names || [], function(def) {
      return {
        name: def.localName,
        localSheetId: def.sheet ? sheetIds[def.sheet.toLowerCase()] : null,
        value: def.value,
        hidden: def.hidden
      };
    })
  }));
  var worksheets = xl.folder("worksheets");
  var drawings = xl.folder("drawings");
  var drawingsRels = drawings.folder("_rels");
  var sheetRels = worksheets.folder("_rels");
  var commentFiles = [];
  var drawingFiles = [];
  for (var idx = 0; idx < sheetCount; idx++) {
    var sheet = this$1._sheets[idx];
    var sheetName = "sheet" + (idx + 1) + ".xml";
    var sheetXML = sheet.toXML(idx);
    var relsXML = sheet.relsToXML();
    var commentsXML2 = sheet.commentsXML();
    var legacyDrawing2 = sheet.legacyDrawing();
    var drawingsXML2 = sheet.drawingsXML(this$1._images);
    if (relsXML) {
      sheetRels.file(sheetName + ".rels", relsXML);
    }
    if (commentsXML2) {
      var name = "comments" + sheet.options.sheetIndex + ".xml";
      xl.file(name, commentsXML2);
      commentFiles.push(name);
    }
    if (legacyDrawing2) {
      drawings.file("vmlDrawing" + sheet.options.sheetIndex + ".vml", legacyDrawing2);
    }
    if (drawingsXML2) {
      var name$1 = "drawing" + sheet.options.sheetIndex + ".xml";
      drawings.file(name$1, drawingsXML2.main);
      drawingsRels.file(name$1 + ".rels", drawingsXML2.rels);
      drawingFiles.push(name$1);
    }
    worksheets.file(sheetName, sheetXML);
  }
  var borders = map(this._borders, parseJSON);
  var styles = map(this._styles, parseJSON);
  var hasFont = function(style) {
    return style.underline || style.bold || style.italic || style.color || style.fontFamily || style.fontSize;
  };
  var convertFontSize = function(value) {
    var fontInPx = Number(value);
    var fontInPt;
    if (fontInPx) {
      fontInPt = fontInPx * 3 / 4;
    }
    return fontInPt;
  };
  var fonts = map(styles, function(style) {
    if (style.fontSize) {
      style.fontSize = convertFontSize(style.fontSize);
    }
    if (style.color) {
      style.color = convertColor(style.color);
    }
    if (hasFont(style)) {
      return style;
    }
  });
  var formats = map(styles, function(style) {
    if (style.format && defaultFormats[style.format] === void 0) {
      return style;
    }
  });
  var fills = map(styles, function(style) {
    if (style.background) {
      style.background = convertColor(style.background);
      return style;
    }
  });
  xl.file("styles.xml", STYLES({
    fonts,
    fills,
    formats,
    borders,
    styles: map(styles, function(style) {
      var result = {};
      if (hasFont(style)) {
        result.fontId = indexOf(style, fonts) + 1;
      }
      if (style.background) {
        result.fillId = indexOf(style, fills) + 2;
      }
      result.textAlign = style.textAlign;
      result.indent = style.indent;
      result.verticalAlign = style.verticalAlign;
      result.wrap = style.wrap;
      result.borderId = style.borderId;
      if (style.format) {
        if (defaultFormats[style.format] !== void 0) {
          result.numFmtId = defaultFormats[style.format];
        } else {
          result.numFmtId = 165 + indexOf(style, formats);
        }
      }
      if (style.disabled != null) {
        result.disabled = style.disabled;
      }
      return result;
    })
  }));
  xl.file("sharedStrings.xml", SHARED_STRINGS(this._strings));
  zip.file("[Content_Types].xml", CONTENT_TYPES({
    sheetCount,
    commentFiles,
    drawingFiles
  }));
  return zip;
};
Workbook.prototype.toDataURL = function toDataURL() {
  var zip = this.toZIP();
  return zip.generateAsync ? zip.generateAsync(DATA_URL_OPTIONS).then(toDataURI) : toDataURI(zip.generate(DATA_URL_OPTIONS));
};
Workbook.prototype.toBlob = function toBlob() {
  var zip = this.toZIP();
  if (zip.generateAsync) {
    return zip.generateAsync(BLOB_OPTIONS);
  }
  return new Blob([zip.generate(ARRAYBUFFER_OPTIONS)], { type: MIME_TYPE });
};
function borderStyle(width) {
  var alias = "thin";
  if (width === 2) {
    alias = "medium";
  } else if (width === 3) {
    alias = "thick";
  }
  return alias;
}
function borderSideTemplate(name, style) {
  var result = "";
  if (style) {
    result += "<" + name + ' style="' + borderStyle(style.size) + '">';
    if (style.color) {
      result += '<color rgb="' + convertColor(style.color) + '"/>';
    }
    result += "</" + name + ">";
  }
  return result;
}
function borderTemplate(border) {
  var diag = border.diagonal ? border.diagonal.type : 0;
  return "<border " + (diag & 2 ? 'diagonalUp="true"' : "") + " " + (diag & 1 ? 'diagonalDown="true"' : "") + ">\n      " + borderSideTemplate("left", border.left) + "\n      " + borderSideTemplate("right", border.right) + "\n      " + borderSideTemplate("top", border.top) + "\n      " + borderSideTemplate("bottom", border.bottom) + "\n      " + borderSideTemplate("diagonal", border.diagonal) + "\n    </border>";
}
var EMPTY_CELL = {};
function inflate(rows, mergedCells) {
  var rowData = [];
  var rowsByIndex = [];
  indexRows(rows, function(row, index) {
    var data = {
      _source: row,
      index,
      height: row.height,
      level: row.level,
      cells: []
    };
    rowData.push(data);
    rowsByIndex[index] = data;
  });
  var sorted = sortByIndex(rowData).slice(0);
  var ctx = {
    rowData,
    rowsByIndex,
    mergedCells
  };
  for (var i = 0; i < sorted.length; i++) {
    fillCells(sorted[i], ctx);
    delete sorted[i]._source;
  }
  return sortByIndex(rowData);
}
function indexRows(rows, callback) {
  for (var i = 0; i < rows.length; i++) {
    var row = rows[i];
    if (!row) {
      continue;
    }
    var index = row.index;
    if (typeof index !== "number") {
      index = i;
    }
    callback(row, index);
  }
}
function sortByIndex(items) {
  return items.sort(function(a, b) {
    return a.index - b.index;
  });
}
function pushUnique(array, el) {
  if (array.indexOf(el) < 0) {
    array.push(el);
  }
}
function getSpan(mergedCells, ref2) {
  for (var i = 0; i < mergedCells.length; ++i) {
    var range = mergedCells[i];
    var a = range.split(":");
    var topLeft = a[0];
    if (topLeft === ref2) {
      var bottomRight = a[1];
      topLeft = parseRef(topLeft);
      bottomRight = parseRef(bottomRight);
      return {
        rowSpan: bottomRight.row - topLeft.row + 1,
        colSpan: bottomRight.col - topLeft.col + 1
      };
    }
  }
}
function parseRef(ref2) {
  function getcol(str) {
    var upperStr = str.toUpperCase();
    var col = 0;
    for (var i = 0; i < upperStr.length; ++i) {
      col = col * 26 + upperStr.charCodeAt(i) - 64;
    }
    return col - 1;
  }
  function getrow(str) {
    return parseInt(str, 10) - 1;
  }
  var m = /^([a-z]+)(\d+)$/i.exec(ref2);
  return {
    row: getrow(m[2]),
    col: getcol(m[1])
  };
}
function pixelsToExcel(px) {
  return Math.round(px * 9525);
}
function fillCells(data, ctx) {
  var row = data._source;
  var rowIndex = data.index;
  var cells = row.cells;
  var cellData = data.cells;
  if (!cells) {
    return;
  }
  for (var i = 0; i < cells.length; i++) {
    var cell = cells[i] || EMPTY_CELL;
    var rowSpan = cell.rowSpan || 1;
    var colSpan = cell.colSpan || 1;
    var cellIndex = insertCell(cellData, cell);
    var topLeftRef = ref(rowIndex, cellIndex);
    if (rowSpan === 1 && colSpan === 1) {
      var tmp = getSpan(ctx.mergedCells, topLeftRef);
      if (tmp) {
        colSpan = tmp.colSpan;
        rowSpan = tmp.rowSpan;
      }
    }
    spanCell(cell, cellData, cellIndex, colSpan);
    if (rowSpan > 1 || colSpan > 1) {
      pushUnique(
        ctx.mergedCells,
        topLeftRef + ":" + ref(
          rowIndex + rowSpan - 1,
          cellIndex + colSpan - 1
        )
      );
    }
    if (rowSpan > 1) {
      for (var ri = rowIndex + 1; ri < rowIndex + rowSpan; ri++) {
        var nextRow = ctx.rowsByIndex[ri];
        if (!nextRow) {
          nextRow = ctx.rowsByIndex[ri] = { index: ri, cells: [] };
          ctx.rowData.push(nextRow);
        }
        spanCell(cell, nextRow.cells, cellIndex - 1, colSpan + 1);
      }
    }
  }
}
function insertCell(data, cell) {
  var index;
  if (typeof cell.index === "number") {
    index = cell.index;
    insertCellAt(data, cell, cell.index);
  } else {
    index = appendCell(data, cell);
  }
  return index;
}
function insertCellAt(data, cell, index) {
  data[index] = cell;
}
function appendCell(data, cell) {
  var index = data.length;
  for (var i = 0; i < data.length + 1; i++) {
    if (!data[i]) {
      data[i] = cell;
      index = i;
      break;
    }
  }
  return index;
}
function spanCell(cell, row, startIndex, colSpan) {
  for (var i = 1; i < colSpan; i++) {
    var tmp = {
      borderTop: cell.borderTop,
      borderRight: cell.borderRight,
      borderBottom: cell.borderBottom,
      borderLeft: cell.borderLeft
    };
    insertCellAt(row, tmp, startIndex + i);
  }
}
var SPREADSHEET_FILTERS = function(ref$1) {
  var ref2 = ref$1.ref;
  var columns = ref$1.columns;
  var generators = ref$1.generators;
  return '\n<autoFilter ref="' + ref2 + '">\n  ' + foreach(columns, function(col) {
    return '\n    <filterColumn colId="' + col.index + '">\n      ' + generators[col.filter](col) + "\n    </filterColumn>\n  ";
  }) + "\n</autoFilter>";
};
var SPREADSHEET_CUSTOM_FILTER = function(ref2) {
  var logic = ref2.logic;
  var criteria = ref2.criteria;
  return "\n<customFilters " + (logic === "and" ? 'and="1"' : "") + ">\n" + foreach(criteria, function(f) {
    var op = spreadsheetFilters.customOperator(f);
    var val = spreadsheetFilters.customValue(f);
    return "<customFilter " + (op ? 'operator="' + op + '"' : "") + ' val="' + val + '"/>';
  }) + "\n</customFilters>";
};
var SPREADSHEET_DYNAMIC_FILTER = function(ref2) {
  var type = ref2.type;
  return '<dynamicFilter type="' + spreadsheetFilters.dynamicFilterType(type) + '" />';
};
var SPREADSHEET_TOP_FILTER = function(ref2) {
  var type = ref2.type;
  var value = ref2.value;
  return '<top10 percent="' + (/percent$/i.test(type) ? 1 : 0) + '"\n       top="' + (/^top/i.test(type) ? 1 : 0) + '"\n       val="' + value + '" />';
};
var SPREADSHEET_VALUE_FILTER = function(ref2) {
  var blanks = ref2.blanks;
  var values = ref2.values;
  return "<filters " + (blanks ? 'blank="1"' : "") + ">\n    " + foreach(values, function(value) {
    return '\n      <filter val="' + value + '" />';
  }) + "\n  </filters>";
};
function spreadsheetFilters(filter2) {
  return SPREADSHEET_FILTERS({
    ref: filter2.ref,
    columns: filter2.columns,
    generators: {
      custom: SPREADSHEET_CUSTOM_FILTER,
      dynamic: SPREADSHEET_DYNAMIC_FILTER,
      top: SPREADSHEET_TOP_FILTER,
      value: SPREADSHEET_VALUE_FILTER
    }
  });
}
spreadsheetFilters.customOperator = function(f) {
  return {
    eq: "equal",
    gt: "greaterThan",
    gte: "greaterThanOrEqual",
    lt: "lessThan",
    lte: "lessThanOrEqual",
    ne: "notEqual",
    // These are not in the spec, but seems to be how Excel does
    // it (see customValue below).  For the non-negated versions,
    // the operator attribute is missing completely.
    doesnotstartwith: "notEqual",
    doesnotendwith: "notEqual",
    doesnotcontain: "notEqual",
    doesnotmatch: "notEqual"
  }[f.operator.toLowerCase()];
};
function quoteSheet(name) {
  if (/^\'/.test(name)) {
    return name;
  }
  if (/^[a-z_][a-z0-9_]*$/i.test(name)) {
    return name;
  }
  return "'" + name.replace(/\x27/g, "\\'") + "'";
}
spreadsheetFilters.customValue = function(f) {
  function esc(str) {
    return str.replace(/([*?])/g, "~$1");
  }
  switch (f.operator.toLowerCase()) {
    case "startswith":
    case "doesnotstartwith":
      return esc(f.value) + "*";
    case "endswith":
    case "doesnotendwith":
      return "*" + esc(f.value);
    case "contains":
    case "doesnotcontain":
      return "*" + esc(f.value) + "*";
    default:
      return f.value;
  }
};
spreadsheetFilters.dynamicFilterType = function(type) {
  return {
    quarter1: "Q1",
    quarter2: "Q2",
    quarter3: "Q3",
    quarter4: "Q4",
    january: "M1",
    february: "M2",
    march: "M3",
    april: "M4",
    may: "M5",
    june: "M6",
    july: "M7",
    august: "M8",
    september: "M9",
    october: "M10",
    november: "M11",
    december: "M12"
  }[type.toLowerCase()] || type;
};

// node_modules/@progress/kendo-vue-excel-export/dist/es/ooxml/ExporterColumns.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var compileTemplate = function compileTemplate2(templateFunction, context, updateContext) {
  var result = function result2(data) {
    updateContext(context, data);
    var templateResult = templateFunction(__assign({}, context));
    var parsed = Number(templateResult);
    return isNaN(parsed) ? templateResult : parsed;
  };
  return result;
};
var updateGroupHeaderContext = function updateGroupHeaderContext2(context, data) {
  context.$implicit = context.group = data;
  context.field = data.field;
  context.value = data.value;
  context.aggregates = data.aggregates;
};
var updateGroupFooterContext = function updateGroupFooterContext2(context, data) {
  context.group = data.group;
  context.$implicit = context.aggregates = data;
};
var updateFooterContext = function updateFooterContext2(_context, _data) {
};
var toExporterColumns = function toExporterColumns2(sourceColumns) {
  var exporterColumns = [];
  var columnIndex = 0;
  var addColumns = function addColumns2(columns, result, level) {
    columns.forEach(function(column) {
      var exporterColumn = new ExporterColumn(column, columnIndex);
      result.push(exporterColumn);
      if (column.children && column.children.length > 1) {
        var children = exporterColumn.columns = [];
        addColumns2(column.children, children, level + 1);
      } else {
        columnIndex++;
      }
    });
  };
  addColumns(sourceColumns, exporterColumns, 0);
  return exporterColumns;
};
var ExporterColumn = (
  /** @class */
  function() {
    function ExporterColumn2(column, columnIndex) {
      this.title = column.title;
      this.field = column.field;
      this.hidden = column.hidden;
      this.locked = column.locked;
      this.width = column.width;
      this.headerCellOptions = column.headerCellOptions;
      this.cellOptions = column.cellOptions;
      this.groupHeaderCellOptions = column.groupHeaderCellOptions;
      this.groupFooterCellOptions = column.groupFooterCellOptions;
      this.footerCellOptions = column.footerCellOptions;
      if (column.footer) {
        this.footerTemplate = compileTemplate(column.footer, {
          $implicit: column,
          column,
          columnIndex
        }, updateFooterContext);
      }
      if (column.groupFooter) {
        this.groupFooterTemplate = compileTemplate(column.groupFooter, {
          column,
          field: column.field
        }, updateGroupFooterContext);
      }
      if (column.groupHeader) {
        this.groupHeaderTemplate = compileTemplate(column.groupHeader, {}, updateGroupHeaderContext);
      }
    }
    return ExporterColumn2;
  }()
);

// node_modules/@progress/kendo-vue-excel-export/dist/es/ooxml/workbook.js
var getDepth = function(data) {
  return Math.max.apply(Math, data.map(function(i) {
    return i.level;
  })) + 1;
};
var workbookOptions = function(options) {
  var columns = toExporterColumns(options.columns);
  var exporter = new excel_exporter_default({
    columns,
    data: options.data,
    filterable: options.filterable,
    groups: options.group,
    paddingCellOptions: options.paddingCellOptions,
    headerPaddingCellOptions: options.headerPaddingCellOptions,
    hierarchy: options.hierarchy ? { depth: getDepth(options.data), itemLevel: function(item) {
      return item.level;
    } } : null,
    collapsible: options.collapsible
  });
  var result = exporter.workbook();
  result.creator = options.creator;
  result.date = options.date;
  result.rtl = options.dir === "rtl";
  return result;
};
var toDataURL2 = function(options) {
  var workbook2 = new Workbook(options);
  return workbook2.toDataURL();
};
var isWorkbookOptions = function(value) {
  return value && value.sheets;
};

// node_modules/@progress/kendo-vue-excel-export/dist/es/package-metadata.js
var packageMetadata = {
  name: "@progress/kendo-vue-excel-export",
  productName: "Kendo UI for Vue",
  productCodes: ["KENDOUIVUE", "KENDOUICOMPLETE"],
  publishDate: 1708438352,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-vue-ui/my-license/?utm_medium=product&utm_source=kendovue&utm_campaign=kendo-ui-vue-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-vue-excel-export/dist/es/saveExcel.js
function saveExcel(exportOptions) {
  validatePackage(packageMetadata);
  var saveFn = function(dataURL) {
    if (exportOptions.onExportComplete) {
      exportOptions.onExportComplete.call(void 0, {
        dataURL,
        options: exportOptions
      });
    }
    saveAs(dataURL, exportOptions.fileName, {
      forceProxy: exportOptions.forceProxy,
      proxyURL: exportOptions.proxyURL
    });
  };
  var options = workbookOptions(exportOptions);
  toDataURL2(options).then(saveFn);
}
export {
  excel_exporter_default as ExcelExporter,
  intl_service_default as IntlService,
  template_service_default as TemplateService,
  Workbook,
  Worksheet,
  isWorkbookOptions,
  saveExcel,
  toDataURL2 as toDataURL,
  workbookOptions
};
//# sourceMappingURL=@progress_kendo-vue-excel-export.js.map
