import {
  CKEditorError,
  Collection,
  ContextPlugin,
  DomEmitterMixin,
  EmitterMixin,
  FocusTracker,
  KeystrokeHandler,
  ObservableMixin,
  Plugin,
  Rect,
  ResizeObserver,
  createElement,
  delay,
  env_default,
  findClosestScrollableAncestor,
  first,
  getElementsIntersectionRect,
  getEnvKeystrokeText,
  getOptimalPosition,
  getScrollableAncestors,
  global_default,
  icons,
  isIterable,
  isNode,
  isRange,
  isVisible,
  logWarning,
  priorities_default,
  toArray,
  toUnit,
  uid,
  verifyLicense
} from "./chunk-JI2V5GJZ.js";
import {
  assignIn_default,
  cloneDeepWith_default,
  debounce_default,
  isElement_default,
  isObject_default,
  throttle_default
} from "./chunk-6DXDGCMU.js";
import {
  __commonJS,
  __toESM
} from "./chunk-HM4MQYWN.js";

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert2 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert2;
    for (const model of Object.keys(convert2)) {
      if (!("channels" in convert2[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert2[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert2[model].labels.length !== convert2[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert2[model];
      delete convert2[model].channels;
      delete convert2[model].labels;
      Object.defineProperty(convert2[model], "channels", { value: channels });
      Object.defineProperty(convert2[model], "labels", { value: labels });
    }
    convert2.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert2.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert2.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert2.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert2.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert2.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert2.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert2.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert2.rgb.lab = function(rgb) {
      const xyz = convert2.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert2.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert2.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert2.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert2.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert2.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert2.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert2.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert2.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert2.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert2.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert2.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert2.hsv.ansi16 = function(args) {
      return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
    };
    convert2.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert2.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert2.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert2.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert2.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert2.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert2.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert2.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert2.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert2.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert2.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert2.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert2.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert2.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert2.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert2.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert2.gray.hsv = convert2.gray.hsl;
    convert2.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert2.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert2.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert2.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert2.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert2 = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert2[fromModel] = {};
      Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert2[fromModel][toModel] = wrapRounded(fn);
        convert2[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert2;
  }
});

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler.js
function clickOutsideHandler({ emitter, activator, callback, contextElements }) {
  emitter.listenTo(document, "mousedown", (evt, domEvt) => {
    if (!activator()) {
      return;
    }
    const path = typeof domEvt.composedPath == "function" ? domEvt.composedPath() : [];
    const contextElementsList = typeof contextElements == "function" ? contextElements() : contextElements;
    for (const contextElement of contextElementsList) {
      if (contextElement.contains(domEvt.target) || path.includes(contextElement)) {
        return;
      }
    }
    callback();
  });
}

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/csstransitiondisablermixin.js
function CssTransitionDisablerMixin(view) {
  class Mixin extends view {
    disableCssTransitions() {
      this._isCssTransitionsDisabled = true;
    }
    enableCssTransitions() {
      this._isCssTransitionsDisabled = false;
    }
    constructor(...args) {
      super(...args);
      this.set("_isCssTransitionsDisabled", false);
      this.initializeCssTransitionDisablerMixin();
    }
    initializeCssTransitionDisablerMixin() {
      this.extendTemplate({
        attributes: {
          class: [
            this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")
          ]
        }
      });
    }
  }
  return Mixin;
}

// node_modules/@ckeditor/ckeditor5-ui/src/viewcollection.js
var ViewCollection = class extends Collection {
  /**
   * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
   *
   * @param initialItems The initial items of the collection.
   */
  constructor(initialItems = []) {
    super(initialItems, {
      // An #id Number attribute should be legal and not break the `ViewCollection` instance.
      // https://github.com/ckeditor/ckeditor5-ui/issues/93
      idProperty: "viewUid"
    });
    this.on("add", (evt, view, index) => {
      this._renderViewIntoCollectionParent(view, index);
    });
    this.on("remove", (evt, view) => {
      if (view.element && this._parentElement) {
        view.element.remove();
      }
    });
    this._parentElement = null;
  }
  /**
   * Destroys the view collection along with child views.
   * See the view {@link module:ui/view~View#destroy} method.
   */
  destroy() {
    this.map((view) => view.destroy());
  }
  /**
   * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
   * {@link #remove removing} views in the collection synchronizes their
   * {@link module:ui/view~View#element elements} in the parent element.
   *
   * @param element A new parent element.
   */
  setParent(elementOrDocFragment) {
    this._parentElement = elementOrDocFragment;
    for (const view of this) {
      this._renderViewIntoCollectionParent(view);
    }
  }
  /**
   * Delegates selected events coming from within views in the collection to any
   * {@link module:utils/emittermixin~Emitter}.
   *
   * For the following views and collection:
   *
   * ```ts
   * const viewA = new View();
   * const viewB = new View();
   * const viewC = new View();
   *
   * const views = parentView.createCollection();
   *
   * views.delegate( 'eventX' ).to( viewB );
   * views.delegate( 'eventX', 'eventY' ).to( viewC );
   *
   * views.add( viewA );
   * ```
   *
   * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventX', customData );
   * ```
   *
   * and `eventY` is delegated (fired by) `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventY', customData );
   * ```
   *
   * See {@link module:utils/emittermixin~Emitter#delegate}.
   *
   * @param events {@link module:ui/view~View} event names to be delegated to another
   * {@link module:utils/emittermixin~Emitter}.
   * @returns Object with `to` property, a function which accepts the destination
   * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
   */
  delegate(...events) {
    if (!events.length || !isStringArray(events)) {
      throw new CKEditorError("ui-viewcollection-delegate-wrong-events", this);
    }
    return {
      to: (dest) => {
        for (const view of this) {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        }
        this.on("add", (evt, view) => {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        });
        this.on("remove", (evt, view) => {
          for (const evtName of events) {
            view.stopDelegating(evtName, dest);
          }
        });
      }
    };
  }
  /**
   * This method {@link module:ui/view~View#render renders} a new view added to the collection.
   *
   * If the {@link #_parentElement parent element} of the collection is set, this method also adds
   * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
   *
   * **Note**: If index is not specified, the view's element is pushed as the last child
   * of the parent element.
   *
   * @param view A new view added to the collection.
   * @param index An index the view holds in the collection. When not specified,
   * the view is added at the end.
   */
  _renderViewIntoCollectionParent(view, index) {
    if (!view.isRendered) {
      view.render();
    }
    if (view.element && this._parentElement) {
      this._parentElement.insertBefore(view.element, this._parentElement.children[index]);
    }
  }
  /**
   * Removes a child view from the collection. If the {@link #setParent parent element} of the
   * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
   * in DOM, reflecting the order of the collection.
   *
   * See the {@link #add} method.
   *
   * @param subject The view to remove, its id or index in the collection.
   * @returns The removed view.
   */
  remove(subject) {
    return super.remove(subject);
  }
};
function isStringArray(arr) {
  return arr.every((a) => typeof a == "string");
}

// node_modules/@ckeditor/ckeditor5-ui/src/template.js
var xhtmlNs = "http://www.w3.org/1999/xhtml";
var Template = class extends EmitterMixin() {
  /**
   * Creates an instance of the {@link ~Template} class.
   *
   * @param def The definition of the template.
   */
  constructor(def) {
    super();
    Object.assign(this, normalize(clone(def)));
    this._isRendered = false;
    this._revertData = null;
  }
  /**
   * Renders a DOM Node (an HTML element or text) out of the template.
   *
   * ```ts
   * const domNode = new Template( { ... } ).render();
   * ```
   *
   * See: {@link #apply}.
   */
  render() {
    const node = this._renderNode({
      intoFragment: true
    });
    this._isRendered = true;
    return node;
  }
  /**
   * Applies the template to an existing DOM Node, either HTML element or text.
   *
   * **Note:** No new DOM nodes will be created. Applying extends:
   *
   * {@link module:ui/template~TemplateDefinition attributes},
   * {@link module:ui/template~TemplateDefinition event listeners}, and
   * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
   *
   * **Note:** Existing `class` and `style` attributes are extended when a template
   * is applied to an HTML element, while other attributes and `textContent` are overridden.
   *
   * **Note:** The process of applying a template can be easily reverted using the
   * {@link module:ui/template~Template#revert} method.
   *
   * ```ts
   * const element = document.createElement( 'div' );
   * const observable = new Model( { divClass: 'my-div' } );
   * const emitter = Object.create( EmitterMixin );
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		id: 'first-div',
   * 		class: bind.to( 'divClass' )
   * 	},
   * 	on: {
   * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
   * 	},
   * 	children: [
   * 		'Div text.'
   * 	]
   * } ).apply( element );
   *
   * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
   * ```
   *
   * @see module:ui/template~Template#render
   * @see module:ui/template~Template#revert
   * @param node Root node for the template to apply.
   */
  apply(node) {
    this._revertData = getEmptyRevertData();
    this._renderNode({
      node,
      intoFragment: false,
      isApplying: true,
      revertData: this._revertData
    });
    return node;
  }
  /**
   * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
   *
   * @param node The root node for the template to revert. In most of the cases, it is the
   * same node used by {@link module:ui/template~Template#apply}.
   */
  revert(node) {
    if (!this._revertData) {
      throw new CKEditorError("ui-template-revert-not-applied", [this, node]);
    }
    this._revertTemplateFromNode(node, this._revertData);
  }
  /**
   * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
   * instances and returns them one by one.
   *
   * ```ts
   * const viewFoo = new View();
   * const viewBar = new View();
   * const viewBaz = new View();
   * const template = new Template( {
   * 	tag: 'div',
   * 	children: [
   * 		viewFoo,
   * 		{
   * 			tag: 'div',
   * 			children: [
   * 				viewBar
   * 			]
   * 		},
   * 		viewBaz
   * 	]
   * } );
   *
   * // Logs: viewFoo, viewBar, viewBaz
   * for ( const view of template.getViews() ) {
   * 	console.log( view );
   * }
   * ```
   */
  *getViews() {
    function* search(def) {
      if (def.children) {
        for (const child of def.children) {
          if (isView(child)) {
            yield child;
          } else if (isTemplate(child)) {
            yield* search(child);
          }
        }
      }
    }
    yield* search(this);
  }
  /**
   * An entry point to the interface which binds DOM nodes to
   * {@link module:utils/observablemixin~Observable observables}.
   * There are two types of bindings:
   *
   * * HTML element attributes or text `textContent` synchronized with attributes of an
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
   * and {@link module:ui/template~BindChain#if}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		// Binds the element "class" attribute to observable#classAttribute.
   * 		class: bind.to( 'classAttribute' )
   * 	}
   * } ).render();
   * ```
   *
   * * DOM events fired on HTML element propagated through
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	on: {
   * 		// Will be fired by the observable.
   * 		click: bind( 'elementClicked' )
   * 	}
   * } ).render();
   * ```
   *
   * Also see {@link module:ui/view~View#bindTemplate}.
   *
   * @param observable An observable which provides boundable attributes.
   * @param emitter An emitter that listens to observable attribute
   * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
   */
  static bind(observable, emitter) {
    return {
      to(eventNameOrFunctionOrAttribute, callback) {
        return new TemplateToBinding({
          eventNameOrFunction: eventNameOrFunctionOrAttribute,
          attribute: eventNameOrFunctionOrAttribute,
          observable,
          emitter,
          callback
        });
      },
      if(attribute, valueIfTrue, callback) {
        return new TemplateIfBinding({
          observable,
          emitter,
          attribute,
          valueIfTrue,
          callback
        });
      }
    };
  }
  /**
   * Extends an existing {@link module:ui/template~Template} instance with some additional content
   * from another {@link module:ui/template~TemplateDefinition}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * const template = new Template( {
   * 	tag: 'p',
   * 	attributes: {
   * 		class: 'a',
   * 		data-x: bind.to( 'foo' )
   * 	},
   * 	children: [
   * 		{
   * 			tag: 'span',
   * 			attributes: {
   * 				class: 'b'
   * 			},
   * 			children: [
   * 				'Span'
   * 			]
   * 		}
   * 	]
   *  } );
   *
   * // Instance-level extension.
   * Template.extend( template, {
   * 	attributes: {
   * 		class: 'b',
   * 		data-x: bind.to( 'bar' )
   * 	},
   * 	children: [
   * 		{
   * 			attributes: {
   * 				class: 'c'
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // Child extension.
   * Template.extend( template.children[ 0 ], {
   * 	attributes: {
   * 		class: 'd'
   * 	}
   * } );
   * ```
   *
   * the `outerHTML` of `template.render()` is:
   *
   * ```html
   * <p class="a b" data-x="{ observable.foo } { observable.bar }">
   * 	<span class="b c d">Span</span>
   * </p>
   * ```
   *
   * @param template An existing template instance to be extended.
   * @param def Additional definition to be applied to a template.
   */
  static extend(template, def) {
    if (template._isRendered) {
      throw new CKEditorError("template-extend-render", [this, template]);
    }
    extendTemplate(template, normalize(clone(def)));
  }
  /**
   * Renders a DOM Node (either an HTML element or text) out of the template.
   *
   * @param data Rendering data.
   */
  _renderNode(data) {
    let isInvalid;
    if (data.node) {
      isInvalid = this.tag && this.text;
    } else {
      isInvalid = this.tag ? this.text : !this.text;
    }
    if (isInvalid) {
      throw new CKEditorError("ui-template-wrong-syntax", this);
    }
    if (this.text) {
      return this._renderText(data);
    } else {
      return this._renderElement(data);
    }
  }
  /**
   * Renders an HTML element out of the template.
   *
   * @param data Rendering data.
   */
  _renderElement(data) {
    let node = data.node;
    if (!node) {
      node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);
    }
    this._renderAttributes(data);
    this._renderElementChildren(data);
    this._setUpListeners(data);
    return node;
  }
  /**
   * Renders a text node out of {@link module:ui/template~Template#text}.
   *
   * @param data Rendering data.
   */
  _renderText(data) {
    let node = data.node;
    if (node) {
      data.revertData.text = node.textContent;
    } else {
      node = data.node = document.createTextNode("");
    }
    if (hasTemplateBinding(this.text)) {
      this._bindToObservable({
        schema: this.text,
        updater: getTextUpdater(node),
        data
      });
    } else {
      node.textContent = this.text.join("");
    }
    return node;
  }
  /**
   * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
   *
   * @param data Rendering data.
   */
  _renderAttributes(data) {
    if (!this.attributes) {
      return;
    }
    const node = data.node;
    const revertData = data.revertData;
    for (const attrName in this.attributes) {
      const domAttrValue = node.getAttribute(attrName);
      const attrValue = this.attributes[attrName];
      if (revertData) {
        revertData.attributes[attrName] = domAttrValue;
      }
      const attrNs = isNamespaced(attrValue) ? attrValue[0].ns : null;
      if (hasTemplateBinding(attrValue)) {
        const valueToBind = isNamespaced(attrValue) ? attrValue[0].value : attrValue;
        if (revertData && shouldExtend(attrName)) {
          valueToBind.unshift(domAttrValue);
        }
        this._bindToObservable({
          schema: valueToBind,
          updater: getAttributeUpdater(node, attrName, attrNs),
          data
        });
      } else if (attrName == "style" && typeof attrValue[0] !== "string") {
        this._renderStyleAttribute(attrValue[0], data);
      } else {
        if (revertData && domAttrValue && shouldExtend(attrName)) {
          attrValue.unshift(domAttrValue);
        }
        const value = attrValue.map((val) => val ? val.value || val : val).reduce((prev, next) => prev.concat(next), []).reduce(arrayValueReducer, "");
        if (!isFalsy(value)) {
          node.setAttributeNS(attrNs, attrName, value);
        }
      }
    }
  }
  /**
   * Renders the `style` attribute of an HTML element based on
   * {@link module:ui/template~Template#attributes}.
   *
   * A style attribute is an object with static values:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: 'red'
   * 	}
   * }
   * ```
   *
   * or values bound to {@link module:ui/model~Model} properties:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: bind.to( ... )
   * 	}
   * }
   * ```
   *
   * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
   * needed.
   *
   * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
   * @param data Rendering data.
   */
  _renderStyleAttribute(styles, data) {
    const node = data.node;
    for (const styleName in styles) {
      const styleValue = styles[styleName];
      if (hasTemplateBinding(styleValue)) {
        this._bindToObservable({
          schema: [styleValue],
          updater: getStyleUpdater(node, styleName),
          data
        });
      } else {
        node.style[styleName] = styleValue;
      }
    }
  }
  /**
   * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
   *
   * @param data Rendering data.
   */
  _renderElementChildren(data) {
    const node = data.node;
    const container = data.intoFragment ? document.createDocumentFragment() : node;
    const isApplying = data.isApplying;
    let childIndex = 0;
    for (const child of this.children) {
      if (isViewCollection(child)) {
        if (!isApplying) {
          child.setParent(node);
          for (const view of child) {
            container.appendChild(view.element);
          }
        }
      } else if (isView(child)) {
        if (!isApplying) {
          if (!child.isRendered) {
            child.render();
          }
          container.appendChild(child.element);
        }
      } else if (isNode(child)) {
        container.appendChild(child);
      } else {
        if (isApplying) {
          const revertData = data.revertData;
          const childRevertData = getEmptyRevertData();
          revertData.children.push(childRevertData);
          child._renderNode({
            intoFragment: false,
            node: container.childNodes[childIndex++],
            isApplying: true,
            revertData: childRevertData
          });
        } else {
          container.appendChild(child.render());
        }
      }
    }
    if (data.intoFragment) {
      node.appendChild(container);
    }
  }
  /**
   * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
   * on an HTML element.
   *
   * @param data Rendering data.
   */
  _setUpListeners(data) {
    if (!this.eventListeners) {
      return;
    }
    for (const key in this.eventListeners) {
      const revertBindings = this.eventListeners[key].map((schemaItem) => {
        const [domEvtName, domSelector] = key.split("@");
        return schemaItem.activateDomEventListener(domEvtName, domSelector, data);
      });
      if (data.revertData) {
        data.revertData.bindings.push(revertBindings);
      }
    }
  }
  /**
   * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
   * activates the binding and sets its initial value.
   *
   * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
   * text node `textContent`.
   *
   * @param options Binding options.
   * @param options.updater A function which updates the DOM (like attribute or text).
   * @param options.data Rendering data.
   */
  _bindToObservable({ schema, updater, data }) {
    const revertData = data.revertData;
    syncValueSchemaValue(schema, updater, data);
    const revertBindings = schema.filter((item) => !isFalsy(item)).filter((item) => item.observable).map((templateBinding) => templateBinding.activateAttributeListener(schema, updater, data));
    if (revertData) {
      revertData.bindings.push(revertBindings);
    }
  }
  /**
   * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
   * return it to the original state.
   *
   * @param node A node to be reverted.
   * @param revertData An object that stores information about what changes have been made by
   * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
   */
  _revertTemplateFromNode(node, revertData) {
    for (const binding of revertData.bindings) {
      for (const revertBinding of binding) {
        revertBinding();
      }
    }
    if (revertData.text) {
      node.textContent = revertData.text;
      return;
    }
    const element = node;
    for (const attrName in revertData.attributes) {
      const attrValue = revertData.attributes[attrName];
      if (attrValue === null) {
        element.removeAttribute(attrName);
      } else {
        element.setAttribute(attrName, attrValue);
      }
    }
    for (let i = 0; i < revertData.children.length; ++i) {
      this._revertTemplateFromNode(element.childNodes[i], revertData.children[i]);
    }
  }
};
var TemplateBinding = class {
  /**
   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
   *
   * @param def The definition of the binding.
   */
  constructor(def) {
    this.attribute = def.attribute;
    this.observable = def.observable;
    this.emitter = def.emitter;
    this.callback = def.callback;
  }
  /**
   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
   *
   * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
   * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}.
   */
  getValue(node) {
    const value = this.observable[this.attribute];
    return this.callback ? this.callback(value, node) : value;
  }
  /**
   * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
   * value of {@link module:ui/template~TemplateValueSchema}.
   *
   * @param schema A full schema to generate an attribute or text in the DOM.
   * @param updater A DOM updater function used to update the native DOM attribute or text.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateAttributeListener(schema, updater, data) {
    const callback = () => syncValueSchemaValue(schema, updater, data);
    this.emitter.listenTo(this.observable, `change:${this.attribute}`, callback);
    return () => {
      this.emitter.stopListening(this.observable, `change:${this.attribute}`, callback);
    };
  }
};
var TemplateToBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.eventNameOrFunction = def.eventNameOrFunction;
  }
  /**
   * Activates the listener for the native DOM event, which when fired, is propagated by
   * the {@link module:ui/template~TemplateBinding#emitter}.
   *
   * @param domEvtName The name of the native DOM event.
   * @param domSelector The selector in the DOM to filter delegated events.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateDomEventListener(domEvtName, domSelector, data) {
    const callback = (evt, domEvt) => {
      if (!domSelector || domEvt.target.matches(domSelector)) {
        if (typeof this.eventNameOrFunction == "function") {
          this.eventNameOrFunction(domEvt);
        } else {
          this.observable.fire(this.eventNameOrFunction, domEvt);
        }
      }
    };
    this.emitter.listenTo(data.node, domEvtName, callback);
    return () => {
      this.emitter.stopListening(data.node, domEvtName, callback);
    };
  }
};
var TemplateIfBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.valueIfTrue = def.valueIfTrue;
  }
  /**
   * @inheritDoc
   */
  getValue(node) {
    const value = super.getValue(node);
    return isFalsy(value) ? false : this.valueIfTrue || true;
  }
};
function hasTemplateBinding(schema) {
  if (!schema) {
    return false;
  }
  if (schema.value) {
    schema = schema.value;
  }
  if (Array.isArray(schema)) {
    return schema.some(hasTemplateBinding);
  } else if (schema instanceof TemplateBinding) {
    return true;
  }
  return false;
}
function getValueSchemaValue(schema, node) {
  return schema.map((schemaItem) => {
    if (schemaItem instanceof TemplateBinding) {
      return schemaItem.getValue(node);
    }
    return schemaItem;
  });
}
function syncValueSchemaValue(schema, updater, { node }) {
  const values = getValueSchemaValue(schema, node);
  let value;
  if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {
    value = values[0];
  } else {
    value = values.reduce(arrayValueReducer, "");
  }
  if (isFalsy(value)) {
    updater.remove();
  } else {
    updater.set(value);
  }
}
function getTextUpdater(node) {
  return {
    set(value) {
      node.textContent = value;
    },
    remove() {
      node.textContent = "";
    }
  };
}
function getAttributeUpdater(el, attrName, ns) {
  return {
    set(value) {
      el.setAttributeNS(ns, attrName, value);
    },
    remove() {
      el.removeAttributeNS(ns, attrName);
    }
  };
}
function getStyleUpdater(el, styleName) {
  return {
    set(value) {
      el.style[styleName] = value;
    },
    remove() {
      el.style[styleName] = null;
    }
  };
}
function clone(def) {
  const clone2 = cloneDeepWith_default(def, (value) => {
    if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {
      return value;
    }
  });
  return clone2;
}
function normalize(def) {
  if (typeof def == "string") {
    def = normalizePlainTextDefinition(def);
  } else if (def.text) {
    normalizeTextDefinition(def);
  }
  if (def.on) {
    def.eventListeners = normalizeListeners(def.on);
    delete def.on;
  }
  if (!def.text) {
    if (def.attributes) {
      normalizeAttributes(def.attributes);
    }
    const children = [];
    if (def.children) {
      if (isViewCollection(def.children)) {
        children.push(def.children);
      } else {
        for (const child of def.children) {
          if (isTemplate(child) || isView(child) || isNode(child)) {
            children.push(child);
          } else {
            children.push(new Template(child));
          }
        }
      }
    }
    def.children = children;
  }
  return def;
}
function normalizeAttributes(attributes) {
  for (const a in attributes) {
    if (attributes[a].value) {
      attributes[a].value = toArray(attributes[a].value);
    }
    arrayify(attributes, a);
  }
}
function normalizeListeners(listeners) {
  for (const l in listeners) {
    arrayify(listeners, l);
  }
  return listeners;
}
function normalizePlainTextDefinition(def) {
  return {
    text: [def]
  };
}
function normalizeTextDefinition(def) {
  def.text = toArray(def.text);
}
function arrayify(obj, key) {
  obj[key] = toArray(obj[key]);
}
function arrayValueReducer(prev, cur) {
  if (isFalsy(cur)) {
    return prev;
  } else if (isFalsy(prev)) {
    return cur;
  } else {
    return `${prev} ${cur}`;
  }
}
function extendObjectValueArray(obj, ext) {
  for (const a in ext) {
    if (obj[a]) {
      obj[a].push(...ext[a]);
    } else {
      obj[a] = ext[a];
    }
  }
}
function extendTemplate(template, def) {
  if (def.attributes) {
    if (!template.attributes) {
      template.attributes = {};
    }
    extendObjectValueArray(template.attributes, def.attributes);
  }
  if (def.eventListeners) {
    if (!template.eventListeners) {
      template.eventListeners = {};
    }
    extendObjectValueArray(template.eventListeners, def.eventListeners);
  }
  if (def.text) {
    template.text.push(...def.text);
  }
  if (def.children && def.children.length) {
    if (template.children.length != def.children.length) {
      throw new CKEditorError("ui-template-extend-children-mismatch", template);
    }
    let childIndex = 0;
    for (const childDef of def.children) {
      extendTemplate(template.children[childIndex++], childDef);
    }
  }
}
function isFalsy(value) {
  return !value && value !== 0;
}
function isView(item) {
  return item instanceof View;
}
function isTemplate(item) {
  return item instanceof Template;
}
function isViewCollection(item) {
  return item instanceof ViewCollection;
}
function isNamespaced(attrValue) {
  return isObject_default(attrValue[0]) && attrValue[0].ns;
}
function getEmptyRevertData() {
  return {
    children: [],
    bindings: [],
    attributes: {}
  };
}
function shouldExtend(attrName) {
  return attrName == "class" || attrName == "style";
}

// node_modules/@ckeditor/ckeditor5-ui/src/view.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/globals/globals.css";
var View = class extends DomEmitterMixin(ObservableMixin()) {
  /**
   * Creates an instance of the {@link module:ui/view~View} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super();
    this.element = null;
    this.isRendered = false;
    this.locale = locale;
    this.t = locale && locale.t;
    this._viewCollections = new Collection();
    this._unboundChildren = this.createCollection();
    this._viewCollections.on("add", (evt, collection) => {
      collection.locale = locale;
      collection.t = locale && locale.t;
    });
    this.decorate("render");
  }
  /**
   * Shorthand for {@link module:ui/template~Template.bind}, a binding
   * {@link module:ui/template~BindChain interface} pre–configured for the view instance.
   *
   * It provides {@link module:ui/template~BindChain#to `to()`} and
   * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
   * observable attributes and attach DOM listeners.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const bind = this.bindTemplate;
   *
   * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
   * 		// the state of the view in DOM.
   * 		this.set( {
   * 			elementClass: 'foo',
   * 		 	isEnabled: true
   * 		 } );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			attributes: {
   * 				// The class HTML attribute will follow elementClass
   * 				// and isEnabled view attributes.
   * 				class: [
   * 					bind.to( 'elementClass' )
   * 					bind.if( 'isEnabled', 'present-when-enabled' )
   * 				]
   * 			},
   *
   * 			on: {
   * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
   * 				click: bind.to( 'clicked' )
   * 			}
   * 		} );
   * 	}
   * }
   * ```
   */
  get bindTemplate() {
    if (this._bindTemplate) {
      return this._bindTemplate;
    }
    return this._bindTemplate = Template.bind(this, this);
  }
  /**
   * Creates a new collection of views, which can be used as
   * {@link module:ui/template~Template#children} of this view.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const child = new ChildView( locale );
   * 		this.items = this.createCollection( [ child ] );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// `items` collection will render here.
   * 			children: this.items
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   * view.render();
   *
   * // It will append <p><child#element></p> to the <body>.
   * document.body.appendChild( view.element );
   * ```
   *
   * @param views Initial views of the collection.
   * @returns A new collection of view instances.
   */
  createCollection(views) {
    const collection = new ViewCollection(views);
    this._viewCollections.add(collection);
    return collection;
  }
  /**
   * Registers a new child view under the view instance. Once registered, a child
   * view is managed by its parent, including {@link #render rendering}
   * and {@link #destroy destruction}.
   *
   * To revert this, use {@link #deregisterChild}.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( { tag: 'p' } );
   *
   * 		// Register the children.
   * 		this.registerChild( [ this.childA, this.childB ] );
   * 	}
   *
   * 	render() {
   * 		super.render();
   *
   * 		this.element.appendChild( this.childA.element );
   * 		this.element.appendChild( this.childB.element );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   *
   * view.render();
   *
   * // Will append <p><childA#element><b></b><childB#element></p>.
   * document.body.appendChild( view.element );
   * ```
   *
   * **Note**: There's no need to add child views if they're already referenced in the
   * {@link #template}:
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// These children will be added automatically. There's no
   * 			// need to call {@link #registerChild} for any of them.
   * 			children: [ this.childA, this.childB ]
   * 		} );
   * 	}
   *
   * 	// ...
   * }
   * ```
   *
   * @param children Children views to be registered.
   */
  registerChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.add(child);
    }
  }
  /**
   * The opposite of {@link #registerChild}. Removes a child view from this view instance.
   * Once removed, the child is no longer managed by its parent, e.g. it can safely
   * become a child of another parent view.
   *
   * @see #registerChild
   * @param children Child views to be removed.
   */
  deregisterChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.remove(child);
    }
  }
  /**
   * Sets the {@link #template} of the view with with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * view.setTemplate( definition );
   * ```
   *
   * @param definition Definition of view's template.
   */
  setTemplate(definition) {
    this.template = new Template(definition);
  }
  /**
   * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
   * with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * Template.extend( view.template, definition );
   * ```
   *
   * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
   *
   * @param definition Definition which extends the {@link #template}.
   */
  extendTemplate(definition) {
    Template.extend(this.template, definition);
  }
  /**
   * Recursively renders the view.
   *
   * Once the view is rendered:
   * * the {@link #element} becomes an HTML element out of {@link #template},
   * * the {@link #isRendered} flag is set `true`.
   *
   * **Note**: The children of the view:
   * * defined directly in the {@link #template}
   * * residing in collections created by the {@link #createCollection} method,
   * * and added by {@link #registerChild}
   * are also rendered in the process.
   *
   * In general, `render()` method is the right place to keep the code which refers to the
   * {@link #element} and should be executed at the very beginning of the view's life cycle.
   *
   * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
   * the view is rendered. To allow an early customization of the view (e.g. by its parent),
   * such references should be done in `render()`.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor() {
   * 		this.setTemplate( {
   * 			// ...
   * 		} );
   * 	},
   *
   * 	render() {
   * 		// View#element becomes available.
   * 		super.render();
   *
   * 		// The "scroll" listener depends on #element.
   * 		this.listenTo( window, 'scroll', () => {
   * 			// A reference to #element would render the #template and make it non-extendable.
   * 			if ( window.scrollY > 0 ) {
   * 				this.element.scrollLeft = 100;
   * 			} else {
   * 				this.element.scrollLeft = 0;
   * 			}
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView();
   *
   * // Let's customize the view before it gets rendered.
   * view.extendTemplate( {
   * 	attributes: {
   * 		class: [
   * 			'additional-class'
   * 		]
   * 	}
   * } );
   *
   * // Late rendering allows customization of the view.
   * view.render();
   * ```
   */
  render() {
    if (this.isRendered) {
      throw new CKEditorError("ui-view-render-already-rendered", this);
    }
    if (this.template) {
      this.element = this.template.render();
      this.registerChild(this.template.getViews());
    }
    this.isRendered = true;
  }
  /**
   * Recursively destroys the view instance and child views added by {@link #registerChild} and
   * residing in collections created by the {@link #createCollection}.
   *
   * Destruction disables all event listeners:
   * * created on the view, e.g. `view.on( 'event', () => {} )`,
   * * defined in the {@link #template} for DOM events.
   */
  destroy() {
    this.stopListening();
    this._viewCollections.map((c) => c.destroy());
    if (this.template && this.template._revertData) {
      this.template.revert(this.element);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/bodycollection.js
var BodyCollection = class extends ViewCollection {
  /**
   * Creates a new instance of the {@link module:ui/editorui/bodycollection~BodyCollection}.
   *
   * @param locale The {@link module:core/editor/editor~Editor editor's locale} instance.
   * @param initialItems The initial items of the collection.
   */
  constructor(locale, initialItems = []) {
    super(initialItems);
    this.locale = locale;
  }
  /**
   * The element holding elements of the body region.
   */
  get bodyCollectionContainer() {
    return this._bodyCollectionContainer;
  }
  /**
   * Attaches the body collection to the DOM body element. You need to execute this method to render the content of
   * the body collection.
   */
  attachToDom() {
    this._bodyCollectionContainer = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset_all",
          "ck-body",
          "ck-rounded-corners"
        ],
        dir: this.locale.uiLanguageDirection
      },
      children: this
    }).render();
    let wrapper = document.querySelector(".ck-body-wrapper");
    if (!wrapper) {
      wrapper = createElement(document, "div", { class: "ck-body-wrapper" });
      document.body.appendChild(wrapper);
    }
    wrapper.appendChild(this._bodyCollectionContainer);
  }
  /**
   * Detaches the collection from the DOM structure. Use this method when you do not need to use the body collection
   * anymore to clean-up the DOM structure.
   */
  detachFromDom() {
    super.destroy();
    if (this._bodyCollectionContainer) {
      this._bodyCollectionContainer.remove();
    }
    const wrapper = document.querySelector(".ck-body-wrapper");
    if (wrapper && wrapper.childElementCount == 0) {
      wrapper.remove();
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/icon/iconview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css";
var IconView = class _IconView extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.set("content", "");
    this.set("viewBox", "0 0 20 20");
    this.set("fillColor", "");
    this.set("isColorInherited", true);
    this.setTemplate({
      tag: "svg",
      ns: "http://www.w3.org/2000/svg",
      attributes: {
        class: [
          "ck",
          "ck-icon",
          // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          "ck-reset_all-excluded",
          // The class to remove the dynamic color inheritance is toggleable
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          bind.if("isColorInherited", "ck-icon_inherit-color")
        ],
        viewBox: bind.to("viewBox")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this._updateXMLContent();
    this._colorFillPaths();
    this.on("change:content", () => {
      this._updateXMLContent();
      this._colorFillPaths();
    });
    this.on("change:fillColor", () => {
      this._colorFillPaths();
    });
  }
  /**
   * Updates the {@link #element} with the value of {@link #content}.
   */
  _updateXMLContent() {
    if (this.content) {
      const parsed = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
      const svg = parsed.querySelector("svg");
      const viewBox = svg.getAttribute("viewBox");
      if (viewBox) {
        this.viewBox = viewBox;
      }
      for (const { name, value } of Array.from(svg.attributes)) {
        if (_IconView.presentationalAttributeNames.includes(name)) {
          this.element.setAttribute(name, value);
        }
      }
      while (this.element.firstChild) {
        this.element.removeChild(this.element.firstChild);
      }
      while (svg.childNodes.length > 0) {
        this.element.appendChild(svg.childNodes[0]);
      }
    }
  }
  /**
   * Fills all child `path.ck-icon__fill` with the `#fillColor`.
   */
  _colorFillPaths() {
    if (this.fillColor) {
      this.element.querySelectorAll(".ck-icon__fill").forEach((path) => {
        path.style.fill = this.fillColor;
      });
    }
  }
};
IconView.presentationalAttributeNames = [
  "alignment-baseline",
  "baseline-shift",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-rendering",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "opacity",
  "overflow",
  "paint-order",
  "pointer-events",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-overflow",
  "text-rendering",
  "transform",
  "unicode-bidi",
  "vector-effect",
  "visibility",
  "white-space",
  "word-spacing",
  "writing-mode"
];

// node_modules/@ckeditor/ckeditor5-ui/src/button/buttonview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css";
var ButtonView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this._focusDelayed = null;
    const bind = this.bindTemplate;
    const ariaLabelUid = uid();
    this.set("ariaChecked", void 0);
    this.set("ariaLabel", void 0);
    this.set("ariaLabelledBy", `ck-editor__aria-label_${ariaLabelUid}`);
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isVisible", true);
    this.set("isToggleable", false);
    this.set("keystroke", void 0);
    this.set("label", void 0);
    this.set("role", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.set("withKeystroke", false);
    this.children = this.createCollection();
    this.labelView = this._createLabelView();
    this.iconView = new IconView();
    this.iconView.extendTemplate({
      attributes: {
        class: "ck-button__icon"
      }
    });
    this.keystrokeView = this._createKeystrokeView();
    this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
    const template = {
      tag: "button",
      attributes: {
        class: [
          "ck",
          "ck-button",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("isVisible", "ck-hidden", (value) => !value),
          bind.to("isOn", (value) => value ? "ck-on" : "ck-off"),
          bind.if("withText", "ck-button_with-text"),
          bind.if("withKeystroke", "ck-button_with-keystroke")
        ],
        role: bind.to("role"),
        type: bind.to("type", (value) => value ? value : "button"),
        tabindex: bind.to("tabindex"),
        "aria-label": bind.to("ariaLabel"),
        "aria-labelledby": bind.to("ariaLabelledBy"),
        "aria-disabled": bind.if("isEnabled", true, (value) => !value),
        "aria-checked": bind.to("isOn"),
        "aria-pressed": bind.to("isOn", (value) => this.isToggleable ? String(!!value) : false),
        "data-cke-tooltip-text": bind.to("_tooltipString"),
        "data-cke-tooltip-position": bind.to("tooltipPosition")
      },
      children: this.children,
      on: {
        click: bind.to((evt) => {
          if (this.isEnabled) {
            this.fire("execute");
          } else {
            evt.preventDefault();
          }
        })
      }
    };
    if (env_default.isSafari) {
      if (!this._focusDelayed) {
        this._focusDelayed = delay(() => this.focus(), 0);
      }
      template.on.mousedown = bind.to(() => {
        this._focusDelayed();
      });
      template.on.mouseup = bind.to(() => {
        this._focusDelayed.cancel();
      });
    }
    this.setTemplate(template);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    if (this.icon) {
      this.iconView.bind("content").to(this, "icon");
      this.children.add(this.iconView);
    }
    this.children.add(this.labelView);
    if (this.withKeystroke && this.keystroke) {
      this.children.add(this.keystrokeView);
    }
  }
  /**
   * Focuses the {@link #element} of the button.
   */
  focus() {
    this.element.focus();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    if (this._focusDelayed) {
      this._focusDelayed.cancel();
    }
    super.destroy();
  }
  /**
   * Creates a label view instance and binds it with button attributes.
   */
  _createLabelView() {
    const labelView = new View();
    const bind = this.bindTemplate;
    labelView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__label"
        ],
        style: bind.to("labelStyle"),
        id: this.ariaLabelledBy
      },
      children: [
        {
          text: bind.to("label")
        }
      ]
    });
    return labelView;
  }
  /**
   * Creates a view that displays a keystroke next to a {@link #labelView label }
   * and binds it with button attributes.
   */
  _createKeystrokeView() {
    const keystrokeView = new View();
    keystrokeView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__keystroke"
        ]
      },
      children: [
        {
          text: this.bindTemplate.to("keystroke", (text) => getEnvKeystrokeText(text))
        }
      ]
    });
    return keystrokeView;
  }
  /**
   * Gets the text for the tooltip from the combination of
   * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
   *
   * @see #tooltip
   * @see #_tooltipString
   * @param tooltip Button tooltip.
   * @param label Button label.
   * @param keystroke Button keystroke.
   */
  _getTooltipString(tooltip, label, keystroke) {
    if (tooltip) {
      if (typeof tooltip == "string") {
        return tooltip;
      } else {
        if (keystroke) {
          keystroke = getEnvKeystrokeText(keystroke);
        }
        if (tooltip instanceof Function) {
          return tooltip(label, keystroke);
        } else {
          return `${label}${keystroke ? ` (${keystroke})` : ""}`;
        }
      }
    }
    return "";
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/button/switchbuttonview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css";
var SwitchButtonView = class extends ButtonView {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.isToggleable = true;
    this.toggleSwitchView = this._createToggleView();
    this.extendTemplate({
      attributes: {
        class: "ck-switchbutton"
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.add(this.toggleSwitchView);
  }
  /**
   * Creates a toggle child view.
   */
  _createToggleView() {
    const toggleSwitchView = new View();
    toggleSwitchView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__toggle"
        ]
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__toggle__inner"
            ]
          }
        }
      ]
    });
    return toggleSwitchView;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/utils.js
function getLocalizedColorOptions(locale, options) {
  const t = locale.t;
  const localizedColorNames = {
    Black: t("Black"),
    "Dim grey": t("Dim grey"),
    Grey: t("Grey"),
    "Light grey": t("Light grey"),
    White: t("White"),
    Red: t("Red"),
    Orange: t("Orange"),
    Yellow: t("Yellow"),
    "Light green": t("Light green"),
    Green: t("Green"),
    Aquamarine: t("Aquamarine"),
    Turquoise: t("Turquoise"),
    "Light blue": t("Light blue"),
    Blue: t("Blue"),
    Purple: t("Purple")
  };
  return options.map((colorOption) => {
    const label = localizedColorNames[colorOption.label];
    if (label && label != colorOption.label) {
      colorOption.label = label;
    }
    return colorOption;
  });
}
function normalizeColorOptions(options) {
  return options.map(normalizeSingleColorDefinition).filter((option) => !!option);
}
function normalizeSingleColorDefinition(color) {
  if (typeof color === "string") {
    return {
      model: color,
      label: color,
      hasBorder: false,
      view: {
        name: "span",
        styles: {
          color
        }
      }
    };
  } else {
    return {
      model: color.color,
      label: color.label || color.color,
      hasBorder: color.hasBorder === void 0 ? false : color.hasBorder,
      view: {
        name: "span",
        styles: {
          color: `${color.color}`
        }
      }
    };
  }
}

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/dropdownbuttonview.js
import dropdownArrowIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
var DropdownButtonView = class extends ButtonView {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.arrowView = this._createArrowView();
    this.extendTemplate({
      attributes: {
        "aria-haspopup": true,
        "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value))
      }
    });
    this.delegate("execute").to(this, "open");
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.add(this.arrowView);
  }
  /**
   * Creates a {@link module:ui/icon/iconview~IconView} instance as {@link #arrowView}.
   */
  _createArrowView() {
    const arrowView = new IconView();
    arrowView.content = dropdownArrowIcon;
    arrowView.extendTemplate({
      attributes: {
        class: "ck-dropdown__arrow"
      }
    });
    return arrowView;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarseparatorview.js
var ToolbarSeparatorView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__separator"
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/focuscycler.js
var FocusCycler = class {
  /**
   * Creates an instance of the focus cycler utility.
   *
   * @param options Configuration options.
   */
  constructor(options) {
    this.focusables = options.focusables;
    this.focusTracker = options.focusTracker;
    this.keystrokeHandler = options.keystrokeHandler;
    this.actions = options.actions;
    if (options.actions && options.keystrokeHandler) {
      for (const methodName in options.actions) {
        let actions = options.actions[methodName];
        if (typeof actions == "string") {
          actions = [actions];
        }
        for (const keystroke of actions) {
          options.keystrokeHandler.set(keystroke, (data, cancel) => {
            this[methodName]();
            cancel();
          });
        }
      }
    }
  }
  /**
   * Returns the first focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get first() {
    return this.focusables.find(isFocusable) || null;
  }
  /**
   * Returns the last focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get last() {
    return this.focusables.filter(isFocusable).slice(-1)[0] || null;
  }
  /**
   * Returns the next focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get next() {
    return this._getFocusableItem(1);
  }
  /**
   * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get previous() {
    return this._getFocusableItem(-1);
  }
  /**
   * An index of the view in the {@link #focusables} which is focused according
   * to {@link #focusTracker}. Returns `null` when there is no such view.
   */
  get current() {
    let index = null;
    if (this.focusTracker.focusedElement === null) {
      return null;
    }
    this.focusables.find((view, viewIndex) => {
      const focused = view.element === this.focusTracker.focusedElement;
      if (focused) {
        index = viewIndex;
      }
      return focused;
    });
    return index;
  }
  /**
   * Focuses the {@link #first} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusFirst() {
    this._focus(this.first);
  }
  /**
   * Focuses the {@link #last} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusLast() {
    this._focus(this.last);
  }
  /**
   * Focuses the {@link #next} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusNext() {
    this._focus(this.next);
  }
  /**
   * Focuses the {@link #previous} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusPrevious() {
    this._focus(this.previous);
  }
  /**
   * Focuses the given view if it exists.
   */
  _focus(view) {
    if (view) {
      view.focus();
    }
  }
  /**
   * Returns the next or previous focusable view in {@link #focusables} with respect
   * to {@link #current}.
   *
   * @param step Either `1` for checking forward from {@link #current} or `-1` for checking backwards.
   */
  _getFocusableItem(step) {
    const current = this.current;
    const collectionLength = this.focusables.length;
    if (!collectionLength) {
      return null;
    }
    if (current === null) {
      return this[step === 1 ? "first" : "last"];
    }
    let index = (current + collectionLength + step) % collectionLength;
    do {
      const view = this.focusables.get(index);
      if (isFocusable(view)) {
        return view;
      }
      index = (index + collectionLength + step) % collectionLength;
    } while (index !== current);
    return null;
  }
};
function isFocusable(view) {
  return !!(view.focus && isVisible(view.element));
}

// node_modules/@ckeditor/ckeditor5-ui/src/list/listview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css";
var ListView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusCycler = new FocusCycler({
      focusables: this.items,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate list items backwards using the arrowup key.
        focusPrevious: "arrowup",
        // Navigate toolbar items forwards using the arrowdown key.
        focusNext: "arrowdown"
      }
    });
    this.set("ariaLabel", void 0);
    this.set("role", void 0);
    this.setTemplate({
      tag: "ul",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-list"
        ],
        role: bind.to("role"),
        "aria-label": bind.to("ariaLabel")
      },
      children: this.items
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const item of this.items) {
      this.focusTracker.add(item.element);
    }
    this.items.on("add", (evt, item) => {
      this.focusTracker.add(item.element);
    });
    this.items.on("remove", (evt, item) => {
      this.focusTracker.remove(item.element);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable in {@link #items}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/list/listitemview.js
var ListItemView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isVisible", true);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__item",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ],
        role: "presentation"
      },
      children: this.children
    });
  }
  /**
   * Focuses the list item.
   */
  focus() {
    this.children.first.focus();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/splitbuttonview.js
import dropdownArrowIcon2 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css";
var SplitButtonView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isToggleable", false);
    this.set("isVisible", true);
    this.set("keystroke", void 0);
    this.set("withKeystroke", false);
    this.set("label", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.children = this.createCollection();
    this.actionView = this._createActionView();
    this.arrowView = this._createArrowView();
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-splitbutton",
          bind.to("class"),
          bind.if("isVisible", "ck-hidden", (value) => !value),
          this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")
        ]
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.add(this.actionView);
    this.children.add(this.arrowView);
    this.focusTracker.add(this.actionView.element);
    this.focusTracker.add(this.arrowView.element);
    this.keystrokes.listenTo(this.element);
    this.keystrokes.set("arrowright", (evt, cancel) => {
      if (this.focusTracker.focusedElement === this.actionView.element) {
        this.arrowView.focus();
        cancel();
      }
    });
    this.keystrokes.set("arrowleft", (evt, cancel) => {
      if (this.focusTracker.focusedElement === this.arrowView.element) {
        this.actionView.focus();
        cancel();
      }
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Focuses the {@link module:ui/button/buttonview~ButtonView#element} of the action part of split button.
   */
  focus() {
    this.actionView.focus();
  }
  /**
   * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #actionView} and binds it with main split button
   * attributes.
   */
  _createActionView() {
    const actionView = new ButtonView();
    actionView.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
    actionView.extendTemplate({
      attributes: {
        class: "ck-splitbutton__action"
      }
    });
    actionView.delegate("execute").to(this);
    return actionView;
  }
  /**
   * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #arrowView} and binds it with main split button
   * attributes.
   */
  _createArrowView() {
    const arrowView = new ButtonView();
    const bind = arrowView.bindTemplate;
    arrowView.icon = dropdownArrowIcon2;
    arrowView.extendTemplate({
      attributes: {
        class: [
          "ck-splitbutton__arrow"
        ],
        "data-cke-tooltip-disabled": bind.to("isOn"),
        "aria-haspopup": true,
        "aria-expanded": bind.to("isOn", (value) => String(value))
      }
    });
    arrowView.bind("isEnabled").to(this);
    arrowView.bind("label").to(this);
    arrowView.bind("tooltip").to(this);
    arrowView.delegate("execute").to(this, "open");
    return arrowView;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownpanelview.js
var DropdownPanelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isVisible", false);
    this.set("position", "se");
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-dropdown__panel",
          bind.to("position", (value) => `ck-dropdown__panel_${value}`),
          bind.if("isVisible", "ck-dropdown__panel-visible")
        ],
        tabindex: "-1"
      },
      children: this.children,
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: bind.to((evt) => {
          if (evt.target.tagName.toLocaleLowerCase() === "input") {
            return;
          }
          evt.preventDefault();
        })
      }
    });
  }
  /**
   * Focuses the first view in the {@link #children} collection.
   *
   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
   */
  focus() {
    if (this.children.length) {
      const firstChild = this.children.first;
      if (typeof firstChild.focus === "function") {
        firstChild.focus();
      } else {
        logWarning("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
      }
    }
  }
  /**
   * Focuses the view element or last item in view collection on opening dropdown's panel.
   *
   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
   */
  focusLast() {
    if (this.children.length) {
      const lastChild = this.children.last;
      if (typeof lastChild.focusLast === "function") {
        lastChild.focusLast();
      } else {
        lastChild.focus();
      }
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css";
var DropdownView = class _DropdownView extends View {
  /**
   * Creates an instance of the dropdown.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(locale, buttonView, panelView) {
    super(locale);
    const bind = this.bindTemplate;
    this.buttonView = buttonView;
    this.panelView = panelView;
    this.set("isOpen", false);
    this.set("isEnabled", true);
    this.set("class", void 0);
    this.set("id", void 0);
    this.set("panelPosition", "auto");
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dropdown",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value)
        ],
        id: bind.to("id"),
        "aria-describedby": bind.to("ariaDescribedById")
      },
      children: [
        buttonView,
        panelView
      ]
    });
    buttonView.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown__button"
        ],
        "data-cke-tooltip-disabled": bind.to("isOpen")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.buttonView.element);
    this.focusTracker.add(this.panelView.element);
    this.listenTo(this.buttonView, "open", () => {
      this.isOpen = !this.isOpen;
    });
    this.panelView.bind("isVisible").to(this, "isOpen");
    this.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen) {
        return;
      }
      if (this.panelPosition === "auto") {
        this.panelView.position = _DropdownView._getOptimalPosition({
          element: this.panelView.element,
          target: this.buttonView.element,
          fitInViewport: true,
          positions: this._panelPositions
        }).name;
      } else {
        this.panelView.position = this.panelPosition;
      }
    });
    this.keystrokes.listenTo(this.element);
    const closeDropdown = (data, cancel) => {
      if (this.isOpen) {
        this.isOpen = false;
        cancel();
      }
    };
    this.keystrokes.set("arrowdown", (data, cancel) => {
      if (this.buttonView.isEnabled && !this.isOpen) {
        this.isOpen = true;
        cancel();
      }
    });
    this.keystrokes.set("arrowright", (data, cancel) => {
      if (this.isOpen) {
        cancel();
      }
    });
    this.keystrokes.set("arrowleft", closeDropdown);
    this.keystrokes.set("esc", closeDropdown);
  }
  /**
   * Focuses the {@link #buttonView}.
   */
  focus() {
    this.buttonView.focus();
  }
  /**
   * Returns {@link #panelView panel} positions to be used by the
   * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
   * utility considering the direction of the language the UI of the editor is displayed in.
   */
  get _panelPositions() {
    const { south, north, southEast, southWest, northEast, northWest, southMiddleEast, southMiddleWest, northMiddleEast, northMiddleWest } = _DropdownView.defaultPanelPositions;
    if (this.locale.uiLanguageDirection !== "rtl") {
      return [
        southEast,
        southWest,
        southMiddleEast,
        southMiddleWest,
        south,
        northEast,
        northWest,
        northMiddleEast,
        northMiddleWest,
        north
      ];
    } else {
      return [
        southWest,
        southEast,
        southMiddleWest,
        southMiddleEast,
        south,
        northWest,
        northEast,
        northMiddleWest,
        northMiddleEast,
        north
      ];
    }
  }
};
DropdownView.defaultPanelPositions = {
  south: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "s"
    };
  },
  southEast: (buttonRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left,
      name: "se"
    };
  },
  southWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "sw"
    };
  },
  southMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "sme"
    };
  },
  southMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "smw"
    };
  },
  north: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "n"
    };
  },
  northEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left,
      name: "ne"
    };
  },
  northWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "nw"
    };
  },
  northMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "nme"
    };
  },
  northMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "nmw"
    };
  }
};
DropdownView._getOptimalPosition = getOptimalPosition;

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarlinebreakview.js
var ToolbarLineBreakView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__line-break"
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/preventdefault.js
function preventDefault(view) {
  return view.bindTemplate.to((evt) => {
    if (evt.target === view.element) {
      evt.preventDefault();
    }
  });
}

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/normalizetoolbarconfig.js
function normalizeToolbarConfig(config) {
  if (Array.isArray(config)) {
    return {
      items: config,
      removeItems: []
    };
  }
  if (!config) {
    return {
      items: [],
      removeItems: []
    };
  }
  return Object.assign({
    items: [],
    removeItems: []
  }, config);
}

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css";
var { threeVerticalDots } = icons;
var NESTED_TOOLBAR_ICONS = {
  alignLeft: icons.alignLeft,
  bold: icons.bold,
  importExport: icons.importExport,
  paragraph: icons.paragraph,
  plus: icons.plus,
  text: icons.text,
  threeVerticalDots: icons.threeVerticalDots
};
var ToolbarView = class extends View {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   * @param options Configuration options of the toolbar.
   */
  constructor(locale, options) {
    super(locale);
    const bind = this.bindTemplate;
    const t = this.t;
    this.options = options || {};
    this.set("ariaLabel", t("Editor toolbar"));
    this.set("maxWidth", "auto");
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.set("class", void 0);
    this.set("isCompact", false);
    this.itemsView = new ItemsView(locale);
    this.children = this.createCollection();
    this.children.add(this.itemsView);
    this.focusables = this.createCollection();
    const isRtl = locale.uiLanguageDirection === "rtl";
    this._focusCycler = new FocusCycler({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate toolbar items backwards using the arrow[left,up] keys.
        focusPrevious: [isRtl ? "arrowright" : "arrowleft", "arrowup"],
        // Navigate toolbar items forwards using the arrow[right,down] keys.
        focusNext: [isRtl ? "arrowleft" : "arrowright", "arrowdown"]
      }
    });
    const classes = [
      "ck",
      "ck-toolbar",
      bind.to("class"),
      bind.if("isCompact", "ck-toolbar_compact")
    ];
    if (this.options.shouldGroupWhenFull && this.options.isFloating) {
      classes.push("ck-toolbar_floating");
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: classes,
        role: "toolbar",
        "aria-label": bind.to("ariaLabel"),
        style: {
          maxWidth: bind.to("maxWidth")
        },
        tabindex: -1
      },
      children: this.children,
      on: {
        // https://github.com/ckeditor/ckeditor5-ui/issues/206
        mousedown: preventDefault(this)
      }
    });
    this._behavior = this.options.shouldGroupWhenFull ? new DynamicGrouping(this) : new StaticLayout(this);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.element);
    for (const item of this.items) {
      this.focusTracker.add(item.element);
    }
    this.items.on("add", (evt, item) => {
      this.focusTracker.add(item.element);
    });
    this.items.on("remove", (evt, item) => {
      this.focusTracker.remove(item.element);
    });
    this.keystrokes.listenTo(this.element);
    this._behavior.render(this);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._behavior.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
    return super.destroy();
  }
  /**
   * Focuses the first focusable in {@link #focusables}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable in {@link #focusables}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
   * A utility that expands the plain toolbar configuration into
   * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
   *
   * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration. When present, applies
   * to this toolbar and all nested ones as well.
   */
  fillFromConfig(itemsOrConfig, factory, removeItems) {
    this.items.addMany(this._buildItemsFromConfig(itemsOrConfig, factory, removeItems));
  }
  /**
   * A utility that expands the plain toolbar configuration into a list of view items using a given component factory.
   *
   * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration. When present, applies
   * to this toolbar and all nested ones as well.
   */
  _buildItemsFromConfig(itemsOrConfig, factory, removeItems) {
    const config = normalizeToolbarConfig(itemsOrConfig);
    const normalizedRemoveItems = removeItems || config.removeItems;
    const itemsToAdd = this._cleanItemsConfiguration(config.items, factory, normalizedRemoveItems).map((item) => {
      if (isObject_default(item)) {
        return this._createNestedToolbarDropdown(item, factory, normalizedRemoveItems);
      } else if (item === "|") {
        return new ToolbarSeparatorView();
      } else if (item === "-") {
        return new ToolbarLineBreakView();
      }
      return factory.create(item);
    }).filter((item) => !!item);
    return itemsToAdd;
  }
  /**
   * Cleans up the {@link module:ui/toolbar/toolbarview~ToolbarView#items} of the toolbar by removing unwanted items and
   * duplicated (obsolete) separators or line breaks.
   *
   * @param items The toolbar items configuration.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration.
   * @returns Items after the clean-up.
   */
  _cleanItemsConfiguration(items, factory, removeItems) {
    const filteredItems = items.filter((item, idx, items2) => {
      if (item === "|") {
        return true;
      }
      if (removeItems.indexOf(item) !== -1) {
        return false;
      }
      if (item === "-") {
        if (this.options.shouldGroupWhenFull) {
          logWarning("toolbarview-line-break-ignored-when-grouping-items", items2);
          return false;
        }
        return true;
      }
      if (!isObject_default(item) && !factory.has(item)) {
        logWarning("toolbarview-item-unavailable", { item });
        return false;
      }
      return true;
    });
    return this._cleanSeparatorsAndLineBreaks(filteredItems);
  }
  /**
   * Remove leading, trailing, and duplicated separators (`-` and `|`).
   *
   * @returns Toolbar items after the separator and line break clean-up.
   */
  _cleanSeparatorsAndLineBreaks(items) {
    const nonSeparatorPredicate = (item) => item !== "-" && item !== "|";
    const count = items.length;
    const firstCommandItemIndex = items.findIndex(nonSeparatorPredicate);
    if (firstCommandItemIndex === -1) {
      return [];
    }
    const lastCommandItemIndex = count - items.slice().reverse().findIndex(nonSeparatorPredicate);
    return items.slice(firstCommandItemIndex, lastCommandItemIndex).filter((name, idx, items2) => {
      if (nonSeparatorPredicate(name)) {
        return true;
      }
      const isDuplicated = idx > 0 && items2[idx - 1] === name;
      return !isDuplicated;
    });
  }
  /**
   * Creates a user-defined dropdown containing a toolbar with items.
   *
   * @param definition A definition of the nested toolbar dropdown.
   * @param definition.label A label of the dropdown.
   * @param definition.icon An icon of the drop-down. One of 'bold', 'plus', 'text', 'importExport', 'alignLeft',
   * 'paragraph' or an SVG string. When `false` is passed, no icon will be used.
   * @param definition.withText When set `true`, the label of the dropdown will be visible. See
   * {@link module:ui/button/buttonview~ButtonView#withText} to learn more.
   * @param definition.tooltip A tooltip of the dropdown button. See
   * {@link module:ui/button/buttonview~ButtonView#tooltip} to learn more. Defaults to `true`.
   * @param componentFactory Component factory used to create items
   * of the nested toolbar.
   */
  _createNestedToolbarDropdown(definition, componentFactory, removeItems) {
    let { label, icon, items, tooltip = true, withText = false } = definition;
    items = this._cleanItemsConfiguration(items, componentFactory, removeItems);
    if (!items.length) {
      return null;
    }
    const locale = this.locale;
    const dropdownView = createDropdown(locale);
    if (!label) {
      logWarning("toolbarview-nested-toolbar-dropdown-missing-label", definition);
    }
    dropdownView.class = "ck-toolbar__nested-toolbar-dropdown";
    dropdownView.buttonView.set({
      label,
      tooltip,
      withText: !!withText
    });
    if (icon !== false) {
      dropdownView.buttonView.icon = NESTED_TOOLBAR_ICONS[icon] || icon || threeVerticalDots;
    } else {
      dropdownView.buttonView.withText = true;
    }
    addToolbarToDropdown(dropdownView, () => dropdownView.toolbarView._buildItemsFromConfig(items, componentFactory, removeItems));
    return dropdownView;
  }
};
var ItemsView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__items"
        ]
      },
      children: this.children
    });
  }
};
var StaticLayout = class {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar
   * behavior.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  constructor(view) {
    const bind = view.bindTemplate;
    view.set("isVertical", false);
    view.itemsView.children.bindTo(view.items).using((item) => item);
    view.focusables.bindTo(view.items).using((item) => item);
    view.extendTemplate({
      attributes: {
        class: [
          // When vertical, the toolbar has an additional CSS class.
          bind.if("isVertical", "ck-toolbar_vertical")
        ]
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
  }
  /**
   * @inheritDoc
   */
  destroy() {
  }
};
var DynamicGrouping = class {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar
   * behavior.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  constructor(view) {
    this.resizeObserver = null;
    this.cachedPadding = null;
    this.shouldUpdateGroupingOnNextResize = false;
    this.view = view;
    this.viewChildren = view.children;
    this.viewFocusables = view.focusables;
    this.viewItemsView = view.itemsView;
    this.viewFocusTracker = view.focusTracker;
    this.viewLocale = view.locale;
    this.ungroupedItems = view.createCollection();
    this.groupedItems = view.createCollection();
    this.groupedItemsDropdown = this._createGroupedItemsDropdown();
    view.itemsView.children.bindTo(this.ungroupedItems).using((item) => item);
    this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this));
    view.children.on("change", this._updateFocusCycleableItems.bind(this));
    view.items.on("change", (evt, changeData) => {
      const index = changeData.index;
      const added = Array.from(changeData.added);
      for (const removedItem of changeData.removed) {
        if (index >= this.ungroupedItems.length) {
          this.groupedItems.remove(removedItem);
        } else {
          this.ungroupedItems.remove(removedItem);
        }
      }
      for (let currentIndex = index; currentIndex < index + added.length; currentIndex++) {
        const addedItem = added[currentIndex - index];
        if (currentIndex > this.ungroupedItems.length) {
          this.groupedItems.add(addedItem, currentIndex - this.ungroupedItems.length);
        } else {
          this.ungroupedItems.add(addedItem, currentIndex);
        }
      }
      this._updateGrouping();
    });
    view.extendTemplate({
      attributes: {
        class: [
          // To group items dynamically, the toolbar needs a dedicated CSS class.
          "ck-toolbar_grouping"
        ]
      }
    });
  }
  /**
   * Enables dynamic items grouping based on the dimensions of the toolbar.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  render(view) {
    this.viewElement = view.element;
    this._enableGroupingOnResize();
    this._enableGroupingOnMaxWidthChange(view);
  }
  /**
   * Cleans up the internals used by this behavior.
   */
  destroy() {
    this.groupedItemsDropdown.destroy();
    this.resizeObserver.destroy();
  }
  /**
   * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,
   * and it will move them to the {@link #groupedItems} when it happens.
   *
   * At the same time, it will also check if there is enough space in the toolbar for the first of the
   * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row
   * without the toolbar wrapping.
   */
  _updateGrouping() {
    if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
      return;
    }
    if (!isVisible(this.viewElement)) {
      this.shouldUpdateGroupingOnNextResize = true;
      return;
    }
    const initialGroupedItemsCount = this.groupedItems.length;
    let wereItemsGrouped;
    while (this._areItemsOverflowing) {
      this._groupLastItem();
      wereItemsGrouped = true;
    }
    if (!wereItemsGrouped && this.groupedItems.length) {
      while (this.groupedItems.length && !this._areItemsOverflowing) {
        this._ungroupFirstItem();
      }
      if (this._areItemsOverflowing) {
        this._groupLastItem();
      }
    }
    if (this.groupedItems.length !== initialGroupedItemsCount) {
      this.view.fire("groupedItemsUpdate");
    }
  }
  /**
   * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,
   * for instance if the toolbar is narrower than its members. Returns `false` otherwise.
   */
  get _areItemsOverflowing() {
    if (!this.ungroupedItems.length) {
      return false;
    }
    const element = this.viewElement;
    const uiLanguageDirection = this.viewLocale.uiLanguageDirection;
    const lastChildRect = new Rect(element.lastChild);
    const toolbarRect = new Rect(element);
    if (!this.cachedPadding) {
      const computedStyle = global_default.window.getComputedStyle(element);
      const paddingProperty = uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft";
      this.cachedPadding = Number.parseInt(computedStyle[paddingProperty]);
    }
    if (uiLanguageDirection === "ltr") {
      return lastChildRect.right > toolbarRect.right - this.cachedPadding;
    } else {
      return lastChildRect.left < toolbarRect.left + this.cachedPadding;
    }
  }
  /**
   * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)
   * upon resize when there is little space available. Instead, the toolbar items are moved to the
   * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).
   *
   * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and "group"
   * them in the dropdown if necessary. It will also observe the browser window for size changes in
   * the future and respond to them by grouping more items or reverting already grouped back, depending
   * on the visual space available.
   */
  _enableGroupingOnResize() {
    let previousWidth;
    this.resizeObserver = new ResizeObserver(this.viewElement, (entry) => {
      if (!previousWidth || previousWidth !== entry.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
        this.shouldUpdateGroupingOnNextResize = false;
        this._updateGrouping();
        previousWidth = entry.contentRect.width;
      }
    });
    this._updateGrouping();
  }
  /**
   * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that
   * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.
   */
  _enableGroupingOnMaxWidthChange(view) {
    view.on("change:maxWidth", () => {
      this._updateGrouping();
    });
  }
  /**
   * When called, it will remove the last item from {@link #ungroupedItems} and move it back
   * to the {@link #groupedItems} collection.
   *
   * The opposite of {@link #_ungroupFirstItem}.
   */
  _groupLastItem() {
    if (!this.groupedItems.length) {
      this.viewChildren.add(new ToolbarSeparatorView());
      this.viewChildren.add(this.groupedItemsDropdown);
      this.viewFocusTracker.add(this.groupedItemsDropdown.element);
    }
    this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
  }
  /**
   * Moves the very first item belonging to {@link #groupedItems} back
   * to the {@link #ungroupedItems} collection.
   *
   * The opposite of {@link #_groupLastItem}.
   */
  _ungroupFirstItem() {
    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
    if (!this.groupedItems.length) {
      this.viewChildren.remove(this.groupedItemsDropdown);
      this.viewChildren.remove(this.viewChildren.last);
      this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
    }
  }
  /**
   * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}
   * collection when there is not enough space in the toolbar to display all items in a single row.
   */
  _createGroupedItemsDropdown() {
    const locale = this.viewLocale;
    const t = locale.t;
    const dropdown = createDropdown(locale);
    dropdown.class = "ck-toolbar__grouped-dropdown";
    dropdown.panelPosition = locale.uiLanguageDirection === "ltr" ? "sw" : "se";
    addToolbarToDropdown(dropdown, this.groupedItems);
    dropdown.buttonView.set({
      label: t("Show more items"),
      tooltip: true,
      tooltipPosition: locale.uiLanguageDirection === "rtl" ? "se" : "sw",
      icon: threeVerticalDots
    });
    return dropdown;
  }
  /**
   * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focus–cycleable items}
   * collection so it represents the up–to–date state of the UI from the perspective of the user.
   *
   * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,
   * it must be subject to focus cycling in the toolbar.
   *
   * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation
   * to learn more about the purpose of this method.
   */
  _updateFocusCycleableItems() {
    this.viewFocusables.clear();
    this.ungroupedItems.map((item) => {
      this.viewFocusables.add(item);
    });
    if (this.groupedItems.length) {
      this.viewFocusables.add(this.groupedItemsDropdown);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/list/listseparatorview.js
var ListSeparatorView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__separator"
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/utils.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/listdropdown.css";
function createDropdown(locale, ButtonClass = DropdownButtonView) {
  const buttonView = new ButtonClass(locale);
  const panelView = new DropdownPanelView(locale);
  const dropdownView = new DropdownView(locale, buttonView, panelView);
  buttonView.bind("isEnabled").to(dropdownView);
  if (buttonView instanceof SplitButtonView) {
    buttonView.arrowView.bind("isOn").to(dropdownView, "isOpen");
  } else {
    buttonView.bind("isOn").to(dropdownView, "isOpen");
  }
  addDefaultBehavior(dropdownView);
  return dropdownView;
}
function addToolbarToDropdown(dropdownView, buttonsOrCallback, options = {}) {
  dropdownView.extendTemplate({
    attributes: {
      class: ["ck-toolbar-dropdown"]
    }
  });
  if (dropdownView.isOpen) {
    addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options);
  } else {
    dropdownView.once("change:isOpen", () => addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options), { priority: "highest" });
  }
  if (options.enableActiveItemFocusOnDropdownOpen) {
    focusChildOnDropdownOpen(dropdownView, () => dropdownView.toolbarView.items.find((item) => item.isOn));
  }
}
function addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options) {
  const locale = dropdownView.locale;
  const t = locale.t;
  const toolbarView = dropdownView.toolbarView = new ToolbarView(locale);
  const buttons = typeof buttonsOrCallback == "function" ? buttonsOrCallback() : buttonsOrCallback;
  toolbarView.ariaLabel = options.ariaLabel || t("Dropdown toolbar");
  if (options.maxWidth) {
    toolbarView.maxWidth = options.maxWidth;
  }
  if (options.class) {
    toolbarView.class = options.class;
  }
  if (options.isCompact) {
    toolbarView.isCompact = options.isCompact;
  }
  if (options.isVertical) {
    toolbarView.isVertical = true;
  }
  if (buttons instanceof ViewCollection) {
    toolbarView.items.bindTo(buttons).using((item) => item);
  } else {
    toolbarView.items.addMany(buttons);
  }
  dropdownView.panelView.children.add(toolbarView);
  toolbarView.items.delegate("execute").to(dropdownView);
}
function addListToDropdown(dropdownView, itemsOrCallback, options = {}) {
  if (dropdownView.isOpen) {
    addListToOpenDropdown(dropdownView, itemsOrCallback, options);
  } else {
    dropdownView.once("change:isOpen", () => addListToOpenDropdown(dropdownView, itemsOrCallback, options), { priority: "highest" });
  }
  focusChildOnDropdownOpen(dropdownView, () => dropdownView.listView.items.find((item) => {
    if (item instanceof ListItemView) {
      return item.children.first.isOn;
    }
    return false;
  }));
}
function addListToOpenDropdown(dropdownView, itemsOrCallback, options) {
  const locale = dropdownView.locale;
  const listView = dropdownView.listView = new ListView(locale);
  const items = typeof itemsOrCallback == "function" ? itemsOrCallback() : itemsOrCallback;
  listView.ariaLabel = options.ariaLabel;
  listView.role = options.role;
  listView.items.bindTo(items).using((def) => {
    if (def.type === "separator") {
      return new ListSeparatorView(locale);
    } else if (def.type === "button" || def.type === "switchbutton") {
      const listItemView = new ListItemView(locale);
      let buttonView;
      if (def.type === "button") {
        buttonView = new ButtonView(locale);
      } else {
        buttonView = new SwitchButtonView(locale);
      }
      buttonView.bind(...Object.keys(def.model)).to(def.model);
      buttonView.delegate("execute").to(listItemView);
      listItemView.children.add(buttonView);
      return listItemView;
    }
    return null;
  });
  dropdownView.panelView.children.add(listView);
  listView.items.delegate("execute").to(dropdownView);
}
function focusChildOnDropdownOpen(dropdownView, childSelectorCallback) {
  dropdownView.on("change:isOpen", () => {
    if (!dropdownView.isOpen) {
      return;
    }
    const childToFocus = childSelectorCallback();
    if (!childToFocus) {
      return;
    }
    if (typeof childToFocus.focus === "function") {
      childToFocus.focus();
    } else {
      logWarning("ui-dropdown-focus-child-on-open-child-missing-focus", { view: childToFocus });
    }
  }, { priority: priorities_default.low - 10 });
}
function addDefaultBehavior(dropdownView) {
  closeDropdownOnClickOutside(dropdownView);
  closeDropdownOnExecute(dropdownView);
  closeDropdownOnBlur(dropdownView);
  focusDropdownContentsOnArrows(dropdownView);
  focusDropdownButtonOnClose(dropdownView);
  focusDropdownPanelOnOpen(dropdownView);
}
function closeDropdownOnClickOutside(dropdownView) {
  dropdownView.on("render", () => {
    clickOutsideHandler({
      emitter: dropdownView,
      activator: () => dropdownView.isOpen,
      callback: () => {
        dropdownView.isOpen = false;
      },
      contextElements: () => [
        dropdownView.element,
        ...dropdownView.focusTracker._elements
      ]
    });
  });
}
function closeDropdownOnExecute(dropdownView) {
  dropdownView.on("execute", (evt) => {
    if (evt.source instanceof SwitchButtonView) {
      return;
    }
    dropdownView.isOpen = false;
  });
}
function closeDropdownOnBlur(dropdownView) {
  dropdownView.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
    if (dropdownView.isOpen && !isFocused) {
      dropdownView.isOpen = false;
    }
  });
}
function focusDropdownContentsOnArrows(dropdownView) {
  dropdownView.keystrokes.set("arrowdown", (data, cancel) => {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focus();
      cancel();
    }
  });
  dropdownView.keystrokes.set("arrowup", (data, cancel) => {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focusLast();
      cancel();
    }
  });
}
function focusDropdownButtonOnClose(dropdownView) {
  dropdownView.on("change:isOpen", (evt, name, isOpen) => {
    if (isOpen) {
      return;
    }
    const element = dropdownView.panelView.element;
    if (element && element.contains(global_default.document.activeElement)) {
      dropdownView.buttonView.focus();
    }
  });
}
function focusDropdownPanelOnOpen(dropdownView) {
  dropdownView.on("change:isOpen", (evt, name, isOpen) => {
    if (!isOpen) {
      return;
    }
    dropdownView.panelView.focus();
  }, { priority: "low" });
}

// node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css";
var toPx = toUnit("px");
var defaultLimiterElement = global_default.document.body;
var BalloonPanelView = class _BalloonPanelView extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("top", 0);
    this.set("left", 0);
    this.set("position", "arrow_nw");
    this.set("isVisible", false);
    this.set("withArrow", true);
    this.set("class", void 0);
    this._pinWhenIsVisibleCallback = null;
    this.content = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-panel",
          bind.to("position", (value) => `ck-balloon-panel_${value}`),
          bind.if("isVisible", "ck-balloon-panel_visible"),
          bind.if("withArrow", "ck-balloon-panel_with-arrow"),
          bind.to("class")
        ],
        style: {
          top: bind.to("top", toPx),
          left: bind.to("left", toPx)
        }
      },
      children: this.content
    });
  }
  /**
   * Shows the panel.
   *
   * See {@link #isVisible}.
   */
  show() {
    this.isVisible = true;
  }
  /**
   * Hides the panel.
   *
   * See {@link #isVisible}.
   */
  hide() {
    this.isVisible = false;
  }
  /**
   * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
   * smart positioning heuristics that chooses from available positions to make sure the panel
   * is visible to the user i.e. within the limits of the viewport.
   *
   * This method accepts configuration {@link module:utils/dom/position~Options options}
   * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Attach the panel to an element with the "target" id DOM.
   * panel.attachTo( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * **Note**: Attaching the panel will also automatically {@link #show} it.
   *
   * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
   * See the {@link #pin} method for a more permanent positioning strategy.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   */
  attachTo(options) {
    this.show();
    const defaultPositions = _BalloonPanelView.defaultPositions;
    const positionOptions = Object.assign({}, {
      element: this.element,
      positions: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthMiddleWest,
        defaultPositions.southArrowNorthMiddleEast,
        defaultPositions.southArrowNorthWest,
        defaultPositions.southArrowNorthEast,
        defaultPositions.northArrowSouth,
        defaultPositions.northArrowSouthMiddleWest,
        defaultPositions.northArrowSouthMiddleEast,
        defaultPositions.northArrowSouthWest,
        defaultPositions.northArrowSouthEast,
        defaultPositions.viewportStickyNorth
      ],
      limiter: defaultLimiterElement,
      fitInViewport: true
    }, options);
    const optimalPosition = _BalloonPanelView._getOptimalPosition(positionOptions);
    const left = parseInt(optimalPosition.left);
    const top = parseInt(optimalPosition.top);
    const position = optimalPosition.name;
    const config = optimalPosition.config || {};
    const { withArrow = true } = config;
    this.top = top;
    this.left = left;
    this.position = position;
    this.withArrow = withArrow;
  }
  /**
   * Works the same way as the {@link #attachTo} method except that the position of the panel is
   * continuously updated when:
   *
   * * any ancestor of the {@link module:utils/dom/position~Options#target}
   * or {@link module:utils/dom/position~Options#limiter} is scrolled,
   * * the browser window gets resized or scrolled.
   *
   * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target}
   * and is immune to the changing environment.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Pin the panel to an element with the "target" id DOM.
   * panel.pin( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * To leave the pinned state, use the {@link #unpin} method.
   *
   * **Note**: Pinning the panel will also automatically {@link #show} it.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   */
  pin(options) {
    this.unpin();
    this._pinWhenIsVisibleCallback = () => {
      if (this.isVisible) {
        this._startPinning(options);
      } else {
        this._stopPinning();
      }
    };
    this._startPinning(options);
    this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
  }
  /**
   * Stops pinning the panel, as set up by {@link #pin}.
   */
  unpin() {
    if (this._pinWhenIsVisibleCallback) {
      this._stopPinning();
      this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
      this._pinWhenIsVisibleCallback = null;
      this.hide();
    }
  }
  /**
   * Starts managing the pinned state of the panel. See {@link #pin}.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   */
  _startPinning(options) {
    this.attachTo(options);
    const targetElement = getDomElement(options.target);
    const limiterElement = options.limiter ? getDomElement(options.limiter) : defaultLimiterElement;
    this.listenTo(global_default.document, "scroll", (evt, domEvt) => {
      const scrollTarget = domEvt.target;
      const isWithinScrollTarget = targetElement && scrollTarget.contains(targetElement);
      const isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains(limiterElement);
      if (isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement) {
        this.attachTo(options);
      }
    }, { useCapture: true });
    this.listenTo(global_default.window, "resize", () => {
      this.attachTo(options);
    });
  }
  /**
   * Stops managing the pinned state of the panel. See {@link #pin}.
   */
  _stopPinning() {
    this.stopListening(global_default.document, "scroll");
    this.stopListening(global_default.window, "resize");
  }
};
BalloonPanelView.arrowSideOffset = 25;
BalloonPanelView.arrowHeightOffset = 10;
BalloonPanelView.stickyVerticalOffset = 20;
BalloonPanelView._getOptimalPosition = getOptimalPosition;
BalloonPanelView.defaultPositions = generatePositions();
function getDomElement(object) {
  if (isElement_default(object)) {
    return object;
  }
  if (isRange(object)) {
    return object.commonAncestorContainer;
  }
  if (typeof object == "function") {
    return getDomElement(object());
  }
  return null;
}
function generatePositions(options = {}) {
  const { sideOffset = BalloonPanelView.arrowSideOffset, heightOffset = BalloonPanelView.arrowHeightOffset, stickyVerticalOffset = BalloonPanelView.stickyVerticalOffset, config } = options;
  return {
    // ------- North west
    northWestArrowSouthWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - sideOffset,
      name: "arrow_sw",
      ...config && { config }
    }),
    northWestArrowSouthMiddleWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_smw",
      ...config && { config }
    }),
    northWestArrowSouth: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width / 2,
      name: "arrow_s",
      ...config && { config }
    }),
    northWestArrowSouthMiddleEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_sme",
      ...config && { config }
    }),
    northWestArrowSouthEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width + sideOffset,
      name: "arrow_se",
      ...config && { config }
    }),
    // ------- North
    northArrowSouthWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - sideOffset,
      name: "arrow_sw",
      ...config && { config }
    }),
    northArrowSouthMiddleWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_smw",
      ...config && { config }
    }),
    northArrowSouth: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
      name: "arrow_s",
      ...config && { config }
    }),
    northArrowSouthMiddleEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_sme",
      ...config && { config }
    }),
    northArrowSouthEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
      name: "arrow_se",
      ...config && { config }
    }),
    // ------- North east
    northEastArrowSouthWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - sideOffset,
      name: "arrow_sw",
      ...config && { config }
    }),
    northEastArrowSouthMiddleWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_smw",
      ...config && { config }
    }),
    northEastArrowSouth: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width / 2,
      name: "arrow_s",
      ...config && { config }
    }),
    northEastArrowSouthMiddleEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_sme",
      ...config && { config }
    }),
    northEastArrowSouthEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width + sideOffset,
      name: "arrow_se",
      ...config && { config }
    }),
    // ------- South west
    southWestArrowNorthWest: (targetRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - sideOffset,
      name: "arrow_nw",
      ...config && { config }
    }),
    southWestArrowNorthMiddleWest: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_nmw",
      ...config && { config }
    }),
    southWestArrowNorth: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width / 2,
      name: "arrow_n",
      ...config && { config }
    }),
    southWestArrowNorthMiddleEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_nme",
      ...config && { config }
    }),
    southWestArrowNorthEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width + sideOffset,
      name: "arrow_ne",
      ...config && { config }
    }),
    // ------- South
    southArrowNorthWest: (targetRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - sideOffset,
      name: "arrow_nw",
      ...config && { config }
    }),
    southArrowNorthMiddleWest: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_nmw",
      ...config && { config }
    }),
    southArrowNorth: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
      name: "arrow_n",
      ...config && { config }
    }),
    southArrowNorthMiddleEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_nme",
      ...config && { config }
    }),
    southArrowNorthEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
      name: "arrow_ne",
      ...config && { config }
    }),
    // ------- South east
    southEastArrowNorthWest: (targetRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - sideOffset,
      name: "arrow_nw",
      ...config && { config }
    }),
    southEastArrowNorthMiddleWest: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_nmw",
      ...config && { config }
    }),
    southEastArrowNorth: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width / 2,
      name: "arrow_n",
      ...config && { config }
    }),
    southEastArrowNorthMiddleEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_nme",
      ...config && { config }
    }),
    southEastArrowNorthEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width + sideOffset,
      name: "arrow_ne",
      ...config && { config }
    }),
    // ------- West
    westArrowEast: (targetRect, balloonRect) => ({
      top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
      left: targetRect.left - balloonRect.width - heightOffset,
      name: "arrow_e",
      ...config && { config }
    }),
    // ------- East
    eastArrowWest: (targetRect, balloonRect) => ({
      top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
      left: targetRect.right + heightOffset,
      name: "arrow_w",
      ...config && { config }
    }),
    // ------- Sticky
    viewportStickyNorth: (targetRect, balloonRect, viewportRect) => {
      if (!targetRect.getIntersection(viewportRect)) {
        return null;
      }
      return {
        top: viewportRect.top + stickyVerticalOffset,
        left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
        name: "arrowless",
        config: {
          withArrow: false,
          ...config
        }
      };
    }
  };
  function getNorthTop(targetRect, balloonRect) {
    return targetRect.top - balloonRect.height - heightOffset;
  }
  function getSouthTop(targetRect) {
    return targetRect.bottom + heightOffset;
  }
}

// node_modules/@ckeditor/ckeditor5-ui/src/notification/notification.js
var Notification = class extends ContextPlugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Notification";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.on("show:warning", (evt, data) => {
      window.alert(data.message);
    }, { priority: "lowest" });
  }
  /**
   * Shows a success notification.
   *
   * By default, it fires the {@link #event:show:success `show:success` event} with the given `data`. The event namespace can be extended
   * using the `data.namespace` option. For example:
   *
   * ```ts
   * showSuccess( 'Image is uploaded.', {
   * 	namespace: 'upload:image'
   * } );
   * ```
   *
   * will fire the `show:success:upload:image` event.
   *
   * You can provide the title of the notification:
   *
   * ```ts
   * showSuccess( 'Image is uploaded.', {
   * 	title: 'Image upload success'
   * } );
   * ```
   *
   * @param message The content of the notification.
   * @param data Additional data.
   * @param data.namespace Additional event namespace.
   * @param data.title The title of the notification.
   */
  showSuccess(message, data = {}) {
    this._showNotification({
      message,
      type: "success",
      namespace: data.namespace,
      title: data.title
    });
  }
  /**
   * Shows an information notification.
   *
   * By default, it fires the {@link #event:show:info `show:info` event} with the given `data`. The event namespace can be extended
   * using the `data.namespace` option. For example:
   *
   * ```ts
   * showInfo( 'Editor is offline.', {
   * 	namespace: 'editor:status'
   * } );
   * ```
   *
   * will fire the `show:info:editor:status` event.
   *
   * You can provide the title of the notification:
   *
   * ```ts
   * showInfo( 'Editor is offline.', {
   * 	title: 'Network information'
   * } );
   * ```
   *
   * @param message The content of the notification.
   * @param data Additional data.
   * @param data.namespace Additional event namespace.
   * @param data.title The title of the notification.
   */
  showInfo(message, data = {}) {
    this._showNotification({
      message,
      type: "info",
      namespace: data.namespace,
      title: data.title
    });
  }
  /**
   * Shows a warning notification.
   *
   * By default, it fires the {@link #event:show:warning `show:warning` event}
   * with the given `data`. The event namespace can be extended using the `data.namespace` option. For example:
   *
   * ```ts
   * showWarning( 'Image upload error.', {
   * 	namespace: 'upload:image'
   * } );
   * ```
   *
   * will fire the `show:warning:upload:image` event.
   *
   * You can provide the title of the notification:
   *
   * ```ts
   * showWarning( 'Image upload error.', {
   * 	title: 'Upload failed'
   * } );
   * ```
   *
   * Note that each unhandled and not stopped `warning` notification will be displayed as a system alert.
   * The plugin responsible for displaying warnings should `stop()` the event to prevent displaying it as an alert:
   *
   * ```ts
   * notifications.on( 'show:warning', ( evt, data ) => {
   * 	// Do something with the data.
   *
   * 	// Stop this event to prevent displaying it as an alert.
   * 	evt.stop();
   * } );
   * ```
   *
   * You can attach many listeners to the same event and `stop()` this event in a listener with a low priority:
   *
   * ```ts
   * notifications.on( 'show:warning', ( evt, data ) => {
   * 	// Show the warning in the UI, but do not stop it.
   * } );
   *
   * notifications.on( 'show:warning', ( evt, data ) => {
   * 	// Log the warning to some error tracker.
   *
   * 	// Stop this event to prevent displaying it as an alert.
   * 	evt.stop();
   * }, { priority: 'low' } );
   * ```
   *
   * @param message The content of the notification.
   * @param data Additional data.
   * @param data.namespace Additional event namespace.
   * @param data.title The title of the notification.
   */
  showWarning(message, data = {}) {
    this._showNotification({
      message,
      type: "warning",
      namespace: data.namespace,
      title: data.title
    });
  }
  /**
   * Fires the `show` event with the specified type, namespace and message.
   *
   * @param data The message data.
   * @param data.message The content of the notification.
   * @param data.type The type of the message.
   * @param data.namespace Additional event namespace.
   * @param data.title The title of the notification.
   */
  _showNotification(data) {
    const event = data.namespace ? `show:${data.type}:${data.namespace}` : `show:${data.type}`;
    this.fire(event, {
      message: data.message,
      type: data.type,
      title: data.title || ""
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/model.js
var Model = class extends ObservableMixin() {
  /**
   * Creates a new Model instance.
   *
   * @param attributes The model state attributes to be defined during the instance creation.
   * @param properties The (out of state) properties to be appended to the instance during creation.
   */
  constructor(attributes, properties) {
    super();
    if (properties) {
      assignIn_default(this, properties);
    }
    if (attributes) {
      this.set(attributes);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon.js
import prevIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/icons/previous-arrow.svg";
import nextIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/icons/next-arrow.svg";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css";
var toPx2 = toUnit("px");
var ContextualBalloon = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ContextualBalloon";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._viewToStack = /* @__PURE__ */ new Map();
    this._idToStack = /* @__PURE__ */ new Map();
    this._view = null;
    this._rotatorView = null;
    this._fakePanelsView = null;
    this.positionLimiter = () => {
      const view = this.editor.editing.view;
      const viewDocument = view.document;
      const editableElement = viewDocument.selection.editableElement;
      if (editableElement) {
        return view.domConverter.mapViewToDom(editableElement.root);
      }
      return null;
    };
    this.set("visibleView", null);
    this.set("_numberOfStacks", 0);
    this.set("_singleViewMode", false);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    if (this._view) {
      this._view.destroy();
    }
    if (this._rotatorView) {
      this._rotatorView.destroy();
    }
    if (this._fakePanelsView) {
      this._fakePanelsView.destroy();
    }
  }
  /**
   * The common balloon panel view.
   */
  get view() {
    if (!this._view) {
      this._createPanelView();
    }
    return this._view;
  }
  /**
   * Returns `true` when the given view is in one of the stacks. Otherwise returns `false`.
   */
  hasView(view) {
    return Array.from(this._viewToStack.keys()).includes(view);
  }
  /**
   * Adds a new view to the stack and makes it visible if the current stack is visible
   * or it is the first view in the balloon.
   *
   * @param data The configuration of the view.
   * @param data.stackId The ID of the stack that the view is added to. Defaults to `'main'`.
   * @param data.view The content of the balloon.
   * @param data.position Positioning options.
   * @param data.balloonClassName An additional CSS class added to the {@link #view balloon} when visible.
   * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow. Defaults to `true`.
   * @param data.singleViewMode Whether the view should be the only visible view even if other stacks were added. Defaults to `false`.
   */
  add(data) {
    if (!this._view) {
      this._createPanelView();
    }
    if (this.hasView(data.view)) {
      throw new CKEditorError("contextualballoon-add-view-exist", [this, data]);
    }
    const stackId = data.stackId || "main";
    if (!this._idToStack.has(stackId)) {
      this._idToStack.set(stackId, /* @__PURE__ */ new Map([[data.view, data]]));
      this._viewToStack.set(data.view, this._idToStack.get(stackId));
      this._numberOfStacks = this._idToStack.size;
      if (!this._visibleStack || data.singleViewMode) {
        this.showStack(stackId);
      }
      return;
    }
    const stack = this._idToStack.get(stackId);
    if (data.singleViewMode) {
      this.showStack(stackId);
    }
    stack.set(data.view, data);
    this._viewToStack.set(data.view, stack);
    if (stack === this._visibleStack) {
      this._showView(data);
    }
  }
  /**
   * Removes the given view from the stack. If the removed view was visible,
   * the view preceding it in the stack will become visible instead.
   * When there is no view in the stack, the next stack will be displayed.
   * When there are no more stacks, the balloon will hide.
   *
   * @param view A view to be removed from the balloon.
   */
  remove(view) {
    if (!this.hasView(view)) {
      throw new CKEditorError("contextualballoon-remove-view-not-exist", [this, view]);
    }
    const stack = this._viewToStack.get(view);
    if (this._singleViewMode && this.visibleView === view) {
      this._singleViewMode = false;
    }
    if (this.visibleView === view) {
      if (stack.size === 1) {
        if (this._idToStack.size > 1) {
          this._showNextStack();
        } else {
          this.view.hide();
          this.visibleView = null;
          this._rotatorView.hideView();
        }
      } else {
        this._showView(Array.from(stack.values())[stack.size - 2]);
      }
    }
    if (stack.size === 1) {
      this._idToStack.delete(this._getStackId(stack));
      this._numberOfStacks = this._idToStack.size;
    } else {
      stack.delete(view);
    }
    this._viewToStack.delete(view);
  }
  /**
   * Updates the position of the balloon using the position data of the first visible view in the stack.
   * When new position data is given, the position data of the currently visible view will be updated.
   *
   * @param position Position options.
   */
  updatePosition(position) {
    if (position) {
      this._visibleStack.get(this.visibleView).position = position;
    }
    this.view.pin(this._getBalloonPosition());
    this._fakePanelsView.updatePosition();
  }
  /**
   * Shows the last view from the stack of a given ID.
   */
  showStack(id) {
    this.visibleStack = id;
    const stack = this._idToStack.get(id);
    if (!stack) {
      throw new CKEditorError("contextualballoon-showstack-stack-not-exist", this);
    }
    if (this._visibleStack === stack) {
      return;
    }
    this._showView(Array.from(stack.values()).pop());
  }
  /**
   * Initializes view instances.
   */
  _createPanelView() {
    this._view = new BalloonPanelView(this.editor.locale);
    this.editor.ui.view.body.add(this._view);
    this.editor.ui.focusTracker.add(this._view.element);
    this._rotatorView = this._createRotatorView();
    this._fakePanelsView = this._createFakePanelsView();
  }
  /**
   * Returns the stack of the currently visible view.
   */
  get _visibleStack() {
    return this._viewToStack.get(this.visibleView);
  }
  /**
   * Returns the ID of the given stack.
   */
  _getStackId(stack) {
    const entry = Array.from(this._idToStack.entries()).find((entry2) => entry2[1] === stack);
    return entry[0];
  }
  /**
   * Shows the last view from the next stack.
   */
  _showNextStack() {
    const stacks = Array.from(this._idToStack.values());
    let nextIndex = stacks.indexOf(this._visibleStack) + 1;
    if (!stacks[nextIndex]) {
      nextIndex = 0;
    }
    this.showStack(this._getStackId(stacks[nextIndex]));
  }
  /**
   * Shows the last view from the previous stack.
   */
  _showPrevStack() {
    const stacks = Array.from(this._idToStack.values());
    let nextIndex = stacks.indexOf(this._visibleStack) - 1;
    if (!stacks[nextIndex]) {
      nextIndex = stacks.length - 1;
    }
    this.showStack(this._getStackId(stacks[nextIndex]));
  }
  /**
   * Creates a rotator view.
   */
  _createRotatorView() {
    const view = new RotatorView(this.editor.locale);
    const t = this.editor.locale.t;
    this.view.content.add(view);
    view.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (value, isSingleViewMode) => {
      return !isSingleViewMode && value > 1;
    });
    view.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" });
    view.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (visibleView, numberOfStacks) => {
      if (numberOfStacks < 2) {
        return "";
      }
      const current = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
      return t("%0 of %1", [current, numberOfStacks]);
    });
    view.buttonNextView.on("execute", () => {
      if (view.focusTracker.isFocused) {
        this.editor.editing.view.focus();
      }
      this._showNextStack();
    });
    view.buttonPrevView.on("execute", () => {
      if (view.focusTracker.isFocused) {
        this.editor.editing.view.focus();
      }
      this._showPrevStack();
    });
    return view;
  }
  /**
   * Creates a fake panels view.
   */
  _createFakePanelsView() {
    const view = new FakePanelsView(this.editor.locale, this.view);
    view.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (number, isSingleViewMode) => {
      const showPanels = !isSingleViewMode && number >= 2;
      return showPanels ? Math.min(number - 1, 2) : 0;
    });
    view.listenTo(this.view, "change:top", () => view.updatePosition());
    view.listenTo(this.view, "change:left", () => view.updatePosition());
    this.editor.ui.view.body.add(view);
    return view;
  }
  /**
   * Sets the view as the content of the balloon and attaches the balloon using position
   * options of the first view.
   *
   * @param data Configuration.
   * @param data.view The view to show in the balloon.
   * @param data.balloonClassName Additional class name which will be added to the {@link #view balloon}.
   * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow.
   */
  _showView({ view, balloonClassName = "", withArrow = true, singleViewMode = false }) {
    this.view.class = balloonClassName;
    this.view.withArrow = withArrow;
    this._rotatorView.showView(view);
    this.visibleView = view;
    this.view.pin(this._getBalloonPosition());
    this._fakePanelsView.updatePosition();
    if (singleViewMode) {
      this._singleViewMode = true;
    }
  }
  /**
   * Returns position options of the last view in the stack.
   * This keeps the balloon in the same position when the view is changed.
   */
  _getBalloonPosition() {
    let position = Array.from(this._visibleStack.values()).pop().position;
    if (position) {
      if (!position.limiter) {
        position = Object.assign({}, position, {
          limiter: this.positionLimiter
        });
      }
      position = Object.assign({}, position, {
        viewportOffsetConfig: this.editor.ui.viewportOffset
      });
    }
    return position;
  }
};
var RotatorView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const t = locale.t;
    const bind = this.bindTemplate;
    this.set("isNavigationVisible", true);
    this.focusTracker = new FocusTracker();
    this.buttonPrevView = this._createButtonView(t("Previous"), prevIcon);
    this.buttonNextView = this._createButtonView(t("Next"), nextIcon);
    this.content = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-rotator"
        ],
        "z-index": "-1"
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck-balloon-rotator__navigation",
              bind.to("isNavigationVisible", (value) => value ? "" : "ck-hidden")
            ]
          },
          children: [
            this.buttonPrevView,
            {
              tag: "span",
              attributes: {
                class: [
                  "ck-balloon-rotator__counter"
                ]
              },
              children: [
                {
                  text: bind.to("counter")
                }
              ]
            },
            this.buttonNextView
          ]
        },
        {
          tag: "div",
          attributes: {
            class: "ck-balloon-rotator__content"
          },
          children: this.content
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
  }
  /**
   * Shows a given view.
   *
   * @param view The view to show.
   */
  showView(view) {
    this.hideView();
    this.content.add(view);
  }
  /**
   * Hides the currently displayed view.
   */
  hideView() {
    this.content.clear();
  }
  /**
   * Creates a navigation button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   */
  _createButtonView(label, icon) {
    const view = new ButtonView(this.locale);
    view.set({
      label,
      icon,
      tooltip: true
    });
    return view;
  }
};
var FakePanelsView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale, balloonPanelView) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("top", 0);
    this.set("left", 0);
    this.set("height", 0);
    this.set("width", 0);
    this.set("numberOfPanels", 0);
    this.content = this.createCollection();
    this._balloonPanelView = balloonPanelView;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-fake-panel",
          bind.to("numberOfPanels", (number) => number ? "" : "ck-hidden")
        ],
        style: {
          top: bind.to("top", toPx2),
          left: bind.to("left", toPx2),
          width: bind.to("width", toPx2),
          height: bind.to("height", toPx2)
        }
      },
      children: this.content
    });
    this.on("change:numberOfPanels", (evt, name, next, prev) => {
      if (next > prev) {
        this._addPanels(next - prev);
      } else {
        this._removePanels(prev - next);
      }
      this.updatePosition();
    });
  }
  _addPanels(number) {
    while (number--) {
      const view = new View();
      view.setTemplate({ tag: "div" });
      this.content.add(view);
      this.registerChild(view);
    }
  }
  _removePanels(number) {
    while (number--) {
      const view = this.content.last;
      this.content.remove(view);
      this.deregisterChild(view);
      view.destroy();
    }
  }
  /**
   * Updates coordinates of fake panels.
   */
  updatePosition() {
    if (this.numberOfPanels) {
      const { top, left } = this._balloonPanelView;
      const { width, height } = new Rect(this._balloonPanelView.element);
      Object.assign(this, { top, left, width, height });
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/submithandler.js
function submitHandler({ view }) {
  view.listenTo(view.element, "submit", (evt, domEvt) => {
    domEvt.preventDefault();
    view.fire("submit");
  }, { useCapture: true });
}

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/addkeyboardhandlingforgrid.js
function addKeyboardHandlingForGrid({ keystrokeHandler, focusTracker, gridItems, numberOfColumns, uiLanguageDirection }) {
  const getNumberOfColumns = typeof numberOfColumns === "number" ? () => numberOfColumns : numberOfColumns;
  keystrokeHandler.set("arrowright", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    return uiLanguageDirection === "rtl" ? getLeftElementIndex(focusedElementIndex, gridItems2.length) : getRightElementIndex(focusedElementIndex, gridItems2.length);
  }));
  keystrokeHandler.set("arrowleft", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    return uiLanguageDirection === "rtl" ? getRightElementIndex(focusedElementIndex, gridItems2.length) : getLeftElementIndex(focusedElementIndex, gridItems2.length);
  }));
  keystrokeHandler.set("arrowup", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    let nextIndex = focusedElementIndex - getNumberOfColumns();
    if (nextIndex < 0) {
      nextIndex = focusedElementIndex + getNumberOfColumns() * Math.floor(gridItems2.length / getNumberOfColumns());
      if (nextIndex > gridItems2.length - 1) {
        nextIndex -= getNumberOfColumns();
      }
    }
    return nextIndex;
  }));
  keystrokeHandler.set("arrowdown", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    let nextIndex = focusedElementIndex + getNumberOfColumns();
    if (nextIndex > gridItems2.length - 1) {
      nextIndex = focusedElementIndex % getNumberOfColumns();
    }
    return nextIndex;
  }));
  function getGridItemFocuser(getIndexToFocus) {
    return (evt) => {
      const focusedElement = gridItems.find((item) => item.element === focusTracker.focusedElement);
      const focusedElementIndex = gridItems.getIndex(focusedElement);
      const nextIndexToFocus = getIndexToFocus(focusedElementIndex, gridItems);
      gridItems.get(nextIndexToFocus).focus();
      evt.stopPropagation();
      evt.preventDefault();
    };
  }
  function getRightElementIndex(elementIndex, collectionLength) {
    if (elementIndex === collectionLength - 1) {
      return 0;
    } else {
      return elementIndex + 1;
    }
  }
  function getLeftElementIndex(elementIndex, collectionLength) {
    if (elementIndex === 0) {
      return collectionLength - 1;
    } else {
      return elementIndex - 1;
    }
  }
}

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colortileview.js
import checkIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-tile-check.svg";
var ColorTileView = class extends ButtonView {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("color", void 0);
    this.set("hasBorder", false);
    this.icon = checkIcon;
    this.extendTemplate({
      attributes: {
        style: {
          backgroundColor: bind.to("color")
        },
        class: [
          "ck",
          "ck-color-grid__tile",
          bind.if("hasBorder", "ck-color-selector__color-tile_bordered")
        ]
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.iconView.fillColor = "hsl(0, 0%, 100%)";
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colorgridview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css";
var ColorGridView = class extends View {
  /**
   * Creates an instance of a color grid containing {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
   *
   * @fires execute
   * @param locale The localization services instance.
   * @param options Component configuration
   * @param options.colorDefinitions Array with definitions
   * required to create the {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
   * @param options.columns A number of columns to display the tiles.
   */
  constructor(locale, options) {
    super(locale);
    const colorDefinitions = options && options.colorDefinitions ? options.colorDefinitions : [];
    this.columns = options && options.columns ? options.columns : 5;
    const viewStyleAttribute = {
      gridTemplateColumns: `repeat( ${this.columns}, 1fr)`
    };
    this.set("selectedColor", void 0);
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.items.on("add", (evt, colorTile) => {
      colorTile.isOn = colorTile.color === this.selectedColor;
    });
    colorDefinitions.forEach((color) => {
      const colorTile = new ColorTileView();
      colorTile.set({
        color: color.color,
        label: color.label,
        tooltip: true,
        hasBorder: color.options.hasBorder
      });
      colorTile.on("execute", () => {
        this.fire("execute", {
          value: color.color,
          hasBorder: color.options.hasBorder,
          label: color.label
        });
      });
      this.items.add(colorTile);
    });
    this.setTemplate({
      tag: "div",
      children: this.items,
      attributes: {
        class: [
          "ck",
          "ck-color-grid"
        ],
        style: viewStyleAttribute
      }
    });
    this.on("change:selectedColor", (evt, name, selectedColor) => {
      for (const item of this.items) {
        item.isOn = item.color === selectedColor;
      }
    });
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */
  focus() {
    if (this.items.length) {
      this.items.first.focus();
    }
  }
  /**
   * Focuses the last focusable in {@link #items}.
   */
  focusLast() {
    if (this.items.length) {
      this.items.last.focus();
    }
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const item of this.items) {
      this.focusTracker.add(item.element);
    }
    this.items.on("add", (evt, item) => {
      this.focusTracker.add(item.element);
    });
    this.items.on("remove", (evt, item) => {
      this.focusTracker.remove(item.element);
    });
    this.keystrokes.listenTo(this.element);
    addKeyboardHandlingForGrid({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.items,
      numberOfColumns: this.columns,
      uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
};

// node_modules/color-parse/index.mjs
var import_color_name = __toESM(require_color_name(), 1);
var color_parse_default = parse;
var baseHues = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function parse(cstr) {
  var m, parts = [], alpha = 1, space;
  if (typeof cstr === "string") {
    if (import_color_name.default[cstr]) {
      parts = import_color_name.default[cstr].slice();
      space = "rgb";
    } else if (cstr === "transparent") {
      alpha = 0;
      space = "rgb";
      parts = [0, 0, 0];
    } else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
      var base = cstr.slice(1);
      var size = base.length;
      var isShort = size <= 4;
      alpha = 1;
      if (isShort) {
        parts = [
          parseInt(base[0] + base[0], 16),
          parseInt(base[1] + base[1], 16),
          parseInt(base[2] + base[2], 16)
        ];
        if (size === 4) {
          alpha = parseInt(base[3] + base[3], 16) / 255;
        }
      } else {
        parts = [
          parseInt(base[0] + base[1], 16),
          parseInt(base[2] + base[3], 16),
          parseInt(base[4] + base[5], 16)
        ];
        if (size === 8) {
          alpha = parseInt(base[6] + base[7], 16) / 255;
        }
      }
      if (!parts[0])
        parts[0] = 0;
      if (!parts[1])
        parts[1] = 0;
      if (!parts[2])
        parts[2] = 0;
      space = "rgb";
    } else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
      var name = m[1];
      var isRGB = name === "rgb";
      var base = name.replace(/a$/, "");
      space = base;
      var size = base === "cmyk" ? 4 : base === "gray" ? 1 : 3;
      parts = m[2].trim().split(/\s*[,\/]\s*|\s+/).map(function(x, i) {
        if (/%$/.test(x)) {
          if (i === size)
            return parseFloat(x) / 100;
          if (base === "rgb")
            return parseFloat(x) * 255 / 100;
          return parseFloat(x);
        } else if (base[i] === "h") {
          if (/deg$/.test(x)) {
            return parseFloat(x);
          } else if (baseHues[x] !== void 0) {
            return baseHues[x];
          }
        }
        return parseFloat(x);
      });
      if (name === base)
        parts.push(1);
      alpha = isRGB ? 1 : parts[size] === void 0 ? 1 : parts[size];
      parts = parts.slice(0, size);
    } else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
      parts = cstr.match(/([0-9]+)/g).map(function(value) {
        return parseFloat(value);
      });
      space = cstr.match(/([a-z])/ig).join("").toLowerCase();
    }
  } else if (!isNaN(cstr)) {
    space = "rgb";
    parts = [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255];
  } else if (Array.isArray(cstr) || cstr.length) {
    parts = [cstr[0], cstr[1], cstr[2]];
    space = "rgb";
    alpha = cstr.length === 4 ? cstr[3] : 1;
  } else if (cstr instanceof Object) {
    if (cstr.r != null || cstr.red != null || cstr.R != null) {
      space = "rgb";
      parts = [
        cstr.r || cstr.red || cstr.R || 0,
        cstr.g || cstr.green || cstr.G || 0,
        cstr.b || cstr.blue || cstr.B || 0
      ];
    } else {
      space = "hsl";
      parts = [
        cstr.h || cstr.hue || cstr.H || 0,
        cstr.s || cstr.saturation || cstr.S || 0,
        cstr.l || cstr.lightness || cstr.L || cstr.b || cstr.brightness
      ];
    }
    alpha = cstr.a || cstr.alpha || cstr.opacity || 1;
    if (cstr.opacity != null)
      alpha /= 100;
  }
  return {
    space,
    values: parts,
    alpha
  };
}

// node_modules/@ckeditor/ckeditor5-ui/src/colorpicker/utils.js
var convert = __toESM(require_color_convert());
function convertColor(color, outputFormat) {
  if (!color) {
    return "";
  }
  const colorObject = parseColorString(color);
  if (!colorObject) {
    return "";
  }
  if (colorObject.space === outputFormat) {
    return color;
  }
  if (!canConvertParsedColor(colorObject)) {
    return "";
  }
  const fromColorSpace = convert[colorObject.space];
  const toColorSpace = fromColorSpace[outputFormat];
  if (!toColorSpace) {
    return "";
  }
  const convertedColorChannels = toColorSpace(colorObject.space === "hex" ? colorObject.hexValue : colorObject.values);
  return formatColorOutput(convertedColorChannels, outputFormat);
}
function convertToHex(color) {
  if (!color) {
    return "";
  }
  const colorObject = parseColorString(color);
  if (!colorObject) {
    return "#000";
  }
  if (colorObject.space === "hex") {
    return colorObject.hexValue;
  }
  return convertColor(color, "hex");
}
function formatColorOutput(values, format2) {
  switch (format2) {
    case "hex":
      return `#${values}`;
    case "rgb":
      return `rgb( ${values[0]}, ${values[1]}, ${values[2]} )`;
    case "hsl":
      return `hsl( ${values[0]}, ${values[1]}%, ${values[2]}% )`;
    case "hwb":
      return `hwb( ${values[0]}, ${values[1]}, ${values[2]} )`;
    case "lab":
      return `lab( ${values[0]}% ${values[1]} ${values[2]} )`;
    case "lch":
      return `lch( ${values[0]}% ${values[1]} ${values[2]} )`;
    default:
      return "";
  }
}
function parseColorString(colorString) {
  if (colorString.startsWith("#")) {
    const parsedHex = color_parse_default(colorString);
    return {
      space: "hex",
      values: parsedHex.values,
      hexValue: colorString,
      alpha: parsedHex.alpha
    };
  }
  const parsed = color_parse_default(colorString);
  if (!parsed.space) {
    return null;
  }
  return parsed;
}
function canConvertParsedColor(parsedColor) {
  return Object.keys(convert).includes(parsedColor.space);
}

// node_modules/@ckeditor/ckeditor5-ui/src/label/labelview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css";
var LabelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("text", void 0);
    this.set("for", void 0);
    this.id = `ck-editor__label_${uid()}`;
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "label",
      attributes: {
        class: [
          "ck",
          "ck-label"
        ],
        id: this.id,
        for: bind.to("for")
      },
      children: [
        {
          text: bind.to("text")
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/labeledfieldview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css";
var LabeledFieldView = class extends View {
  /**
   * Creates an instance of the labeled field view class using a provided creator function
   * that provides the view to be labeled.
   *
   * @param locale The locale instance.
   * @param viewCreator A function that returns a {@link module:ui/view~View}
   * that will be labeled. The following arguments are passed to the creator function:
   *
   * * an instance of the `LabeledFieldView` to allow binding observable properties,
   * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
   * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
   */
  constructor(locale, viewCreator) {
    super(locale);
    const viewUid = `ck-labeled-field-view-${uid()}`;
    const statusUid = `ck-labeled-field-view-status-${uid()}`;
    this.fieldView = viewCreator(this, viewUid, statusUid);
    this.set("label", void 0);
    this.set("isEnabled", true);
    this.set("isEmpty", true);
    this.set("isFocused", false);
    this.set("errorText", null);
    this.set("infoText", null);
    this.set("class", void 0);
    this.set("placeholder", void 0);
    this.labelView = this._createLabelView(viewUid);
    this.statusView = this._createStatusView(statusUid);
    this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]);
    this.bind("_statusText").to(this, "errorText", this, "infoText", (errorText, infoText) => errorText || infoText);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("isEmpty", "ck-labeled-field-view_empty"),
          bind.if("isFocused", "ck-labeled-field-view_focused"),
          bind.if("placeholder", "ck-labeled-field-view_placeholder"),
          bind.if("errorText", "ck-error")
        ]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view__input-wrapper"
            ]
          },
          children: this.fieldWrapperChildren
        },
        this.statusView
      ]
    });
  }
  /**
   * Creates label view class instance and bind with view.
   *
   * @param id Unique id to set as labelView#for attribute.
   */
  _createLabelView(id) {
    const labelView = new LabelView(this.locale);
    labelView.for = id;
    labelView.bind("text").to(this, "label");
    return labelView;
  }
  /**
   * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
   * next to the {@link #fieldView}. See {@link #_statusText}.
   *
   * @param statusUid Unique id of the status, shared with the {@link #fieldView view's}
   * `aria-describedby` attribute.
   */
  _createStatusView(statusUid) {
    const statusView = new View(this.locale);
    const bind = this.bindTemplate;
    statusView.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view__status",
          bind.if("errorText", "ck-labeled-field-view__status_error"),
          bind.if("_statusText", "ck-hidden", (value) => !value)
        ],
        id: statusUid,
        role: bind.if("errorText", "alert")
      },
      children: [
        {
          text: bind.to("_statusText")
        }
      ]
    });
    return statusView;
  }
  /**
   * Focuses the {@link #fieldView}.
   */
  focus() {
    this.fieldView.focus();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/input/inputview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/input/input.css";
var InputView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("value", void 0);
    this.set("id", void 0);
    this.set("placeholder", void 0);
    this.set("isReadOnly", false);
    this.set("hasError", false);
    this.set("ariaDescribedById", void 0);
    this.focusTracker = new FocusTracker();
    this.bind("isFocused").to(this.focusTracker);
    this.set("isEmpty", true);
    this.set("inputMode", "text");
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck",
          "ck-input",
          bind.if("isFocused", "ck-input_focused"),
          bind.if("isEmpty", "ck-input-text_empty"),
          bind.if("hasError", "ck-error")
        ],
        id: bind.to("id"),
        placeholder: bind.to("placeholder"),
        readonly: bind.to("isReadOnly"),
        inputmode: bind.to("inputMode"),
        "aria-invalid": bind.if("hasError", true),
        "aria-describedby": bind.to("ariaDescribedById")
      },
      on: {
        input: bind.to((...args) => {
          this.fire("input", ...args);
          this._updateIsEmpty();
        }),
        change: bind.to(this._updateIsEmpty.bind(this))
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.element);
    this._setDomElementValue(this.value);
    this._updateIsEmpty();
    this.on("change:value", (evt, name, value) => {
      this._setDomElementValue(value);
      this._updateIsEmpty();
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
  }
  /**
   * Moves the focus to the input and selects the value.
   */
  select() {
    this.element.select();
  }
  /**
   * Focuses the input.
   */
  focus() {
    this.element.focus();
  }
  /**
   * Updates the {@link #isEmpty} property value on demand.
   */
  _updateIsEmpty() {
    this.isEmpty = isInputElementEmpty(this.element);
  }
  /**
   * Sets the `value` property of the {@link #element DOM element} on demand.
   */
  _setDomElementValue(value) {
    this.element.value = !value && value !== 0 ? "" : value;
  }
};
function isInputElementEmpty(domElement) {
  return !domElement.value;
}

// node_modules/@ckeditor/ckeditor5-ui/src/inputtext/inputtextview.js
var InputTextView = class extends InputView {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.extendTemplate({
      attributes: {
        type: "text",
        class: [
          "ck-input-text"
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/inputnumber/inputnumberview.js
var InputNumberView = class extends InputView {
  /**
   * Creates an instance of the input number view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param options The options of the input.
   * @param options.min The value of the `min` DOM attribute (the lowest accepted value).
   * @param options.max The value of the `max` DOM attribute (the highest accepted value).
   * @param options.step The value of the `step` DOM attribute.
   */
  constructor(locale, { min, max, step } = {}) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("min", min);
    this.set("max", max);
    this.set("step", step);
    this.extendTemplate({
      attributes: {
        type: "number",
        class: [
          "ck-input-number"
        ],
        min: bind.to("min"),
        max: bind.to("max"),
        step: bind.to("step")
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/utils.js
function createLabeledInputText(labeledFieldView, viewUid, statusUid) {
  const inputView = new InputTextView(labeledFieldView.locale);
  inputView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  inputView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
  return inputView;
}
function createLabeledInputNumber(labeledFieldView, viewUid, statusUid) {
  const inputView = new InputNumberView(labeledFieldView.locale);
  inputView.set({
    id: viewUid,
    ariaDescribedById: statusUid,
    inputMode: "numeric"
  });
  inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  inputView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
  return inputView;
}
function createLabeledDropdown(labeledFieldView, viewUid, statusUid) {
  const dropdownView = createDropdown(labeledFieldView.locale);
  dropdownView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  dropdownView.bind("isEnabled").to(labeledFieldView);
  return dropdownView;
}

// node_modules/vanilla-colorful/lib/utils/math.js
var clamp = (number, min = 0, max = 1) => {
  return number > max ? max : number < min ? min : number;
};
var round = (number, digits = 0, base = Math.pow(10, digits)) => {
  return Math.round(base * number) / base;
};

// node_modules/vanilla-colorful/lib/utils/convert.js
var angleUnits = {
  grad: 360 / 400,
  turn: 360,
  rad: 360 / (Math.PI * 2)
};
var hexToHsva = (hex) => rgbaToHsva(hexToRgba(hex));
var hexToRgba = (hex) => {
  if (hex[0] === "#")
    hex = hex.substring(1);
  if (hex.length < 6) {
    return {
      r: parseInt(hex[0] + hex[0], 16),
      g: parseInt(hex[1] + hex[1], 16),
      b: parseInt(hex[2] + hex[2], 16),
      a: hex.length === 4 ? round(parseInt(hex[3] + hex[3], 16) / 255, 2) : 1
    };
  }
  return {
    r: parseInt(hex.substring(0, 2), 16),
    g: parseInt(hex.substring(2, 4), 16),
    b: parseInt(hex.substring(4, 6), 16),
    a: hex.length === 8 ? round(parseInt(hex.substring(6, 8), 16) / 255, 2) : 1
  };
};
var hsvaToHex = (hsva) => rgbaToHex(hsvaToRgba(hsva));
var hsvaToHsla = ({ h, s, v, a }) => {
  const hh = (200 - s) * v / 100;
  return {
    h: round(h),
    s: round(hh > 0 && hh < 200 ? s * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),
    l: round(hh / 2),
    a: round(a, 2)
  };
};
var hsvaToHslString = (hsva) => {
  const { h, s, l } = hsvaToHsla(hsva);
  return `hsl(${h}, ${s}%, ${l}%)`;
};
var hsvaToRgba = ({ h, s, v, a }) => {
  h = h / 360 * 6;
  s = s / 100;
  v = v / 100;
  const hh = Math.floor(h), b = v * (1 - s), c = v * (1 - (h - hh) * s), d = v * (1 - (1 - h + hh) * s), module = hh % 6;
  return {
    r: round([v, c, b, b, d, v][module] * 255),
    g: round([d, v, v, c, b, b][module] * 255),
    b: round([b, b, d, v, v, c][module] * 255),
    a: round(a, 2)
  };
};
var format = (number) => {
  const hex = number.toString(16);
  return hex.length < 2 ? "0" + hex : hex;
};
var rgbaToHex = ({ r, g, b, a }) => {
  const alphaHex = a < 1 ? format(round(a * 255)) : "";
  return "#" + format(r) + format(g) + format(b) + alphaHex;
};
var rgbaToHsva = ({ r, g, b, a }) => {
  const max = Math.max(r, g, b);
  const delta = max - Math.min(r, g, b);
  const hh = delta ? max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;
  return {
    h: round(60 * (hh < 0 ? hh + 6 : hh)),
    s: round(max ? delta / max * 100 : 0),
    v: round(max / 255 * 100),
    a
  };
};

// node_modules/vanilla-colorful/lib/utils/compare.js
var equalColorObjects = (first2, second) => {
  if (first2 === second)
    return true;
  for (const prop in first2) {
    if (first2[prop] !== second[prop])
      return false;
  }
  return true;
};
var equalHex = (first2, second) => {
  if (first2.toLowerCase() === second.toLowerCase())
    return true;
  return equalColorObjects(hexToRgba(first2), hexToRgba(second));
};

// node_modules/vanilla-colorful/lib/utils/dom.js
var cache = {};
var tpl = (html) => {
  let template = cache[html];
  if (!template) {
    template = document.createElement("template");
    template.innerHTML = html;
    cache[html] = template;
  }
  return template;
};
var fire = (target, type, detail) => {
  target.dispatchEvent(new CustomEvent(type, {
    bubbles: true,
    detail
  }));
};

// node_modules/vanilla-colorful/lib/components/slider.js
var hasTouched = false;
var isTouch = (e) => "touches" in e;
var isValid = (event) => {
  if (hasTouched && !isTouch(event))
    return false;
  if (!hasTouched)
    hasTouched = isTouch(event);
  return true;
};
var pointerMove = (target, event) => {
  const pointer = isTouch(event) ? event.touches[0] : event;
  const rect = target.el.getBoundingClientRect();
  fire(target.el, "move", target.getMove({
    x: clamp((pointer.pageX - (rect.left + window.pageXOffset)) / rect.width),
    y: clamp((pointer.pageY - (rect.top + window.pageYOffset)) / rect.height)
  }));
};
var keyMove = (target, event) => {
  const keyCode = event.keyCode;
  if (keyCode > 40 || target.xy && keyCode < 37 || keyCode < 33)
    return;
  event.preventDefault();
  fire(target.el, "move", target.getMove({
    x: keyCode === 39 ? 0.01 : keyCode === 37 ? -0.01 : keyCode === 34 ? 0.05 : keyCode === 33 ? -0.05 : keyCode === 35 ? 1 : keyCode === 36 ? -1 : 0,
    y: keyCode === 40 ? 0.01 : keyCode === 38 ? -0.01 : 0
  }, true));
};
var Slider = class {
  constructor(root, part, aria, xy) {
    const template = tpl(`<div role="slider" tabindex="0" part="${part}" ${aria}><div part="${part}-pointer"></div></div>`);
    root.appendChild(template.content.cloneNode(true));
    const el = root.querySelector(`[part=${part}]`);
    el.addEventListener("mousedown", this);
    el.addEventListener("touchstart", this);
    el.addEventListener("keydown", this);
    this.el = el;
    this.xy = xy;
    this.nodes = [el.firstChild, el];
  }
  set dragging(state) {
    const toggleEvent = state ? document.addEventListener : document.removeEventListener;
    toggleEvent(hasTouched ? "touchmove" : "mousemove", this);
    toggleEvent(hasTouched ? "touchend" : "mouseup", this);
  }
  handleEvent(event) {
    switch (event.type) {
      case "mousedown":
      case "touchstart":
        event.preventDefault();
        if (!isValid(event) || !hasTouched && event.button != 0)
          return;
        this.el.focus();
        pointerMove(this, event);
        this.dragging = true;
        break;
      case "mousemove":
      case "touchmove":
        event.preventDefault();
        pointerMove(this, event);
        break;
      case "mouseup":
      case "touchend":
        this.dragging = false;
        break;
      case "keydown":
        keyMove(this, event);
        break;
    }
  }
  style(styles) {
    styles.forEach((style, i) => {
      for (const p in style) {
        this.nodes[i].style.setProperty(p, style[p]);
      }
    });
  }
};

// node_modules/vanilla-colorful/lib/components/hue.js
var Hue = class extends Slider {
  constructor(root) {
    super(root, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
  }
  update({ h }) {
    this.h = h;
    this.style([
      {
        left: `${h / 360 * 100}%`,
        color: hsvaToHslString({ h, s: 100, v: 100, a: 1 })
      }
    ]);
    this.el.setAttribute("aria-valuenow", `${round(h)}`);
  }
  getMove(offset, key) {
    return { h: key ? clamp(this.h + offset.x * 360, 0, 360) : 360 * offset.x };
  }
};

// node_modules/vanilla-colorful/lib/components/saturation.js
var Saturation = class extends Slider {
  constructor(root) {
    super(root, "saturation", 'aria-label="Color"', true);
  }
  update(hsva) {
    this.hsva = hsva;
    this.style([
      {
        top: `${100 - hsva.v}%`,
        left: `${hsva.s}%`,
        color: hsvaToHslString(hsva)
      },
      {
        "background-color": hsvaToHslString({ h: hsva.h, s: 100, v: 100, a: 1 })
      }
    ]);
    this.el.setAttribute("aria-valuetext", `Saturation ${round(hsva.s)}%, Brightness ${round(hsva.v)}%`);
  }
  getMove(offset, key) {
    return {
      s: key ? clamp(this.hsva.s + offset.x * 100, 0, 100) : offset.x * 100,
      v: key ? clamp(this.hsva.v - offset.y * 100, 0, 100) : Math.round(100 - offset.y * 100)
    };
  }
};

// node_modules/vanilla-colorful/lib/styles/color-picker.js
var color_picker_default = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`;

// node_modules/vanilla-colorful/lib/styles/hue.js
var hue_default = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`;

// node_modules/vanilla-colorful/lib/styles/saturation.js
var saturation_default = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`;

// node_modules/vanilla-colorful/lib/components/color-picker.js
var $isSame = Symbol("same");
var $color = Symbol("color");
var $hsva = Symbol("hsva");
var $update = Symbol("update");
var $parts = Symbol("parts");
var $css = Symbol("css");
var $sliders = Symbol("sliders");
var ColorPicker = class extends HTMLElement {
  static get observedAttributes() {
    return ["color"];
  }
  get [$css]() {
    return [color_picker_default, hue_default, saturation_default];
  }
  get [$sliders]() {
    return [Saturation, Hue];
  }
  get color() {
    return this[$color];
  }
  set color(newColor) {
    if (!this[$isSame](newColor)) {
      const newHsva = this.colorModel.toHsva(newColor);
      this[$update](newHsva);
      this[$color] = newColor;
    }
  }
  constructor() {
    super();
    const template = tpl(`<style>${this[$css].join("")}</style>`);
    const root = this.attachShadow({ mode: "open" });
    root.appendChild(template.content.cloneNode(true));
    root.addEventListener("move", this);
    this[$parts] = this[$sliders].map((slider) => new slider(root));
  }
  connectedCallback() {
    if (this.hasOwnProperty("color")) {
      const value = this.color;
      delete this["color"];
      this.color = value;
    } else if (!this.color) {
      this.color = this.colorModel.defaultColor;
    }
  }
  attributeChangedCallback(_attr, _oldVal, newVal) {
    const color = this.colorModel.fromAttr(newVal);
    if (!this[$isSame](color)) {
      this.color = color;
    }
  }
  handleEvent(event) {
    const oldHsva = this[$hsva];
    const newHsva = { ...oldHsva, ...event.detail };
    this[$update](newHsva);
    let newColor;
    if (!equalColorObjects(newHsva, oldHsva) && !this[$isSame](newColor = this.colorModel.fromHsva(newHsva))) {
      this[$color] = newColor;
      fire(this, "color-changed", { value: newColor });
    }
  }
  [$isSame](color) {
    return this.color && this.colorModel.equal(color, this.color);
  }
  [$update](hsva) {
    this[$hsva] = hsva;
    this[$parts].forEach((part) => part.update(hsva));
  }
};

// node_modules/vanilla-colorful/lib/entrypoints/hex.js
var colorModel = {
  defaultColor: "#000",
  toHsva: hexToHsva,
  fromHsva: ({ h, s, v }) => hsvaToHex({ h, s, v, a: 1 }),
  equal: equalHex,
  fromAttr: (color) => color
};
var HexBase = class extends ColorPicker {
  get colorModel() {
    return colorModel;
  }
};

// node_modules/vanilla-colorful/hex-color-picker.js
var HexColorPicker = class extends HexBase {
};
customElements.define("hex-color-picker", HexColorPicker);

// node_modules/@ckeditor/ckeditor5-ui/src/colorpicker/colorpickerview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/colorpicker/colorpicker.css";
var waitingTime = 150;
var ColorPickerView = class extends View {
  /**
   * Creates a view of color picker.
   *
   * @param locale
   * @param config
   */
  constructor(locale, config = {}) {
    super(locale);
    this.set({
      color: "",
      _hexColor: ""
    });
    this.hexInputRow = this._createInputRow();
    const children = this.createCollection();
    if (!config.hideInput) {
      children.add(this.hexInputRow);
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-color-picker"],
        tabindex: -1
      },
      children
    });
    this._config = config;
    this._debounceColorPickerEvent = debounce_default((color) => {
      this.set("color", color);
      this.fire("colorSelected", { color: this.color });
    }, waitingTime, {
      leading: true
    });
    this.on("set:color", (evt, propertyName, newValue) => {
      evt.return = convertColor(newValue, this._config.format || "hsl");
    });
    this.on("change:color", () => {
      this._hexColor = convertColorToCommonHexFormat(this.color);
    });
    this.on("change:_hexColor", () => {
      if (document.activeElement !== this.picker) {
        this.picker.setAttribute("color", this._hexColor);
      }
      if (convertColorToCommonHexFormat(this.color) != convertColorToCommonHexFormat(this._hexColor)) {
        this.color = this._hexColor;
      }
    });
  }
  /**
   * Renders color picker in the view.
   */
  render() {
    super.render();
    this.picker = global_default.document.createElement("hex-color-picker");
    this.picker.setAttribute("class", "hex-color-picker");
    this.picker.setAttribute("tabindex", "-1");
    this._createSlidersView();
    if (this.element) {
      if (this.hexInputRow.element) {
        this.element.insertBefore(this.picker, this.hexInputRow.element);
      } else {
        this.element.appendChild(this.picker);
      }
      const styleSheetForFocusedColorPicker = document.createElement("style");
      styleSheetForFocusedColorPicker.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}';
      this.picker.shadowRoot.appendChild(styleSheetForFocusedColorPicker);
    }
    this.picker.addEventListener("color-changed", (event) => {
      const customEvent = event;
      const color = customEvent.detail.value;
      this._debounceColorPickerEvent(color);
    });
  }
  /**
   * Focuses the first pointer in color picker.
   *
   */
  focus() {
    if (!this._config.hideInput && (env_default.isGecko || env_default.isiOS || env_default.isSafari)) {
      const input = this.hexInputRow.children.get(1);
      input.focus();
    }
    const firstSlider = this.slidersView.first;
    firstSlider.focus();
  }
  /**
   * Creates collection of sliders in color picker.
   *
   * @private
   */
  _createSlidersView() {
    const colorPickersChildren = [...this.picker.shadowRoot.children];
    const sliders = colorPickersChildren.filter((item) => item.getAttribute("role") === "slider");
    const slidersView = sliders.map((slider) => {
      const view = new SliderView(slider);
      return view;
    });
    this.slidersView = this.createCollection();
    slidersView.forEach((item) => {
      this.slidersView.add(item);
    });
  }
  /**
   * Creates input row for defining custom colors in color picker.
   *
   * @private
   */
  _createInputRow() {
    const hashView = new HashView();
    const colorInput = this._createColorInput();
    return new ColorPickerInputRowView(this.locale, [hashView, colorInput]);
  }
  /**
   * Creates the input where user can type or paste the color in hex format.
   *
   * @private
   */
  _createColorInput() {
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
    const { t } = this.locale;
    labeledInput.set({
      label: t("HEX"),
      class: "color-picker-hex-input"
    });
    labeledInput.fieldView.bind("value").to(this, "_hexColor", (pickerColor) => {
      if (labeledInput.isFocused) {
        return labeledInput.fieldView.value;
      } else {
        return pickerColor.startsWith("#") ? pickerColor.substring(1) : pickerColor;
      }
    });
    labeledInput.fieldView.on("input", () => {
      const inputValue = labeledInput.fieldView.element.value;
      if (inputValue) {
        const trimmedValue = inputValue.trim();
        const hashlessInput = trimmedValue.startsWith("#") ? trimmedValue.substring(1) : trimmedValue;
        const isValidHexColor = [3, 4, 6, 8].includes(hashlessInput.length) && /(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})/.test(hashlessInput);
        if (isValidHexColor) {
          this._debounceColorPickerEvent("#" + hashlessInput);
        }
      }
    });
    return labeledInput;
  }
};
function convertColorToCommonHexFormat(inputColor) {
  let ret = convertToHex(inputColor);
  if (!ret) {
    ret = "#000";
  }
  if (ret.length === 4) {
    ret = "#" + [ret[1], ret[1], ret[2], ret[2], ret[3], ret[3]].join("");
  }
  return ret.toLowerCase();
}
var SliderView = class extends View {
  /**
   * @param element HTML elemnt of slider in color picker.
   */
  constructor(element) {
    super();
    this.element = element;
  }
  /**
   * Focuses element.
   */
  focus() {
    this.element.focus();
  }
};
var HashView = class extends View {
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-picker__hash-view"
        ]
      },
      children: "#"
    });
  }
};
var ColorPickerInputRowView = class extends View {
  /**
   * Creates an instance of the form row class.
   *
   * @param locale The locale instance.
   */
  constructor(locale, children) {
    super(locale);
    this.children = this.createCollection(children);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-picker__row"
        ]
      },
      children: this.children
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/documentcolorcollection.js
var DocumentColorCollection = class extends ObservableMixin(Collection) {
  constructor(options) {
    super(options);
    this.set("isEmpty", true);
    this.on("change", () => {
      this.set("isEmpty", this.length === 0);
    });
  }
  /**
   * Adds a color to the document color collection.
   *
   * This method ensures that no color duplicates are inserted (compared using
   * the color value of the {@link module:ui/colorgrid/colorgridview~ColorDefinition}).
   *
   * If the item does not have an ID, it will be automatically generated and set on the item.
   *
   * @param index The position of the item in the collection. The item is pushed to the collection when `index` is not specified.
   * @fires add
   * @fires change
   */
  add(item, index) {
    if (this.find((element) => element.color === item.color)) {
      return this;
    }
    return super.add(item, index);
  }
  /**
   * Checks if an object with given colors is present in the document color collection.
   */
  hasColor(color) {
    return !!this.find((item) => item.color === color);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorgridsfragmentview.js
import removeButtonIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-core/theme/icons/eraser.svg";
import colorPaletteIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-palette.svg";
var ColorGridsFragmentView = class extends View {
  /**
   * Creates an instance of the view.
   *
   * @param locale The localization services instance.
   * @param colors An array with definitions of colors to be displayed in the table.
   * @param columns The number of columns in the color grid.
   * @param removeButtonLabel The label of the button responsible for removing the color.
   * @param colorPickerLabel The label of the button responsible for color picker appearing.
   * @param documentColorsLabel The label for the section with the document colors.
   * @param documentColorsCount The number of colors in the document colors section inside the color dropdown.
   * @param focusTracker Tracks information about the DOM focus in the list.
   * @param focusables A collection of views that can be focused in the view.
   */
  constructor(locale, { colors, columns, removeButtonLabel, documentColorsLabel, documentColorsCount, colorPickerLabel, focusTracker, focusables }) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isVisible", true);
    this.focusTracker = focusTracker;
    this.items = this.createCollection();
    this.colorDefinitions = colors;
    this.columns = columns;
    this.documentColors = new DocumentColorCollection();
    this.documentColorsCount = documentColorsCount;
    this._focusables = focusables;
    this._removeButtonLabel = removeButtonLabel;
    this._colorPickerLabel = colorPickerLabel;
    this._documentColorsLabel = documentColorsLabel;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-color-grids-fragment",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: this.items
    });
    this.removeColorButtonView = this._createRemoveColorButton();
    this.items.add(this.removeColorButtonView);
  }
  /**
   * Scans through the editor model and searches for text node attributes with the given attribute name.
   * Found entries are set as document colors.
   *
   * All the previously stored document colors will be lost in the process.
   *
   * @param model The model used as a source to obtain the document colors.
   * @param attributeName Determines the name of the related model's attribute for a given dropdown.
   */
  updateDocumentColors(model, attributeName) {
    const document2 = model.document;
    const maxCount = this.documentColorsCount;
    this.documentColors.clear();
    for (const root of document2.getRoots()) {
      const range = model.createRangeIn(root);
      for (const node of range.getItems()) {
        if (node.is("$textProxy") && node.hasAttribute(attributeName)) {
          this._addColorToDocumentColors(node.getAttribute(attributeName));
          if (this.documentColors.length >= maxCount) {
            return;
          }
        }
      }
    }
  }
  /**
   * Refreshes the state of the selected color in one or both {@link module:ui/colorgrid/colorgridview~ColorGridView}s
   * available in the {@link module:ui/colorselector/colorselectorview~ColorSelectorView}. It guarantees that the selection will
   * occur only in one of them.
   */
  updateSelectedColors() {
    const documentColorsGrid = this.documentColorsGrid;
    const staticColorsGrid = this.staticColorsGrid;
    const selectedColor = this.selectedColor;
    staticColorsGrid.selectedColor = selectedColor;
    if (documentColorsGrid) {
      documentColorsGrid.selectedColor = selectedColor;
    }
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.staticColorsGrid = this._createStaticColorsGrid();
    this.items.add(this.staticColorsGrid);
    if (this.documentColorsCount) {
      const bind = Template.bind(this.documentColors, this.documentColors);
      const label = new LabelView(this.locale);
      label.text = this._documentColorsLabel;
      label.extendTemplate({
        attributes: {
          class: [
            "ck",
            "ck-color-grid__label",
            bind.if("isEmpty", "ck-hidden")
          ]
        }
      });
      this.items.add(label);
      this.documentColorsGrid = this._createDocumentColorsGrid();
      this.items.add(this.documentColorsGrid);
    }
    this._createColorPickerButton();
    this._addColorSelectorElementsToFocusTracker();
    this.focus();
  }
  /**
   * Focuses the component.
   */
  focus() {
    this.removeColorButtonView.focus();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
  }
  /**
   * Handles displaying the color picker button (if it was previously created) and making it focusable.
   */
  addColorPickerButton() {
    if (this.colorPickerButtonView) {
      this.items.add(this.colorPickerButtonView);
      this.focusTracker.add(this.colorPickerButtonView.element);
      this._focusables.add(this.colorPickerButtonView);
    }
  }
  /**
   * Adds color selector elements to focus tracker.
   */
  _addColorSelectorElementsToFocusTracker() {
    this.focusTracker.add(this.removeColorButtonView.element);
    this._focusables.add(this.removeColorButtonView);
    if (this.staticColorsGrid) {
      this.focusTracker.add(this.staticColorsGrid.element);
      this._focusables.add(this.staticColorsGrid);
    }
    if (this.documentColorsGrid) {
      this.focusTracker.add(this.documentColorsGrid.element);
      this._focusables.add(this.documentColorsGrid);
    }
  }
  /**
   * Creates the button responsible for displaying the color picker component.
   */
  _createColorPickerButton() {
    this.colorPickerButtonView = new ButtonView();
    this.colorPickerButtonView.set({
      label: this._colorPickerLabel,
      withText: true,
      icon: colorPaletteIcon,
      class: "ck-color-selector__color-picker"
    });
    this.colorPickerButtonView.on("execute", () => {
      this.fire("colorPicker:show");
    });
  }
  /**
   * Adds the remove color button as a child of the current view.
   */
  _createRemoveColorButton() {
    const buttonView = new ButtonView();
    buttonView.set({
      withText: true,
      icon: removeButtonIcon,
      label: this._removeButtonLabel
    });
    buttonView.class = "ck-color-selector__remove-color";
    buttonView.on("execute", () => {
      this.fire("execute", {
        value: null,
        source: "removeColorButton"
      });
    });
    buttonView.render();
    return buttonView;
  }
  /**
   * Creates a static color grid based on the editor configuration.
   */
  _createStaticColorsGrid() {
    const colorGrid = new ColorGridView(this.locale, {
      colorDefinitions: this.colorDefinitions,
      columns: this.columns
    });
    colorGrid.on("execute", (evt, data) => {
      this.fire("execute", {
        value: data.value,
        source: "staticColorsGrid"
      });
    });
    return colorGrid;
  }
  /**
   * Creates the document colors section view and binds it to {@link #documentColors}.
   */
  _createDocumentColorsGrid() {
    const bind = Template.bind(this.documentColors, this.documentColors);
    const documentColorsGrid = new ColorGridView(this.locale, {
      columns: this.columns
    });
    documentColorsGrid.extendTemplate({
      attributes: {
        class: bind.if("isEmpty", "ck-hidden")
      }
    });
    documentColorsGrid.items.bindTo(this.documentColors).using((colorObj) => {
      const colorTile = new ColorTileView();
      colorTile.set({
        color: colorObj.color,
        hasBorder: colorObj.options && colorObj.options.hasBorder
      });
      if (colorObj.label) {
        colorTile.set({
          label: colorObj.label,
          tooltip: true
        });
      }
      colorTile.on("execute", () => {
        this.fire("execute", {
          value: colorObj.color,
          source: "documentColorsGrid"
        });
      });
      return colorTile;
    });
    this.documentColors.on("change:isEmpty", (evt, name, val) => {
      if (val) {
        documentColorsGrid.selectedColor = null;
      }
    });
    return documentColorsGrid;
  }
  /**
   * Adds a given color to the document colors list. If possible, the method will attempt to use
   * data from the {@link #colorDefinitions} (label, color options).
   *
   * @param color A string that stores the value of the recently applied color.
   */
  _addColorToDocumentColors(color) {
    const predefinedColor = this.colorDefinitions.find((definition) => definition.color === color);
    if (!predefinedColor) {
      this.documentColors.add({
        color,
        label: color,
        options: {
          hasBorder: false
        }
      });
    } else {
      this.documentColors.add(Object.assign({}, predefinedColor));
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorpickerfragmentview.js
import checkButtonIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-core/theme/icons/check.svg";
import cancelButtonIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-core/theme/icons/cancel.svg";
var ColorPickerFragmentView = class extends View {
  /**
   * Creates an instance of the view.
   *
   * @param locale The localization services instance.
   * @param focusTracker Tracks information about the DOM focus in the list.
   * @param focusables A collection of views that can be focused in the view..
   * @param keystrokes An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
   * @param colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker
   * will not be rendered.
   */
  constructor(locale, { focusTracker, focusables, keystrokes, colorPickerViewConfig }) {
    super(locale);
    this.items = this.createCollection();
    this.focusTracker = focusTracker;
    this.keystrokes = keystrokes;
    this.set("isVisible", false);
    this.set("selectedColor", void 0);
    this._focusables = focusables;
    this._colorPickerViewConfig = colorPickerViewConfig;
    const bind = this.bindTemplate;
    const { saveButtonView, cancelButtonView } = this._createActionButtons();
    this.saveButtonView = saveButtonView;
    this.cancelButtonView = cancelButtonView;
    this.actionBarView = this._createActionBarView({ saveButtonView, cancelButtonView });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-color-picker-fragment",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: this.items
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    const colorPickerView = new ColorPickerView(this.locale, {
      ...this._colorPickerViewConfig
    });
    this.colorPickerView = colorPickerView;
    this.colorPickerView.render();
    if (this.selectedColor) {
      colorPickerView.color = this.selectedColor;
    }
    this.listenTo(this, "change:selectedColor", (evt, name, value) => {
      colorPickerView.color = value;
    });
    this.items.add(this.colorPickerView);
    this.items.add(this.actionBarView);
    this._addColorPickersElementsToFocusTracker();
    this._stopPropagationOnArrowsKeys();
    this._executeOnEnterPress();
    this._executeUponColorChange();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
  }
  /**
   * Focuses the color picker.
   */
  focus() {
    this.colorPickerView.focus();
  }
  /**
   * When color picker is focused and "enter" is pressed it executes command.
   */
  _executeOnEnterPress() {
    this.keystrokes.set("enter", (evt) => {
      if (this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element) {
        this.fire("execute", {
          value: this.selectedColor
        });
        evt.stopPropagation();
        evt.preventDefault();
      }
    });
  }
  /**
   * Removes default behavior of arrow keys in dropdown.
   */
  _stopPropagationOnArrowsKeys() {
    const stopPropagation = (data) => data.stopPropagation();
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  /**
   * Adds color picker elements to focus tracker.
   */
  _addColorPickersElementsToFocusTracker() {
    for (const slider of this.colorPickerView.slidersView) {
      this.focusTracker.add(slider.element);
      this._focusables.add(slider);
    }
    const input = this.colorPickerView.hexInputRow.children.get(1);
    if (input.element) {
      this.focusTracker.add(input.element);
      this._focusables.add(input);
    }
    this.focusTracker.add(this.saveButtonView.element);
    this._focusables.add(this.saveButtonView);
    this.focusTracker.add(this.cancelButtonView.element);
    this._focusables.add(this.cancelButtonView);
  }
  /**
   * Creates bar containing "Save" and "Cancel" buttons.
   */
  _createActionBarView({ saveButtonView, cancelButtonView }) {
    const actionBarRow = new View();
    const children = this.createCollection();
    children.add(saveButtonView);
    children.add(cancelButtonView);
    actionBarRow.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-selector_action-bar"
        ]
      },
      children
    });
    return actionBarRow;
  }
  /**
   * Creates "Save" and "Cancel" buttons.
   */
  _createActionButtons() {
    const locale = this.locale;
    const t = locale.t;
    const saveButtonView = new ButtonView(locale);
    const cancelButtonView = new ButtonView(locale);
    saveButtonView.set({
      icon: checkButtonIcon,
      class: "ck-button-save",
      type: "button",
      withText: false,
      label: t("Accept")
    });
    cancelButtonView.set({
      icon: cancelButtonIcon,
      class: "ck-button-cancel",
      type: "button",
      withText: false,
      label: t("Cancel")
    });
    saveButtonView.on("execute", () => {
      this.fire("execute", {
        source: "colorPickerSaveButton",
        value: this.selectedColor
      });
    });
    cancelButtonView.on("execute", () => {
      this.fire("colorPicker:cancel");
    });
    return {
      saveButtonView,
      cancelButtonView
    };
  }
  /**
   * Fires the `execute` event if color in color picker has been changed
   * by the user.
   */
  _executeUponColorChange() {
    this.colorPickerView.on("colorSelected", (evt, data) => {
      this.fire("execute", {
        value: data.color,
        source: "colorPicker"
      });
      this.set("selectedColor", data.color);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorselectorview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/colorselector/colorselector.css";
var ColorSelectorView = class extends View {
  /**
   * Creates a view to be inserted as a child of {@link module:ui/dropdown/dropdownview~DropdownView}.
   *
   * @param locale The localization services instance.
   * @param colors An array with definitions of colors to be displayed in the table.
   * @param columns The number of columns in the color grid.
   * @param removeButtonLabel The label of the button responsible for removing the color.
   * @param colorPickerLabel The label of the button responsible for color picker appearing.
   * @param documentColorsLabel The label for the section with the document colors.
   * @param documentColorsCount The number of colors in the document colors section inside the color dropdown.
   * @param colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker will be hidden.
   */
  constructor(locale, { colors, columns, removeButtonLabel, documentColorsLabel, documentColorsCount, colorPickerLabel, colorPickerViewConfig }) {
    super(locale);
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusables = new ViewCollection();
    this._colorPickerViewConfig = colorPickerViewConfig;
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate list items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate list items forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    });
    this.colorGridsFragmentView = new ColorGridsFragmentView(locale, {
      colors,
      columns,
      removeButtonLabel,
      documentColorsLabel,
      documentColorsCount,
      colorPickerLabel,
      focusTracker: this.focusTracker,
      focusables: this._focusables
    });
    this.colorPickerFragmentView = new ColorPickerFragmentView(locale, {
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokes: this.keystrokes,
      colorPickerViewConfig
    });
    this.set("_isColorGridsFragmentVisible", true);
    this.set("_isColorPickerFragmentVisible", false);
    this.set("selectedColor", void 0);
    this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible");
    this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible");
    this.on("change:selectedColor", (evt, evtName, data) => {
      this.colorGridsFragmentView.set("selectedColor", data);
      this.colorPickerFragmentView.set("selectedColor", data);
    });
    this.colorGridsFragmentView.on("change:selectedColor", (evt, evtName, data) => {
      this.set("selectedColor", data);
    });
    this.colorPickerFragmentView.on("change:selectedColor", (evt, evtName, data) => {
      this.set("selectedColor", data);
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-selector"
        ]
      },
      children: this.items
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Renders the internals of the component on demand:
   * * {@link #colorPickerFragmentView},
   * * {@link #colorGridsFragmentView}.
   *
   * It allows for deferring component initialization to improve the performance.
   *
   * See {@link #showColorPickerFragment}, {@link #showColorGridsFragment}.
   */
  appendUI() {
    this._appendColorGridsFragment();
    if (this._colorPickerViewConfig) {
      this._appendColorPickerFragment();
    }
  }
  /**
   * Shows the {@link #colorPickerFragmentView} and hides the {@link #colorGridsFragmentView}.
   *
   * **Note**: It requires {@link #appendUI} to be called first.
   *
   * See {@link #showColorGridsFragment}, {@link ~ColorSelectorView#event:colorPicker:show}.
   */
  showColorPickerFragment() {
    if (!this.colorPickerFragmentView.colorPickerView || this._isColorPickerFragmentVisible) {
      return;
    }
    this._isColorPickerFragmentVisible = true;
    this.colorPickerFragmentView.focus();
    this._isColorGridsFragmentVisible = false;
  }
  /**
   * Shows the {@link #colorGridsFragmentView} and hides the {@link #colorPickerFragmentView}.
   *
   * See {@link #showColorPickerFragment}.
   *
   * **Note**: It requires {@link #appendUI} to be called first.
   */
  showColorGridsFragment() {
    if (this._isColorGridsFragmentVisible) {
      return;
    }
    this._isColorGridsFragmentVisible = true;
    this.colorGridsFragmentView.focus();
    this._isColorPickerFragmentVisible = false;
  }
  /**
   * Focuses the first focusable element in {@link #items}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable element in {@link #items}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
   * Scans through the editor model and searches for text node attributes with the given `attributeName`.
   * Found entries are set as document colors in {@link #colorGridsFragmentView}.
   *
   * All the previously stored document colors will be lost in the process.
   *
   * @param model The model used as a source to obtain the document colors.
   * @param attributeName Determines the name of the related model's attribute for a given dropdown.
   */
  updateDocumentColors(model, attributeName) {
    this.colorGridsFragmentView.updateDocumentColors(model, attributeName);
  }
  /**
   * Refreshes the state of the selected color in one or both grids located in {@link #colorGridsFragmentView}.
   *
   * It guarantees that the selection will occur only in one of them.
   */
  updateSelectedColors() {
    this.colorGridsFragmentView.updateSelectedColors();
  }
  /**
   * Appends the view containing static and document color grid views.
   */
  _appendColorGridsFragment() {
    if (this.items.length) {
      return;
    }
    this.items.add(this.colorGridsFragmentView);
    this.colorGridsFragmentView.delegate("execute").to(this);
    this.colorGridsFragmentView.delegate("colorPicker:show").to(this);
  }
  /**
   * Appends the view with the color picker.
   */
  _appendColorPickerFragment() {
    if (this.items.length === 2) {
      return;
    }
    this.items.add(this.colorPickerFragmentView);
    if (this.colorGridsFragmentView.colorPickerButtonView) {
      this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
        this.showColorPickerFragment();
      });
    }
    this.colorGridsFragmentView.addColorPickerButton();
    this.colorPickerFragmentView.delegate("execute").to(this);
    this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/componentfactory.js
var ComponentFactory = class {
  /**
   * Creates an instance of the factory.
   *
   * @param editor The editor instance.
   */
  constructor(editor) {
    this._components = /* @__PURE__ */ new Map();
    this.editor = editor;
  }
  /**
   * Returns an iterator of registered component names. Names are returned in lower case.
   */
  *names() {
    for (const value of this._components.values()) {
      yield value.originalName;
    }
  }
  /**
   * Registers a component factory function that will be used by the
   * {@link #create create} method and called with the
   * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
   * allowing localization of the {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @param callback The callback that returns the component.
   */
  add(name, callback) {
    this._components.set(getNormalized(name), { callback, originalName: name });
  }
  /**
   * Creates an instance of a component registered in the factory under a specific name.
   *
   * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
   * the previously {@link #add added} factory function, allowing localization of the
   * {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @returns The instantiated component view.
   */
  create(name) {
    if (!this.has(name)) {
      throw new CKEditorError("componentfactory-item-missing", this, { name });
    }
    return this._components.get(getNormalized(name)).callback(this.editor.locale);
  }
  /**
   * Checks if a component of a given name is registered in the factory.
   *
   * @param name The name of the component.
   */
  has(name) {
    return this._components.has(getNormalized(name));
  }
};
function getNormalized(name) {
  return String(name).toLowerCase();
}

// node_modules/@ckeditor/ckeditor5-ui/src/tooltipmanager.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css";
var BALLOON_CLASS = "ck-tooltip";
var TooltipManager = class _TooltipManager extends DomEmitterMixin() {
  /**
   * Creates an instance of the tooltip manager.
   */
  constructor(editor) {
    super();
    this._currentElementWithTooltip = null;
    this._currentTooltipPosition = null;
    this._resizeObserver = null;
    _TooltipManager._editors.add(editor);
    if (_TooltipManager._instance) {
      return _TooltipManager._instance;
    }
    _TooltipManager._instance = this;
    this.tooltipTextView = new View(editor.locale);
    this.tooltipTextView.set("text", "");
    this.tooltipTextView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-tooltip__text"
        ]
      },
      children: [
        {
          text: this.tooltipTextView.bindTemplate.to("text")
        }
      ]
    });
    this.balloonPanelView = new BalloonPanelView(editor.locale);
    this.balloonPanelView.class = BALLOON_CLASS;
    this.balloonPanelView.content.add(this.tooltipTextView);
    this._pinTooltipDebounced = debounce_default(this._pinTooltip, 600);
    this.listenTo(global_default.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "scroll", this._onScroll.bind(this), { useCapture: true });
    this._watchdogExcluded = true;
  }
  /**
   * Destroys the tooltip manager.
   *
   * **Note**: The manager singleton cannot be destroyed until all editors that use it are destroyed.
   *
   * @param editor The editor the manager was created for.
   */
  destroy(editor) {
    const editorBodyViewCollection = editor.ui.view && editor.ui.view.body;
    _TooltipManager._editors.delete(editor);
    this.stopListening(editor.ui);
    if (editorBodyViewCollection && editorBodyViewCollection.has(this.balloonPanelView)) {
      editorBodyViewCollection.remove(this.balloonPanelView);
    }
    if (!_TooltipManager._editors.size) {
      this._unpinTooltip();
      this.balloonPanelView.destroy();
      this.stopListening();
      _TooltipManager._instance = null;
    }
  }
  /**
   * Returns {@link #balloonPanelView} {@link module:utils/dom/position~PositioningFunction positioning functions} for a given position
   * name.
   *
   * @param position Name of the position (`s`, `se`, `sw`, `n`, `e`, or `w`).
   * @returns Positioning functions to be used by the {@link #balloonPanelView}.
   */
  static getPositioningFunctions(position) {
    const defaultPositions = _TooltipManager.defaultBalloonPositions;
    return {
      // South is most popular. We can use positioning heuristics to avoid clipping by the viewport with the sane fallback.
      s: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthEast,
        defaultPositions.southArrowNorthWest
      ],
      n: [defaultPositions.northArrowSouth],
      e: [defaultPositions.eastArrowWest],
      w: [defaultPositions.westArrowEast],
      sw: [defaultPositions.southArrowNorthEast],
      se: [defaultPositions.southArrowNorthWest]
    }[position];
  }
  /**
   * Handles displaying tooltips on `mouseenter` and `focus` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onEnterOrFocus(evt, { target }) {
    const elementWithTooltipAttribute = getDescendantWithTooltip(target);
    if (!elementWithTooltipAttribute) {
      return;
    }
    if (elementWithTooltipAttribute === this._currentElementWithTooltip) {
      return;
    }
    this._unpinTooltip();
    this._pinTooltipDebounced(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
  }
  /**
   * Handles hiding tooltips on `mouseleave` and `blur` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onLeaveOrBlur(evt, { target, relatedTarget }) {
    if (evt.name === "mouseleave") {
      if (!isElement_default(target)) {
        return;
      }
      if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      const descendantWithTooltip = getDescendantWithTooltip(target);
      const relatedDescendantWithTooltip = getDescendantWithTooltip(relatedTarget);
      if (descendantWithTooltip && descendantWithTooltip !== relatedDescendantWithTooltip) {
        this._unpinTooltip();
      }
    } else {
      if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      this._unpinTooltip();
    }
  }
  /**
   * Handles hiding tooltips on `scroll` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onScroll(evt, { target }) {
    if (!this._currentElementWithTooltip) {
      return;
    }
    if (target.contains(this.balloonPanelView.element) && target.contains(this._currentElementWithTooltip)) {
      return;
    }
    this._unpinTooltip();
  }
  /**
   * Pins the tooltip to a specific DOM element.
   *
   * @param options.text Text of the tooltip to display.
   * @param options.position The position of the tooltip.
   * @param options.cssClass Additional CSS class of the balloon with the tooltip.
   */
  _pinTooltip(targetDomElement, { text, position, cssClass }) {
    const bodyViewCollection = first(_TooltipManager._editors.values()).ui.view.body;
    if (!bodyViewCollection.has(this.balloonPanelView)) {
      bodyViewCollection.add(this.balloonPanelView);
    }
    this.tooltipTextView.text = text;
    this.balloonPanelView.pin({
      target: targetDomElement,
      positions: _TooltipManager.getPositioningFunctions(position)
    });
    this._resizeObserver = new ResizeObserver(targetDomElement, () => {
      if (!isVisible(targetDomElement)) {
        this._unpinTooltip();
      }
    });
    this.balloonPanelView.class = [BALLOON_CLASS, cssClass].filter((className) => className).join(" ");
    for (const editor of _TooltipManager._editors) {
      this.listenTo(editor.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
    }
    this._currentElementWithTooltip = targetDomElement;
    this._currentTooltipPosition = position;
  }
  /**
   * Unpins the tooltip and cancels all queued pinning.
   */
  _unpinTooltip() {
    this._pinTooltipDebounced.cancel();
    this.balloonPanelView.unpin();
    for (const editor of _TooltipManager._editors) {
      this.stopListening(editor.ui, "update");
    }
    this._currentElementWithTooltip = null;
    this._currentTooltipPosition = null;
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  /**
   * Updates the position of the tooltip so it stays in sync with the element it is pinned to.
   *
   * Hides the tooltip when the element is no longer visible in DOM.
   */
  _updateTooltipPosition() {
    if (!isVisible(this._currentElementWithTooltip)) {
      this._unpinTooltip();
      return;
    }
    this.balloonPanelView.pin({
      target: this._currentElementWithTooltip,
      positions: _TooltipManager.getPositioningFunctions(this._currentTooltipPosition)
    });
  }
};
TooltipManager.defaultBalloonPositions = generatePositions({
  heightOffset: 5,
  sideOffset: 13
});
TooltipManager._editors = /* @__PURE__ */ new Set();
TooltipManager._instance = null;
function getDescendantWithTooltip(element) {
  if (!isElement_default(element)) {
    return null;
  }
  return element.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])");
}
function getTooltipData(element) {
  return {
    text: element.dataset.ckeTooltipText,
    position: element.dataset.ckeTooltipPosition || "s",
    cssClass: element.dataset.ckeTooltipClass || ""
  };
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/poweredby.js
import poweredByIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/icons/project-logo.svg";
var ICON_WIDTH = 53;
var ICON_HEIGHT = 10;
var NARROW_ROOT_HEIGHT_THRESHOLD = 50;
var NARROW_ROOT_WIDTH_THRESHOLD = 350;
var DEFAULT_LABEL = "Powered by";
var OFF_THE_SCREEN_POSITION = {
  top: -99999,
  left: -99999,
  name: "invalid",
  config: {
    withArrow: false
  }
};
var PoweredBy = class extends DomEmitterMixin() {
  /**
   * Creates a "powered by" helper for a given editor. The feature is initialized on Editor#ready
   * event.
   *
   * @param editor
   */
  constructor(editor) {
    super();
    this.editor = editor;
    this._balloonView = null;
    this._lastFocusedEditableElement = null;
    this._showBalloonThrottled = throttle_default(this._showBalloon.bind(this), 50, { leading: true });
    editor.on("ready", this._handleEditorReady.bind(this));
  }
  /**
   * Destroys the "powered by" helper along with its view.
   */
  destroy() {
    const balloon = this._balloonView;
    if (balloon) {
      balloon.unpin();
      this._balloonView = null;
    }
    this._showBalloonThrottled.cancel();
    this.stopListening();
  }
  /**
   * Enables "powered by" label once the editor (ui) is ready.
   */
  _handleEditorReady() {
    const editor = this.editor;
    const forceVisible = !!editor.config.get("ui.poweredBy.forceVisible");
    if (!forceVisible && verifyLicense(editor.config.get("licenseKey")) === "VALID") {
      return;
    }
    if (!editor.ui.view) {
      return;
    }
    editor.ui.focusTracker.on("change:isFocused", (evt, data, isFocused) => {
      this._updateLastFocusedEditableElement();
      if (isFocused) {
        this._showBalloon();
      } else {
        this._hideBalloon();
      }
    });
    editor.ui.focusTracker.on("change:focusedElement", (evt, data, focusedElement) => {
      this._updateLastFocusedEditableElement();
      if (focusedElement) {
        this._showBalloon();
      }
    });
    editor.ui.on("update", () => {
      this._showBalloonThrottled();
    });
  }
  /**
   * Creates an instance of the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon panel}
   * with the "powered by" view inside ready for positioning.
   */
  _createBalloonView() {
    const editor = this.editor;
    const balloon = this._balloonView = new BalloonPanelView();
    const poweredByConfig = getNormalizedConfig(editor);
    const view = new PoweredByView(editor.locale, poweredByConfig.label);
    balloon.content.add(view);
    balloon.set({
      class: "ck-powered-by-balloon"
    });
    editor.ui.view.body.add(balloon);
    editor.ui.focusTracker.add(balloon.element);
    this._balloonView = balloon;
  }
  /**
   * Attempts to display the balloon with the "powered by" view.
   */
  _showBalloon() {
    if (!this._lastFocusedEditableElement) {
      return;
    }
    const attachOptions = getBalloonAttachOptions(this.editor, this._lastFocusedEditableElement);
    if (attachOptions) {
      if (!this._balloonView) {
        this._createBalloonView();
      }
      this._balloonView.pin(attachOptions);
    }
  }
  /**
   * Hides the "powered by" balloon if already visible.
   */
  _hideBalloon() {
    if (this._balloonView) {
      this._balloonView.unpin();
    }
  }
  /**
   * Updates the {@link #_lastFocusedEditableElement} based on the state of the global focus tracker.
   */
  _updateLastFocusedEditableElement() {
    const editor = this.editor;
    const isFocused = editor.ui.focusTracker.isFocused;
    const focusedElement = editor.ui.focusTracker.focusedElement;
    if (!isFocused || !focusedElement) {
      this._lastFocusedEditableElement = null;
      return;
    }
    const editableEditorElements = Array.from(editor.ui.getEditableElementsNames()).map((name) => {
      return editor.ui.getEditableElement(name);
    });
    if (editableEditorElements.includes(focusedElement)) {
      this._lastFocusedEditableElement = focusedElement;
    } else {
      this._lastFocusedEditableElement = editableEditorElements[0];
    }
  }
};
var PoweredByView = class extends View {
  /**
   * Created an instance of the "powered by" view.
   *
   * @param locale The localization services instance.
   * @param label The label text.
   */
  constructor(locale, label) {
    super(locale);
    const iconView = new IconView();
    const bind = this.bindTemplate;
    iconView.set({
      content: poweredByIcon,
      isColorInherited: false
    });
    iconView.extendTemplate({
      attributes: {
        style: {
          width: ICON_WIDTH + "px",
          height: ICON_HEIGHT + "px"
        }
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-powered-by"],
        "aria-hidden": true
      },
      children: [
        {
          tag: "a",
          attributes: {
            href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
            target: "_blank",
            tabindex: "-1"
          },
          children: [
            ...label ? [
              {
                tag: "span",
                attributes: {
                  class: ["ck", "ck-powered-by__label"]
                },
                children: [label]
              }
            ] : [],
            iconView
          ],
          on: {
            dragstart: bind.to((evt) => evt.preventDefault())
          }
        }
      ]
    });
  }
};
function getBalloonAttachOptions(editor, focusedEditableElement) {
  const poweredByConfig = getNormalizedConfig(editor);
  const positioningFunction = poweredByConfig.side === "right" ? getLowerRightCornerPosition(focusedEditableElement, poweredByConfig) : getLowerLeftCornerPosition(focusedEditableElement, poweredByConfig);
  return {
    target: focusedEditableElement,
    positions: [positioningFunction]
  };
}
function getLowerRightCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect, balloonRect) => {
    return rootRect.left + rootRect.width - balloonRect.width - config.horizontalOffset;
  });
}
function getLowerLeftCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect) => rootRect.left + config.horizontalOffset);
}
function getLowerCornerPosition(focusedEditableElement, config, getBalloonLeft) {
  return (editableElementRect, balloonRect) => {
    const visibleEditableElementRect = editableElementRect.getVisible();
    if (!visibleEditableElementRect) {
      return OFF_THE_SCREEN_POSITION;
    }
    if (editableElementRect.width < NARROW_ROOT_WIDTH_THRESHOLD || editableElementRect.height < NARROW_ROOT_HEIGHT_THRESHOLD) {
      return OFF_THE_SCREEN_POSITION;
    }
    let balloonTop;
    if (config.position === "inside") {
      balloonTop = editableElementRect.bottom - balloonRect.height;
    } else {
      balloonTop = editableElementRect.bottom - balloonRect.height / 2;
    }
    balloonTop -= config.verticalOffset;
    const balloonLeft = getBalloonLeft(editableElementRect, balloonRect);
    if (config.position === "inside") {
      const newBalloonRect = balloonRect.clone().moveTo(balloonLeft, balloonTop);
      if (newBalloonRect.getIntersectionArea(visibleEditableElementRect) < newBalloonRect.getArea()) {
        return OFF_THE_SCREEN_POSITION;
      }
    } else {
      const firstScrollableEditableElementAncestor = findClosestScrollableAncestor(focusedEditableElement);
      if (firstScrollableEditableElementAncestor) {
        const firstScrollableEditableElementAncestorRect = new Rect(firstScrollableEditableElementAncestor);
        const notVisibleVertically = visibleEditableElementRect.bottom + balloonRect.height / 2 > firstScrollableEditableElementAncestorRect.bottom;
        const notVisibleHorizontally = config.side === "left" ? editableElementRect.left < firstScrollableEditableElementAncestorRect.left : editableElementRect.right > firstScrollableEditableElementAncestorRect.right;
        if (notVisibleVertically || notVisibleHorizontally) {
          return OFF_THE_SCREEN_POSITION;
        }
      }
    }
    return {
      top: balloonTop,
      left: balloonLeft,
      name: `position_${config.position}-side_${config.side}`,
      config: {
        withArrow: false
      }
    };
  };
}
function getNormalizedConfig(editor) {
  const userConfig = editor.config.get("ui.poweredBy");
  const position = userConfig && userConfig.position || "border";
  return {
    position,
    label: DEFAULT_LABEL,
    verticalOffset: position === "inside" ? 5 : 0,
    horizontalOffset: 5,
    side: editor.locale.contentLanguageDirection === "ltr" ? "right" : "left",
    ...userConfig
  };
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/editorui.js
var EditorUI = class extends ObservableMixin() {
  /**
   * Creates an instance of the editor UI class.
   *
   * @param editor The editor instance.
   */
  constructor(editor) {
    super();
    this.isReady = false;
    this._editableElementsMap = /* @__PURE__ */ new Map();
    this._focusableToolbarDefinitions = [];
    const editingView = editor.editing.view;
    this.editor = editor;
    this.componentFactory = new ComponentFactory(editor);
    this.focusTracker = new FocusTracker();
    this.tooltipManager = new TooltipManager(editor);
    this.poweredBy = new PoweredBy(editor);
    this.set("viewportOffset", this._readViewportOffsetFromConfig());
    this.once("ready", () => {
      this.isReady = true;
    });
    this.listenTo(editingView.document, "layoutChanged", this.update.bind(this));
    this.listenTo(editingView, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this));
    this._initFocusTracking();
  }
  /**
   * The main (outermost) DOM element of the editor UI.
   *
   * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
   * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
   * it is the editable element itself (as there is no other wrapper). However, in
   * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
   * come with a single "main" HTML element (its editable element and toolbar are separate).
   *
   * This property can be understood as a shorthand for retrieving the element that a specific editor integration
   * considers to be its main DOM element.
   */
  get element() {
    return null;
  }
  /**
   * Fires the {@link module:ui/editorui/editorui~EditorUI#event:update `update`} event.
   *
   * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
   * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
   */
  update() {
    this.fire("update");
  }
  /**
   * Destroys the UI.
   */
  destroy() {
    this.stopListening();
    this.focusTracker.destroy();
    this.tooltipManager.destroy(this.editor);
    this.poweredBy.destroy();
    for (const domElement of this._editableElementsMap.values()) {
      domElement.ckeditorInstance = null;
      this.editor.keystrokes.stopListening(domElement);
    }
    this._editableElementsMap = /* @__PURE__ */ new Map();
    this._focusableToolbarDefinitions = [];
  }
  /**
   * Stores the native DOM editable element used by the editor under a unique name.
   *
   * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable
   * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.
   *
   * @param rootName The unique name of the editable element.
   * @param domElement The native DOM editable element.
   */
  setEditableElement(rootName, domElement) {
    this._editableElementsMap.set(rootName, domElement);
    if (!domElement.ckeditorInstance) {
      domElement.ckeditorInstance = this.editor;
    }
    this.focusTracker.add(domElement);
    const setUpKeystrokeHandler = () => {
      if (this.editor.editing.view.getDomRoot(rootName)) {
        return;
      }
      this.editor.keystrokes.listenTo(domElement);
    };
    if (this.isReady) {
      setUpKeystrokeHandler();
    } else {
      this.once("ready", setUpKeystrokeHandler);
    }
  }
  /**
   * Removes the editable from the editor UI. Removes all handlers added by {@link #setEditableElement}.
   *
   * @param rootName The name of the editable element to remove.
   */
  removeEditableElement(rootName) {
    const domElement = this._editableElementsMap.get(rootName);
    if (!domElement) {
      return;
    }
    this._editableElementsMap.delete(rootName);
    this.editor.keystrokes.stopListening(domElement);
    this.focusTracker.remove(domElement);
    domElement.ckeditorInstance = null;
  }
  /**
   * Returns the editable editor element with the given name or null if editable does not exist.
   *
   * @param rootName The editable name.
   */
  getEditableElement(rootName = "main") {
    return this._editableElementsMap.get(rootName);
  }
  /**
   * Returns array of names of all editor editable elements.
   */
  getEditableElementsNames() {
    return this._editableElementsMap.keys();
  }
  /**
   * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.
   *
   * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.
   * Successive keystroke presses navigate over available toolbars.
   *
   * @param toolbarView A instance of the toolbar to be registered.
   */
  addToolbar(toolbarView, options = {}) {
    if (toolbarView.isRendered) {
      this.focusTracker.add(toolbarView.element);
      this.editor.keystrokes.listenTo(toolbarView.element);
    } else {
      toolbarView.once("render", () => {
        this.focusTracker.add(toolbarView.element);
        this.editor.keystrokes.listenTo(toolbarView.element);
      });
    }
    this._focusableToolbarDefinitions.push({ toolbarView, options });
  }
  /**
   * Stores all editable elements used by the editor instance.
   *
   * @deprecated
   */
  get _editableElements() {
    console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this });
    return this._editableElementsMap;
  }
  /**
   * Returns viewport offsets object:
   *
   * ```js
   * {
   * 	top: Number,
   * 	right: Number,
   * 	bottom: Number,
   * 	left: Number
   * }
   * ```
   *
   * Only top property is currently supported.
   */
  _readViewportOffsetFromConfig() {
    const editor = this.editor;
    const viewportOffsetConfig = editor.config.get("ui.viewportOffset");
    if (viewportOffsetConfig) {
      return viewportOffsetConfig;
    }
    const legacyOffsetConfig = editor.config.get("toolbar.viewportTopOffset");
    if (legacyOffsetConfig) {
      console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.");
      return { top: legacyOffsetConfig };
    }
    return { top: 0 };
  }
  /**
   * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable
   * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}
   * to allow users navigate across the UI.
   */
  _initFocusTracking() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    let lastFocusedForeignElement;
    let candidateDefinitions;
    editor.keystrokes.set("Alt+F10", (data, cancel) => {
      const focusedElement = this.focusTracker.focusedElement;
      if (Array.from(this._editableElementsMap.values()).includes(focusedElement) && !Array.from(editingView.domRoots.values()).includes(focusedElement)) {
        lastFocusedForeignElement = focusedElement;
      }
      const currentFocusedToolbarDefinition = this._getCurrentFocusedToolbarDefinition();
      if (!currentFocusedToolbarDefinition || !candidateDefinitions) {
        candidateDefinitions = this._getFocusableCandidateToolbarDefinitions();
      }
      for (let i = 0; i < candidateDefinitions.length; i++) {
        const candidateDefinition = candidateDefinitions.shift();
        candidateDefinitions.push(candidateDefinition);
        if (candidateDefinition !== currentFocusedToolbarDefinition && this._focusFocusableCandidateToolbar(candidateDefinition)) {
          if (currentFocusedToolbarDefinition && currentFocusedToolbarDefinition.options.afterBlur) {
            currentFocusedToolbarDefinition.options.afterBlur();
          }
          break;
        }
      }
      cancel();
    });
    editor.keystrokes.set("Esc", (data, cancel) => {
      const focusedToolbarDef = this._getCurrentFocusedToolbarDefinition();
      if (!focusedToolbarDef) {
        return;
      }
      if (lastFocusedForeignElement) {
        lastFocusedForeignElement.focus();
        lastFocusedForeignElement = null;
      } else {
        editor.editing.view.focus();
      }
      if (focusedToolbarDef.options.afterBlur) {
        focusedToolbarDef.options.afterBlur();
      }
      cancel();
    });
  }
  /**
   * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.
   *
   * Focusable toolbars candidates are either:
   * * already visible,
   * * have `beforeFocus()` set in their {@link module:ui/editorui/editorui~FocusableToolbarDefinition definition} that suggests that
   * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible
   * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).
   *
   * **Note**: Contextual toolbars take precedence over regular toolbars.
   */
  _getFocusableCandidateToolbarDefinitions() {
    const definitions = [];
    for (const toolbarDef of this._focusableToolbarDefinitions) {
      const { toolbarView, options } = toolbarDef;
      if (isVisible(toolbarView.element) || options.beforeFocus) {
        definitions.push(toolbarDef);
      }
    }
    definitions.sort((defA, defB) => getToolbarDefinitionWeight(defA) - getToolbarDefinitionWeight(defB));
    return definitions;
  }
  /**
   * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).
   *
   * `null` is returned when no toolbar is currently focused.
   */
  _getCurrentFocusedToolbarDefinition() {
    for (const definition of this._focusableToolbarDefinitions) {
      if (definition.toolbarView.element && definition.toolbarView.element.contains(this.focusTracker.focusedElement)) {
        return definition;
      }
    }
    return null;
  }
  /**
   * Focuses a focusable toolbar candidate using its definition.
   *
   * @param candidateToolbarDefinition A definition of the toolbar to focus.
   * @returns `true` when the toolbar candidate was focused. `false` otherwise.
   */
  _focusFocusableCandidateToolbar(candidateToolbarDefinition) {
    const { toolbarView, options: { beforeFocus } } = candidateToolbarDefinition;
    if (beforeFocus) {
      beforeFocus();
    }
    if (!isVisible(toolbarView.element)) {
      return false;
    }
    toolbarView.focus();
    return true;
  }
  /**
   * Provides an integration between {@link #viewportOffset} and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
   * It allows the UI-agnostic engine method to consider user-configured viewport offsets specific for the integration.
   *
   * @param evt The `scrollToTheSelection` event info.
   * @param data The payload carried by the `scrollToTheSelection` event.
   */
  _handleScrollToTheSelection(evt, data) {
    const configuredViewportOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      ...this.viewportOffset
    };
    data.viewportOffset.top += configuredViewportOffset.top;
    data.viewportOffset.bottom += configuredViewportOffset.bottom;
    data.viewportOffset.left += configuredViewportOffset.left;
    data.viewportOffset.right += configuredViewportOffset.right;
  }
};
function getToolbarDefinitionWeight(toolbarDef) {
  const { toolbarView, options } = toolbarDef;
  let weight = 10;
  if (isVisible(toolbarView.element)) {
    weight--;
  }
  if (options.isContextual) {
    weight--;
  }
  return weight;
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/editoruiview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/editorui/editorui.css";
var EditorUIView = class extends View {
  /**
   * Creates an instance of the editor UI view class.
   *
   * @param locale The locale instance.
   */
  constructor(locale) {
    super(locale);
    this.body = new BodyCollection(locale);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.body.attachToDom();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this.body.detachFromDom();
    return super.destroy();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/boxed/boxededitoruiview.js
var BoxedEditorUIView = class extends EditorUIView {
  /**
   * Creates an instance of the boxed editor UI view class.
   *
   * @param locale The locale instance..
   */
  constructor(locale) {
    super(locale);
    this.top = this.createCollection();
    this.main = this.createCollection();
    this._voiceLabelView = this._createVoiceLabel();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-editor",
          "ck-rounded-corners"
        ],
        role: "application",
        dir: locale.uiLanguageDirection,
        lang: locale.uiLanguage,
        "aria-labelledby": this._voiceLabelView.id
      },
      children: [
        this._voiceLabelView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__top",
              "ck-reset_all"
            ],
            role: "presentation"
          },
          children: this.top
        },
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__main"
            ],
            role: "presentation"
          },
          children: this.main
        }
      ]
    });
  }
  /**
   * Creates a voice label view instance.
   */
  _createVoiceLabel() {
    const t = this.t;
    const voiceLabel = new LabelView();
    voiceLabel.text = t("Rich Text Editor");
    voiceLabel.extendTemplate({
      attributes: {
        class: "ck-voice-label"
      }
    });
    return voiceLabel;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editableui/editableuiview.js
var EditableUIView = class extends View {
  /**
   * Creates an instance of EditableUIView class.
   *
   * @param locale The locale instance.
   * @param editingView The editing view instance the editable is related to.
   * @param editableElement The editable element. If not specified, this view
   * should create it. Otherwise, the existing element should be used.
   */
  constructor(locale, editingView, editableElement) {
    super(locale);
    this.name = null;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-content",
          "ck-editor__editable",
          "ck-rounded-corners"
        ],
        lang: locale.contentLanguage,
        dir: locale.contentLanguageDirection
      }
    });
    this.set("isFocused", false);
    this._editableElement = editableElement;
    this._hasExternalElement = !!this._editableElement;
    this._editingView = editingView;
  }
  /**
   * Renders the view by either applying the {@link #template} to the existing
   * {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement} or assigning {@link #element}
   * as {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement}.
   */
  render() {
    super.render();
    if (this._hasExternalElement) {
      this.template.apply(this.element = this._editableElement);
    } else {
      this._editableElement = this.element;
    }
    this.on("change:isFocused", () => this._updateIsFocusedClasses());
    this._updateIsFocusedClasses();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    if (this._hasExternalElement) {
      this.template.revert(this._editableElement);
    }
    super.destroy();
  }
  /**
   * Whether an external {@link #_editableElement} was passed into the constructor, which also means
   * the view will not render its {@link #template}.
   */
  get hasExternalElement() {
    return this._hasExternalElement;
  }
  /**
   * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to
   * the {@link #isFocused} property value using the {@link #_editingView editing view} API.
   */
  _updateIsFocusedClasses() {
    const editingView = this._editingView;
    if (editingView.isRenderingInProgress) {
      updateAfterRender(this);
    } else {
      update(this);
    }
    function update(view) {
      editingView.change((writer) => {
        const viewRoot = editingView.document.getRoot(view.name);
        writer.addClass(view.isFocused ? "ck-focused" : "ck-blurred", viewRoot);
        writer.removeClass(view.isFocused ? "ck-blurred" : "ck-focused", viewRoot);
      });
    }
    function updateAfterRender(view) {
      editingView.once("change:isRenderingInProgress", (evt, name, value) => {
        if (!value) {
          update(view);
        } else {
          updateAfterRender(view);
        }
      });
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editableui/inline/inlineeditableuiview.js
var InlineEditableUIView = class extends EditableUIView {
  /**
   * Creates an instance of the InlineEditableUIView class.
   *
   * @param locale The locale instance.
   * @param editingView The editing view instance the editable is related to.
   * @param editableElement The editable element. If not specified, the
   * {@link module:ui/editableui/editableuiview~EditableUIView}
   * will create it. Otherwise, the existing element will be used.
   * @param options Additional configuration of the view.
   * @param options.label A function that gets called with the instance of this view as an argument
   * and should return a string that represents the label of the editable for assistive technologies. If not provided,
   * a default label generator is used.
   */
  constructor(locale, editingView, editableElement, options = {}) {
    super(locale, editingView, editableElement);
    const t = locale.t;
    this.extendTemplate({
      attributes: {
        role: "textbox",
        class: "ck-editor__editable_inline"
      }
    });
    this._generateLabel = options.label || (() => t("Editor editing area: %0", this.name));
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    const editingView = this._editingView;
    editingView.change((writer) => {
      const viewRoot = editingView.document.getRoot(this.name);
      writer.setAttribute("aria-label", this._generateLabel(this), viewRoot);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/formheader/formheaderview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css";
var FormHeaderView = class extends View {
  /**
   * Creates an instance of the form header class.
   *
   * @param locale The locale instance.
   * @param options.label A label.
   * @param options.class An additional class.
   */
  constructor(locale, options = {}) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("label", options.label || "");
    this.set("class", options.class || null);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-form__header",
          bind.to("class")
        ]
      },
      children: this.children
    });
    const label = new View(locale);
    label.setTemplate({
      tag: "h2",
      attributes: {
        class: [
          "ck",
          "ck-form__header__label"
        ]
      },
      children: [
        { text: bind.to("label") }
      ]
    });
    this.children.add(label);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css";
var toPx3 = toUnit("px");
var StickyPanelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isActive", false);
    this.set("isSticky", false);
    this.set("limiterElement", null);
    this.set("limiterBottomOffset", 50);
    this.set("viewportTopOffset", 0);
    this.set("_marginLeft", null);
    this.set("_isStickyToTheBottomOfLimiter", false);
    this.set("_stickyTopOffset", null);
    this.set("_stickyBottomOffset", null);
    this.content = this.createCollection();
    this._contentPanelPlaceholder = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__placeholder"
        ],
        style: {
          display: bind.to("isSticky", (isSticky) => isSticky ? "block" : "none"),
          height: bind.to("isSticky", (isSticky) => {
            return isSticky ? toPx3(this._contentPanelRect.height) : null;
          })
        }
      }
    }).render();
    this._contentPanel = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__content",
          // Toggle class of the panel when "sticky" state changes in the view.
          bind.if("isSticky", "ck-sticky-panel__content_sticky"),
          bind.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")
        ],
        style: {
          width: bind.to("isSticky", (isSticky) => {
            return isSticky ? toPx3(this._contentPanelPlaceholder.getBoundingClientRect().width) : null;
          }),
          top: bind.to("_stickyTopOffset", (value) => value ? toPx3(value) : value),
          bottom: bind.to("_stickyBottomOffset", (value) => value ? toPx3(value) : value),
          marginLeft: bind.to("_marginLeft")
        }
      },
      children: this.content
    }).render();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel"
        ]
      },
      children: [
        this._contentPanelPlaceholder,
        this._contentPanel
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.checkIfShouldBeSticky();
    this.listenTo(global_default.document, "scroll", (evt, data) => {
      this.checkIfShouldBeSticky(data.target);
    }, { useCapture: true });
    this.listenTo(this, "change:isActive", () => {
      this.checkIfShouldBeSticky();
    });
  }
  /**
   * Analyzes the environment to decide whether the panel should be sticky or not.
   * Then handles the positioning of the panel.
   *
   * @param [scrollTarget] The element which is being scrolled.
   */
  checkIfShouldBeSticky(scrollTarget) {
    if (!this.limiterElement || !this.isActive) {
      this._unstick();
      return;
    }
    const scrollableAncestors = getScrollableAncestors(this.limiterElement);
    if (scrollTarget && !scrollableAncestors.includes(scrollTarget)) {
      return;
    }
    const visibleAncestorsRect = getElementsIntersectionRect(scrollableAncestors, this.viewportTopOffset);
    const limiterRect = new Rect(this.limiterElement);
    if (visibleAncestorsRect && limiterRect.top < visibleAncestorsRect.top) {
      const visibleLimiterRect = limiterRect.getIntersection(visibleAncestorsRect);
      if (visibleLimiterRect) {
        const visibleAncestorsTop = visibleAncestorsRect.top;
        if (visibleAncestorsTop + this._contentPanelRect.height + this.limiterBottomOffset > visibleLimiterRect.bottom) {
          const stickyBottomOffset = Math.max(limiterRect.bottom - visibleAncestorsRect.bottom, 0) + this.limiterBottomOffset;
          if (limiterRect.bottom - stickyBottomOffset > limiterRect.top + this._contentPanelRect.height) {
            this._stickToBottomOfLimiter(stickyBottomOffset);
          } else {
            this._unstick();
          }
        } else {
          if (this._contentPanelRect.height + this.limiterBottomOffset < limiterRect.height) {
            this._stickToTopOfAncestors(visibleAncestorsTop);
          } else {
            this._unstick();
          }
        }
      } else {
        this._unstick();
      }
    } else {
      this._unstick();
    }
  }
  /**
   * Sticks the panel at the given CSS `top` offset.
   *
   * @private
   * @param topOffset
   */
  _stickToTopOfAncestors(topOffset) {
    this.isSticky = true;
    this._isStickyToTheBottomOfLimiter = false;
    this._stickyTopOffset = topOffset;
    this._stickyBottomOffset = null;
    this._marginLeft = toPx3(-global_default.window.scrollX);
  }
  /**
   * Sticks the panel at the bottom of the limiter with a given CSS `bottom` offset.
   *
   * @private
   * @param stickyBottomOffset
   */
  _stickToBottomOfLimiter(stickyBottomOffset) {
    this.isSticky = true;
    this._isStickyToTheBottomOfLimiter = true;
    this._stickyTopOffset = null;
    this._stickyBottomOffset = stickyBottomOffset;
    this._marginLeft = toPx3(-global_default.window.scrollX);
  }
  /**
   * Unsticks the panel putting it back to its original position.
   *
   * @private
   */
  _unstick() {
    this.isSticky = false;
    this._isStickyToTheBottomOfLimiter = false;
    this._stickyTopOffset = null;
    this._stickyBottomOffset = null;
    this._marginLeft = null;
  }
  /**
   * Returns the bounding rect of the {@link #_contentPanel}.
   *
   * @private
   */
  get _contentPanelRect() {
    return new Rect(this._contentPanel);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/balloon/balloontoolbar.js
var toPx4 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/block/blockbuttonview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css";
var toPx5 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/block/blocktoolbar.js
var toPx6 = toUnit("px");
var { pilcrow } = icons;

// node_modules/@ckeditor/ckeditor5-ui/src/index.js
import { default as colorPaletteIcon2 } from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-palette.svg";

export {
  clickOutsideHandler,
  CssTransitionDisablerMixin,
  submitHandler,
  addKeyboardHandlingForGrid,
  ViewCollection,
  View,
  Template,
  BodyCollection,
  IconView,
  ButtonView,
  SwitchButtonView,
  getLocalizedColorOptions,
  normalizeColorOptions,
  LabelView,
  LabeledFieldView,
  InputTextView,
  DropdownButtonView,
  FocusCycler,
  ToolbarSeparatorView,
  normalizeToolbarConfig,
  ToolbarView,
  ListView,
  ListItemView,
  SplitButtonView,
  createDropdown,
  addToolbarToDropdown,
  addListToDropdown,
  focusChildOnDropdownOpen,
  createLabeledInputText,
  createLabeledInputNumber,
  createLabeledDropdown,
  ColorSelectorView,
  BalloonPanelView,
  EditorUI,
  EditorUIView,
  BoxedEditorUIView,
  InlineEditableUIView,
  FormHeaderView,
  Notification,
  Model,
  ContextualBalloon,
  StickyPanelView
};
/*! Bundled license information:

@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/csstransitiondisablermixin.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/viewcollection.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/template.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/view.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/bodycollection.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/icon/iconview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/buttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/switchbuttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorgrid/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/button/dropdownbuttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/toolbarseparatorview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/focuscycler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listitemview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/button/splitbuttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/dropdownpanelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/dropdownview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/toolbarlinebreakview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/preventdefault.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/normalizetoolbarconfig.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/toolbarview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listseparatorview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/notification/notification.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/model.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/injectcsstransitiondisabler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/submithandler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/addkeyboardhandlingforgrid.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorgrid/colortileview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorgrid/colorgridview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorpicker/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/label/labelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/labeledfield/labeledfieldview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/input/inputview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/inputtext/inputtextview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/inputnumber/inputnumberview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/labeledfield/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorpicker/colorpickerview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-ui/src/colorselector/documentcolorcollection.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/colorgridsfragmentview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/colorpickerfragmentview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/colorselectorview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/componentfactory.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/tooltipmanager.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/poweredby.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-ui/src/editorui/editorui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/editoruiview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/boxed/boxededitoruiview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editableui/editableuiview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editableui/inline/inlineeditableuiview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/formheader/formheaderview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/iframe/iframeview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/balloon/balloontoolbar.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/block/blockbuttonview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/block/blocktoolbar.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-SGTDNT4V.js.map
