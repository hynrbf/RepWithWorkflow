import "./chunk-SX3YCKSJ.js";
import {
  FileDialogButtonView,
  FileRepository
} from "./chunk-P3DP7CWK.js";
import {
  Undo
} from "./chunk-5CZTTXVA.js";
import {
  Clipboard,
  ClipboardPipeline
} from "./chunk-74PGQAYV.js";
import {
  Widget,
  WidgetResize,
  WidgetToolbarRepository,
  findOptimalInsertionRange,
  isWidget,
  toWidget,
  toWidgetEditable
} from "./chunk-NMGSIING.js";
import "./chunk-DEIZSOIF.js";
import "./chunk-GGCPNJOL.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  BalloonPanelView,
  ButtonView,
  ContextualBalloon,
  CssTransitionDisablerMixin,
  DropdownButtonView,
  FocusCycler,
  LabeledFieldView,
  Model,
  Notification,
  SplitButtonView,
  View,
  ViewCollection,
  addListToDropdown,
  addToolbarToDropdown,
  clickOutsideHandler,
  createDropdown,
  createLabeledInputText,
  submitHandler
} from "./chunk-SGTDNT4V.js";
import "./chunk-W3CRWNYM.js";
import {
  Delete
} from "./chunk-4MFML76R.js";
import "./chunk-6LVMAMLV.js";
import {
  CKEditorError,
  Collection,
  Command,
  Element,
  FocusTracker,
  KeystrokeHandler,
  LivePosition,
  LiveRange,
  Observer,
  Plugin,
  UpcastWriter,
  enablePlaceholder,
  env_default,
  first,
  global_default,
  icons,
  logWarning,
  toArray
} from "./chunk-JI2V5GJZ.js";
import {
  identity_default,
  isObject_default
} from "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-image/src/image/utils.js
function createInlineImageViewElement(writer) {
  return writer.createContainerElement("span", { class: "image-inline" }, writer.createEmptyElement("img"));
}
function createBlockImageViewElement(writer) {
  return writer.createContainerElement("figure", { class: "image" }, [
    writer.createEmptyElement("img"),
    writer.createSlot("children")
  ]);
}
function getImgViewElementMatcher(editor, matchImageType) {
  const imageUtils = editor.plugins.get("ImageUtils");
  const areBothImagePluginsLoaded = editor.plugins.has("ImageInlineEditing") && editor.plugins.has("ImageBlockEditing");
  return (element) => {
    if (!imageUtils.isInlineImageView(element)) {
      return null;
    }
    if (!areBothImagePluginsLoaded) {
      return getPositiveMatchPattern(element);
    }
    const imageType = element.getStyle("display") == "block" || element.findAncestor(imageUtils.isBlockImageView) ? "imageBlock" : "imageInline";
    if (imageType !== matchImageType) {
      return null;
    }
    return getPositiveMatchPattern(element);
  };
  function getPositiveMatchPattern(element) {
    const pattern = {
      name: true
    };
    if (element.hasAttribute("src")) {
      pattern.attributes = ["src"];
    }
    return pattern;
  }
}
function determineImageTypeForInsertionAtSelection(schema, selection) {
  const firstBlock = first(selection.getSelectedBlocks());
  if (!firstBlock || schema.isObject(firstBlock)) {
    return "imageBlock";
  }
  if (firstBlock.isEmpty && firstBlock.name != "listItem") {
    return "imageBlock";
  }
  return "imageInline";
}

// node_modules/@ckeditor/ckeditor5-image/src/imageutils.js
var ImageUtils = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageUtils";
  }
  /**
   * Checks if the provided model element is an `image` or `imageInline`.
   */
  isImage(modelElement) {
    return this.isInlineImage(modelElement) || this.isBlockImage(modelElement);
  }
  /**
   * Checks if the provided view element represents an inline image.
   *
   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
   */
  isInlineImageView(element) {
    return !!element && element.is("element", "img");
  }
  /**
   * Checks if the provided view element represents a block image.
   *
   * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
   */
  isBlockImageView(element) {
    return !!element && element.is("element", "figure") && element.hasClass("image");
  }
  /**
   * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}
   * method.
   *
   * ```ts
   * const imageUtils = editor.plugins.get( 'ImageUtils' );
   *
   * imageUtils.insertImage( { src: 'path/to/image.jpg' } );
   * ```
   *
   * @param attributes Attributes of the inserted image.
   * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.
   * @param selectable Place to insert the image. If not specified,
   * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images
   * and `model.document.selection` for the inline images.
   *
   * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)
   * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.
   *
   * @param imageType Image type of inserted image. If not specified,
   * it will be determined automatically depending of editor config or place of the insertion.
   * @return The inserted model image element.
   */
  insertImage(attributes = {}, selectable = null, imageType = null) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    imageType = determineImageTypeForInsertion(editor, selectable || selection, imageType);
    attributes = {
      ...Object.fromEntries(selection.getAttributes()),
      ...attributes
    };
    for (const attributeName in attributes) {
      if (!model.schema.checkAttribute(imageType, attributeName)) {
        delete attributes[attributeName];
      }
    }
    return model.change((writer) => {
      const imageElement = writer.createElement(imageType, attributes);
      model.insertObject(imageElement, selectable, null, {
        setSelection: "on",
        // If we want to insert a block image (for whatever reason) then we don't want to split text blocks.
        // This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).
        findOptimalPosition: !selectable && imageType != "imageInline" ? "auto" : void 0
      });
      if (imageElement.parent) {
        return imageElement;
      }
      return null;
    });
  }
  /**
   * Returns an image widget editing view element if one is selected or is among the selection's ancestors.
   */
  getClosestSelectedImageWidget(selection) {
    const selectionPosition = selection.getFirstPosition();
    if (!selectionPosition) {
      return null;
    }
    const viewElement = selection.getSelectedElement();
    if (viewElement && this.isImageWidget(viewElement)) {
      return viewElement;
    }
    let parent = selectionPosition.parent;
    while (parent) {
      if (parent.is("element") && this.isImageWidget(parent)) {
        return parent;
      }
      parent = parent.parent;
    }
    return null;
  }
  /**
   * Returns a image model element if one is selected or is among the selection's ancestors.
   */
  getClosestSelectedImageElement(selection) {
    const selectedElement = selection.getSelectedElement();
    return this.isImage(selectedElement) ? selectedElement : selection.getFirstPosition().findAncestor("imageBlock");
  }
  /**
   * Checks if image can be inserted at current model selection.
   *
   * @internal
   */
  isImageAllowed() {
    const model = this.editor.model;
    const selection = model.document.selection;
    return isImageAllowedInParent(this.editor, selection) && isNotInsideImage(selection);
  }
  /**
   * Converts a given {@link module:engine/view/element~Element} to an image widget:
   * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget
   * element.
   * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
   *
   * @param writer An instance of the view writer.
   * @param label The element's label. It will be concatenated with the image `alt` attribute if one is present.
   */
  toImageWidget(viewElement, writer, label) {
    writer.setCustomProperty("image", true, viewElement);
    const labelCreator = () => {
      const imgElement = this.findViewImgElement(viewElement);
      const altText = imgElement.getAttribute("alt");
      return altText ? `${altText} ${label}` : label;
    };
    return toWidget(viewElement, writer, { label: labelCreator });
  }
  /**
   * Checks if a given view element is an image widget.
   */
  isImageWidget(viewElement) {
    return !!viewElement.getCustomProperty("image") && isWidget(viewElement);
  }
  /**
   * Checks if the provided model element is an `image`.
   */
  isBlockImage(modelElement) {
    return !!modelElement && modelElement.is("element", "imageBlock");
  }
  /**
   * Checks if the provided model element is an `imageInline`.
   */
  isInlineImage(modelElement) {
    return !!modelElement && modelElement.is("element", "imageInline");
  }
  /**
   * Get the view `<img>` from another view element, e.g. a widget (`<figure class="image">`), a link (`<a>`).
   *
   * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.
   */
  findViewImgElement(figureView) {
    if (this.isInlineImageView(figureView)) {
      return figureView;
    }
    const editingView = this.editor.editing.view;
    for (const { item } of editingView.createRangeIn(figureView)) {
      if (this.isInlineImageView(item)) {
        return item;
      }
    }
  }
};
function isImageAllowedInParent(editor, selection) {
  const imageType = determineImageTypeForInsertion(editor, selection, null);
  if (imageType == "imageBlock") {
    const parent = getInsertImageParent(selection, editor.model);
    if (editor.model.schema.checkChild(parent, "imageBlock")) {
      return true;
    }
  } else if (editor.model.schema.checkChild(selection.focus, "imageInline")) {
    return true;
  }
  return false;
}
function isNotInsideImage(selection) {
  return [...selection.focus.getAncestors()].every((ancestor) => !ancestor.is("element", "imageBlock"));
}
function getInsertImageParent(selection, model) {
  const insertionRange = findOptimalInsertionRange(selection, model);
  const parent = insertionRange.start.parent;
  if (parent.isEmpty && !parent.is("element", "$root")) {
    return parent.parent;
  }
  return parent;
}
function determineImageTypeForInsertion(editor, selectable, imageType) {
  const schema = editor.model.schema;
  const configImageInsertType = editor.config.get("image.insert.type");
  if (!editor.plugins.has("ImageBlockEditing")) {
    return "imageInline";
  }
  if (!editor.plugins.has("ImageInlineEditing")) {
    return "imageBlock";
  }
  if (imageType) {
    return imageType;
  }
  if (configImageInsertType === "inline") {
    return "imageInline";
  }
  if (configImageInsertType === "block") {
    return "imageBlock";
  }
  if (selectable.is("selection")) {
    return determineImageTypeForInsertionAtSelection(schema, selectable);
  }
  return schema.checkChild(selectable, "imageInline") ? "imageInline" : "imageBlock";
}

// node_modules/@ckeditor/ckeditor5-image/src/autoimage.js
var IMAGE_URL_REGEXP = new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source));
var AutoImage = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Clipboard, ImageUtils, Undo, Delete];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AutoImage";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._timeoutId = null;
    this._positionToInsert = null;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const modelDocument = editor.model.document;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    this.listenTo(clipboardPipeline, "inputTransformation", () => {
      const firstRange = modelDocument.selection.getFirstRange();
      const leftLivePosition = LivePosition.fromPosition(firstRange.start);
      leftLivePosition.stickiness = "toPrevious";
      const rightLivePosition = LivePosition.fromPosition(firstRange.end);
      rightLivePosition.stickiness = "toNext";
      modelDocument.once("change:data", () => {
        this._embedImageBetweenPositions(leftLivePosition, rightLivePosition);
        leftLivePosition.detach();
        rightLivePosition.detach();
      }, { priority: "high" });
    });
    editor.commands.get("undo").on("execute", () => {
      if (this._timeoutId) {
        global_default.window.clearTimeout(this._timeoutId);
        this._positionToInsert.detach();
        this._timeoutId = null;
        this._positionToInsert = null;
      }
    }, { priority: "high" });
  }
  /**
   * Analyzes the part of the document between provided positions in search for a URL representing an image.
   * When the URL is found, it is automatically converted into an image.
   *
   * @param leftPosition Left position of the selection.
   * @param rightPosition Right position of the selection.
   */
  _embedImageBetweenPositions(leftPosition, rightPosition) {
    const editor = this.editor;
    const urlRange = new LiveRange(leftPosition, rightPosition);
    const walker = urlRange.getWalker({ ignoreElementEnd: true });
    const selectionAttributes = Object.fromEntries(editor.model.document.selection.getAttributes());
    const imageUtils = this.editor.plugins.get("ImageUtils");
    let src = "";
    for (const node of walker) {
      if (node.item.is("$textProxy")) {
        src += node.item.data;
      }
    }
    src = src.trim();
    if (!src.match(IMAGE_URL_REGEXP)) {
      urlRange.detach();
      return;
    }
    this._positionToInsert = LivePosition.fromPosition(leftPosition);
    this._timeoutId = setTimeout(() => {
      const imageCommand = editor.commands.get("insertImage");
      if (!imageCommand.isEnabled) {
        urlRange.detach();
        return;
      }
      editor.model.change((writer) => {
        this._timeoutId = null;
        writer.remove(urlRange);
        urlRange.detach();
        let insertionPosition;
        if (this._positionToInsert.root.rootName !== "$graveyard") {
          insertionPosition = this._positionToInsert.toPosition();
        }
        imageUtils.insertImage({ ...selectionAttributes, src }, insertionPosition);
        this._positionToInsert.detach();
        this._positionToInsert = null;
      });
      const deletePlugin = editor.plugins.get("Delete");
      deletePlugin.requestUndoOnBackspace();
    }, 100);
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativecommand.js
var ImageTextAlternativeCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = imageUtils.getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!element;
    if (this.isEnabled && element.hasAttribute("alt")) {
      this.value = element.getAttribute("alt");
    } else {
      this.value = false;
    }
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options
   * @param options.newValue The new value of the `alt` attribute to set.
   */
  execute(options) {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const model = editor.model;
    const imageElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
    model.change((writer) => {
      writer.setAttribute("alt", options.newValue, imageElement);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativeediting.js
var ImageTextAlternativeEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageUtils];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageTextAlternativeEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.editor.commands.add("imageTextAlternative", new ImageTextAlternativeCommand(this.editor));
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/ui/textalternativeformview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css";
var TextAlternativeFormView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const t = this.locale.t;
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.labeledInput = this._createLabeledInputView();
    this.saveButtonView = this._createButton(t("Save"), icons.check, "ck-button-save");
    this.saveButtonView.type = "submit";
    this.cancelButtonView = this._createButton(t("Cancel"), icons.cancel, "ck-button-cancel", "cancel");
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-text-alternative-form",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-image/issues/40
        tabindex: "-1"
      },
      children: [
        this.labeledInput,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.keystrokes.listenTo(this.element);
    submitHandler({ view: this });
    [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((v) => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Creates the button view.
   *
   * @param label The button label
   * @param icon The button's icon.
   * @param className The additional button CSS class name.
   * @param eventName The event name that the ButtonView#execute event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(label, icon, className, eventName) {
    const button = new ButtonView(this.locale);
    button.set({
      label,
      icon,
      tooltip: true
    });
    button.extendTemplate({
      attributes: {
        class: className
      }
    });
    if (eventName) {
      button.delegate("execute").to(this, eventName);
    }
    return button;
  }
  /**
   * Creates an input with a label.
   *
   * @returns Labeled field view instance.
   */
  _createLabeledInputView() {
    const t = this.locale.t;
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
    labeledInput.label = t("Text alternative");
    return labeledInput;
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/image/ui/utils.js
function repositionContextualBalloon(editor) {
  const balloon = editor.plugins.get("ContextualBalloon");
  const imageUtils = editor.plugins.get("ImageUtils");
  if (imageUtils.getClosestSelectedImageWidget(editor.editing.view.document.selection)) {
    const position = getBalloonPositionData(editor);
    balloon.updatePosition(position);
  }
}
function getBalloonPositionData(editor) {
  const editingView = editor.editing.view;
  const defaultPositions = BalloonPanelView.defaultPositions;
  const imageUtils = editor.plugins.get("ImageUtils");
  return {
    target: editingView.domConverter.mapViewToDom(imageUtils.getClosestSelectedImageWidget(editingView.document.selection)),
    positions: [
      defaultPositions.northArrowSouth,
      defaultPositions.northArrowSouthWest,
      defaultPositions.northArrowSouthEast,
      defaultPositions.southArrowNorth,
      defaultPositions.southArrowNorthWest,
      defaultPositions.southArrowNorthEast,
      defaultPositions.viewportStickyNorth
    ]
  };
}

// node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativeui.js
var ImageTextAlternativeUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ContextualBalloon];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageTextAlternativeUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    this._createButton();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    if (this._form) {
      this._form.destroy();
    }
  }
  /**
   * Creates a button showing the balloon panel for changing the image text alternative and
   * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
   */
  _createButton() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("imageTextAlternative", (locale) => {
      const command = editor.commands.get("imageTextAlternative");
      const view = new ButtonView(locale);
      view.set({
        label: t("Change image text alternative"),
        icon: icons.lowVision,
        tooltip: true
      });
      view.bind("isEnabled").to(command, "isEnabled");
      view.bind("isOn").to(command, "value", (value) => !!value);
      this.listenTo(view, "execute", () => {
        this._showForm();
      });
      return view;
    });
  }
  /**
   * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}
   * form.
   */
  _createForm() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const imageUtils = editor.plugins.get("ImageUtils");
    this._balloon = this.editor.plugins.get("ContextualBalloon");
    this._form = new (CssTransitionDisablerMixin(TextAlternativeFormView))(editor.locale);
    this._form.render();
    this.listenTo(this._form, "submit", () => {
      editor.execute("imageTextAlternative", {
        newValue: this._form.labeledInput.fieldView.element.value
      });
      this._hideForm(true);
    });
    this.listenTo(this._form, "cancel", () => {
      this._hideForm(true);
    });
    this._form.keystrokes.set("Esc", (data, cancel) => {
      this._hideForm(true);
      cancel();
    });
    this.listenTo(editor.ui, "update", () => {
      if (!imageUtils.getClosestSelectedImageWidget(viewDocument.selection)) {
        this._hideForm(true);
      } else if (this._isVisible) {
        repositionContextualBalloon(editor);
      }
    });
    clickOutsideHandler({
      emitter: this._form,
      activator: () => this._isVisible,
      contextElements: () => [this._balloon.view.element],
      callback: () => this._hideForm()
    });
  }
  /**
   * Shows the {@link #_form} in the {@link #_balloon}.
   */
  _showForm() {
    if (this._isVisible) {
      return;
    }
    if (!this._form) {
      this._createForm();
    }
    const editor = this.editor;
    const command = editor.commands.get("imageTextAlternative");
    const labeledInput = this._form.labeledInput;
    this._form.disableCssTransitions();
    if (!this._isInBalloon) {
      this._balloon.add({
        view: this._form,
        position: getBalloonPositionData(editor)
      });
    }
    labeledInput.fieldView.value = labeledInput.fieldView.element.value = command.value || "";
    this._form.labeledInput.fieldView.select();
    this._form.enableCssTransitions();
  }
  /**
   * Removes the {@link #_form} from the {@link #_balloon}.
   *
   * @param focusEditable Controls whether the editing view is focused afterwards.
   */
  _hideForm(focusEditable = false) {
    if (!this._isInBalloon) {
      return;
    }
    if (this._form.focusTracker.isFocused) {
      this._form.saveButtonView.focus();
    }
    this._balloon.remove(this._form);
    if (focusEditable) {
      this.editor.editing.view.focus();
    }
  }
  /**
   * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.
   */
  get _isVisible() {
    return !!this._balloon && this._balloon.visibleView === this._form;
  }
  /**
   * Returns `true` when the {@link #_form} is in the {@link #_balloon}.
   */
  get _isInBalloon() {
    return !!this._balloon && this._balloon.hasView(this._form);
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative.js
var ImageTextAlternative = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageTextAlternativeEditing, ImageTextAlternativeUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageTextAlternative";
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/image/converters.js
function upcastImageFigure(imageUtils) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.test(data.viewItem, { name: true, classes: "image" })) {
      return;
    }
    const viewImage = imageUtils.findViewImgElement(data.viewItem);
    if (!viewImage || !conversionApi.consumable.test(viewImage, { name: true })) {
      return;
    }
    conversionApi.consumable.consume(data.viewItem, { name: true, classes: "image" });
    const conversionResult = conversionApi.convertItem(viewImage, data.modelCursor);
    const modelImage = first(conversionResult.modelRange.getItems());
    if (!modelImage) {
      conversionApi.consumable.revert(data.viewItem, { name: true, classes: "image" });
      return;
    }
    conversionApi.convertChildren(data.viewItem, modelImage);
    conversionApi.updateConversionResult(modelImage, data);
  };
  return (dispatcher) => {
    dispatcher.on("element:figure", converter);
  };
}
function upcastPicture(imageUtils) {
  const sourceAttributeNames = ["srcset", "media", "type", "sizes"];
  const converter = (evt, data, conversionApi) => {
    const pictureViewElement = data.viewItem;
    if (!conversionApi.consumable.test(pictureViewElement, { name: true })) {
      return;
    }
    const sources = /* @__PURE__ */ new Map();
    for (const childSourceElement of pictureViewElement.getChildren()) {
      if (childSourceElement.is("element", "source")) {
        const attributes = {};
        for (const name of sourceAttributeNames) {
          if (childSourceElement.hasAttribute(name)) {
            if (conversionApi.consumable.test(childSourceElement, { attributes: name })) {
              attributes[name] = childSourceElement.getAttribute(name);
            }
          }
        }
        if (Object.keys(attributes).length) {
          sources.set(childSourceElement, attributes);
        }
      }
    }
    const imgViewElement = imageUtils.findViewImgElement(pictureViewElement);
    if (!imgViewElement) {
      return;
    }
    let modelImage = data.modelCursor.parent;
    if (!modelImage.is("element", "imageBlock")) {
      const conversionResult = conversionApi.convertItem(imgViewElement, data.modelCursor);
      data.modelRange = conversionResult.modelRange;
      data.modelCursor = conversionResult.modelCursor;
      modelImage = first(conversionResult.modelRange.getItems());
    }
    conversionApi.consumable.consume(pictureViewElement, { name: true });
    for (const [sourceElement, attributes] of sources) {
      conversionApi.consumable.consume(sourceElement, { attributes: Object.keys(attributes) });
    }
    if (sources.size) {
      conversionApi.writer.setAttribute("sources", Array.from(sources.values()), modelImage);
    }
    conversionApi.convertChildren(pictureViewElement, modelImage);
  };
  return (dispatcher) => {
    dispatcher.on("element:picture", converter);
  };
}
function downcastSrcsetAttribute(imageUtils, imageType) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const writer = conversionApi.writer;
    const element = conversionApi.mapper.toViewElement(data.item);
    const img = imageUtils.findViewImgElement(element);
    if (data.attributeNewValue === null) {
      const srcset = data.attributeOldValue;
      if (srcset && srcset.data) {
        writer.removeAttribute("srcset", img);
        writer.removeAttribute("sizes", img);
        if (srcset.width) {
          writer.removeAttribute("width", img);
        }
      }
    } else {
      const srcset = data.attributeNewValue;
      if (srcset && srcset.data) {
        writer.setAttribute("srcset", srcset.data, img);
        writer.setAttribute("sizes", "100vw", img);
        if (srcset.width) {
          writer.setAttribute("width", srcset.width, img);
        }
      }
    }
  };
  return (dispatcher) => {
    dispatcher.on(`attribute:srcset:${imageType}`, converter);
  };
}
function downcastSourcesAttribute(imageUtils) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const element = conversionApi.mapper.toViewElement(data.item);
    const imgElement = imageUtils.findViewImgElement(element);
    const attributeNewValue = data.attributeNewValue;
    if (attributeNewValue && attributeNewValue.length) {
      const pictureElement = viewWriter.createContainerElement("picture", null, attributeNewValue.map((sourceAttributes) => {
        return viewWriter.createEmptyElement("source", sourceAttributes);
      }));
      const attributeElements = [];
      let viewElement = imgElement.parent;
      while (viewElement && viewElement.is("attributeElement")) {
        const parentElement = viewElement.parent;
        viewWriter.unwrap(viewWriter.createRangeOn(imgElement), viewElement);
        attributeElements.unshift(viewElement);
        viewElement = parentElement;
      }
      viewWriter.insert(viewWriter.createPositionBefore(imgElement), pictureElement);
      viewWriter.move(viewWriter.createRangeOn(imgElement), viewWriter.createPositionAt(pictureElement, "end"));
      for (const attributeElement of attributeElements) {
        viewWriter.wrap(viewWriter.createRangeOn(pictureElement), attributeElement);
      }
    } else if (imgElement.parent.is("element", "picture")) {
      const pictureElement = imgElement.parent;
      viewWriter.move(viewWriter.createRangeOn(imgElement), viewWriter.createPositionBefore(pictureElement));
      viewWriter.remove(pictureElement);
    }
  };
  return (dispatcher) => {
    dispatcher.on("attribute:sources:imageBlock", converter);
    dispatcher.on("attribute:sources:imageInline", converter);
  };
}
function downcastImageAttribute(imageUtils, imageType, attributeKey) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const element = conversionApi.mapper.toViewElement(data.item);
    const img = imageUtils.findViewImgElement(element);
    viewWriter.setAttribute(data.attributeKey, data.attributeNewValue || "", img);
  };
  return (dispatcher) => {
    dispatcher.on(`attribute:${attributeKey}:${imageType}`, converter);
  };
}

// node_modules/@ckeditor/ckeditor5-image/src/image/imageloadobserver.js
var ImageLoadObserver = class extends Observer {
  /**
   * @inheritDoc
   */
  observe(domRoot) {
    this.listenTo(domRoot, "load", (event, domEvent) => {
      const domElement = domEvent.target;
      if (this.checkShouldIgnoreEventFromTarget(domElement)) {
        return;
      }
      if (domElement.tagName == "IMG") {
        this._fireEvents(domEvent);
      }
    }, { useCapture: true });
  }
  /**
   * @inheritDoc
   */
  stopObserving(domRoot) {
    this.stopListening(domRoot);
  }
  /**
   * Fires {@link module:engine/view/document~Document#event:layoutChanged} and
   * {@link module:engine/view/document~Document#event:imageLoaded}
   * if observer {@link #isEnabled is enabled}.
   *
   * @param domEvent The DOM event.
   */
  _fireEvents(domEvent) {
    if (this.isEnabled) {
      this.document.fire("layoutChanged");
      this.document.fire("imageLoaded", domEvent);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/image/insertimagecommand.js
var InsertImageCommand = class extends Command {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    const configImageInsertType = editor.config.get("image.insert.type");
    if (!editor.plugins.has("ImageBlockEditing")) {
      if (configImageInsertType === "block") {
        logWarning("image-block-plugin-required");
      }
    }
    if (!editor.plugins.has("ImageInlineEditing")) {
      if (configImageInsertType === "inline") {
        logWarning("image-inline-plugin-required");
      }
    }
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const imageUtils = this.editor.plugins.get("ImageUtils");
    this.isEnabled = imageUtils.isImageAllowed();
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.source The image source or an array of image sources to insert.
   * See the documentation of the command to learn more about accepted formats.
   */
  execute(options) {
    const sourceDefinitions = toArray(options.source);
    const selection = this.editor.model.document.selection;
    const imageUtils = this.editor.plugins.get("ImageUtils");
    const selectionAttributes = Object.fromEntries(selection.getAttributes());
    sourceDefinitions.forEach((sourceDefinition, index) => {
      const selectedElement = selection.getSelectedElement();
      if (typeof sourceDefinition === "string") {
        sourceDefinition = { src: sourceDefinition };
      }
      if (index && selectedElement && imageUtils.isImage(selectedElement)) {
        const position = this.editor.model.createPositionAfter(selectedElement);
        imageUtils.insertImage({ ...sourceDefinition, ...selectionAttributes }, position);
      } else {
        imageUtils.insertImage({ ...sourceDefinition, ...selectionAttributes });
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/image/replaceimagesourcecommand.js
var ReplaceImageSourceCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = this.editor.model.document.selection.getSelectedElement();
    this.isEnabled = imageUtils.isImage(element);
    this.value = this.isEnabled ? element.getAttribute("src") : null;
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.source The image source to replace.
   */
  execute(options) {
    const image = this.editor.model.document.selection.getSelectedElement();
    this.editor.model.change((writer) => {
      writer.setAttribute("src", options.source, image);
      writer.removeAttribute("srcset", image);
      writer.removeAttribute("sizes", image);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/image/imageediting.js
var ImageEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageUtils];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const conversion = editor.conversion;
    editor.editing.view.addObserver(ImageLoadObserver);
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "img",
        key: "alt"
      },
      model: "alt"
    }).attributeToAttribute({
      view: {
        name: "img",
        key: "srcset"
      },
      model: {
        key: "srcset",
        value: (viewImage) => {
          const value = {
            data: viewImage.getAttribute("srcset")
          };
          if (viewImage.hasAttribute("width")) {
            value.width = viewImage.getAttribute("width");
          }
          return value;
        }
      }
    });
    const insertImageCommand = new InsertImageCommand(editor);
    const replaceImageSourceCommand = new ReplaceImageSourceCommand(editor);
    editor.commands.add("insertImage", insertImageCommand);
    editor.commands.add("replaceImageSource", replaceImageSourceCommand);
    editor.commands.add("imageInsert", insertImageCommand);
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/image/imagetypecommand.js
var ImageTypeCommand = class extends Command {
  /**
   * @inheritDoc
   *
   * @param modelElementName Model element name the command converts to.
   */
  constructor(editor, modelElementName) {
    super(editor);
    this._modelElementName = modelElementName;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = imageUtils.getClosestSelectedImageElement(this.editor.model.document.selection);
    if (this._modelElementName === "imageBlock") {
      this.isEnabled = imageUtils.isInlineImage(element);
    } else {
      this.isEnabled = imageUtils.isBlockImage(element);
    }
  }
  /**
   * Executes the command and changes the type of a selected image.
   *
   * @fires execute
   * @returns An object containing references to old and new model image elements
   * (for before and after the change) so external integrations can hook into the decorated
   * `execute` event and handle this change. `null` if the type change failed.
   */
  execute() {
    const editor = this.editor;
    const model = this.editor.model;
    const imageUtils = editor.plugins.get("ImageUtils");
    const oldElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
    const attributes = Object.fromEntries(oldElement.getAttributes());
    if (!attributes.src && !attributes.uploadId) {
      return null;
    }
    return model.change((writer) => {
      const markers = Array.from(model.markers).filter((marker) => marker.getRange().containsItem(oldElement));
      const newElement = imageUtils.insertImage(attributes, model.createSelection(oldElement, "on"), this._modelElementName);
      if (!newElement) {
        return null;
      }
      const newElementRange = writer.createRangeOn(newElement);
      for (const marker of markers) {
        const markerRange = marker.getRange();
        const range = markerRange.root.rootName != "$graveyard" ? markerRange.getJoined(newElementRange, true) : newElementRange;
        writer.updateMarker(marker, { range });
      }
      return {
        oldElement,
        newElement
      };
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/image/imageblockediting.js
var ImageBlockEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageEditing, ImageUtils, ClipboardPipeline];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageBlockEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    schema.register("imageBlock", {
      inheritAllFrom: "$blockObject",
      allowAttributes: ["alt", "src", "srcset"]
    });
    this._setupConversion();
    if (editor.plugins.has("ImageInlineEditing")) {
      editor.commands.add("imageTypeBlock", new ImageTypeCommand(this.editor, "imageBlock"));
      this._setupClipboardIntegration();
    }
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting
   * block images (block image widgets) and their attributes.
   */
  _setupConversion() {
    const editor = this.editor;
    const t = editor.t;
    const conversion = editor.conversion;
    const imageUtils = editor.plugins.get("ImageUtils");
    conversion.for("dataDowncast").elementToStructure({
      model: "imageBlock",
      view: (modelElement, { writer }) => createBlockImageViewElement(writer)
    });
    conversion.for("editingDowncast").elementToStructure({
      model: "imageBlock",
      view: (modelElement, { writer }) => imageUtils.toImageWidget(createBlockImageViewElement(writer), writer, t("image widget"))
    });
    conversion.for("downcast").add(downcastImageAttribute(imageUtils, "imageBlock", "src")).add(downcastImageAttribute(imageUtils, "imageBlock", "alt")).add(downcastSrcsetAttribute(imageUtils, "imageBlock"));
    conversion.for("upcast").elementToElement({
      view: getImgViewElementMatcher(editor, "imageBlock"),
      model: (viewImage, { writer }) => writer.createElement("imageBlock", viewImage.hasAttribute("src") ? { src: viewImage.getAttribute("src") } : void 0)
    }).add(upcastImageFigure(imageUtils));
  }
  /**
   * Integrates the plugin with the clipboard pipeline.
   *
   * Idea is that the feature should recognize the user's intent when an **inline** image is
   * pasted or dropped. If such an image is pasted/dropped:
   *
   * * into an empty block (e.g. an empty paragraph),
   * * on another object (e.g. some block widget).
   *
   * it gets converted into a block image on the fly. We assume this is the user's intent
   * if they decided to put their image there.
   *
   * See the `ImageInlineEditing` for the similar integration that works in the opposite direction.
   */
  _setupClipboardIntegration() {
    const editor = this.editor;
    const model = editor.model;
    const editingView = editor.editing.view;
    const imageUtils = editor.plugins.get("ImageUtils");
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
      const docFragmentChildren = Array.from(data.content.getChildren());
      let modelRange;
      if (!docFragmentChildren.every(imageUtils.isInlineImageView)) {
        return;
      }
      if (data.targetRanges) {
        modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
      } else {
        modelRange = model.document.selection.getFirstRange();
      }
      const selection = model.createSelection(modelRange);
      if (determineImageTypeForInsertionAtSelection(model.schema, selection) === "imageBlock") {
        const writer = new UpcastWriter(editingView.document);
        const blockViewImages = docFragmentChildren.map((inlineViewImage) => writer.createElement("figure", { class: "image" }, inlineViewImage));
        data.content = writer.createDocumentFragment(blockViewImages);
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageblock.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/image.css";
var ImageBlock = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageBlockEditing, Widget, ImageTextAlternative];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageBlock";
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/image/imageinlineediting.js
var ImageInlineEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageEditing, ImageUtils, ClipboardPipeline];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInlineEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    schema.register("imageInline", {
      inheritAllFrom: "$inlineObject",
      allowAttributes: ["alt", "src", "srcset"]
    });
    schema.addChildCheck((context, childDefinition) => {
      if (context.endsWith("caption") && childDefinition.name === "imageInline") {
        return false;
      }
    });
    this._setupConversion();
    if (editor.plugins.has("ImageBlockEditing")) {
      editor.commands.add("imageTypeInline", new ImageTypeCommand(this.editor, "imageInline"));
      this._setupClipboardIntegration();
    }
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting
   * inline images (inline image widgets) and their attributes.
   */
  _setupConversion() {
    const editor = this.editor;
    const t = editor.t;
    const conversion = editor.conversion;
    const imageUtils = editor.plugins.get("ImageUtils");
    conversion.for("dataDowncast").elementToElement({
      model: "imageInline",
      view: (modelElement, { writer }) => writer.createEmptyElement("img")
    });
    conversion.for("editingDowncast").elementToStructure({
      model: "imageInline",
      view: (modelElement, { writer }) => imageUtils.toImageWidget(createInlineImageViewElement(writer), writer, t("image widget"))
    });
    conversion.for("downcast").add(downcastImageAttribute(imageUtils, "imageInline", "src")).add(downcastImageAttribute(imageUtils, "imageInline", "alt")).add(downcastSrcsetAttribute(imageUtils, "imageInline"));
    conversion.for("upcast").elementToElement({
      view: getImgViewElementMatcher(editor, "imageInline"),
      model: (viewImage, { writer }) => writer.createElement("imageInline", viewImage.hasAttribute("src") ? { src: viewImage.getAttribute("src") } : void 0)
    });
  }
  /**
   * Integrates the plugin with the clipboard pipeline.
   *
   * Idea is that the feature should recognize the user's intent when an **block** image is
   * pasted or dropped. If such an image is pasted/dropped into a non-empty block
   * (e.g. a paragraph with some text) it gets converted into an inline image on the fly.
   *
   * We assume this is the user's intent if they decided to put their image there.
   *
   * **Note**: If a block image has a caption, it will not be converted to an inline image
   * to avoid the confusion. Captions are added on purpose and they should never be lost
   * in the clipboard pipeline.
   *
   * See the `ImageBlockEditing` for the similar integration that works in the opposite direction.
   */
  _setupClipboardIntegration() {
    const editor = this.editor;
    const model = editor.model;
    const editingView = editor.editing.view;
    const imageUtils = editor.plugins.get("ImageUtils");
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
      const docFragmentChildren = Array.from(data.content.getChildren());
      let modelRange;
      if (!docFragmentChildren.every(imageUtils.isBlockImageView)) {
        return;
      }
      if (data.targetRanges) {
        modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
      } else {
        modelRange = model.document.selection.getFirstRange();
      }
      const selection = model.createSelection(modelRange);
      if (determineImageTypeForInsertionAtSelection(model.schema, selection) === "imageInline") {
        const writer = new UpcastWriter(editingView.document);
        const inlineViewImages = docFragmentChildren.map((blockViewImage) => {
          if (blockViewImage.childCount === 1) {
            Array.from(blockViewImage.getAttributes()).forEach((attribute) => writer.setAttribute(...attribute, imageUtils.findViewImgElement(blockViewImage)));
            return blockViewImage.getChild(0);
          } else {
            return blockViewImage;
          }
        });
        data.content = writer.createDocumentFragment(inlineViewImages);
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageinline.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/image.css";
var ImageInline = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageInlineEditing, Widget, ImageTextAlternative];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInline";
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/image.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/image.css";
var Image = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageBlock, ImageInline];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Image";
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagecaption/imagecaptionutils.js
var ImageCaptionUtils = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaptionUtils";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageUtils];
  }
  /**
   * Returns the caption model element from a given image element. Returns `null` if no caption is found.
   */
  getCaptionFromImageModelElement(imageModelElement) {
    for (const node of imageModelElement.getChildren()) {
      if (!!node && node.is("element", "caption")) {
        return node;
      }
    }
    return null;
  }
  /**
   * Returns the caption model element for a model selection. Returns `null` if the selection has no caption element ancestor.
   */
  getCaptionFromModelSelection(selection) {
    const imageUtils = this.editor.plugins.get("ImageUtils");
    const captionElement = selection.getFirstPosition().findAncestor("caption");
    if (!captionElement) {
      return null;
    }
    if (imageUtils.isBlockImage(captionElement.parent)) {
      return captionElement;
    }
    return null;
  }
  /**
   * {@link module:engine/view/matcher~Matcher} pattern. Checks if a given element is a `<figcaption>` element that is placed
   * inside the image `<figure>` element.
   * @returns Returns the object accepted by {@link module:engine/view/matcher~Matcher} or `null` if the element
   * cannot be matched.
   */
  matchImageCaptionViewElement(element) {
    const imageUtils = this.editor.plugins.get("ImageUtils");
    if (element.name == "figcaption" && imageUtils.isBlockImageView(element.parent)) {
      return { name: true };
    }
    return null;
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagecaption/toggleimagecaptioncommand.js
var ToggleImageCaptionCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    const imageUtils = editor.plugins.get("ImageUtils");
    if (!editor.plugins.has(ImageBlockEditing)) {
      this.isEnabled = false;
      this.value = false;
      return;
    }
    const selection = editor.model.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (!selectedElement) {
      const ancestorCaptionElement = imageCaptionUtils.getCaptionFromModelSelection(selection);
      this.isEnabled = !!ancestorCaptionElement;
      this.value = !!ancestorCaptionElement;
      return;
    }
    this.isEnabled = imageUtils.isImage(selectedElement);
    if (!this.isEnabled) {
      this.value = false;
    } else {
      this.value = !!imageCaptionUtils.getCaptionFromImageModelElement(selectedElement);
    }
  }
  /**
   * Executes the command.
   *
   * ```ts
   * editor.execute( 'toggleImageCaption' );
   * ```
   *
   * @param options Options for the executed command.
   * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
   * @fires execute
   */
  execute(options = {}) {
    const { focusCaptionOnShow } = options;
    this.editor.model.change((writer) => {
      if (this.value) {
        this._hideImageCaption(writer);
      } else {
        this._showImageCaption(writer, focusCaptionOnShow);
      }
    });
  }
  /**
   * Shows the caption of the `<imageBlock>` or `<imageInline>`. Also:
   *
   * * it converts `<imageInline>` to `<imageBlock>` to show the caption,
   * * it attempts to restore the caption content from the `ImageCaptionEditing` caption registry,
   * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
   */
  _showImageCaption(writer, focusCaptionOnShow) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const imageCaptionEditing = this.editor.plugins.get("ImageCaptionEditing");
    const imageUtils = this.editor.plugins.get("ImageUtils");
    let selectedImage = selection.getSelectedElement();
    const savedCaption = imageCaptionEditing._getSavedCaption(selectedImage);
    if (imageUtils.isInlineImage(selectedImage)) {
      this.editor.execute("imageTypeBlock");
      selectedImage = selection.getSelectedElement();
    }
    const newCaptionElement = savedCaption || writer.createElement("caption");
    writer.append(newCaptionElement, selectedImage);
    if (focusCaptionOnShow) {
      writer.setSelection(newCaptionElement, "in");
    }
  }
  /**
   * Hides the caption of a selected image (or an image caption the selection is anchored to).
   *
   * The content of the caption is stored in the `ImageCaptionEditing` caption registry to make this
   * a reversible action.
   */
  _hideImageCaption(writer) {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const imageCaptionEditing = editor.plugins.get("ImageCaptionEditing");
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    let selectedImage = selection.getSelectedElement();
    let captionElement;
    if (selectedImage) {
      captionElement = imageCaptionUtils.getCaptionFromImageModelElement(selectedImage);
    } else {
      captionElement = imageCaptionUtils.getCaptionFromModelSelection(selection);
      selectedImage = captionElement.parent;
    }
    imageCaptionEditing._saveCaption(selectedImage, captionElement);
    writer.setSelection(selectedImage, "on");
    writer.remove(captionElement);
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagecaption/imagecaptionediting.js
var ImageCaptionEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageUtils, ImageCaptionUtils];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaptionEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    if (!schema.isRegistered("caption")) {
      schema.register("caption", {
        allowIn: "imageBlock",
        allowContentOf: "$block",
        isLimit: true
      });
    } else {
      schema.extend("caption", {
        allowIn: "imageBlock"
      });
    }
    editor.commands.add("toggleImageCaption", new ToggleImageCaptionCommand(this.editor));
    this._setupConversion();
    this._setupImageTypeCommandsIntegration();
    this._registerCaptionReconversion();
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting
   * image captions.
   */
  _setupConversion() {
    const editor = this.editor;
    const view = editor.editing.view;
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    const t = editor.t;
    editor.conversion.for("upcast").elementToElement({
      view: (element) => imageCaptionUtils.matchImageCaptionViewElement(element),
      model: "caption"
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "caption",
      view: (modelElement, { writer }) => {
        if (!imageUtils.isBlockImage(modelElement.parent)) {
          return null;
        }
        return writer.createContainerElement("figcaption");
      }
    });
    editor.conversion.for("editingDowncast").elementToElement({
      model: "caption",
      view: (modelElement, { writer }) => {
        if (!imageUtils.isBlockImage(modelElement.parent)) {
          return null;
        }
        const figcaptionElement = writer.createEditableElement("figcaption");
        writer.setCustomProperty("imageCaption", true, figcaptionElement);
        figcaptionElement.placeholder = t("Enter image caption");
        enablePlaceholder({
          view,
          element: figcaptionElement,
          keepOnFocus: true
        });
        const imageAlt = modelElement.parent.getAttribute("alt");
        const label = imageAlt ? t("Caption for image: %0", [imageAlt]) : t("Caption for the image");
        return toWidgetEditable(figcaptionElement, writer, { label });
      }
    });
  }
  /**
   * Integrates with {@link module:image/image/imagetypecommand~ImageTypeCommand image type commands}
   * to make sure the caption is preserved when the type of an image changes so it can be restored
   * in the future if the user decides they want their caption back.
   */
  _setupImageTypeCommandsIntegration() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    const imageTypeInlineCommand = editor.commands.get("imageTypeInline");
    const imageTypeBlockCommand = editor.commands.get("imageTypeBlock");
    const handleImageTypeChange = (evt) => {
      if (!evt.return) {
        return;
      }
      const { oldElement, newElement } = evt.return;
      if (!oldElement) {
        return;
      }
      if (imageUtils.isBlockImage(oldElement)) {
        const oldCaptionElement = imageCaptionUtils.getCaptionFromImageModelElement(oldElement);
        if (oldCaptionElement) {
          this._saveCaption(newElement, oldCaptionElement);
          return;
        }
      }
      const savedOldElementCaption = this._getSavedCaption(oldElement);
      if (savedOldElementCaption) {
        this._saveCaption(newElement, savedOldElementCaption);
      }
    };
    if (imageTypeInlineCommand) {
      this.listenTo(imageTypeInlineCommand, "execute", handleImageTypeChange, { priority: "low" });
    }
    if (imageTypeBlockCommand) {
      this.listenTo(imageTypeBlockCommand, "execute", handleImageTypeChange, { priority: "low" });
    }
  }
  /**
   * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
   * of an image model element.
   *
   * See {@link #_saveCaption}.
   *
   * @internal
   * @param imageModelElement The model element the caption should be returned for.
   * @returns The model caption element or `null` if there is none.
   */
  _getSavedCaption(imageModelElement) {
    const jsonObject = this._savedCaptionsMap.get(imageModelElement);
    return jsonObject ? Element.fromJSON(jsonObject) : null;
  }
  /**
   * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
   * an image element to allow restoring it in the future.
   *
   * A caption is saved every time it gets hidden and/or the type of an image changes. The
   * user should be able to restore it on demand.
   *
   * **Note**: The caption cannot be stored in the image model element attribute because,
   * for instance, when the model state propagates to collaborators, the attribute would get
   * lost (mainly because it does not convert to anything when the caption is hidden) and
   * the states of collaborators' models would de-synchronize causing numerous issues.
   *
   * See {@link #_getSavedCaption}.
   *
   * @internal
   * @param imageModelElement The model element the caption is saved for.
   * @param caption The caption model element to be saved.
   */
  _saveCaption(imageModelElement, caption) {
    this._savedCaptionsMap.set(imageModelElement, caption.toJSON());
  }
  /**
   * Reconverts image caption when image alt attribute changes.
   * The change of alt attribute is reflected in caption's aria-label attribute.
   */
  _registerCaptionReconversion() {
    const editor = this.editor;
    const model = editor.model;
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    model.document.on("change:data", () => {
      const changes = model.document.differ.getChanges();
      for (const change of changes) {
        if (change.attributeKey !== "alt") {
          continue;
        }
        const image = change.range.start.nodeAfter;
        if (imageUtils.isBlockImage(image)) {
          const caption = imageCaptionUtils.getCaptionFromImageModelElement(image);
          if (!caption) {
            return;
          }
          editor.editing.reconvertItem(caption);
        }
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagecaption/imagecaptionui.js
var ImageCaptionUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageCaptionUtils];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaptionUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const imageCaptionUtils = editor.plugins.get("ImageCaptionUtils");
    const t = editor.t;
    editor.ui.componentFactory.add("toggleImageCaption", (locale) => {
      const command = editor.commands.get("toggleImageCaption");
      const view = new ButtonView(locale);
      view.set({
        icon: icons.caption,
        tooltip: true,
        isToggleable: true
      });
      view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
      view.bind("label").to(command, "value", (value) => value ? t("Toggle caption off") : t("Toggle caption on"));
      this.listenTo(view, "execute", () => {
        editor.execute("toggleImageCaption", { focusCaptionOnShow: true });
        const modelCaptionElement = imageCaptionUtils.getCaptionFromModelSelection(editor.model.document.selection);
        if (modelCaptionElement) {
          const figcaptionElement = editor.editing.mapper.toViewElement(modelCaptionElement);
          editingView.scrollToTheSelection();
          editingView.change((writer) => {
            writer.addClass("image__caption_highlighted", figcaptionElement);
          });
        }
        editor.editing.view.focus();
      });
      return view;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagecaption.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css";
var ImageCaption = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageCaptionEditing, ImageCaptionUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageCaption";
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageupload/utils.js
function createImageTypeRegExp(types) {
  const regExpSafeNames = types.map((type) => type.replace("+", "\\+"));
  return new RegExp(`^image\\/(${regExpSafeNames.join("|")})$`);
}
function fetchLocalImage(image) {
  return new Promise((resolve, reject) => {
    const imageSrc = image.getAttribute("src");
    fetch(imageSrc).then((resource) => resource.blob()).then((blob) => {
      const mimeType = getImageMimeType(blob, imageSrc);
      const ext = mimeType.replace("image/", "");
      const filename = `image.${ext}`;
      const file = new File([blob], filename, { type: mimeType });
      resolve(file);
    }).catch((err) => {
      return err && err.name === "TypeError" ? convertLocalImageOnCanvas(imageSrc).then(resolve).catch(reject) : reject(err);
    });
  });
}
function isLocalImage(imageUtils, node) {
  if (!imageUtils.isInlineImageView(node) || !node.getAttribute("src")) {
    return false;
  }
  return !!node.getAttribute("src").match(/^data:image\/\w+;base64,/g) || !!node.getAttribute("src").match(/^blob:/g);
}
function getImageMimeType(blob, src) {
  if (blob.type) {
    return blob.type;
  } else if (src.match(/data:(image\/\w+);base64/)) {
    return src.match(/data:(image\/\w+);base64/)[1].toLowerCase();
  } else {
    return "image/jpeg";
  }
}
function convertLocalImageOnCanvas(imageSrc) {
  return getBlobFromCanvas(imageSrc).then((blob) => {
    const mimeType = getImageMimeType(blob, imageSrc);
    const ext = mimeType.replace("image/", "");
    const filename = `image.${ext}`;
    return new File([blob], filename, { type: mimeType });
  });
}
function getBlobFromCanvas(imageSrc) {
  return new Promise((resolve, reject) => {
    const image = global_default.document.createElement("img");
    image.addEventListener("load", () => {
      const canvas = global_default.document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0);
      canvas.toBlob((blob) => blob ? resolve(blob) : reject());
    });
    image.addEventListener("error", () => reject());
    image.src = imageSrc;
  });
}

// node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadui.js
var ImageUploadUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageUploadUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const componentCreator = (locale) => {
      const view = new FileDialogButtonView(locale);
      const command = editor.commands.get("uploadImage");
      const imageTypes = editor.config.get("image.upload.types");
      const imageTypesRegExp = createImageTypeRegExp(imageTypes);
      view.set({
        acceptedType: imageTypes.map((type) => `image/${type}`).join(","),
        allowMultipleFiles: true
      });
      view.buttonView.set({
        label: t("Insert image"),
        icon: icons.image,
        tooltip: true
      });
      view.buttonView.bind("isEnabled").to(command);
      view.on("done", (evt, files) => {
        const imagesToUpload = Array.from(files).filter((file) => imageTypesRegExp.test(file.type));
        if (imagesToUpload.length) {
          editor.execute("uploadImage", { file: imagesToUpload });
          editor.editing.view.focus();
        }
      });
      return view;
    };
    editor.ui.componentFactory.add("uploadImage", componentCreator);
    editor.ui.componentFactory.add("imageUpload", componentCreator);
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadprogress.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css";
var ImageUploadProgress = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageUploadProgress";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this.uploadStatusChange = (evt, data, conversionApi) => {
      const editor2 = this.editor;
      const modelImage = data.item;
      const uploadId = modelImage.getAttribute("uploadId");
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const imageUtils = editor2.plugins.get("ImageUtils");
      const fileRepository = editor2.plugins.get(FileRepository);
      const status = uploadId ? data.attributeNewValue : null;
      const placeholder = this.placeholder;
      const viewFigure = editor2.editing.mapper.toViewElement(modelImage);
      const viewWriter = conversionApi.writer;
      if (status == "reading") {
        _startAppearEffect(viewFigure, viewWriter);
        _showPlaceholder(imageUtils, placeholder, viewFigure, viewWriter);
        return;
      }
      if (status == "uploading") {
        const loader = fileRepository.loaders.get(uploadId);
        _startAppearEffect(viewFigure, viewWriter);
        if (!loader) {
          _showPlaceholder(imageUtils, placeholder, viewFigure, viewWriter);
        } else {
          _hidePlaceholder(viewFigure, viewWriter);
          _showProgressBar(viewFigure, viewWriter, loader, editor2.editing.view);
          _displayLocalImage(imageUtils, viewFigure, viewWriter, loader);
        }
        return;
      }
      if (status == "complete" && fileRepository.loaders.get(uploadId)) {
        _showCompleteIcon(viewFigure, viewWriter, editor2.editing.view);
      }
      _hideProgressBar(viewFigure, viewWriter);
      _hidePlaceholder(viewFigure, viewWriter);
      _stopAppearEffect(viewFigure, viewWriter);
    };
    this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    if (editor.plugins.has("ImageBlockEditing")) {
      editor.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange);
    }
    if (editor.plugins.has("ImageInlineEditing")) {
      editor.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
    }
  }
};
function _startAppearEffect(viewFigure, writer) {
  if (!viewFigure.hasClass("ck-appear")) {
    writer.addClass("ck-appear", viewFigure);
  }
}
function _stopAppearEffect(viewFigure, writer) {
  writer.removeClass("ck-appear", viewFigure);
}
function _showPlaceholder(imageUtils, placeholder, viewFigure, writer) {
  if (!viewFigure.hasClass("ck-image-upload-placeholder")) {
    writer.addClass("ck-image-upload-placeholder", viewFigure);
  }
  const viewImg = imageUtils.findViewImgElement(viewFigure);
  if (viewImg.getAttribute("src") !== placeholder) {
    writer.setAttribute("src", placeholder, viewImg);
  }
  if (!_getUIElement(viewFigure, "placeholder")) {
    writer.insert(writer.createPositionAfter(viewImg), _createPlaceholder(writer));
  }
}
function _hidePlaceholder(viewFigure, writer) {
  if (viewFigure.hasClass("ck-image-upload-placeholder")) {
    writer.removeClass("ck-image-upload-placeholder", viewFigure);
  }
  _removeUIElement(viewFigure, writer, "placeholder");
}
function _showProgressBar(viewFigure, writer, loader, view) {
  const progressBar = _createProgressBar(writer);
  writer.insert(writer.createPositionAt(viewFigure, "end"), progressBar);
  loader.on("change:uploadedPercent", (evt, name, value) => {
    view.change((writer2) => {
      writer2.setStyle("width", value + "%", progressBar);
    });
  });
}
function _hideProgressBar(viewFigure, writer) {
  _removeUIElement(viewFigure, writer, "progressBar");
}
function _showCompleteIcon(viewFigure, writer, view) {
  const completeIcon = writer.createUIElement("div", { class: "ck-image-upload-complete-icon" });
  writer.insert(writer.createPositionAt(viewFigure, "end"), completeIcon);
  setTimeout(() => {
    view.change((writer2) => writer2.remove(writer2.createRangeOn(completeIcon)));
  }, 3e3);
}
function _createProgressBar(writer) {
  const progressBar = writer.createUIElement("div", { class: "ck-progress-bar" });
  writer.setCustomProperty("progressBar", true, progressBar);
  return progressBar;
}
function _createPlaceholder(writer) {
  const placeholder = writer.createUIElement("div", { class: "ck-upload-placeholder-loader" });
  writer.setCustomProperty("placeholder", true, placeholder);
  return placeholder;
}
function _getUIElement(imageFigure, uniqueProperty) {
  for (const child of imageFigure.getChildren()) {
    if (child.getCustomProperty(uniqueProperty)) {
      return child;
    }
  }
}
function _removeUIElement(viewFigure, writer, uniqueProperty) {
  const element = _getUIElement(viewFigure, uniqueProperty);
  if (element) {
    writer.remove(writer.createRangeOn(element));
  }
}
function _displayLocalImage(imageUtils, viewFigure, writer, loader) {
  if (loader.data) {
    const viewImg = imageUtils.findViewImgElement(viewFigure);
    writer.setAttribute("src", loader.data, viewImg);
  }
}

// node_modules/@ckeditor/ckeditor5-image/src/imageupload/uploadimagecommand.js
var UploadImageCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const selectedElement = editor.model.document.selection.getSelectedElement();
    this.isEnabled = imageUtils.isImageAllowed() || imageUtils.isImage(selectedElement);
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options Options for the executed command.
   * @param options.file The image file or an array of image files to upload.
   */
  execute(options) {
    const files = toArray(options.file);
    const selection = this.editor.model.document.selection;
    const imageUtils = this.editor.plugins.get("ImageUtils");
    const selectionAttributes = Object.fromEntries(selection.getAttributes());
    files.forEach((file, index) => {
      const selectedElement = selection.getSelectedElement();
      if (index && selectedElement && imageUtils.isImage(selectedElement)) {
        const position = this.editor.model.createPositionAfter(selectedElement);
        this._uploadImage(file, selectionAttributes, position);
      } else {
        this._uploadImage(file, selectionAttributes);
      }
    });
  }
  /**
   * Handles uploading single file.
   */
  _uploadImage(file, attributes, position) {
    const editor = this.editor;
    const fileRepository = editor.plugins.get(FileRepository);
    const loader = fileRepository.createLoader(file);
    const imageUtils = editor.plugins.get("ImageUtils");
    if (!loader) {
      return;
    }
    imageUtils.insertImage({ ...attributes, uploadId: loader.id }, position);
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadediting.js
var ImageUploadEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [FileRepository, Notification, ClipboardPipeline, ImageUtils];
  }
  static get pluginName() {
    return "ImageUploadEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("image", {
      upload: {
        types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]
      }
    });
    this._uploadImageElements = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const doc = editor.model.document;
    const conversion = editor.conversion;
    const fileRepository = editor.plugins.get(FileRepository);
    const imageUtils = editor.plugins.get("ImageUtils");
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    const imageTypes = createImageTypeRegExp(editor.config.get("image.upload.types"));
    const uploadImageCommand = new UploadImageCommand(editor);
    editor.commands.add("uploadImage", uploadImageCommand);
    editor.commands.add("imageUpload", uploadImageCommand);
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "img",
        key: "uploadId"
      },
      model: "uploadId"
    });
    this.listenTo(editor.editing.view.document, "clipboardInput", (evt, data) => {
      if (isHtmlIncluded(data.dataTransfer)) {
        return;
      }
      const images = Array.from(data.dataTransfer.files).filter((file) => {
        if (!file) {
          return false;
        }
        return imageTypes.test(file.type);
      });
      if (!images.length) {
        return;
      }
      evt.stop();
      editor.model.change((writer) => {
        if (data.targetRanges) {
          writer.setSelection(data.targetRanges.map((viewRange) => editor.editing.mapper.toModelRange(viewRange)));
        }
        editor.model.enqueueChange(() => {
          editor.execute("uploadImage", { file: images });
        });
      });
    });
    this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
      const fetchableImages = Array.from(editor.editing.view.createRangeIn(data.content)).map((value) => value.item).filter((viewElement) => isLocalImage(imageUtils, viewElement) && !viewElement.getAttribute("uploadProcessed")).map((viewElement) => {
        return { promise: fetchLocalImage(viewElement), imageElement: viewElement };
      });
      if (!fetchableImages.length) {
        return;
      }
      const writer = new UpcastWriter(editor.editing.view.document);
      for (const fetchableImage of fetchableImages) {
        writer.setAttribute("uploadProcessed", true, fetchableImage.imageElement);
        const loader = fileRepository.createLoader(fetchableImage.promise);
        if (loader) {
          writer.setAttribute("src", "", fetchableImage.imageElement);
          writer.setAttribute("uploadId", loader.id, fetchableImage.imageElement);
        }
      }
    });
    editor.editing.view.document.on("dragover", (evt, data) => {
      data.preventDefault();
    });
    doc.on("change", () => {
      const changes = doc.differ.getChanges({ includeChangesInGraveyard: true }).reverse();
      const insertedImagesIds = /* @__PURE__ */ new Set();
      for (const entry of changes) {
        if (entry.type == "insert" && entry.name != "$text") {
          const item = entry.position.nodeAfter;
          const isInsertedInGraveyard = entry.position.root.rootName == "$graveyard";
          for (const imageElement of getImagesFromChangeItem(editor, item)) {
            const uploadId = imageElement.getAttribute("uploadId");
            if (!uploadId) {
              continue;
            }
            const loader = fileRepository.loaders.get(uploadId);
            if (!loader) {
              continue;
            }
            if (isInsertedInGraveyard) {
              if (!insertedImagesIds.has(uploadId)) {
                loader.abort();
              }
            } else {
              insertedImagesIds.add(uploadId);
              this._uploadImageElements.set(uploadId, imageElement);
              if (loader.status == "idle") {
                this._readAndUpload(loader);
              }
            }
          }
        }
      }
    });
    this.on("uploadComplete", (evt, { imageElement, data }) => {
      const urls = data.urls ? data.urls : data;
      this.editor.model.change((writer) => {
        writer.setAttribute("src", urls.default, imageElement);
        this._parseAndSetSrcsetAttributeOnImage(urls, imageElement, writer);
      });
    }, { priority: "low" });
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const schema = this.editor.model.schema;
    if (this.editor.plugins.has("ImageBlockEditing")) {
      schema.extend("imageBlock", {
        allowAttributes: ["uploadId", "uploadStatus"]
      });
    }
    if (this.editor.plugins.has("ImageInlineEditing")) {
      schema.extend("imageInline", {
        allowAttributes: ["uploadId", "uploadStatus"]
      });
    }
  }
  /**
   * Reads and uploads an image.
   *
   * The image is read from the disk and as a Base64-encoded string it is set temporarily to
   * `image[src]`. When the image is successfully uploaded, the temporary data is replaced with the target
   * image's URL (the URL to the uploaded image on the server).
   */
  _readAndUpload(loader) {
    const editor = this.editor;
    const model = editor.model;
    const t = editor.locale.t;
    const fileRepository = editor.plugins.get(FileRepository);
    const notification = editor.plugins.get(Notification);
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageUploadElements = this._uploadImageElements;
    model.enqueueChange({ isUndoable: false }, (writer) => {
      writer.setAttribute("uploadStatus", "reading", imageUploadElements.get(loader.id));
    });
    return loader.read().then(() => {
      const promise = loader.upload();
      const imageElement = imageUploadElements.get(loader.id);
      if (env_default.isSafari) {
        const viewFigure = editor.editing.mapper.toViewElement(imageElement);
        const viewImg = imageUtils.findViewImgElement(viewFigure);
        editor.editing.view.once("render", () => {
          if (!viewImg.parent) {
            return;
          }
          const domFigure = editor.editing.view.domConverter.mapViewToDom(viewImg.parent);
          if (!domFigure) {
            return;
          }
          const originalDisplay = domFigure.style.display;
          domFigure.style.display = "none";
          domFigure._ckHack = domFigure.offsetHeight;
          domFigure.style.display = originalDisplay;
        });
      }
      model.enqueueChange({ isUndoable: false }, (writer) => {
        writer.setAttribute("uploadStatus", "uploading", imageElement);
      });
      return promise;
    }).then((data) => {
      model.enqueueChange({ isUndoable: false }, (writer) => {
        const imageElement = imageUploadElements.get(loader.id);
        writer.setAttribute("uploadStatus", "complete", imageElement);
        this.fire("uploadComplete", { data, imageElement });
      });
      clean();
    }).catch((error) => {
      if (loader.status !== "error" && loader.status !== "aborted") {
        throw error;
      }
      if (loader.status == "error" && error) {
        notification.showWarning(error, {
          title: t("Upload failed"),
          namespace: "upload"
        });
      }
      model.enqueueChange({ isUndoable: false }, (writer) => {
        writer.remove(imageUploadElements.get(loader.id));
      });
      clean();
    });
    function clean() {
      model.enqueueChange({ isUndoable: false }, (writer) => {
        const imageElement = imageUploadElements.get(loader.id);
        writer.removeAttribute("uploadId", imageElement);
        writer.removeAttribute("uploadStatus", imageElement);
        imageUploadElements.delete(loader.id);
      });
      fileRepository.destroyLoader(loader);
    }
  }
  /**
   * Creates the `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.
   *
   * @param data Data object from which `srcset` will be created.
   * @param image The image element on which the `srcset` attribute will be set.
   */
  _parseAndSetSrcsetAttributeOnImage(data, image, writer) {
    let maxWidth = 0;
    const srcsetAttribute = Object.keys(data).filter((key) => {
      const width = parseInt(key, 10);
      if (!isNaN(width)) {
        maxWidth = Math.max(maxWidth, width);
        return true;
      }
    }).map((key) => `${data[key]} ${key}w`).join(", ");
    if (srcsetAttribute != "") {
      writer.setAttribute("srcset", {
        data: srcsetAttribute,
        width: maxWidth
      }, image);
    }
  }
};
function isHtmlIncluded(dataTransfer) {
  return Array.from(dataTransfer.types).includes("text/html") && dataTransfer.getData("text/html") !== "";
}
function getImagesFromChangeItem(editor, item) {
  const imageUtils = editor.plugins.get("ImageUtils");
  return Array.from(editor.model.createRangeOn(item)).filter((value) => imageUtils.isImage(value.item)).map((value) => value.item);
}

// node_modules/@ckeditor/ckeditor5-image/src/imageupload.js
var ImageUpload = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageUpload";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageUploadEditing, ImageUploadUI, ImageUploadProgress];
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageinsert/ui/imageinsertformrowview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/imageinsertformrowview.css";
var ImageUploadFormRowView = class extends View {
  /**
   * Creates an instance of the form row class.
   *
   * @param locale The locale instance.
   * @param options.labelView When passed, the row gets the `group` and `aria-labelledby`
   * DOM attributes and gets described by the label.
   */
  constructor(locale, options = {}) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("class", options.class || null);
    this.children = this.createCollection();
    if (options.children) {
      options.children.forEach((child) => this.children.add(child));
    }
    this.set("_role", null);
    this.set("_ariaLabelledBy", null);
    if (options.labelView) {
      this.set({
        _role: "group",
        _ariaLabelledBy: options.labelView.id
      });
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-form__row",
          bind.to("class")
        ],
        role: bind.to("_role"),
        "aria-labelledby": bind.to("_ariaLabelledBy")
      },
      children: this.children
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageinsert/ui/imageinsertpanelview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/imageinsert.css";
var ImageInsertPanelView = class extends View {
  /**
   * Creates a view for the dropdown panel of {@link module:image/imageinsert/imageinsertui~ImageInsertUI}.
   *
   * @param locale The localization services instance.
   * @param integrations An integrations object that contains components (or tokens for components) to be shown in the panel view.
   */
  constructor(locale, integrations = {}) {
    super(locale);
    const { insertButtonView, cancelButtonView } = this._createActionButtons(locale);
    this.insertButtonView = insertButtonView;
    this.cancelButtonView = cancelButtonView;
    this.set("imageURLInputValue", "");
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.set("_integrations", new Collection());
    for (const [integration, integrationView] of Object.entries(integrations)) {
      if (integration === "insertImageViaUrl") {
        integrationView.fieldView.bind("value").to(this, "imageURLInputValue", (value) => value || "");
        integrationView.fieldView.on("input", () => {
          this.imageURLInputValue = integrationView.fieldView.element.value.trim();
        });
      }
      integrationView.name = integration;
      this._integrations.add(integrationView);
    }
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-image-insert-form"
        ],
        tabindex: "-1"
      },
      children: [
        ...this._integrations,
        new ImageUploadFormRowView(locale, {
          children: [
            this.insertButtonView,
            this.cancelButtonView
          ],
          class: "ck-image-insert-form__action-row"
        })
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    const childViews = [
      ...this._integrations,
      this.insertButtonView,
      this.cancelButtonView
    ];
    childViews.forEach((v) => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });
    this.keystrokes.listenTo(this.element);
    const stopPropagation = (data) => data.stopPropagation();
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Returns a view of the integration.
   *
   * @param name The name of the integration.
   */
  getIntegration(name) {
    return this._integrations.find((integration) => integration.name === name);
  }
  /**
   * Creates the following form controls:
   *
   * * {@link #insertButtonView},
   * * {@link #cancelButtonView}.
   *
   * @param locale The localization services instance.
   */
  _createActionButtons(locale) {
    const t = locale.t;
    const insertButtonView = new ButtonView(locale);
    const cancelButtonView = new ButtonView(locale);
    insertButtonView.set({
      label: t("Insert"),
      icon: icons.check,
      class: "ck-button-save",
      type: "submit",
      withText: true,
      isEnabled: this.imageURLInputValue
    });
    cancelButtonView.set({
      label: t("Cancel"),
      icon: icons.cancel,
      class: "ck-button-cancel",
      withText: true
    });
    insertButtonView.bind("isEnabled").to(this, "imageURLInputValue", (value) => !!value);
    insertButtonView.delegate("execute").to(this, "submit");
    cancelButtonView.delegate("execute").to(this, "cancel");
    return { insertButtonView, cancelButtonView };
  }
  /**
   * Focuses the first {@link #_focusables focusable} in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageinsert/utils.js
function prepareIntegrations(editor) {
  const panelItems = editor.config.get("image.insert.integrations");
  const imageInsertUIPlugin = editor.plugins.get("ImageInsertUI");
  const PREDEFINED_INTEGRATIONS = {
    "insertImageViaUrl": createLabeledInputView(editor.locale)
  };
  if (!panelItems) {
    return PREDEFINED_INTEGRATIONS;
  }
  if (panelItems.find((item) => item === "openCKFinder") && editor.ui.componentFactory.has("ckfinder")) {
    const ckFinderButton = editor.ui.componentFactory.create("ckfinder");
    ckFinderButton.set({
      withText: true,
      class: "ck-image-insert__ck-finder-button"
    });
    ckFinderButton.delegate("execute").to(imageInsertUIPlugin, "cancel");
    PREDEFINED_INTEGRATIONS.openCKFinder = ckFinderButton;
  }
  return panelItems.reduce((object, key) => {
    if (PREDEFINED_INTEGRATIONS[key]) {
      object[key] = PREDEFINED_INTEGRATIONS[key];
    } else if (editor.ui.componentFactory.has(key)) {
      object[key] = editor.ui.componentFactory.create(key);
    }
    return object;
  }, {});
}
function createLabeledInputView(locale) {
  const t = locale.t;
  const labeledInputView = new LabeledFieldView(locale, createLabeledInputText);
  labeledInputView.set({
    label: t("Insert image via URL")
  });
  labeledInputView.fieldView.placeholder = "https://example.com/image.png";
  return labeledInputView;
}

// node_modules/@ckeditor/ckeditor5-image/src/imageinsert/imageinsertui.js
var ImageInsertUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInsertUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const componentCreator = (locale) => {
      return this._createDropdownView(locale);
    };
    editor.ui.componentFactory.add("insertImage", componentCreator);
    editor.ui.componentFactory.add("imageInsert", componentCreator);
  }
  /**
   * Creates the dropdown view.
   *
   * @param locale The localization services instance.
   */
  _createDropdownView(locale) {
    const editor = this.editor;
    const t = locale.t;
    const uploadImageCommand = editor.commands.get("uploadImage");
    const insertImageCommand = editor.commands.get("insertImage");
    this.dropdownView = createDropdown(locale, uploadImageCommand ? SplitButtonView : void 0);
    const buttonView = this.dropdownView.buttonView;
    const panelView = this.dropdownView.panelView;
    buttonView.set({
      label: t("Insert image"),
      icon: icons.image,
      tooltip: true
    });
    panelView.extendTemplate({
      attributes: {
        class: "ck-image-insert__panel"
      }
    });
    if (uploadImageCommand) {
      const splitButtonView = this.dropdownView.buttonView;
      splitButtonView.actionView = editor.ui.componentFactory.create("uploadImage");
      splitButtonView.actionView.extendTemplate({
        attributes: {
          class: "ck ck-button ck-splitbutton__action"
        }
      });
    }
    return this._setUpDropdown(uploadImageCommand || insertImageCommand);
  }
  /**
   * Sets up the dropdown view.
   *
   * @param command An uploadImage or insertImage command.
   */
  _setUpDropdown(command) {
    const editor = this.editor;
    const t = editor.t;
    const dropdownView = this.dropdownView;
    const panelView = dropdownView.panelView;
    const imageUtils = this.editor.plugins.get("ImageUtils");
    const replaceImageSourceCommand = editor.commands.get("replaceImageSource");
    let imageInsertView;
    dropdownView.bind("isEnabled").to(command);
    dropdownView.once("change:isOpen", () => {
      imageInsertView = new ImageInsertPanelView(editor.locale, prepareIntegrations(editor));
      imageInsertView.delegate("submit", "cancel").to(dropdownView);
      panelView.children.add(imageInsertView);
    });
    dropdownView.on("change:isOpen", () => {
      const selectedElement = editor.model.document.selection.getSelectedElement();
      const insertButtonView = imageInsertView.insertButtonView;
      const insertImageViaUrlForm = imageInsertView.getIntegration("insertImageViaUrl");
      if (dropdownView.isOpen) {
        if (imageUtils.isImage(selectedElement)) {
          imageInsertView.imageURLInputValue = replaceImageSourceCommand.value;
          insertButtonView.label = t("Update");
          insertImageViaUrlForm.label = t("Update image URL");
        } else {
          imageInsertView.imageURLInputValue = "";
          insertButtonView.label = t("Insert");
          insertImageViaUrlForm.label = t("Insert image via URL");
        }
      }
    }, { priority: "low" });
    this.delegate("cancel").to(dropdownView);
    dropdownView.on("submit", () => {
      closePanel();
      onSubmit();
    });
    dropdownView.on("cancel", () => {
      closePanel();
    });
    function onSubmit() {
      const selectedElement = editor.model.document.selection.getSelectedElement();
      if (imageUtils.isImage(selectedElement)) {
        editor.execute("replaceImageSource", { source: imageInsertView.imageURLInputValue });
      } else {
        editor.execute("insertImage", { source: imageInsertView.imageURLInputValue });
      }
    }
    function closePanel() {
      editor.editing.view.focus();
      dropdownView.isOpen = false;
    }
    return dropdownView;
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageinsertviaurl.js
var ImageInsertViaUrl = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInsertViaUrl";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageInsertUI];
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageinsert.js
var ImageInsert = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageInsert";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageUpload, ImageInsertViaUrl, ImageInsertUI];
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageresize/resizeimagecommand.js
var ResizeImageCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = imageUtils.getClosestSelectedImageElement(editor.model.document.selection);
    this.isEnabled = !!element;
    if (!element || !element.hasAttribute("width")) {
      this.value = null;
    } else {
      this.value = {
        width: element.getAttribute("width"),
        height: null
      };
    }
  }
  /**
   * Executes the command.
   *
   * ```ts
   * // Sets the width to 50%:
   * editor.execute( 'resizeImage', { width: '50%' } );
   *
   * // Removes the width attribute:
   * editor.execute( 'resizeImage', { width: null } );
   * ```
   *
   * @param options
   * @param options.width The new width of the image.
   * @fires execute
   */
  execute(options) {
    const editor = this.editor;
    const model = editor.model;
    const imageUtils = editor.plugins.get("ImageUtils");
    const imageElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
    this.value = {
      width: options.width,
      height: null
    };
    if (imageElement) {
      model.change((writer) => {
        writer.setAttribute("width", options.width, imageElement);
      });
    }
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageresize/imageresizeediting.js
var ImageResizeEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageUtils];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResizeEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("image", {
      resizeUnit: "%",
      resizeOptions: [
        {
          name: "resizeImage:original",
          value: null,
          icon: "original"
        },
        {
          name: "resizeImage:25",
          value: "25",
          icon: "small"
        },
        {
          name: "resizeImage:50",
          value: "50",
          icon: "medium"
        },
        {
          name: "resizeImage:75",
          value: "75",
          icon: "large"
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const resizeImageCommand = new ResizeImageCommand(editor);
    this._registerSchema();
    this._registerConverters("imageBlock");
    this._registerConverters("imageInline");
    editor.commands.add("resizeImage", resizeImageCommand);
    editor.commands.add("imageResize", resizeImageCommand);
  }
  _registerSchema() {
    if (this.editor.plugins.has("ImageBlockEditing")) {
      this.editor.model.schema.extend("imageBlock", { allowAttributes: "width" });
    }
    if (this.editor.plugins.has("ImageInlineEditing")) {
      this.editor.model.schema.extend("imageInline", { allowAttributes: "width" });
    }
  }
  /**
   * Registers image resize converters.
   *
   * @param imageType The type of the image.
   */
  _registerConverters(imageType) {
    const editor = this.editor;
    editor.conversion.for("downcast").add((dispatcher) => dispatcher.on(`attribute:width:${imageType}`, (evt, data, conversionApi) => {
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const viewWriter = conversionApi.writer;
      const figure = conversionApi.mapper.toViewElement(data.item);
      if (data.attributeNewValue !== null) {
        viewWriter.setStyle("width", data.attributeNewValue, figure);
        viewWriter.addClass("image_resized", figure);
      } else {
        viewWriter.removeStyle("width", figure);
        viewWriter.removeClass("image_resized", figure);
      }
    }));
    editor.conversion.for("upcast").attributeToAttribute({
      view: {
        name: imageType === "imageBlock" ? "figure" : "img",
        styles: {
          width: /.+/
        }
      },
      model: {
        key: "width",
        value: (viewElement) => viewElement.getStyle("width")
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageresize/imageresizebuttons.js
var RESIZE_ICONS = {
  small: icons.objectSizeSmall,
  medium: icons.objectSizeMedium,
  large: icons.objectSizeLarge,
  original: icons.objectSizeFull
};
var ImageResizeButtons = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageResizeEditing];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResizeButtons";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._resizeUnit = editor.config.get("image.resizeUnit");
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const options = editor.config.get("image.resizeOptions");
    const command = editor.commands.get("resizeImage");
    this.bind("isEnabled").to(command);
    for (const option of options) {
      this._registerImageResizeButton(option);
    }
    this._registerImageResizeDropdown(options);
  }
  /**
   * A helper function that creates a standalone button component for the plugin.
   *
   * @param resizeOption A model of the resize option.
   */
  _registerImageResizeButton(option) {
    const editor = this.editor;
    const { name, value, icon } = option;
    const optionValueWithUnit = value ? value + this._resizeUnit : null;
    editor.ui.componentFactory.add(name, (locale) => {
      const button = new ButtonView(locale);
      const command = editor.commands.get("resizeImage");
      const labelText = this._getOptionLabelValue(option, true);
      if (!RESIZE_ICONS[icon]) {
        throw new CKEditorError("imageresizebuttons-missing-icon", editor, option);
      }
      button.set({
        // Use the `label` property for a verbose description (because of ARIA).
        label: labelText,
        icon: RESIZE_ICONS[icon],
        tooltip: labelText,
        isToggleable: true
      });
      button.bind("isEnabled").to(this);
      button.bind("isOn").to(command, "value", getIsOnButtonCallback(optionValueWithUnit));
      this.listenTo(button, "execute", () => {
        editor.execute("resizeImage", { width: optionValueWithUnit });
      });
      return button;
    });
  }
  /**
   * A helper function that creates a dropdown component for the plugin containing all the resize options defined in
   * the editor configuration.
   *
   * @param options An array of configured options.
   */
  _registerImageResizeDropdown(options) {
    const editor = this.editor;
    const t = editor.t;
    const originalSizeOption = options.find((option) => !option.value);
    const componentCreator = (locale) => {
      const command = editor.commands.get("resizeImage");
      const dropdownView = createDropdown(locale, DropdownButtonView);
      const dropdownButton = dropdownView.buttonView;
      const accessibleLabel = t("Resize image");
      dropdownButton.set({
        tooltip: accessibleLabel,
        commandValue: originalSizeOption.value,
        icon: RESIZE_ICONS.medium,
        isToggleable: true,
        label: this._getOptionLabelValue(originalSizeOption),
        withText: true,
        class: "ck-resize-image-button",
        ariaLabel: accessibleLabel,
        ariaLabelledBy: void 0
      });
      dropdownButton.bind("label").to(command, "value", (commandValue) => {
        if (commandValue && commandValue.width) {
          return commandValue.width;
        } else {
          return this._getOptionLabelValue(originalSizeOption);
        }
      });
      dropdownView.bind("isEnabled").to(this);
      addListToDropdown(dropdownView, () => this._getResizeDropdownListItemDefinitions(options, command), {
        ariaLabel: t("Image resize list"),
        role: "menu"
      });
      this.listenTo(dropdownView, "execute", (evt) => {
        editor.execute(evt.source.commandName, { width: evt.source.commandValue });
        editor.editing.view.focus();
      });
      return dropdownView;
    };
    editor.ui.componentFactory.add("resizeImage", componentCreator);
    editor.ui.componentFactory.add("imageResize", componentCreator);
  }
  /**
   * A helper function for creating an option label value string.
   *
   * @param option A resize option object.
   * @param forTooltip An optional flag for creating a tooltip label.
   * @returns A user-defined label combined from the numeric value and the resize unit or the default label
   * for reset options (`Original`).
   */
  _getOptionLabelValue(option, forTooltip = false) {
    const t = this.editor.t;
    if (option.label) {
      return option.label;
    } else if (forTooltip) {
      if (option.value) {
        return t("Resize image to %0", option.value + this._resizeUnit);
      } else {
        return t("Resize image to the original size");
      }
    } else {
      if (option.value) {
        return option.value + this._resizeUnit;
      } else {
        return t("Original");
      }
    }
  }
  /**
   * A helper function that parses the resize options and returns list item definitions ready for use in the dropdown.
   *
   * @param options The resize options.
   * @param command The resize image command.
   * @returns Dropdown item definitions.
   */
  _getResizeDropdownListItemDefinitions(options, command) {
    const itemDefinitions = new Collection();
    options.map((option) => {
      const optionValueWithUnit = option.value ? option.value + this._resizeUnit : null;
      const definition = {
        type: "button",
        model: new Model({
          commandName: "resizeImage",
          commandValue: optionValueWithUnit,
          label: this._getOptionLabelValue(option),
          role: "menuitemradio",
          withText: true,
          icon: null
        })
      };
      definition.model.bind("isOn").to(command, "value", getIsOnButtonCallback(optionValueWithUnit));
      itemDefinitions.add(definition);
    });
    return itemDefinitions;
  }
};
function getIsOnButtonCallback(value) {
  return (commandValue) => {
    const objectCommandValue = commandValue;
    if (value === null && objectCommandValue === value) {
      return true;
    }
    return objectCommandValue !== null && objectCommandValue.width === value;
  };
}

// node_modules/@ckeditor/ckeditor5-image/src/imageresize/imageresizehandles.js
var RESIZABLE_IMAGES_CSS_SELECTOR = "figure.image.ck-widget > img,figure.image.ck-widget > picture > img,figure.image.ck-widget > a > img,figure.image.ck-widget > a > picture > img,span.image-inline.ck-widget > img,span.image-inline.ck-widget > picture > img";
var IMAGE_WIDGETS_CLASSES_MATCH_REGEXP = /(image|image-inline)/;
var RESIZED_IMAGE_CLASS = "image_resized";
var ImageResizeHandles = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [WidgetResize];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResizeHandles";
  }
  /**
   * @inheritDoc
   */
  init() {
    const command = this.editor.commands.get("resizeImage");
    this.bind("isEnabled").to(command);
    this._setupResizerCreator();
  }
  /**
   * Attaches the listeners responsible for creating a resizer for each image, except for images inside the HTML embed preview.
   */
  _setupResizerCreator() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    editingView.addObserver(ImageLoadObserver);
    this.listenTo(editingView.document, "imageLoaded", (evt, domEvent) => {
      if (!domEvent.target.matches(RESIZABLE_IMAGES_CSS_SELECTOR)) {
        return;
      }
      const domConverter = editor.editing.view.domConverter;
      const imageView = domConverter.domToView(domEvent.target);
      const widgetView = imageView.findAncestor({ classes: IMAGE_WIDGETS_CLASSES_MATCH_REGEXP });
      let resizer = this.editor.plugins.get(WidgetResize).getResizerByViewElement(widgetView);
      if (resizer) {
        resizer.redraw();
        return;
      }
      const mapper = editor.editing.mapper;
      const imageModel = mapper.toModelElement(widgetView);
      resizer = editor.plugins.get(WidgetResize).attachTo({
        unit: editor.config.get("image.resizeUnit"),
        modelElement: imageModel,
        viewElement: widgetView,
        editor,
        getHandleHost(domWidgetElement) {
          return domWidgetElement.querySelector("img");
        },
        getResizeHost() {
          return domConverter.mapViewToDom(mapper.toViewElement(imageModel.parent));
        },
        // TODO consider other positions.
        isCentered() {
          const imageStyle = imageModel.getAttribute("imageStyle");
          return !imageStyle || imageStyle == "block" || imageStyle == "alignCenter";
        },
        onCommit(newValue) {
          editingView.change((writer) => {
            writer.removeClass(RESIZED_IMAGE_CLASS, widgetView);
          });
          editor.execute("resizeImage", { width: newValue });
        }
      });
      resizer.on("updateSize", () => {
        if (!widgetView.hasClass(RESIZED_IMAGE_CLASS)) {
          editingView.change((writer) => {
            writer.addClass(RESIZED_IMAGE_CLASS, widgetView);
          });
        }
      });
      resizer.bind("isEnabled").to(this);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imageresize.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css";
var ImageResize = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageResizeEditing, ImageResizeHandles, ImageResizeButtons];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageResize";
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagestyle/imagestylecommand.js
var ImageStyleCommand = class extends Command {
  /**
   * Creates an instance of the image style command. When executed, the command applies one of
   * {@link module:image/imageconfig~ImageStyleConfig#options style options} to the currently selected image.
   *
   * @param editor The editor instance.
   * @param styles The style options that this command supports.
   */
  constructor(editor, styles) {
    super(editor);
    this._defaultStyles = {
      imageBlock: false,
      imageInline: false
    };
    this._styles = new Map(styles.map((style) => {
      if (style.isDefault) {
        for (const modelElementName of style.modelElements) {
          this._defaultStyles[modelElementName] = style.name;
        }
      }
      return [style.name, style];
    }));
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const imageUtils = editor.plugins.get("ImageUtils");
    const element = imageUtils.getClosestSelectedImageElement(this.editor.model.document.selection);
    this.isEnabled = !!element;
    if (!this.isEnabled) {
      this.value = false;
    } else if (element.hasAttribute("imageStyle")) {
      this.value = element.getAttribute("imageStyle");
    } else {
      this.value = this._defaultStyles[element.name];
    }
  }
  /**
   * Executes the command and applies the style to the currently selected image:
   *
   * ```ts
   * editor.execute( 'imageStyle', { value: 'side' } );
   * ```
   *
   * **Note**: Executing this command may change the image model element if the desired style requires an image
   * of a different type. Learn more about {@link module:image/imageconfig~ImageStyleOptionDefinition#modelElements model element}
   * configuration for the style option.
   *
   * @param options.value The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
   * @fires execute
   */
  execute(options = {}) {
    const editor = this.editor;
    const model = editor.model;
    const imageUtils = editor.plugins.get("ImageUtils");
    model.change((writer) => {
      const requestedStyle = options.value;
      let imageElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
      if (requestedStyle && this.shouldConvertImageType(requestedStyle, imageElement)) {
        this.editor.execute(imageUtils.isBlockImage(imageElement) ? "imageTypeInline" : "imageTypeBlock");
        imageElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
      }
      if (!requestedStyle || this._styles.get(requestedStyle).isDefault) {
        writer.removeAttribute("imageStyle", imageElement);
      } else {
        writer.setAttribute("imageStyle", requestedStyle, imageElement);
      }
    });
  }
  /**
   * Returns `true` if requested style change would trigger the image type change.
   *
   * @param requestedStyle The name of the style (as configured in {@link module:image/imageconfig~ImageStyleConfig#options}).
   * @param imageElement The image model element.
   */
  shouldConvertImageType(requestedStyle, imageElement) {
    const supportedTypes = this._styles.get(requestedStyle).modelElements;
    return !supportedTypes.includes(imageElement.name);
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagestyle/utils.js
var { objectFullWidth, objectInline, objectLeft, objectRight, objectCenter, objectBlockLeft, objectBlockRight } = icons;
var DEFAULT_OPTIONS = {
  // This style represents an image placed in the line of text.
  get inline() {
    return {
      name: "inline",
      title: "In line",
      icon: objectInline,
      modelElements: ["imageInline"],
      isDefault: true
    };
  },
  // This style represents an image aligned to the left and wrapped with text.
  get alignLeft() {
    return {
      name: "alignLeft",
      title: "Left aligned image",
      icon: objectLeft,
      modelElements: ["imageBlock", "imageInline"],
      className: "image-style-align-left"
    };
  },
  // This style represents an image aligned to the left.
  get alignBlockLeft() {
    return {
      name: "alignBlockLeft",
      title: "Left aligned image",
      icon: objectBlockLeft,
      modelElements: ["imageBlock"],
      className: "image-style-block-align-left"
    };
  },
  // This style represents a centered image.
  get alignCenter() {
    return {
      name: "alignCenter",
      title: "Centered image",
      icon: objectCenter,
      modelElements: ["imageBlock"],
      className: "image-style-align-center"
    };
  },
  // This style represents an image aligned to the right and wrapped with text.
  get alignRight() {
    return {
      name: "alignRight",
      title: "Right aligned image",
      icon: objectRight,
      modelElements: ["imageBlock", "imageInline"],
      className: "image-style-align-right"
    };
  },
  // This style represents an image aligned to the right.
  get alignBlockRight() {
    return {
      name: "alignBlockRight",
      title: "Right aligned image",
      icon: objectBlockRight,
      modelElements: ["imageBlock"],
      className: "image-style-block-align-right"
    };
  },
  // This option is equal to the situation when no style is applied.
  get block() {
    return {
      name: "block",
      title: "Centered image",
      icon: objectCenter,
      modelElements: ["imageBlock"],
      isDefault: true
    };
  },
  // This represents a side image.
  get side() {
    return {
      name: "side",
      title: "Side image",
      icon: objectRight,
      modelElements: ["imageBlock"],
      className: "image-style-side"
    };
  }
};
var DEFAULT_ICONS = {
  full: objectFullWidth,
  left: objectBlockLeft,
  right: objectBlockRight,
  center: objectCenter,
  inlineLeft: objectLeft,
  inlineRight: objectRight,
  inline: objectInline
};
var DEFAULT_DROPDOWN_DEFINITIONS = [{
  name: "imageStyle:wrapText",
  title: "Wrap text",
  defaultItem: "imageStyle:alignLeft",
  items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
}, {
  name: "imageStyle:breakText",
  title: "Break text",
  defaultItem: "imageStyle:block",
  items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
}];
function normalizeStyles(config) {
  const configuredStyles = config.configuredStyles.options || [];
  const styles = configuredStyles.map((arrangement) => normalizeDefinition(arrangement)).filter((arrangement) => isValidOption(arrangement, config));
  return styles;
}
function getDefaultStylesConfiguration(isBlockPluginLoaded, isInlinePluginLoaded) {
  if (isBlockPluginLoaded && isInlinePluginLoaded) {
    return {
      options: [
        "inline",
        "alignLeft",
        "alignRight",
        "alignCenter",
        "alignBlockLeft",
        "alignBlockRight",
        "block",
        "side"
      ]
    };
  } else if (isBlockPluginLoaded) {
    return {
      options: ["block", "side"]
    };
  } else if (isInlinePluginLoaded) {
    return {
      options: ["inline", "alignLeft", "alignRight"]
    };
  }
  return {};
}
function getDefaultDropdownDefinitions(pluginCollection) {
  if (pluginCollection.has("ImageBlockEditing") && pluginCollection.has("ImageInlineEditing")) {
    return [...DEFAULT_DROPDOWN_DEFINITIONS];
  } else {
    return [];
  }
}
function normalizeDefinition(definition) {
  if (typeof definition === "string") {
    if (!DEFAULT_OPTIONS[definition]) {
      definition = { name: definition };
    } else {
      definition = { ...DEFAULT_OPTIONS[definition] };
    }
  } else {
    definition = extendStyle(DEFAULT_OPTIONS[definition.name], definition);
  }
  if (typeof definition.icon === "string") {
    definition.icon = DEFAULT_ICONS[definition.icon] || definition.icon;
  }
  return definition;
}
function isValidOption(option, { isBlockPluginLoaded, isInlinePluginLoaded }) {
  const { modelElements, name } = option;
  if (!modelElements || !modelElements.length || !name) {
    warnInvalidStyle({ style: option });
    return false;
  } else {
    const supportedElements = [isBlockPluginLoaded ? "imageBlock" : null, isInlinePluginLoaded ? "imageInline" : null];
    if (!modelElements.some((elementName) => supportedElements.includes(elementName))) {
      logWarning("image-style-missing-dependency", {
        style: option,
        missingPlugins: modelElements.map((name2) => name2 === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")
      });
      return false;
    }
  }
  return true;
}
function extendStyle(source, style) {
  const extendedStyle = { ...style };
  for (const prop in source) {
    if (!Object.prototype.hasOwnProperty.call(style, prop)) {
      extendedStyle[prop] = source[prop];
    }
  }
  return extendedStyle;
}
function warnInvalidStyle(info) {
  logWarning("image-style-configuration-definition-invalid", info);
}
var utils_default = {
  normalizeStyles,
  getDefaultStylesConfiguration,
  getDefaultDropdownDefinitions,
  warnInvalidStyle,
  DEFAULT_OPTIONS,
  DEFAULT_ICONS,
  DEFAULT_DROPDOWN_DEFINITIONS
};

// node_modules/@ckeditor/ckeditor5-image/src/imagestyle/converters.js
function modelToViewStyleAttribute(styles) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const newStyle = getStyleDefinitionByName(data.attributeNewValue, styles);
    const oldStyle = getStyleDefinitionByName(data.attributeOldValue, styles);
    const viewElement = conversionApi.mapper.toViewElement(data.item);
    const viewWriter = conversionApi.writer;
    if (oldStyle) {
      viewWriter.removeClass(oldStyle.className, viewElement);
    }
    if (newStyle) {
      viewWriter.addClass(newStyle.className, viewElement);
    }
  };
}
function viewToModelStyleAttribute(styles) {
  const nonDefaultStyles = {
    imageInline: styles.filter((style) => !style.isDefault && style.modelElements.includes("imageInline")),
    imageBlock: styles.filter((style) => !style.isDefault && style.modelElements.includes("imageBlock"))
  };
  return (evt, data, conversionApi) => {
    if (!data.modelRange) {
      return;
    }
    const viewElement = data.viewItem;
    const modelImageElement = first(data.modelRange.getItems());
    if (!modelImageElement) {
      return;
    }
    if (!conversionApi.schema.checkAttribute(modelImageElement, "imageStyle")) {
      return;
    }
    for (const style of nonDefaultStyles[modelImageElement.name]) {
      if (conversionApi.consumable.consume(viewElement, { classes: style.className })) {
        conversionApi.writer.setAttribute("imageStyle", style.name, modelImageElement);
      }
    }
  };
}
function getStyleDefinitionByName(name, styles) {
  for (const style of styles) {
    if (style.name === name) {
      return style;
    }
  }
}

// node_modules/@ckeditor/ckeditor5-image/src/imagestyle/imagestyleediting.js
var ImageStyleEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageStyleEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageUtils];
  }
  /**
   * @inheritDoc
   */
  init() {
    const { normalizeStyles: normalizeStyles2, getDefaultStylesConfiguration: getDefaultStylesConfiguration2 } = utils_default;
    const editor = this.editor;
    const isBlockPluginLoaded = editor.plugins.has("ImageBlockEditing");
    const isInlinePluginLoaded = editor.plugins.has("ImageInlineEditing");
    editor.config.define("image.styles", getDefaultStylesConfiguration2(isBlockPluginLoaded, isInlinePluginLoaded));
    this.normalizedStyles = normalizeStyles2({
      configuredStyles: editor.config.get("image.styles"),
      isBlockPluginLoaded,
      isInlinePluginLoaded
    });
    this._setupConversion(isBlockPluginLoaded, isInlinePluginLoaded);
    this._setupPostFixer();
    editor.commands.add("imageStyle", new ImageStyleCommand(editor, this.normalizedStyles));
  }
  /**
   * Sets the editor conversion taking the presence of
   * {@link module:image/image/imageinlineediting~ImageInlineEditing `ImageInlineEditing`}
   * and {@link module:image/image/imageblockediting~ImageBlockEditing `ImageBlockEditing`} plugins into consideration.
   */
  _setupConversion(isBlockPluginLoaded, isInlinePluginLoaded) {
    const editor = this.editor;
    const schema = editor.model.schema;
    const modelToViewConverter = modelToViewStyleAttribute(this.normalizedStyles);
    const viewToModelConverter = viewToModelStyleAttribute(this.normalizedStyles);
    editor.editing.downcastDispatcher.on("attribute:imageStyle", modelToViewConverter);
    editor.data.downcastDispatcher.on("attribute:imageStyle", modelToViewConverter);
    if (isBlockPluginLoaded) {
      schema.extend("imageBlock", { allowAttributes: "imageStyle" });
      editor.data.upcastDispatcher.on("element:figure", viewToModelConverter, { priority: "low" });
    }
    if (isInlinePluginLoaded) {
      schema.extend("imageInline", { allowAttributes: "imageStyle" });
      editor.data.upcastDispatcher.on("element:img", viewToModelConverter, { priority: "low" });
    }
  }
  /**
   * Registers a post-fixer that will make sure that the style attribute value is correct for a specific image type (block vs inline).
   */
  _setupPostFixer() {
    const editor = this.editor;
    const document = editor.model.document;
    const imageUtils = editor.plugins.get(ImageUtils);
    const stylesMap = new Map(this.normalizedStyles.map((style) => [style.name, style]));
    document.registerPostFixer((writer) => {
      let changed = false;
      for (const change of document.differ.getChanges()) {
        if (change.type == "insert" || change.type == "attribute" && change.attributeKey == "imageStyle") {
          let element = change.type == "insert" ? change.position.nodeAfter : change.range.start.nodeAfter;
          if (element && element.is("element", "paragraph") && element.childCount > 0) {
            element = element.getChild(0);
          }
          if (!imageUtils.isImage(element)) {
            continue;
          }
          const imageStyle = element.getAttribute("imageStyle");
          if (!imageStyle) {
            continue;
          }
          const imageStyleDefinition = stylesMap.get(imageStyle);
          if (!imageStyleDefinition || !imageStyleDefinition.modelElements.includes(element.name)) {
            writer.removeAttribute("imageStyle", element);
            changed = true;
          }
        }
      }
      return changed;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagestyle/imagestyleui.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css";
var ImageStyleUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageStyleEditing];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageStyleUI";
  }
  /**
   * Returns the default localized style titles provided by the plugin.
   *
   * The following localized titles corresponding with
   * {@link module:image/imagestyle/utils#DEFAULT_OPTIONS} are available:
   *
   * * `'Wrap text'`,
   * * `'Break text'`,
   * * `'In line'`,
   * * `'Full size image'`,
   * * `'Side image'`,
   * * `'Left aligned image'`,
   * * `'Centered image'`,
   * * `'Right aligned image'`
   */
  get localizedDefaultStylesTitles() {
    const t = this.editor.t;
    return {
      "Wrap text": t("Wrap text"),
      "Break text": t("Break text"),
      "In line": t("In line"),
      "Full size image": t("Full size image"),
      "Side image": t("Side image"),
      "Left aligned image": t("Left aligned image"),
      "Centered image": t("Centered image"),
      "Right aligned image": t("Right aligned image")
    };
  }
  /**
   * @inheritDoc
   */
  init() {
    const plugins = this.editor.plugins;
    const toolbarConfig = this.editor.config.get("image.toolbar") || [];
    const imageStyleEditing = plugins.get("ImageStyleEditing");
    const definedStyles = translateStyles(imageStyleEditing.normalizedStyles, this.localizedDefaultStylesTitles);
    for (const styleConfig of definedStyles) {
      this._createButton(styleConfig);
    }
    const definedDropdowns = translateStyles([
      ...toolbarConfig.filter(isObject_default),
      ...utils_default.getDefaultDropdownDefinitions(plugins)
    ], this.localizedDefaultStylesTitles);
    for (const dropdownConfig of definedDropdowns) {
      this._createDropdown(dropdownConfig, definedStyles);
    }
  }
  /**
   * Creates a dropdown and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
   */
  _createDropdown(dropdownConfig, definedStyles) {
    const factory = this.editor.ui.componentFactory;
    factory.add(dropdownConfig.name, (locale) => {
      let defaultButton;
      const { defaultItem, items, title } = dropdownConfig;
      const buttonViews = items.filter((itemName) => definedStyles.find(({ name }) => getUIComponentName(name) === itemName)).map((buttonName) => {
        const button = factory.create(buttonName);
        if (buttonName === defaultItem) {
          defaultButton = button;
        }
        return button;
      });
      if (items.length !== buttonViews.length) {
        utils_default.warnInvalidStyle({ dropdown: dropdownConfig });
      }
      const dropdownView = createDropdown(locale, SplitButtonView);
      const splitButtonView = dropdownView.buttonView;
      const splitButtonViewArrow = splitButtonView.arrowView;
      addToolbarToDropdown(dropdownView, buttonViews, { enableActiveItemFocusOnDropdownOpen: true });
      splitButtonView.set({
        label: getDropdownButtonTitle(title, defaultButton.label),
        class: null,
        tooltip: true
      });
      splitButtonViewArrow.unbind("label");
      splitButtonViewArrow.set({
        label: title
      });
      splitButtonView.bind("icon").toMany(buttonViews, "isOn", (...areOn) => {
        const index = areOn.findIndex(identity_default);
        return index < 0 ? defaultButton.icon : buttonViews[index].icon;
      });
      splitButtonView.bind("label").toMany(buttonViews, "isOn", (...areOn) => {
        const index = areOn.findIndex(identity_default);
        return getDropdownButtonTitle(title, index < 0 ? defaultButton.label : buttonViews[index].label);
      });
      splitButtonView.bind("isOn").toMany(buttonViews, "isOn", (...areOn) => areOn.some(identity_default));
      splitButtonView.bind("class").toMany(buttonViews, "isOn", (...areOn) => areOn.some(identity_default) ? "ck-splitbutton_flatten" : void 0);
      splitButtonView.on("execute", () => {
        if (!buttonViews.some(({ isOn }) => isOn)) {
          defaultButton.fire("execute");
        } else {
          dropdownView.isOpen = !dropdownView.isOpen;
        }
      });
      dropdownView.bind("isEnabled").toMany(buttonViews, "isEnabled", (...areEnabled) => areEnabled.some(identity_default));
      this.listenTo(dropdownView, "execute", () => {
        this.editor.editing.view.focus();
      });
      return dropdownView;
    });
  }
  /**
   * Creates a button and stores it in the editor {@link module:ui/componentfactory~ComponentFactory}.
   */
  _createButton(buttonConfig) {
    const buttonName = buttonConfig.name;
    this.editor.ui.componentFactory.add(getUIComponentName(buttonName), (locale) => {
      const command = this.editor.commands.get("imageStyle");
      const view = new ButtonView(locale);
      view.set({
        label: buttonConfig.title,
        icon: buttonConfig.icon,
        tooltip: true,
        isToggleable: true
      });
      view.bind("isEnabled").to(command, "isEnabled");
      view.bind("isOn").to(command, "value", (value) => value === buttonName);
      view.on("execute", this._executeCommand.bind(this, buttonName));
      return view;
    });
  }
  _executeCommand(name) {
    this.editor.execute("imageStyle", { value: name });
    this.editor.editing.view.focus();
  }
};
function translateStyles(styles, titles) {
  for (const style of styles) {
    if (titles[style.title]) {
      style.title = titles[style.title];
    }
  }
  return styles;
}
function getUIComponentName(name) {
  return `imageStyle:${name}`;
}
function getDropdownButtonTitle(dropdownTitle, buttonTitle) {
  return (dropdownTitle ? dropdownTitle + ": " : "") + buttonTitle;
}

// node_modules/@ckeditor/ckeditor5-image/src/imagestyle.js
var ImageStyle = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageStyleEditing, ImageStyleUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageStyle";
  }
};

// node_modules/@ckeditor/ckeditor5-image/src/imagetoolbar.js
var ImageToolbar = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [WidgetToolbarRepository, ImageUtils];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ImageToolbar";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const editor = this.editor;
    const t = editor.t;
    const widgetToolbarRepository = editor.plugins.get(WidgetToolbarRepository);
    const imageUtils = editor.plugins.get("ImageUtils");
    widgetToolbarRepository.register("image", {
      ariaLabel: t("Image toolbar"),
      items: normalizeDeclarativeConfig(editor.config.get("image.toolbar") || []),
      getRelatedElement: (selection) => imageUtils.getClosestSelectedImageWidget(selection)
    });
  }
};
function normalizeDeclarativeConfig(config) {
  return config.map((item) => isObject_default(item) ? item.name : item);
}

// node_modules/@ckeditor/ckeditor5-image/src/pictureediting.js
var PictureEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ImageEditing, ImageUtils];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PictureEditing";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const editor = this.editor;
    if (editor.plugins.has("ImageBlockEditing")) {
      editor.model.schema.extend("imageBlock", {
        allowAttributes: ["sources"]
      });
    }
    if (editor.plugins.has("ImageInlineEditing")) {
      editor.model.schema.extend("imageInline", {
        allowAttributes: ["sources"]
      });
    }
    this._setupConversion();
    this._setupImageUploadEditingIntegration();
  }
  /**
   * Configures conversion pipelines to support upcasting and downcasting images using the `<picture>` view element
   * and the model `sources` attribute.
   */
  _setupConversion() {
    const editor = this.editor;
    const conversion = editor.conversion;
    const imageUtils = editor.plugins.get("ImageUtils");
    conversion.for("upcast").add(upcastPicture(imageUtils));
    conversion.for("downcast").add(downcastSourcesAttribute(imageUtils));
  }
  /**
   * Makes it possible for uploaded images to get the `sources` model attribute and the `<picture>...</picture>`
   * view structure out-of-the-box if relevant data is provided along the
   * {@link module:image/imageupload/imageuploadediting~ImageUploadEditing#event:uploadComplete} event.
   */
  _setupImageUploadEditingIntegration() {
    const editor = this.editor;
    if (!editor.plugins.has("ImageUploadEditing")) {
      return;
    }
    const imageUploadEditing = editor.plugins.get("ImageUploadEditing");
    this.listenTo(imageUploadEditing, "uploadComplete", (evt, { imageElement, data }) => {
      const sources = data.sources;
      if (!sources) {
        return;
      }
      editor.model.change((writer) => {
        writer.setAttributes({
          sources
        }, imageElement);
      });
    });
  }
};
export {
  AutoImage,
  Image,
  ImageBlock,
  ImageBlockEditing,
  ImageCaption,
  ImageCaptionEditing,
  ImageCaptionUI,
  ImageCaptionUtils,
  ImageEditing,
  ImageInline,
  ImageInsert,
  ImageInsertUI,
  ImageInsertViaUrl,
  ImageResize,
  ImageResizeButtons,
  ImageResizeEditing,
  ImageResizeHandles,
  ImageStyle,
  ImageStyleEditing,
  ImageStyleUI,
  ImageTextAlternative,
  ImageTextAlternativeEditing,
  ImageTextAlternativeUI,
  ImageToolbar,
  ImageUpload,
  ImageUploadEditing,
  ImageUploadProgress,
  ImageUploadUI,
  ImageUtils,
  PictureEditing
};
/*! Bundled license information:

@ckeditor/ckeditor5-image/src/image/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageutils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/autoimage.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativeediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagetextalternative/ui/textalternativeformview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image/ui/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativeui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagetextalternative.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image/converters.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image/imageloadobserver.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image/insertimagecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image/replaceimagesourcecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image/imageediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image/imagetypecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image/imageblockediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageblock.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image/imageinlineediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageinline.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/image.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagecaption/imagecaptionutils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagecaption/toggleimagecaptioncommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagecaption/imagecaptionediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore if: paranoid check -- @preserve *)

@ckeditor/ckeditor5-image/src/imagecaption/imagecaptionui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagecaption.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageupload/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageupload/imageuploadui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageupload/imageuploadprogress.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageupload/uploadimagecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageupload/imageuploadediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-image/src/imageupload.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageinsert/ui/imageinsertformrowview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageinsert/ui/imageinsertpanelview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageinsert/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageinsert/imageinsertui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageinsertviaurl.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageinsert.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageresize/resizeimagecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageresize/imageresizeediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageresize/imageresizebuttons.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageresize/imageresizehandles.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imageresize.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagestyle/imagestylecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagestyle/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagestyle/converters.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagestyle/imagestyleediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagestyle/imagestyleui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagestyle.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/imagetoolbar.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/pictureediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-image/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-image.js.map
