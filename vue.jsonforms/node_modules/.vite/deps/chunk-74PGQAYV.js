import {
  Widget,
  isWidget
} from "./chunk-NMGSIING.js";
import {
  DataTransfer,
  DomEventObserver,
  EventInfo,
  LiveRange,
  MouseObserver,
  Plugin,
  delay,
  env_default,
  toUnit,
  uid
} from "./chunk-JI2V5GJZ.js";
import {
  throttle_default
} from "./chunk-6DXDGCMU.js";

// node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js
var ClipboardObserver = class extends DomEventObserver {
  constructor(view) {
    super(view);
    this.domEventType = [
      "paste",
      "copy",
      "cut",
      "drop",
      "dragover",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave"
    ];
    const viewDocument = this.document;
    this.listenTo(viewDocument, "paste", handleInput("clipboardInput"), { priority: "low" });
    this.listenTo(viewDocument, "drop", handleInput("clipboardInput"), { priority: "low" });
    this.listenTo(viewDocument, "dragover", handleInput("dragging"), { priority: "low" });
    function handleInput(type) {
      return (evt, data) => {
        data.preventDefault();
        const targetRanges = data.dropRange ? [data.dropRange] : null;
        const eventInfo = new EventInfo(viewDocument, type);
        viewDocument.fire(eventInfo, {
          dataTransfer: data.dataTransfer,
          method: evt.name,
          targetRanges,
          target: data.target,
          domEvent: data.domEvent
        });
        if (eventInfo.stop.called) {
          data.stopPropagation();
        }
      };
    }
  }
  onDomEvent(domEvent) {
    const nativeDataTransfer = "clipboardData" in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;
    const cacheFiles = domEvent.type == "drop" || domEvent.type == "paste";
    const evtData = {
      dataTransfer: new DataTransfer(nativeDataTransfer, { cacheFiles })
    };
    if (domEvent.type == "drop" || domEvent.type == "dragover") {
      evtData.dropRange = getDropViewRange(this.view, domEvent);
    }
    this.fire(domEvent.type, domEvent, evtData);
  }
};
function getDropViewRange(view, domEvent) {
  const domDoc = domEvent.target.ownerDocument;
  const x = domEvent.clientX;
  const y = domEvent.clientY;
  let domRange;
  if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x, y)) {
    domRange = domDoc.caretRangeFromPoint(x, y);
  } else if (domEvent.rangeParent) {
    domRange = domDoc.createRange();
    domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);
    domRange.collapse(true);
  }
  if (domRange) {
    return view.domConverter.domRangeToView(domRange);
  }
  return null;
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js
function plainTextToHtml(text) {
  text = text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
  if (text.includes("</p><p>") || text.includes("<br>")) {
    text = `<p>${text}</p>`;
  }
  return text;
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js
function normalizeClipboardData(data) {
  return data.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
    if (spaces.length == 1) {
      return " ";
    }
    return spaces;
  }).replace(/<!--[\s\S]*?-->/g, "");
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js
var smallPaddingElements = ["figcaption", "li"];
function viewToPlainText(viewItem) {
  let text = "";
  if (viewItem.is("$text") || viewItem.is("$textProxy")) {
    text = viewItem.data;
  } else if (viewItem.is("element", "img") && viewItem.hasAttribute("alt")) {
    text = viewItem.getAttribute("alt");
  } else if (viewItem.is("element", "br")) {
    text = "\n";
  } else {
    let prev = null;
    for (const child of viewItem.getChildren()) {
      const childText = viewToPlainText(child);
      if (prev && (prev.is("containerElement") || child.is("containerElement"))) {
        if (smallPaddingElements.includes(prev.name) || smallPaddingElements.includes(child.name)) {
          text += "\n";
        } else {
          text += "\n\n";
        }
      }
      text += childText;
      prev = child;
    }
  }
  return text;
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardpipeline.js
var ClipboardPipeline = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ClipboardPipeline";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    view.addObserver(ClipboardObserver);
    this._setupPasteDrop();
    this._setupCopyCut();
  }
  /**
   * The clipboard paste pipeline.
   */
  _setupPasteDrop() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const viewDocument = view.document;
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      if (data.method == "paste" && !editor.model.canEditAt(editor.model.document.selection)) {
        evt.stop();
      }
    }, { priority: "highest" });
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      const dataTransfer = data.dataTransfer;
      let content;
      if (data.content) {
        content = data.content;
      } else {
        let contentData = "";
        if (dataTransfer.getData("text/html")) {
          contentData = normalizeClipboardData(dataTransfer.getData("text/html"));
        } else if (dataTransfer.getData("text/plain")) {
          contentData = plainTextToHtml(dataTransfer.getData("text/plain"));
        }
        content = this.editor.data.htmlProcessor.toView(contentData);
      }
      const eventInfo = new EventInfo(this, "inputTransformation");
      this.fire(eventInfo, {
        content,
        dataTransfer,
        targetRanges: data.targetRanges,
        method: data.method
      });
      if (eventInfo.stop.called) {
        evt.stop();
      }
      view.scrollToTheSelection();
    }, { priority: "low" });
    this.listenTo(this, "inputTransformation", (evt, data) => {
      if (data.content.isEmpty) {
        return;
      }
      const dataController = this.editor.data;
      const modelFragment = dataController.toModel(data.content, "$clipboardHolder");
      if (modelFragment.childCount == 0) {
        return;
      }
      evt.stop();
      model.change(() => {
        this.fire("contentInsertion", {
          content: modelFragment,
          method: data.method,
          dataTransfer: data.dataTransfer,
          targetRanges: data.targetRanges
        });
      });
    }, { priority: "low" });
    this.listenTo(this, "contentInsertion", (evt, data) => {
      data.resultRange = model.insertContent(data.content);
    }, { priority: "low" });
  }
  /**
   * The clipboard copy/cut pipeline.
   */
  _setupCopyCut() {
    const editor = this.editor;
    const modelDocument = editor.model.document;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const onCopyCut = (evt, data) => {
      const dataTransfer = data.dataTransfer;
      data.preventDefault();
      const content = editor.data.toView(editor.model.getSelectedContent(modelDocument.selection));
      viewDocument.fire("clipboardOutput", {
        dataTransfer,
        content,
        method: evt.name
      });
    };
    this.listenTo(viewDocument, "copy", onCopyCut, { priority: "low" });
    this.listenTo(viewDocument, "cut", (evt, data) => {
      if (!editor.model.canEditAt(editor.model.document.selection)) {
        data.preventDefault();
      } else {
        onCopyCut(evt, data);
      }
    }, { priority: "low" });
    this.listenTo(viewDocument, "clipboardOutput", (evt, data) => {
      if (!data.content.isEmpty) {
        data.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(data.content));
        data.dataTransfer.setData("text/plain", viewToPlainText(data.content));
      }
      if (data.method == "cut") {
        editor.model.deleteContent(modelDocument.selection);
      }
    }, { priority: "low" });
  }
};

// node_modules/@ckeditor/ckeditor5-clipboard/src/dragdrop.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css";
var DragDrop = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DragDrop";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardPipeline, Widget];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    this._draggedRange = null;
    this._draggingUid = "";
    this._draggableElement = null;
    this._updateDropMarkerThrottled = throttle_default((targetRange) => this._updateDropMarker(targetRange), 40);
    this._removeDropMarkerDelayed = delay(() => this._removeDropMarker(), 40);
    this._clearDraggableAttributesDelayed = delay(() => this._clearDraggableAttributes(), 40);
    if (editor.plugins.has("DragDropExperimental")) {
      this.forceDisabled("DragDropExperimental");
      return;
    }
    view.addObserver(ClipboardObserver);
    view.addObserver(MouseObserver);
    this._setupDragging();
    this._setupContentInsertionIntegration();
    this._setupClipboardInputIntegration();
    this._setupDropMarker();
    this._setupDraggableAttributeHandling();
    this.listenTo(editor, "change:isReadOnly", (evt, name, isReadOnly) => {
      if (isReadOnly) {
        this.forceDisabled("readOnlyMode");
      } else {
        this.clearForceDisabled("readOnlyMode");
      }
    });
    this.on("change:isEnabled", (evt, name, isEnabled) => {
      if (!isEnabled) {
        this._finalizeDragging(false);
      }
    });
    if (env_default.isAndroid) {
      this.forceDisabled("noAndroidSupport");
    }
  }
  /**
   * @inheritDoc
   */
  destroy() {
    if (this._draggedRange) {
      this._draggedRange.detach();
      this._draggedRange = null;
    }
    this._updateDropMarkerThrottled.cancel();
    this._removeDropMarkerDelayed.cancel();
    this._clearDraggableAttributesDelayed.cancel();
    return super.destroy();
  }
  /**
   * Drag and drop events handling.
   */
  _setupDragging() {
    const editor = this.editor;
    const model = editor.model;
    const modelDocument = model.document;
    const view = editor.editing.view;
    const viewDocument = view.document;
    this.listenTo(viewDocument, "dragstart", (evt, data) => {
      const selection = modelDocument.selection;
      if (data.target && data.target.is("editableElement")) {
        data.preventDefault();
        return;
      }
      const draggableWidget = data.target ? findDraggableWidget(data.target) : null;
      if (draggableWidget) {
        const modelElement = editor.editing.mapper.toModelElement(draggableWidget);
        this._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement));
        if (editor.plugins.has("WidgetToolbarRepository")) {
          const widgetToolbarRepository = editor.plugins.get("WidgetToolbarRepository");
          widgetToolbarRepository.forceDisabled("dragDrop");
        }
      } else if (!viewDocument.selection.isCollapsed) {
        const selectedElement = viewDocument.selection.getSelectedElement();
        if (!selectedElement || !isWidget(selectedElement)) {
          this._draggedRange = LiveRange.fromRange(selection.getFirstRange());
        }
      }
      if (!this._draggedRange) {
        data.preventDefault();
        return;
      }
      this._draggingUid = uid();
      const canEditAtDraggedRange = this.isEnabled && editor.model.canEditAt(this._draggedRange);
      data.dataTransfer.effectAllowed = canEditAtDraggedRange ? "copyMove" : "copy";
      data.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
      const draggedSelection = model.createSelection(this._draggedRange.toRange());
      const content = editor.data.toView(model.getSelectedContent(draggedSelection));
      viewDocument.fire("clipboardOutput", {
        dataTransfer: data.dataTransfer,
        content,
        method: "dragstart"
      });
      if (!canEditAtDraggedRange) {
        this._draggedRange.detach();
        this._draggedRange = null;
        this._draggingUid = "";
      }
    }, { priority: "low" });
    this.listenTo(viewDocument, "dragend", (evt, data) => {
      this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == "move");
    }, { priority: "low" });
    this.listenTo(viewDocument, "dragenter", () => {
      if (!this.isEnabled) {
        return;
      }
      view.focus();
    });
    this.listenTo(viewDocument, "dragleave", () => {
      this._removeDropMarkerDelayed();
    });
    this.listenTo(viewDocument, "dragging", (evt, data) => {
      if (!this.isEnabled) {
        data.dataTransfer.dropEffect = "none";
        return;
      }
      this._removeDropMarkerDelayed.cancel();
      const targetRange = findDropTargetRange(editor, data.targetRanges, data.target);
      if (!editor.model.canEditAt(targetRange)) {
        data.dataTransfer.dropEffect = "none";
        return;
      }
      if (!this._draggedRange) {
        data.dataTransfer.dropEffect = "copy";
      }
      if (!env_default.isGecko) {
        if (data.dataTransfer.effectAllowed == "copy") {
          data.dataTransfer.dropEffect = "copy";
        } else if (["all", "copyMove"].includes(data.dataTransfer.effectAllowed)) {
          data.dataTransfer.dropEffect = "move";
        }
      }
      if (targetRange) {
        this._updateDropMarkerThrottled(targetRange);
      }
    }, { priority: "low" });
  }
  /**
   * Integration with the `clipboardInput` event.
   */
  _setupClipboardInputIntegration() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      if (data.method != "drop") {
        return;
      }
      const targetRange = findDropTargetRange(editor, data.targetRanges, data.target);
      this._removeDropMarker();
      if (!targetRange || !editor.model.canEditAt(targetRange)) {
        this._finalizeDragging(false);
        evt.stop();
        return;
      }
      if (this._draggedRange && this._draggingUid != data.dataTransfer.getData("application/ckeditor5-dragging-uid")) {
        this._draggedRange.detach();
        this._draggedRange = null;
        this._draggingUid = "";
      }
      const isMove = getFinalDropEffect(data.dataTransfer) == "move";
      if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {
        this._finalizeDragging(false);
        evt.stop();
        return;
      }
      data.targetRanges = [editor.editing.mapper.toViewRange(targetRange)];
    }, { priority: "high" });
  }
  /**
   * Integration with the `contentInsertion` event of the clipboard pipeline.
   */
  _setupContentInsertionIntegration() {
    const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);
    clipboardPipeline.on("contentInsertion", (evt, data) => {
      if (!this.isEnabled || data.method !== "drop") {
        return;
      }
      const ranges = data.targetRanges.map((viewRange) => this.editor.editing.mapper.toModelRange(viewRange));
      this.editor.model.change((writer) => writer.setSelection(ranges));
    }, { priority: "high" });
    clipboardPipeline.on("contentInsertion", (evt, data) => {
      if (!this.isEnabled || data.method !== "drop") {
        return;
      }
      const isMove = getFinalDropEffect(data.dataTransfer) == "move";
      const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;
      this._finalizeDragging(isSuccess && isMove);
    }, { priority: "lowest" });
  }
  /**
   * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.
   */
  _setupDraggableAttributeHandling() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    this.listenTo(viewDocument, "mousedown", (evt, data) => {
      if (env_default.isAndroid || !data) {
        return;
      }
      this._clearDraggableAttributesDelayed.cancel();
      let draggableElement = findDraggableWidget(data.target);
      if (env_default.isBlink && !draggableElement && !viewDocument.selection.isCollapsed) {
        const selectedElement = viewDocument.selection.getSelectedElement();
        if (!selectedElement || !isWidget(selectedElement)) {
          const editableElement = viewDocument.selection.editableElement;
          if (editableElement && !editableElement.isReadOnly) {
            draggableElement = editableElement;
          }
        }
      }
      if (draggableElement) {
        view.change((writer) => {
          writer.setAttribute("draggable", "true", draggableElement);
        });
        this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);
      }
    });
    this.listenTo(viewDocument, "mouseup", () => {
      if (!env_default.isAndroid) {
        this._clearDraggableAttributesDelayed();
      }
    });
  }
  /**
   * Removes the `draggable` attribute from the element that was used for dragging.
   */
  _clearDraggableAttributes() {
    const editing = this.editor.editing;
    editing.view.change((writer) => {
      if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") {
        writer.removeAttribute("draggable", editing.mapper.toViewElement(this._draggableElement));
      }
      this._draggableElement = null;
    });
  }
  /**
   * Creates downcast conversion for the drop target marker.
   */
  _setupDropMarker() {
    const editor = this.editor;
    editor.conversion.for("editingDowncast").markerToHighlight({
      model: "drop-target",
      view: {
        classes: ["ck-clipboard-drop-target-range"]
      }
    });
    editor.conversion.for("editingDowncast").markerToElement({
      model: "drop-target",
      view: (data, { writer }) => {
        const inText = editor.model.schema.checkChild(data.markerRange.start, "$text");
        if (!inText) {
          return;
        }
        return writer.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(domDocument) {
          const domElement = this.toDomElement(domDocument);
          domElement.append("⁠", domDocument.createElement("span"), "⁠");
          return domElement;
        });
      }
    });
  }
  /**
   * Updates the drop target marker to the provided range.
   *
   * @param targetRange The range to set the marker to.
   */
  _updateDropMarker(targetRange) {
    const editor = this.editor;
    const markers = editor.model.markers;
    editor.model.change((writer) => {
      if (markers.has("drop-target")) {
        if (!markers.get("drop-target").getRange().isEqual(targetRange)) {
          writer.updateMarker("drop-target", { range: targetRange });
        }
      } else {
        writer.addMarker("drop-target", {
          range: targetRange,
          usingOperation: false,
          affectsData: false
        });
      }
    });
  }
  /**
   * Removes the drop target marker.
   */
  _removeDropMarker() {
    const model = this.editor.model;
    this._removeDropMarkerDelayed.cancel();
    this._updateDropMarkerThrottled.cancel();
    if (model.markers.has("drop-target")) {
      model.change((writer) => {
        writer.removeMarker("drop-target");
      });
    }
  }
  /**
   * Deletes the dragged content from its original range and clears the dragging state.
   *
   * @param moved Whether the move succeeded.
   */
  _finalizeDragging(moved) {
    const editor = this.editor;
    const model = editor.model;
    this._removeDropMarker();
    this._clearDraggableAttributes();
    if (editor.plugins.has("WidgetToolbarRepository")) {
      const widgetToolbarRepository = editor.plugins.get("WidgetToolbarRepository");
      widgetToolbarRepository.clearForceDisabled("dragDrop");
    }
    this._draggingUid = "";
    if (!this._draggedRange) {
      return;
    }
    if (moved && this.isEnabled) {
      model.deleteContent(model.createSelection(this._draggedRange), { doNotAutoparagraph: true });
    }
    this._draggedRange.detach();
    this._draggedRange = null;
  }
};
function findDropTargetRange(editor, targetViewRanges, targetViewElement) {
  const model = editor.model;
  const mapper = editor.editing.mapper;
  let range = null;
  const targetViewPosition = targetViewRanges ? targetViewRanges[0].start : null;
  if (targetViewElement.is("uiElement")) {
    targetViewElement = targetViewElement.parent;
  }
  range = findDropTargetRangeOnWidget(editor, targetViewElement);
  if (range) {
    return range;
  }
  const targetModelElement = getClosestMappedModelElement(editor, targetViewElement);
  const targetModelPosition = targetViewPosition ? mapper.toModelPosition(targetViewPosition) : null;
  if (!targetModelPosition) {
    return findDropTargetRangeInElement(editor, targetModelElement);
  }
  range = findDropTargetRangeBetweenBlocks(editor, targetModelPosition, targetModelElement);
  if (range) {
    return range;
  }
  range = model.schema.getNearestSelectionRange(targetModelPosition, env_default.isGecko ? "forward" : "backward");
  if (range) {
    return range;
  }
  return findDropTargetRangeOnAncestorObject(editor, targetModelPosition.parent);
}
function findDropTargetRangeOnWidget(editor, targetViewElement) {
  const model = editor.model;
  const mapper = editor.editing.mapper;
  if (isWidget(targetViewElement)) {
    return model.createRangeOn(mapper.toModelElement(targetViewElement));
  }
  if (!targetViewElement.is("editableElement")) {
    const ancestor = targetViewElement.findAncestor((node) => isWidget(node) || node.is("editableElement"));
    if (isWidget(ancestor)) {
      return model.createRangeOn(mapper.toModelElement(ancestor));
    }
  }
  return null;
}
function findDropTargetRangeInElement(editor, targetModelElement) {
  const model = editor.model;
  const schema = model.schema;
  const positionAtElementStart = model.createPositionAt(targetModelElement, 0);
  return schema.getNearestSelectionRange(positionAtElementStart, "forward");
}
function findDropTargetRangeBetweenBlocks(editor, targetModelPosition, targetModelElement) {
  const model = editor.model;
  if (!model.schema.checkChild(targetModelElement, "$block")) {
    return null;
  }
  const positionAtElementStart = model.createPositionAt(targetModelElement, 0);
  const commonPath = targetModelPosition.path.slice(0, positionAtElementStart.path.length);
  const betweenBlocksPosition = model.createPositionFromPath(targetModelPosition.root, commonPath);
  const nodeAfter = betweenBlocksPosition.nodeAfter;
  if (nodeAfter && model.schema.isObject(nodeAfter)) {
    return model.createRangeOn(nodeAfter);
  }
  return null;
}
function findDropTargetRangeOnAncestorObject(editor, element) {
  const model = editor.model;
  let currentElement = element;
  while (currentElement) {
    if (model.schema.isObject(currentElement)) {
      return model.createRangeOn(currentElement);
    }
    currentElement = currentElement.parent;
  }
  return null;
}
function getClosestMappedModelElement(editor, element) {
  const mapper = editor.editing.mapper;
  const view = editor.editing.view;
  const targetModelElement = mapper.toModelElement(element);
  if (targetModelElement) {
    return targetModelElement;
  }
  const viewPosition = view.createPositionBefore(element);
  const viewElement = mapper.findMappedViewAncestor(viewPosition);
  return mapper.toModelElement(viewElement);
}
function getFinalDropEffect(dataTransfer) {
  if (env_default.isGecko) {
    return dataTransfer.dropEffect;
  }
  return ["all", "copyMove"].includes(dataTransfer.effectAllowed) ? "move" : "copy";
}
function findDraggableWidget(target) {
  if (target.is("editableElement")) {
    return null;
  }
  if (target.hasClass("ck-widget__selection-handle")) {
    return target.findAncestor(isWidget);
  }
  if (isWidget(target)) {
    return target;
  }
  const ancestor = target.findAncestor((node) => isWidget(node) || node.is("editableElement"));
  if (isWidget(ancestor)) {
    return ancestor;
  }
  return null;
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/pasteplaintext.js
var PastePlainText = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PastePlainText";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardPipeline];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const selection = model.document.selection;
    let shiftPressed = false;
    view.addObserver(ClipboardObserver);
    this.listenTo(viewDocument, "keydown", (evt, data) => {
      shiftPressed = data.shiftKey;
    });
    editor.plugins.get(ClipboardPipeline).on("contentInsertion", (evt, data) => {
      if (!shiftPressed && !isPlainTextFragment(data.content, model.schema)) {
        return;
      }
      model.change((writer) => {
        const textAttributes = Array.from(selection.getAttributes()).filter(([key]) => model.schema.getAttributeProperties(key).isFormatting);
        if (!selection.isCollapsed) {
          model.deleteContent(selection, { doNotAutoparagraph: true });
        }
        textAttributes.push(...selection.getAttributes());
        const range = writer.createRangeIn(data.content);
        for (const item of range.getItems()) {
          if (item.is("$textProxy")) {
            writer.setAttributes(textAttributes, item);
          }
        }
      });
    });
  }
};
function isPlainTextFragment(documentFragment, schema) {
  if (documentFragment.childCount > 1) {
    return false;
  }
  const child = documentFragment.getChild(0);
  if (schema.isObject(child)) {
    return false;
  }
  return Array.from(child.getAttributeKeys()).length == 0;
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/clipboard.js
var Clipboard = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Clipboard";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardPipeline, DragDrop, PastePlainText];
  }
};

// node_modules/@ckeditor/ckeditor5-clipboard/src/lineview.js
var toPx = toUnit("px");

// node_modules/@ckeditor/ckeditor5-clipboard/src/dragdropexperimental.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css";

export {
  ClipboardPipeline,
  Clipboard
};
/*! Bundled license information:

@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/clipboardpipeline.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/dragdrop.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)
  (* istanbul ignore if -- @preserve *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-clipboard/src/pasteplaintext.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/clipboard.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/lineview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore file -- @preserve *)

@ckeditor/ckeditor5-clipboard/src/dragdroptarget.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore file -- @preserve *)

@ckeditor/ckeditor5-clipboard/src/dragdropexperimental.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore file -- @preserve *)

@ckeditor/ckeditor5-clipboard/src/dragdropblocktoolbar.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore file -- @preserve *)

@ckeditor/ckeditor5-clipboard/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/clipboard.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-74PGQAYV.js.map
