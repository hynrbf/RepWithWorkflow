import {
  ClipboardPipeline
} from "./chunk-74PGQAYV.js";
import "./chunk-NMGSIING.js";
import "./chunk-DEIZSOIF.js";
import "./chunk-GGCPNJOL.js";
import "./chunk-SGTDNT4V.js";
import "./chunk-4MFML76R.js";
import "./chunk-6LVMAMLV.js";
import {
  Document,
  DomConverter,
  Matcher,
  Plugin,
  UpcastWriter
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/list.js
function transformListItemLikeElementsIntoLists(documentFragment, stylesString) {
  if (!documentFragment.childCount) {
    return;
  }
  const writer = new UpcastWriter(documentFragment.document);
  const itemLikeElements = findAllItemLikeElements(documentFragment, writer);
  if (!itemLikeElements.length) {
    return;
  }
  let currentList = null;
  let currentIndentation = 1;
  itemLikeElements.forEach((itemLikeElement, i) => {
    const isDifferentList = isNewListNeeded(itemLikeElements[i - 1], itemLikeElement);
    const previousItemLikeElement = isDifferentList ? null : itemLikeElements[i - 1];
    const indentationDifference = getIndentationDifference(previousItemLikeElement, itemLikeElement);
    if (isDifferentList) {
      currentList = null;
      currentIndentation = 1;
    }
    if (!currentList || indentationDifference !== 0) {
      const listStyle = detectListStyle(itemLikeElement, stylesString);
      if (!currentList) {
        currentList = insertNewEmptyList(listStyle, itemLikeElement.element, writer);
      } else if (itemLikeElement.indent > currentIndentation) {
        const lastListItem = currentList.getChild(currentList.childCount - 1);
        const lastListItemChild = lastListItem.getChild(lastListItem.childCount - 1);
        currentList = insertNewEmptyList(listStyle, lastListItemChild, writer);
        currentIndentation += 1;
      } else if (itemLikeElement.indent < currentIndentation) {
        const differentIndentation = currentIndentation - itemLikeElement.indent;
        currentList = findParentListAtLevel(currentList, differentIndentation);
        currentIndentation = itemLikeElement.indent;
      }
      if (itemLikeElement.indent <= currentIndentation) {
        if (!currentList.is("element", listStyle.type)) {
          currentList = writer.rename(listStyle.type, currentList);
        }
      }
    }
    const listItem = transformElementIntoListItem(itemLikeElement.element, writer);
    writer.appendChild(listItem, currentList);
  });
}
function unwrapParagraphInListItem(documentFragment, writer) {
  for (const value of writer.createRangeIn(documentFragment)) {
    const element = value.item;
    if (element.is("element", "li")) {
      const firstChild = element.getChild(0);
      if (firstChild && firstChild.is("element", "p")) {
        writer.unwrapElement(firstChild);
      }
    }
  }
}
function findAllItemLikeElements(documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const itemLikeElementsMatcher = new Matcher({
    name: /^p|h\d+$/,
    styles: {
      "mso-list": /.*/
    }
  });
  const itemLikeElements = [];
  for (const value of range) {
    if (value.type === "elementStart" && itemLikeElementsMatcher.match(value.item)) {
      const itemData = getListItemData(value.item);
      itemLikeElements.push({
        element: value.item,
        id: itemData.id,
        order: itemData.order,
        indent: itemData.indent
      });
    }
  }
  return itemLikeElements;
}
function detectListStyle(listLikeItem, stylesString) {
  const listStyleRegexp = new RegExp(`@list l${listLikeItem.id}:level${listLikeItem.indent}\\s*({[^}]*)`, "gi");
  const listStyleTypeRegex = /mso-level-number-format:([^;]{0,100});/gi;
  const listStartIndexRegex = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi;
  const listStyleMatch = listStyleRegexp.exec(stylesString);
  let listStyleType = "decimal";
  let type = "ol";
  let startIndex = null;
  if (listStyleMatch && listStyleMatch[1]) {
    const listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);
    if (listStyleTypeMatch && listStyleTypeMatch[1]) {
      listStyleType = listStyleTypeMatch[1].trim();
      type = listStyleType !== "bullet" && listStyleType !== "image" ? "ol" : "ul";
    }
    if (listStyleType === "bullet") {
      const bulletedStyle = findBulletedListStyle(listLikeItem.element);
      if (bulletedStyle) {
        listStyleType = bulletedStyle;
      }
    } else {
      const listStartIndexMatch = listStartIndexRegex.exec(listStyleMatch[1]);
      if (listStartIndexMatch && listStartIndexMatch[1]) {
        startIndex = parseInt(listStartIndexMatch[1]);
      }
    }
  }
  return {
    type,
    startIndex,
    style: mapListStyleDefinition(listStyleType)
  };
}
function findBulletedListStyle(element) {
  const listMarkerElement = findListMarkerNode(element);
  if (!listMarkerElement) {
    return null;
  }
  const listMarker = listMarkerElement._data;
  if (listMarker === "o") {
    return "circle";
  } else if (listMarker === "·") {
    return "disc";
  } else if (listMarker === "§") {
    return "square";
  }
  return null;
}
function findListMarkerNode(element) {
  if (element.getChild(0).is("$text")) {
    return null;
  }
  for (const childNode of element.getChildren()) {
    if (!childNode.is("element", "span")) {
      continue;
    }
    const textNodeOrElement = childNode.getChild(0);
    if (!textNodeOrElement) {
      continue;
    }
    if (textNodeOrElement.is("$text")) {
      return textNodeOrElement;
    }
    return textNodeOrElement.getChild(0);
  }
  return null;
}
function mapListStyleDefinition(value) {
  if (value.startsWith("arabic-leading-zero")) {
    return "decimal-leading-zero";
  }
  switch (value) {
    case "alpha-upper":
      return "upper-alpha";
    case "alpha-lower":
      return "lower-alpha";
    case "roman-upper":
      return "upper-roman";
    case "roman-lower":
      return "lower-roman";
    case "circle":
    case "disc":
    case "square":
      return value;
    default:
      return null;
  }
}
function insertNewEmptyList(listStyle, element, writer) {
  const parent = element.parent;
  const list = writer.createElement(listStyle.type);
  const position = parent.getChildIndex(element) + 1;
  writer.insertChild(position, list, parent);
  if (listStyle.style) {
    writer.setStyle("list-style-type", listStyle.style, list);
  }
  if (listStyle.startIndex && listStyle.startIndex > 1) {
    writer.setAttribute("start", listStyle.startIndex, list);
  }
  return list;
}
function transformElementIntoListItem(element, writer) {
  removeBulletElement(element, writer);
  writer.removeStyle("text-indent", element);
  return writer.rename("li", element);
}
function getListItemData(element) {
  const data = {};
  const listStyle = element.getStyle("mso-list");
  if (listStyle) {
    const idMatch = listStyle.match(/(^|\s{1,100})l(\d+)/i);
    const orderMatch = listStyle.match(/\s{0,100}lfo(\d+)/i);
    const indentMatch = listStyle.match(/\s{0,100}level(\d+)/i);
    if (idMatch && orderMatch && indentMatch) {
      data.id = idMatch[2];
      data.order = orderMatch[1];
      data.indent = parseInt(indentMatch[1]);
    }
  }
  return data;
}
function removeBulletElement(element, writer) {
  const bulletMatcher = new Matcher({
    name: "span",
    styles: {
      "mso-list": "Ignore"
    }
  });
  const range = writer.createRangeIn(element);
  for (const value of range) {
    if (value.type === "elementStart" && bulletMatcher.match(value.item)) {
      writer.remove(value.item);
    }
  }
}
function isNewListNeeded(previousItem, currentItem) {
  if (!previousItem) {
    return true;
  }
  if (previousItem.id !== currentItem.id) {
    if (currentItem.indent - previousItem.indent === 1) {
      return false;
    }
    return true;
  }
  const previousSibling = currentItem.element.previousSibling;
  if (!previousSibling) {
    return true;
  }
  return !isList(previousSibling);
}
function isList(element) {
  return element.is("element", "ol") || element.is("element", "ul");
}
function getIndentationDifference(previousItem, currentItem) {
  return previousItem ? currentItem.indent - previousItem.indent : currentItem.indent - 1;
}
function findParentListAtLevel(listElement, indentationDifference) {
  const ancestors = listElement.getAncestors({ parentFirst: true });
  let parentList = null;
  let levelChange = 0;
  for (const ancestor of ancestors) {
    if (ancestor.is("element", "ul") || ancestor.is("element", "ol")) {
      levelChange++;
    }
    if (levelChange === indentationDifference) {
      parentList = ancestor;
      break;
    }
  }
  return parentList;
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/image.js
function replaceImagesSourceWithBase64(documentFragment, rtfData) {
  if (!documentFragment.childCount) {
    return;
  }
  const upcastWriter = new UpcastWriter(documentFragment.document);
  const shapesIds = findAllShapesIds(documentFragment, upcastWriter);
  removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);
  insertMissingImgs(shapesIds, documentFragment, upcastWriter);
  removeAllShapeElements(documentFragment, upcastWriter);
  const images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);
  if (images.length) {
    replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);
  }
}
function _convertHexToBase64(hexString) {
  return btoa(hexString.match(/\w{2}/g).map((char) => {
    return String.fromCharCode(parseInt(char, 16));
  }).join(""));
}
function findAllShapesIds(documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const shapeElementsMatcher = new Matcher({
    name: /v:(.+)/
  });
  const shapesIds = [];
  for (const value of range) {
    if (value.type != "elementStart") {
      continue;
    }
    const el = value.item;
    const previousSibling = el.previousSibling;
    const prevSiblingName = previousSibling && previousSibling.is("element") ? previousSibling.name : null;
    if (shapeElementsMatcher.match(el) && el.getAttribute("o:gfxdata") && prevSiblingName !== "v:shapetype") {
      shapesIds.push(value.item.getAttribute("id"));
    }
  }
  return shapesIds;
}
function removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const imageElementsMatcher = new Matcher({
    name: "img"
  });
  const imgs = [];
  for (const value of range) {
    if (value.item.is("element") && imageElementsMatcher.match(value.item)) {
      const el = value.item;
      const shapes = el.getAttribute("v:shapes") ? el.getAttribute("v:shapes").split(" ") : [];
      if (shapes.length && shapes.every((shape) => shapesIds.indexOf(shape) > -1)) {
        imgs.push(el);
      } else if (!el.getAttribute("src")) {
        imgs.push(el);
      }
    }
  }
  for (const img of imgs) {
    writer.remove(img);
  }
}
function removeAllShapeElements(documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const shapeElementsMatcher = new Matcher({
    name: /v:(.+)/
  });
  const shapes = [];
  for (const value of range) {
    if (value.type == "elementStart" && shapeElementsMatcher.match(value.item)) {
      shapes.push(value.item);
    }
  }
  for (const shape of shapes) {
    writer.remove(shape);
  }
}
function insertMissingImgs(shapeIds, documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const shapes = [];
  for (const value of range) {
    if (value.type == "elementStart" && value.item.is("element", "v:shape")) {
      const id = value.item.getAttribute("id");
      if (shapeIds.includes(id)) {
        continue;
      }
      if (!containsMatchingImg(value.item.parent.getChildren(), id)) {
        shapes.push(value.item);
      }
    }
  }
  for (const shape of shapes) {
    const attrs = {
      src: findSrc(shape)
    };
    if (shape.hasAttribute("alt")) {
      attrs.alt = shape.getAttribute("alt");
    }
    const img = writer.createElement("img", attrs);
    writer.insertChild(shape.index + 1, img, shape.parent);
  }
  function containsMatchingImg(nodes, id) {
    for (const node of nodes) {
      if (node.is("element")) {
        if (node.name == "img" && node.getAttribute("v:shapes") == id) {
          return true;
        }
        if (containsMatchingImg(node.getChildren(), id)) {
          return true;
        }
      }
    }
    return false;
  }
  function findSrc(shape) {
    for (const child of shape.getChildren()) {
      if (child.is("element") && child.getAttribute("src")) {
        return child.getAttribute("src");
      }
    }
  }
}
function findAllImageElementsWithLocalSource(documentFragment, writer) {
  const range = writer.createRangeIn(documentFragment);
  const imageElementsMatcher = new Matcher({
    name: "img"
  });
  const imgs = [];
  for (const value of range) {
    if (value.item.is("element") && imageElementsMatcher.match(value.item)) {
      if (value.item.getAttribute("src").startsWith("file://")) {
        imgs.push(value.item);
      }
    }
  }
  return imgs;
}
function extractImageDataFromRtf(rtfData) {
  if (!rtfData) {
    return [];
  }
  const regexPictureHeader = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/;
  const regexPicture = new RegExp("(?:(" + regexPictureHeader.source + "))([\\da-fA-F\\s]+)\\}", "g");
  const images = rtfData.match(regexPicture);
  const result = [];
  if (images) {
    for (const image of images) {
      let imageType = false;
      if (image.includes("\\pngblip")) {
        imageType = "image/png";
      } else if (image.includes("\\jpegblip")) {
        imageType = "image/jpeg";
      }
      if (imageType) {
        result.push({
          hex: image.replace(regexPictureHeader, "").replace(/[^\da-fA-F]/g, ""),
          type: imageType
        });
      }
    }
  }
  return result;
}
function replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {
  if (imageElements.length === imagesHexSources.length) {
    for (let i = 0; i < imageElements.length; i++) {
      const newSrc = `data:${imagesHexSources[i].type};base64,${_convertHexToBase64(imagesHexSources[i].hex)}`;
      writer.setAttribute("src", newSrc, imageElements[i]);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/normalizers/mswordnormalizer.js
var msWordMatch1 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i;
var msWordMatch2 = /xmlns:o="urn:schemas-microsoft-com/i;
var MSWordNormalizer = class {
  /**
   * Creates a new `MSWordNormalizer` instance.
   *
   * @param document View document.
   */
  constructor(document) {
    this.document = document;
  }
  /**
   * @inheritDoc
   */
  isActive(htmlString) {
    return msWordMatch1.test(htmlString) || msWordMatch2.test(htmlString);
  }
  /**
   * @inheritDoc
   */
  execute(data) {
    const { body: documentFragment, stylesString } = data._parsedData;
    transformListItemLikeElementsIntoLists(documentFragment, stylesString);
    replaceImagesSourceWithBase64(documentFragment, data.dataTransfer.getData("text/rtf"));
    data.content = documentFragment;
  }
};

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removeboldwrapper.js
function removeBoldWrapper(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "b") && child.getStyle("font-weight") === "normal") {
      const childIndex = documentFragment.getChildIndex(child);
      writer.remove(child);
      writer.insertChild(childIndex, child.getChildren(), documentFragment);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/br.js
function transformBlockBrsToParagraphs(documentFragment, writer) {
  const viewDocument = new Document(writer.document.stylesProcessor);
  const domConverter = new DomConverter(viewDocument, { renderingMode: "data" });
  const blockElements = domConverter.blockElements;
  const inlineObjectElements = domConverter.inlineObjectElements;
  const elementsToReplace = [];
  for (const value of writer.createRangeIn(documentFragment)) {
    const element = value.item;
    if (element.is("element", "br")) {
      const nextSibling = findSibling(element, "forward", writer, { blockElements, inlineObjectElements });
      const previousSibling = findSibling(element, "backward", writer, { blockElements, inlineObjectElements });
      const nextSiblingIsBlock = isBlockViewElement(nextSibling, blockElements);
      const previousSiblingIsBlock = isBlockViewElement(previousSibling, blockElements);
      if (previousSiblingIsBlock || nextSiblingIsBlock) {
        elementsToReplace.push(element);
      }
    }
  }
  for (const element of elementsToReplace) {
    if (element.hasClass("Apple-interchange-newline")) {
      writer.remove(element);
    } else {
      writer.replace(element, writer.createElement("p"));
    }
  }
}
function findSibling(viewElement, direction, writer, { blockElements, inlineObjectElements }) {
  let position = writer.createPositionAt(viewElement, direction == "forward" ? "after" : "before");
  position = position.getLastMatchingPosition(({ item }) => item.is("element") && !blockElements.includes(item.name) && !inlineObjectElements.includes(item.name), { direction });
  return direction == "forward" ? position.nodeAfter : position.nodeBefore;
}
function isBlockViewElement(node, blockElements) {
  return !!node && node.is("element") && blockElements.includes(node.name);
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/normalizers/googledocsnormalizer.js
var googleDocsMatch = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
var GoogleDocsNormalizer = class {
  /**
   * Creates a new `GoogleDocsNormalizer` instance.
   *
   * @param document View document.
   */
  constructor(document) {
    this.document = document;
  }
  /**
   * @inheritDoc
   */
  isActive(htmlString) {
    return googleDocsMatch.test(htmlString);
  }
  /**
   * @inheritDoc
   */
  execute(data) {
    const writer = new UpcastWriter(this.document);
    const { body: documentFragment } = data._parsedData;
    removeBoldWrapper(documentFragment, writer);
    unwrapParagraphInListItem(documentFragment, writer);
    transformBlockBrsToParagraphs(documentFragment, writer);
    data.content = documentFragment;
  }
};

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removexmlns.js
function removeXmlns(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "table") && child.hasAttribute("xmlns")) {
      writer.removeAttribute("xmlns", child);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removegooglesheetstag.js
function removeGoogleSheetsTag(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "google-sheets-html-origin")) {
      const childIndex = documentFragment.getChildIndex(child);
      writer.remove(child);
      writer.insertChild(childIndex, child.getChildren(), documentFragment);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removeinvalidtablewidth.js
function removeInvalidTableWidth(documentFragment, writer) {
  for (const child of documentFragment.getChildren()) {
    if (child.is("element", "table") && child.getStyle("width") === "0px") {
      writer.removeStyle("width", child);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removestyleblock.js
function removeStyleBlock(documentFragment, writer) {
  for (const child of Array.from(documentFragment.getChildren())) {
    if (child.is("element", "style")) {
      writer.remove(child);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/normalizers/googlesheetsnormalizer.js
var googleSheetsMatch = /<google-sheets-html-origin/i;
var GoogleSheetsNormalizer = class {
  /**
   * Creates a new `GoogleSheetsNormalizer` instance.
   *
   * @param document View document.
   */
  constructor(document) {
    this.document = document;
  }
  /**
   * @inheritDoc
   */
  isActive(htmlString) {
    return googleSheetsMatch.test(htmlString);
  }
  /**
   * @inheritDoc
   */
  execute(data) {
    const writer = new UpcastWriter(this.document);
    const { body: documentFragment } = data._parsedData;
    removeGoogleSheetsTag(documentFragment, writer);
    removeXmlns(documentFragment, writer);
    removeInvalidTableWidth(documentFragment, writer);
    removeStyleBlock(documentFragment, writer);
    data.content = documentFragment;
  }
};

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/space.js
function normalizeSpacing(htmlString) {
  return normalizeSafariSpaceSpans(normalizeSafariSpaceSpans(htmlString)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
}
function normalizeSpacerunSpans(htmlDocument) {
  htmlDocument.querySelectorAll("span[style*=spacerun]").forEach((el) => {
    const htmlElement = el;
    const innerTextLength = htmlElement.innerText.length || 0;
    htmlElement.innerText = Array(innerTextLength + 1).join("  ").substr(0, innerTextLength);
  });
}
function normalizeSafariSpaceSpans(htmlString) {
  return htmlString.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
    return spaces.length === 1 ? " " : Array(spaces.length + 1).join("  ").substr(0, spaces.length);
  });
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/parse.js
function parseHtml(htmlString, stylesProcessor) {
  const domParser = new DOMParser();
  htmlString = htmlString.replace(/<!--\[if gte vml 1]>/g, "");
  const normalizedHtml = normalizeSpacing(cleanContentAfterBody(htmlString));
  const htmlDocument = domParser.parseFromString(normalizedHtml, "text/html");
  normalizeSpacerunSpans(htmlDocument);
  const bodyString = htmlDocument.body.innerHTML;
  const bodyView = documentToView(htmlDocument, stylesProcessor);
  const stylesObject = extractStyles(htmlDocument);
  return {
    body: bodyView,
    bodyString,
    styles: stylesObject.styles,
    stylesString: stylesObject.stylesString
  };
}
function documentToView(htmlDocument, stylesProcessor) {
  const viewDocument = new Document(stylesProcessor);
  const domConverter = new DomConverter(viewDocument, { renderingMode: "data" });
  const fragment = htmlDocument.createDocumentFragment();
  const nodes = htmlDocument.body.childNodes;
  while (nodes.length > 0) {
    fragment.appendChild(nodes[0]);
  }
  return domConverter.domToView(fragment, { skipComments: true });
}
function extractStyles(htmlDocument) {
  const styles = [];
  const stylesString = [];
  const styleTags = Array.from(htmlDocument.getElementsByTagName("style"));
  for (const style of styleTags) {
    if (style.sheet && style.sheet.cssRules && style.sheet.cssRules.length) {
      styles.push(style.sheet);
      stylesString.push(style.innerHTML);
    }
  }
  return {
    styles,
    stylesString: stylesString.join(" ")
  };
}
function cleanContentAfterBody(htmlString) {
  const bodyCloseTag = "</body>";
  const htmlCloseTag = "</html>";
  const bodyCloseIndex = htmlString.indexOf(bodyCloseTag);
  if (bodyCloseIndex < 0) {
    return htmlString;
  }
  const htmlCloseIndex = htmlString.indexOf(htmlCloseTag, bodyCloseIndex + bodyCloseTag.length);
  return htmlString.substring(0, bodyCloseIndex + bodyCloseTag.length) + (htmlCloseIndex >= 0 ? htmlString.substring(htmlCloseIndex) : "");
}

// node_modules/@ckeditor/ckeditor5-paste-from-office/src/pastefromoffice.js
var PasteFromOffice = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PasteFromOffice";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardPipeline];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    const viewDocument = editor.editing.view.document;
    const normalizers = [];
    normalizers.push(new MSWordNormalizer(viewDocument));
    normalizers.push(new GoogleDocsNormalizer(viewDocument));
    normalizers.push(new GoogleSheetsNormalizer(viewDocument));
    clipboardPipeline.on("inputTransformation", (evt, data) => {
      if (data._isTransformedWithPasteFromOffice) {
        return;
      }
      const codeBlock = editor.model.document.selection.getFirstPosition().parent;
      if (codeBlock.is("element", "codeBlock")) {
        return;
      }
      const htmlString = data.dataTransfer.getData("text/html");
      const activeNormalizer = normalizers.find((normalizer) => normalizer.isActive(htmlString));
      if (activeNormalizer) {
        if (!data._parsedData) {
          data._parsedData = parseHtml(htmlString, viewDocument.stylesProcessor);
        }
        activeNormalizer.execute(data);
        data._isTransformedWithPasteFromOffice = true;
      }
    }, { priority: "high" });
  }
};
export {
  MSWordNormalizer,
  PasteFromOffice,
  parseHtml
};
/*! Bundled license information:

@ckeditor/ckeditor5-paste-from-office/src/filters/list.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-paste-from-office/src/filters/image.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-paste-from-office/src/normalizers/mswordnormalizer.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removeboldwrapper.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/br.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/normalizers/googledocsnormalizer.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removexmlns.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removegooglesheetstag.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removeinvalidtablewidth.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/removestyleblock.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/normalizers/googlesheetsnormalizer.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/space.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/filters/parse.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/pastefromoffice.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-paste-from-office/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-paste-from-office.js.map
