{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-typing/src/utils/changebuffer.js", "../../@ckeditor/ckeditor5-typing/src/inserttextcommand.js", "../../@ckeditor/ckeditor5-typing/src/inserttextobserver.js", "../../@ckeditor/ckeditor5-typing/src/input.js", "../../@ckeditor/ckeditor5-typing/src/deletecommand.js", "../../@ckeditor/ckeditor5-typing/src/deleteobserver.js", "../../@ckeditor/ckeditor5-typing/src/delete.js", "../../@ckeditor/ckeditor5-typing/src/typing.js", "../../@ckeditor/ckeditor5-typing/src/utils/getlasttextline.js", "../../@ckeditor/ckeditor5-typing/src/textwatcher.js", "../../@ckeditor/ckeditor5-typing/src/twostepcaretmovement.js", "../../@ckeditor/ckeditor5-typing/src/utils/findattributerange.js", "../../@ckeditor/ckeditor5-typing/src/utils/inlinehighlight.js", "../../@ckeditor/ckeditor5-typing/src/texttransformation.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Change buffer allows to group atomic changes (like characters that have been typed) into\n * {@link module:engine/model/batch~Batch batches}.\n *\n * Batches represent single undo steps, hence changes added to one single batch are undone together.\n *\n * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was\n * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.\n *\n * To use the change buffer you need to let it know about the number of changes that were added to the batch:\n *\n * ```ts\n * const buffer = new ChangeBuffer( model, LIMIT );\n *\n * // Later on in your feature:\n * buffer.batch.insert( pos, insertedCharacters );\n * buffer.input( insertedCharacters.length );\n * ```\n */\nexport default class ChangeBuffer {\n    /**\n     * Creates a new instance of the change buffer.\n     *\n     * @param limit The maximum number of atomic changes which can be contained in one batch.\n     */\n    constructor(model, limit = 20) {\n        /**\n         * The current batch instance.\n         */\n        this._batch = null;\n        this.model = model;\n        this._size = 0;\n        this.limit = limit;\n        this._isLocked = false;\n        // The function to be called in order to notify the buffer about batches which appeared in the document.\n        // The callback will check whether it is a new batch and in that case the buffer will be flushed.\n        //\n        // The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards\n        // should be added to a new batch. For instance, when the user types, then inserts an image, and then types again,\n        // the characters typed after inserting the image should be added to a different batch than the characters typed before.\n        this._changeCallback = (evt, batch) => {\n            if (batch.isLocal && batch.isUndoable && batch !== this._batch) {\n                this._reset(true);\n            }\n        };\n        this._selectionChangeCallback = () => {\n            this._reset();\n        };\n        this.model.document.on('change', this._changeCallback);\n        this.model.document.selection.on('change:range', this._selectionChangeCallback);\n        this.model.document.selection.on('change:attribute', this._selectionChangeCallback);\n    }\n    /**\n     * The current batch to which a feature should add its operations. Once the {@link #size}\n     * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n     */\n    get batch() {\n        if (!this._batch) {\n            this._batch = this.model.createBatch({ isTyping: true });\n        }\n        return this._batch;\n    }\n    /**\n     * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},\n     * the {@link #batch batch} is set to a new one.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * The input number of changes into the buffer. Once the {@link #size} is\n     * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n     *\n     * @param changeCount The number of atomic changes to input.\n     */\n    input(changeCount) {\n        this._size += changeCount;\n        if (this._size >= this.limit) {\n            this._reset(true);\n        }\n    }\n    /**\n     * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.\n     */\n    get isLocked() {\n        return this._isLocked;\n    }\n    /**\n     * Locks the buffer.\n     */\n    lock() {\n        this._isLocked = true;\n    }\n    /**\n     * Unlocks the buffer.\n     */\n    unlock() {\n        this._isLocked = false;\n    }\n    /**\n     * Destroys the buffer.\n     */\n    destroy() {\n        this.model.document.off('change', this._changeCallback);\n        this.model.document.selection.off('change:range', this._selectionChangeCallback);\n        this.model.document.selection.off('change:attribute', this._selectionChangeCallback);\n    }\n    /**\n     * Resets the change buffer.\n     *\n     * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.\n     */\n    _reset(ignoreLock = false) {\n        if (!this.isLocked || ignoreLock) {\n            this._batch = null;\n            this._size = 0;\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/inserttextcommand\n */\nimport { Command } from '@ckeditor/ckeditor5-core';\nimport ChangeBuffer from './utils/changebuffer';\n/**\n * The insert text command. Used by the {@link module:typing/input~Input input feature} to handle typing.\n */\nexport default class InsertTextCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param undoStepSize The maximum number of atomic changes\n     * which can be contained in one batch in the command buffer.\n     */\n    constructor(editor, undoStepSize) {\n        super(editor);\n        this._buffer = new ChangeBuffer(editor.model, undoStepSize);\n        // Since this command may execute on different selectable than selection, it should be checked directly in execute block.\n        this._isEnabledBasedOnSelection = false;\n    }\n    /**\n     * The current change buffer.\n     */\n    get buffer() {\n        return this._buffer;\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        this._buffer.destroy();\n    }\n    /**\n     * Executes the input command. It replaces the content within the given range with the given text.\n     * Replacing is a two step process, first the content within the range is removed and then the new text is inserted\n     * at the beginning of the range (which after the removal is a collapsed range).\n     *\n     * @fires execute\n     * @param options The command options.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const doc = model.document;\n        const text = options.text || '';\n        const textInsertions = text.length;\n        let selection = doc.selection;\n        if (options.selection) {\n            selection = options.selection;\n        }\n        else if (options.range) {\n            selection = model.createSelection(options.range);\n        }\n        // Stop executing if selectable is in non-editable place.\n        if (!model.canEditAt(selection)) {\n            return;\n        }\n        const resultRange = options.resultRange;\n        model.enqueueChange(this._buffer.batch, writer => {\n            this._buffer.lock();\n            model.deleteContent(selection);\n            if (text) {\n                model.insertContent(writer.createText(text, doc.selection.getAttributes()), selection);\n            }\n            if (resultRange) {\n                writer.setSelection(resultRange);\n            }\n            else if (!selection.is('documentSelection')) {\n                writer.setSelection(selection);\n            }\n            this._buffer.unlock();\n            this._buffer.input(textInsertions);\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/inserttextobserver\n */\nimport { env, EventInfo } from '@ckeditor/ckeditor5-utils';\nimport { DomEventData, Observer, FocusObserver } from '@ckeditor/ckeditor5-engine';\nconst TYPING_INPUT_TYPES = [\n    // For collapsed range:\n    //\t- This one is a regular typing (all browsers, all systems).\n    //\t- This one is used by Chrome when typing accented letter – 2nd step when the user selects the accent (Mac).\n    // For non-collapsed range:\n    //\t- This one is used by Chrome when typing accented letter – when the selection box first appears (Mac).\n    //\t- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).\n    'insertText',\n    // This one is used by Safari when typing accented letter (Mac).\n    // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).\n    'insertReplacementText'\n];\n/**\n * Text insertion observer introduces the {@link module:engine/view/document~Document#event:insertText} event.\n */\nexport default class InsertTextObserver extends Observer {\n    /**\n     * @inheritDoc\n     */\n    constructor(view) {\n        super(view);\n        this.focusObserver = view.getObserver(FocusObserver);\n        // On Android composition events should immediately be applied to the model. Rendering is not disabled.\n        // On non-Android the model is updated only on composition end.\n        // On Android we can't rely on composition start/end to update model.\n        if (env.isAndroid) {\n            TYPING_INPUT_TYPES.push('insertCompositionText');\n        }\n        const viewDocument = view.document;\n        viewDocument.on('beforeinput', (evt, data) => {\n            if (!this.isEnabled) {\n                return;\n            }\n            const { data: text, targetRanges, inputType, domEvent } = data;\n            if (!TYPING_INPUT_TYPES.includes(inputType)) {\n                return;\n            }\n            // Mark the latest focus change as complete (we are typing in editable after the focus\n            // so the selection is in the focused element).\n            this.focusObserver.flush();\n            const eventInfo = new EventInfo(viewDocument, 'insertText');\n            viewDocument.fire(eventInfo, new DomEventData(view, domEvent, {\n                text,\n                selection: view.createSelection(targetRanges)\n            }));\n            // Stop the beforeinput event if `delete` event was stopped.\n            // https://github.com/ckeditor/ckeditor5/issues/753\n            if (eventInfo.stop.called) {\n                evt.stop();\n            }\n        });\n        // Note: The priority must be lower than the CompositionObserver handler to call it after the renderer is unblocked.\n        viewDocument.on('compositionend', (evt, { data, domEvent }) => {\n            // On Android composition events are immediately applied to the model.\n            // On non-Android the model is updated only on composition end.\n            // On Android we can't rely on composition start/end to update model.\n            if (!this.isEnabled || env.isAndroid) {\n                return;\n            }\n            // In case of aborted composition.\n            if (!data) {\n                return;\n            }\n            // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n            // @if CK_DEBUG_TYPING // \tconsole.log( `%c[InsertTextObserver]%c Fire insertText event, text: ${ JSON.stringify( data ) }`,\n            // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', ''\n            // @if CK_DEBUG_TYPING // \t);\n            // @if CK_DEBUG_TYPING // }\n            // How do we know where to insert the composed text?\n            // The selection observer is blocked and the view is not updated with the composition changes.\n            // There were three options:\n            //   - Store the selection on `compositionstart` and use it now. This wouldn't work in RTC\n            //     where the view would change and the stored selection might get incorrect.\n            //     We'd need to fallback to the current view selection anyway.\n            //   - Use the current view selection. This is a bit weird and non-intuitive because\n            //     this isn't necessarily the selection on which the user started composing.\n            //     We cannot even know whether it's still collapsed (there might be some weird\n            //     editor feature that changed it in unpredictable ways for us). But it's by far\n            //     the simplest solution and should be stable (the selection is definitely correct)\n            //     and probably mostly predictable (features usually don't modify the selection\n            //     unless called explicitly by the user).\n            //   - Try to follow it from the `beforeinput` events. This would be really complex as each\n            //     `beforeinput` would come with just the range it's changing and we'd need to calculate that.\n            // We decided to go with the 2nd option for its simplicity and stability.\n            viewDocument.fire('insertText', new DomEventData(view, domEvent, {\n                text: data,\n                selection: viewDocument.selection\n            }));\n        }, { priority: 'lowest' });\n    }\n    /**\n     * @inheritDoc\n     */\n    observe() { }\n    /**\n     * @inheritDoc\n     */\n    stopObserving() { }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/input\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { env } from '@ckeditor/ckeditor5-utils';\nimport InsertTextCommand from './inserttextcommand';\nimport InsertTextObserver from './inserttextobserver';\n/**\n * Handles text input coming from the keyboard or other input methods.\n */\nexport default class Input extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Input';\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const modelSelection = model.document.selection;\n        view.addObserver(InsertTextObserver);\n        // TODO The above default configuration value should be defined using editor.config.define() once it's fixed.\n        const insertTextCommand = new InsertTextCommand(editor, editor.config.get('typing.undoStep') || 20);\n        // Register `insertText` command and add `input` command as an alias for backward compatibility.\n        editor.commands.add('insertText', insertTextCommand);\n        editor.commands.add('input', insertTextCommand);\n        this.listenTo(view.document, 'insertText', (evt, data) => {\n            // Rendering is disabled while composing so prevent events that will be rendered by the engine\n            // and should not be applied by the browser.\n            if (!view.document.isComposing) {\n                data.preventDefault();\n            }\n            const { text, selection: viewSelection, resultRange: viewResultRange } = data;\n            // If view selection was specified, translate it to model selection.\n            const modelRanges = Array.from(viewSelection.getRanges()).map(viewRange => {\n                return editor.editing.mapper.toModelRange(viewRange);\n            });\n            let insertText = text;\n            // Typing in English on Android is firing composition events for the whole typed word.\n            // We need to check the target range text to only apply the difference.\n            if (env.isAndroid) {\n                const selectedText = Array.from(modelRanges[0].getItems()).reduce((rangeText, node) => {\n                    return rangeText + (node.is('$textProxy') ? node.data : '');\n                }, '');\n                if (selectedText) {\n                    if (selectedText.length <= insertText.length) {\n                        if (insertText.startsWith(selectedText)) {\n                            insertText = insertText.substring(selectedText.length);\n                            modelRanges[0].start = modelRanges[0].start.getShiftedBy(selectedText.length);\n                        }\n                    }\n                    else {\n                        if (selectedText.startsWith(insertText)) {\n                            // TODO this should be mapped as delete?\n                            modelRanges[0].start = modelRanges[0].start.getShiftedBy(insertText.length);\n                            insertText = '';\n                        }\n                    }\n                }\n            }\n            const insertTextCommandData = {\n                text: insertText,\n                selection: model.createSelection(modelRanges)\n            };\n            // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n            // @if CK_DEBUG_TYPING // \tconsole.log( '%c[Input]%c Execute insertText:',\n            // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', '',\n            // @if CK_DEBUG_TYPING // \t\tinsertText,\n            // @if CK_DEBUG_TYPING // \t\t`[${ modelRanges[ 0 ].start.path }]-[${ modelRanges[ 0 ].end.path }]`\n            // @if CK_DEBUG_TYPING // \t);\n            // @if CK_DEBUG_TYPING // }\n            if (viewResultRange) {\n                insertTextCommandData.resultRange = editor.editing.mapper.toModelRange(viewResultRange);\n            }\n            editor.execute('insertText', insertTextCommandData);\n            view.scrollToTheSelection();\n        });\n        if (env.isAndroid) {\n            // On Android with English keyboard, the composition starts just by putting caret\n            // at the word end or by selecting a table column. This is not a real composition started.\n            // Trigger delete content on first composition key pressed.\n            this.listenTo(view.document, 'keydown', (evt, data) => {\n                if (modelSelection.isCollapsed || data.keyCode != 229 || !view.document.isComposing) {\n                    return;\n                }\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconst firstPositionPath = modelSelection.getFirstPosition()!.path;\n                // @if CK_DEBUG_TYPING // \tconst lastPositionPath = modelSelection.getLastPosition()!.path;\n                // @if CK_DEBUG_TYPING // \tconsole.log( '%c[Input]%c KeyDown 229 -> model.deleteContent()',\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', '',\n                // @if CK_DEBUG_TYPING // \t\t`[${ firstPositionPath }]-[${ lastPositionPath }]`\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n                deleteSelectionContent(model, insertTextCommand);\n            });\n        }\n        else {\n            // Note: The priority must precede the CompositionObserver handler to call it before\n            // the renderer is blocked, because we want to render this change.\n            this.listenTo(view.document, 'compositionstart', () => {\n                if (modelSelection.isCollapsed) {\n                    return;\n                }\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconst firstPositionPath = modelSelection.getFirstPosition()!.path;\n                // @if CK_DEBUG_TYPING // \tconst lastPositionPath = modelSelection.getLastPosition()!.path;\n                // @if CK_DEBUG_TYPING // \tconsole.log( '%c[Input]%c Composition start -> model.deleteContent()',\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', '',\n                // @if CK_DEBUG_TYPING // \t\t`[${ firstPositionPath }]-[${ lastPositionPath }]`\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n                deleteSelectionContent(model, insertTextCommand);\n            });\n        }\n    }\n}\nfunction deleteSelectionContent(model, insertTextCommand) {\n    // By relying on the state of the input command we allow disabling the entire input easily\n    // by just disabling the input command. We could’ve used here the delete command but that\n    // would mean requiring the delete feature which would block loading one without the other.\n    // We could also check the editor.isReadOnly property, but that wouldn't allow to block\n    // the input without blocking other features.\n    if (!insertTextCommand.isEnabled) {\n        return;\n    }\n    const buffer = insertTextCommand.buffer;\n    buffer.lock();\n    model.enqueueChange(buffer.batch, () => {\n        model.deleteContent(model.document.selection);\n    });\n    buffer.unlock();\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/deletecommand\n */\nimport { Command } from '@ckeditor/ckeditor5-core';\nimport { count } from '@ckeditor/ckeditor5-utils';\nimport ChangeBuffer from './utils/changebuffer';\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n */\nexport default class DeleteCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param direction The directionality of the delete describing in what direction it\n     * should consume the content when the selection is collapsed.\n     */\n    constructor(editor, direction) {\n        super(editor);\n        this.direction = direction;\n        this._buffer = new ChangeBuffer(editor.model, editor.config.get('typing.undoStep'));\n        // Since this command may execute on different selectable than selection, it should be checked directly in execute block.\n        this._isEnabledBasedOnSelection = false;\n    }\n    /**\n     * The current change buffer.\n     */\n    get buffer() {\n        return this._buffer;\n    }\n    /**\n     * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n     * or a piece of content in the {@link #direction defined direction}.\n     *\n     * @fires execute\n     * @param options The command options.\n     * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n     * @param options.sequence A number describing which subsequent delete event it is without the key being released.\n     * See the {@link module:engine/view/document~Document#event:delete} event data.\n     * @param options.selection Selection to remove. If not set, current model selection will be used.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const doc = model.document;\n        model.enqueueChange(this._buffer.batch, writer => {\n            this._buffer.lock();\n            const selection = writer.createSelection(options.selection || doc.selection);\n            // Don't execute command when selection is in non-editable place.\n            if (!model.canEditAt(selection)) {\n                return;\n            }\n            const sequence = options.sequence || 1;\n            // Do not replace the whole selected content if selection was collapsed.\n            // This prevents such situation:\n            //\n            // <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n            // starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n            const doNotResetEntireContent = selection.isCollapsed;\n            // Try to extend the selection in the specified direction.\n            if (selection.isCollapsed) {\n                model.modifySelection(selection, {\n                    direction: this.direction,\n                    unit: options.unit,\n                    treatEmojiAsSingleUnit: true\n                });\n            }\n            // Check if deleting in an empty editor. See #61.\n            if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {\n                this._replaceEntireContentWithParagraph(writer);\n                return;\n            }\n            // Check if deleting in the first empty block.\n            // See https://github.com/ckeditor/ckeditor5/issues/8137.\n            if (this._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {\n                this.editor.execute('paragraph', { selection });\n                return;\n            }\n            // If selection is still collapsed, then there's nothing to delete.\n            if (selection.isCollapsed) {\n                return;\n            }\n            let changeCount = 0;\n            selection.getFirstRange().getMinimalFlatRanges().forEach(range => {\n                changeCount += count(range.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));\n            });\n            // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n            // @if CK_DEBUG_TYPING // \tconsole.log( '%c[DeleteCommand]%c Delete content',\n            // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', '',\n            // @if CK_DEBUG_TYPING // \t\t`[${ selection.getFirstPosition()!.path }]-[${ selection.getLastPosition()!.path }]`, options\n            // @if CK_DEBUG_TYPING // \t);\n            // @if CK_DEBUG_TYPING // }\n            model.deleteContent(selection, {\n                doNotResetEntireContent,\n                direction: this.direction\n            });\n            this._buffer.input(changeCount);\n            writer.setSelection(selection);\n            this._buffer.unlock();\n        });\n    }\n    /**\n     * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n     * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n     * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n     *\n     * But, if the user pressed the key in an empty editable for the first time,\n     * we want to replace the entire content with a paragraph if:\n     *\n     * * the current limit element is empty,\n     * * the paragraph is allowed in the limit element,\n     * * the limit doesn't already have a paragraph inside.\n     *\n     * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n     *\n     * @param sequence A number describing which subsequent delete event it is without the key being released.\n     */\n    _shouldEntireContentBeReplacedWithParagraph(sequence) {\n        // Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n        if (sequence > 1) {\n            return false;\n        }\n        const model = this.editor.model;\n        const doc = model.document;\n        const selection = doc.selection;\n        const limitElement = model.schema.getLimitElement(selection);\n        // If a collapsed selection contains the whole content it means that the content is empty\n        // (from the user perspective).\n        const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);\n        if (!limitElementIsEmpty) {\n            return false;\n        }\n        if (!model.schema.checkChild(limitElement, 'paragraph')) {\n            return false;\n        }\n        const limitElementFirstChild = limitElement.getChild(0);\n        // Does nothing if the limit element already contains only a paragraph.\n        // We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n        // because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n        if (limitElementFirstChild && limitElementFirstChild.is('element', 'paragraph')) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n     *\n     * @param writer The model writer.\n     */\n    _replaceEntireContentWithParagraph(writer) {\n        const model = this.editor.model;\n        const doc = model.document;\n        const selection = doc.selection;\n        const limitElement = model.schema.getLimitElement(selection);\n        const paragraph = writer.createElement('paragraph');\n        writer.remove(writer.createRangeIn(limitElement));\n        writer.insert(paragraph, limitElement);\n        writer.setSelection(paragraph, 0);\n    }\n    /**\n     * Checks if the selection is inside an empty element that is the first child of the limit element\n     * and should be replaced with a paragraph.\n     *\n     * @param selection The selection.\n     * @param sequence A number describing which subsequent delete event it is without the key being released.\n     */\n    _shouldReplaceFirstBlockWithParagraph(selection, sequence) {\n        const model = this.editor.model;\n        // Does nothing if user pressed and held the \"Backspace\" key or it was a \"Delete\" button.\n        if (sequence > 1 || this.direction != 'backward') {\n            return false;\n        }\n        if (!selection.isCollapsed) {\n            return false;\n        }\n        const position = selection.getFirstPosition();\n        const limitElement = model.schema.getLimitElement(position);\n        const limitElementFirstChild = limitElement.getChild(0);\n        // Only elements that are direct children of the limit element can be replaced.\n        // Unwrapping from a block quote should be handled in a dedicated feature.\n        if (position.parent != limitElementFirstChild) {\n            return false;\n        }\n        // A block should be replaced only if it was empty.\n        if (!selection.containsEntireContent(limitElementFirstChild)) {\n            return false;\n        }\n        // Replace with a paragraph only if it's allowed there.\n        if (!model.schema.checkChild(limitElement, 'paragraph')) {\n            return false;\n        }\n        // Does nothing if the limit element already contains only a paragraph.\n        if (limitElementFirstChild.name == 'paragraph') {\n            return false;\n        }\n        return true;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/deleteobserver\n */\nimport { env, keyCodes, isInsideCombinedSymbol, isInsideEmojiSequence, isInsideSurrogatePair } from '@ckeditor/ckeditor5-utils';\nimport { BubblingEventInfo, DomEventData, Observer } from '@ckeditor/ckeditor5-engine';\nconst DELETE_CHARACTER = 'character';\nconst DELETE_WORD = 'word';\nconst DELETE_CODE_POINT = 'codePoint';\nconst DELETE_SELECTION = 'selection';\nconst DELETE_BACKWARD = 'backward';\nconst DELETE_FORWARD = 'forward';\nconst DELETE_EVENT_TYPES = {\n    // --------------------------------------- Backward delete types -----------------------------------------------------\n    // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.\n    deleteContent: {\n        unit: DELETE_SELECTION,\n        // According to the Input Events Level 2 spec, this delete type has no direction\n        // but to keep things simple, let's default to backward.\n        direction: DELETE_BACKWARD\n    },\n    // Chrome and Safari on Mac: Backspace or Ctrl + H\n    deleteContentBackward: {\n        // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.\n        // Take for instance \"👨‍👩‍👧‍👧\", it equals:\n        //\n        //\t* [ \"👨\", \"ZERO WIDTH JOINER\", \"👩\", \"ZERO WIDTH JOINER\", \"👧\", \"ZERO WIDTH JOINER\", \"👧\" ]\n        //\t* or simply \"\\u{1F468}\\u200D\\u{1F469}\\u200D\\u{1F467}\\u200D\\u{1F467}\"\n        //\n        // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user\n        // intention when deleting backwards (\"👨‍👩‍👧‍👧[]\", then backspace) is gradual \"decomposition\" (first to \"👨‍👩‍👧‍[]\",\n        // then to \"👨‍👩‍[]\", etc.).\n        //\n        //\t* \"👨‍👩‍👧‍👧[]\" + backward delete (by code point)  -> results in \"👨‍👩‍👧[]\", removed the last \"👧\" 👍\n        //\t* \"👨‍👩‍👧‍👧[]\" + backward delete (by character)  -> results in \"[]\", removed the whole grapheme 👎\n        //\n        // Deleting by code-point is simply a better UX. See \"deleteContentForward\" to learn more.\n        unit: DELETE_CODE_POINT,\n        direction: DELETE_BACKWARD\n    },\n    // On Mac: Option + Backspace.\n    // On iOS: Hold the backspace for a while and the whole words will start to disappear.\n    deleteWordBackward: {\n        unit: DELETE_WORD,\n        direction: DELETE_BACKWARD\n    },\n    // Safari on Mac: Cmd + Backspace\n    deleteHardLineBackward: {\n        unit: DELETE_SELECTION,\n        direction: DELETE_BACKWARD\n    },\n    // Chrome on Mac: Cmd + Backspace.\n    deleteSoftLineBackward: {\n        unit: DELETE_SELECTION,\n        direction: DELETE_BACKWARD\n    },\n    // --------------------------------------- Forward delete types -----------------------------------------------------\n    // Chrome on Mac: Fn + Backspace or Ctrl + D\n    // Safari on Mac: Ctrl + K or Ctrl + D\n    deleteContentForward: {\n        // Unlike backward delete, this delete must be performed by character instead of by code point, which\n        // provides the best UX for working with accented letters.\n        // Take, for example \"b̂\" (\"\\u0062\\u0302\", or [ \"LATIN SMALL LETTER B\", \"COMBINING CIRCUMFLEX ACCENT\" ]):\n        //\n        //\t* \"b̂[]\" + backward delete (by code point)  -> results in \"b[]\", removed the combining mark 👍\n        //\t* \"[]b̂\" + forward delete (by code point)   -> results in \"[]^\", a bare combining mark does that not make sense when alone 👎\n        //\t* \"[]b̂\" + forward delete (by character)    -> results in \"[]\", removed both \"b\" and the combining mark 👍\n        //\n        // See: \"deleteContentBackward\" to learn more.\n        unit: DELETE_CHARACTER,\n        direction: DELETE_FORWARD\n    },\n    // On Mac: Fn + Option + Backspace.\n    deleteWordForward: {\n        unit: DELETE_WORD,\n        direction: DELETE_FORWARD\n    },\n    // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)\n    // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing\n    // on Apple's webpage.\n    deleteHardLineForward: {\n        unit: DELETE_SELECTION,\n        direction: DELETE_FORWARD\n    },\n    // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with\n    // deleteSoftLineBackward.\n    deleteSoftLineForward: {\n        unit: DELETE_SELECTION,\n        direction: DELETE_FORWARD\n    }\n};\n/**\n * Delete observer introduces the {@link module:engine/view/document~Document#event:delete} event.\n */\nexport default class DeleteObserver extends Observer {\n    /**\n     * @inheritDoc\n     */\n    constructor(view) {\n        super(view);\n        const document = view.document;\n        // It matters how many subsequent deletions were made, e.g. when the backspace key was pressed and held\n        // by the user for some time. For instance, if such scenario ocurred and the heading the selection was\n        // anchored to was the only content of the editor, it will not be converted into a paragraph (the user\n        // wanted to clean it up, not remove it, it's about UX). Check out the DeleteCommand implementation to learn more.\n        //\n        // Fun fact: Safari on Mac won't fire beforeinput for backspace in an empty heading (only content).\n        let sequence = 0;\n        document.on('keydown', () => {\n            sequence++;\n        });\n        document.on('keyup', () => {\n            sequence = 0;\n        });\n        document.on('beforeinput', (evt, data) => {\n            if (!this.isEnabled) {\n                return;\n            }\n            const { targetRanges, domEvent, inputType } = data;\n            const deleteEventSpec = DELETE_EVENT_TYPES[inputType];\n            if (!deleteEventSpec) {\n                return;\n            }\n            const deleteData = {\n                direction: deleteEventSpec.direction,\n                unit: deleteEventSpec.unit,\n                sequence\n            };\n            if (deleteData.unit == DELETE_SELECTION) {\n                deleteData.selectionToRemove = view.createSelection(targetRanges[0]);\n            }\n            // The default deletion unit for deleteContentBackward is a single code point\n            // but if the browser provides a wider target range then we should use it.\n            if (inputType === 'deleteContentBackward') {\n                // On Android, deleteContentBackward has sequence 1 by default.\n                if (env.isAndroid) {\n                    deleteData.sequence = 1;\n                }\n                // The beforeInput event wants more than a single character to be removed.\n                if (shouldUseTargetRanges(targetRanges)) {\n                    deleteData.unit = DELETE_SELECTION;\n                    deleteData.selectionToRemove = view.createSelection(targetRanges);\n                }\n            }\n            const eventInfo = new BubblingEventInfo(document, 'delete', targetRanges[0]);\n            document.fire(eventInfo, new DomEventData(view, domEvent, deleteData));\n            // Stop the beforeinput event if `delete` event was stopped.\n            // https://github.com/ckeditor/ckeditor5/issues/753\n            if (eventInfo.stop.called) {\n                evt.stop();\n            }\n        });\n        // TODO: to be removed when https://bugs.chromium.org/p/chromium/issues/detail?id=1365311 is solved.\n        if (env.isBlink) {\n            enableChromeWorkaround(this);\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    observe() { }\n    /**\n     * @inheritDoc\n     */\n    stopObserving() { }\n}\n/**\n * Enables workaround for the issue https://github.com/ckeditor/ckeditor5/issues/11904.\n */\nfunction enableChromeWorkaround(observer) {\n    const view = observer.view;\n    const document = view.document;\n    let pressedKeyCode = null;\n    let beforeInputReceived = false;\n    document.on('keydown', (evt, { keyCode }) => {\n        pressedKeyCode = keyCode;\n        beforeInputReceived = false;\n    });\n    document.on('keyup', (evt, { keyCode, domEvent }) => {\n        const selection = document.selection;\n        const shouldFireDeleteEvent = observer.isEnabled &&\n            keyCode == pressedKeyCode &&\n            isDeleteKeyCode(keyCode) &&\n            !selection.isCollapsed &&\n            !beforeInputReceived;\n        pressedKeyCode = null;\n        if (shouldFireDeleteEvent) {\n            const targetRange = selection.getFirstRange();\n            const eventInfo = new BubblingEventInfo(document, 'delete', targetRange);\n            const deleteData = {\n                unit: DELETE_SELECTION,\n                direction: getDeleteDirection(keyCode),\n                selectionToRemove: selection\n            };\n            document.fire(eventInfo, new DomEventData(view, domEvent, deleteData));\n        }\n    });\n    document.on('beforeinput', (evt, { inputType }) => {\n        const deleteEventSpec = DELETE_EVENT_TYPES[inputType];\n        const isMatchingBeforeInput = isDeleteKeyCode(pressedKeyCode) &&\n            deleteEventSpec &&\n            deleteEventSpec.direction == getDeleteDirection(pressedKeyCode);\n        if (isMatchingBeforeInput) {\n            beforeInputReceived = true;\n        }\n    }, { priority: 'high' });\n    document.on('beforeinput', (evt, { inputType, data }) => {\n        const shouldIgnoreBeforeInput = pressedKeyCode == keyCodes.delete &&\n            inputType == 'insertText' &&\n            data == '\\x7f'; // Delete character :P\n        if (shouldIgnoreBeforeInput) {\n            evt.stop();\n        }\n    }, { priority: 'high' });\n    function isDeleteKeyCode(keyCode) {\n        return keyCode == keyCodes.backspace || keyCode == keyCodes.delete;\n    }\n    function getDeleteDirection(keyCode) {\n        return keyCode == keyCodes.backspace ? DELETE_BACKWARD : DELETE_FORWARD;\n    }\n}\n/**\n * Verifies whether the given target ranges cover more than a single character and should be used instead of a single code-point deletion.\n */\nfunction shouldUseTargetRanges(targetRanges) {\n    // The collapsed target range could happen for example while deleting inside an inline filler\n    // (it's mapped to collapsed position before an inline filler).\n    if (targetRanges.length != 1 || targetRanges[0].isCollapsed) {\n        return false;\n    }\n    const walker = targetRanges[0].getWalker({\n        direction: 'backward',\n        singleCharacters: true,\n        ignoreElementEnd: true\n    });\n    let count = 0;\n    for (const { nextPosition } of walker) {\n        // There is some element in the range so count it as a single character.\n        if (!nextPosition.parent.is('$text')) {\n            count++;\n        }\n        else {\n            const data = nextPosition.parent.data;\n            const offset = nextPosition.offset;\n            // Count combined symbols and emoji sequences as a single character.\n            if (isInsideSurrogatePair(data, offset) ||\n                isInsideCombinedSymbol(data, offset) ||\n                isInsideEmojiSequence(data, offset)) {\n                continue;\n            }\n            count++;\n        }\n        if (count > 1) {\n            return true;\n        }\n    }\n    return false;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/delete\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport DeleteCommand from './deletecommand';\nimport DeleteObserver from './deleteobserver';\n/**\n * The delete and backspace feature. Handles keys such as <kbd>Delete</kbd> and <kbd>Backspace</kbd>, other\n * keystrokes and user actions that result in deleting content in the editor.\n */\nexport default class Delete extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Delete';\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const modelDocument = editor.model.document;\n        view.addObserver(DeleteObserver);\n        this._undoOnBackspace = false;\n        const deleteForwardCommand = new DeleteCommand(editor, 'forward');\n        // Register `deleteForward` command and add `forwardDelete` command as an alias for backward compatibility.\n        editor.commands.add('deleteForward', deleteForwardCommand);\n        editor.commands.add('forwardDelete', deleteForwardCommand);\n        editor.commands.add('delete', new DeleteCommand(editor, 'backward'));\n        this.listenTo(viewDocument, 'delete', (evt, data) => {\n            // When not in composition, we handle the action, so prevent the default one.\n            // When in composition, it's the browser who modify the DOM (renderer is disabled).\n            if (!viewDocument.isComposing) {\n                data.preventDefault();\n            }\n            const { direction, sequence, selectionToRemove, unit } = data;\n            const commandName = direction === 'forward' ? 'deleteForward' : 'delete';\n            const commandData = { sequence };\n            if (unit == 'selection') {\n                const modelRanges = Array.from(selectionToRemove.getRanges()).map(viewRange => {\n                    return editor.editing.mapper.toModelRange(viewRange);\n                });\n                commandData.selection = editor.model.createSelection(modelRanges);\n            }\n            else {\n                commandData.unit = unit;\n            }\n            editor.execute(commandName, commandData);\n            view.scrollToTheSelection();\n        }, { priority: 'low' });\n        if (this.editor.plugins.has('UndoEditing')) {\n            this.listenTo(viewDocument, 'delete', (evt, data) => {\n                if (this._undoOnBackspace && data.direction == 'backward' && data.sequence == 1 && data.unit == 'codePoint') {\n                    this._undoOnBackspace = false;\n                    editor.execute('undo');\n                    data.preventDefault();\n                    evt.stop();\n                }\n            }, { context: '$capture' });\n            this.listenTo(modelDocument, 'change', () => {\n                this._undoOnBackspace = false;\n            });\n        }\n    }\n    /**\n     * If the next user action after calling this method is pressing backspace, it would undo the last change.\n     *\n     * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.\n     */\n    requestUndoOnBackspace() {\n        if (this.editor.plugins.has('UndoEditing')) {\n            this._undoOnBackspace = true;\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/typing\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport Input from './input';\nimport Delete from './delete';\n/**\n * The typing feature. It handles typing.\n *\n * This is a \"glue\" plugin which loads the {@link module:typing/input~Input} and {@link module:typing/delete~Delete}\n * plugins.\n */\nexport default class Typing extends Plugin {\n    static get requires() {\n        return [Input, Delete];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Typing';\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Returns the last text line from the given range.\n *\n * \"The last text line\" is understood as text (from one or more text nodes) which is limited either by a parent block\n * or by inline elements (e.g. `<softBreak>`).\n *\n * ```ts\n * const rangeToCheck = model.createRange(\n * \tmodel.createPositionAt( paragraph, 0 ),\n * \tmodel.createPositionAt( paragraph, 'end' )\n * );\n *\n * const { text, range } = getLastTextLine( rangeToCheck, model );\n * ```\n *\n * For model below, the returned `text` will be \"Foo bar baz\" and `range` will be set on whole `<paragraph>` content:\n *\n * ```xml\n * <paragraph>Foo bar baz<paragraph>\n * ```\n *\n * However, in below case, `text` will be set to \"baz\" and `range` will be set only on \"baz\".\n *\n * ```xml\n * <paragraph>Foo<softBreak></softBreak>bar<softBreak></softBreak>baz<paragraph>\n * ```\n */\nexport default function getLastTextLine(range, model) {\n    let start = range.start;\n    const text = Array.from(range.getWalker({ ignoreElementEnd: false })).reduce((rangeText, { item }) => {\n        // Trim text to a last occurrence of an inline element and update range start.\n        if (!(item.is('$text') || item.is('$textProxy'))) {\n            start = model.createPositionAfter(item);\n            return '';\n        }\n        return rangeText + item.data;\n    }, '');\n    return { text, range: model.createRange(start, range.end) };\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/textwatcher\n */\nimport { ObservableMixin } from '@ckeditor/ckeditor5-utils';\nimport getLastTextLine from './utils/getlasttextline';\n/**\n * The text watcher feature.\n *\n * Fires the {@link module:typing/textwatcher~TextWatcher#event:matched:data `matched:data`},\n * {@link module:typing/textwatcher~TextWatcher#event:matched:selection `matched:selection`} and\n * {@link module:typing/textwatcher~TextWatcher#event:unmatched `unmatched`} events on typing or selection changes.\n */\nexport default class TextWatcher extends ObservableMixin() {\n    /**\n     * Creates a text watcher instance.\n     *\n     * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.\n     */\n    constructor(model, testCallback) {\n        super();\n        this.model = model;\n        this.testCallback = testCallback;\n        this._hasMatch = false;\n        this.set('isEnabled', true);\n        // Toggle text watching on isEnabled state change.\n        this.on('change:isEnabled', () => {\n            if (this.isEnabled) {\n                this._startListening();\n            }\n            else {\n                this.stopListening(model.document.selection);\n                this.stopListening(model.document);\n            }\n        });\n        this._startListening();\n    }\n    /**\n     * Flag indicating whether there is a match currently.\n     */\n    get hasMatch() {\n        return this._hasMatch;\n    }\n    /**\n     * Starts listening to the editor for typing and selection events.\n     */\n    _startListening() {\n        const model = this.model;\n        const document = model.document;\n        this.listenTo(document.selection, 'change:range', (evt, { directChange }) => {\n            // Indirect changes (i.e. when the user types or external changes are applied) are handled in the document's change event.\n            if (!directChange) {\n                return;\n            }\n            // Act only on collapsed selection.\n            if (!document.selection.isCollapsed) {\n                if (this.hasMatch) {\n                    this.fire('unmatched');\n                    this._hasMatch = false;\n                }\n                return;\n            }\n            this._evaluateTextBeforeSelection('selection');\n        });\n        this.listenTo(document, 'change:data', (evt, batch) => {\n            if (batch.isUndo || !batch.isLocal) {\n                return;\n            }\n            this._evaluateTextBeforeSelection('data', { batch });\n        });\n    }\n    /**\n     * Checks the editor content for matched text.\n     *\n     * @fires matched:data\n     * @fires matched:selection\n     * @fires unmatched\n     *\n     * @param suffix A suffix used for generating the event name.\n     * @param data Data object for event.\n     */\n    _evaluateTextBeforeSelection(suffix, data = {}) {\n        const model = this.model;\n        const document = model.document;\n        const selection = document.selection;\n        const rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);\n        const { text, range } = getLastTextLine(rangeBeforeSelection, model);\n        const testResult = this.testCallback(text);\n        if (!testResult && this.hasMatch) {\n            this.fire('unmatched');\n        }\n        this._hasMatch = !!testResult;\n        if (testResult) {\n            const eventData = Object.assign(data, { text, range });\n            // If the test callback returns an object with additional data, assign the data as well.\n            if (typeof testResult == 'object') {\n                Object.assign(eventData, testResult);\n            }\n            this.fire(`matched:${suffix}`, eventData);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/twostepcaretmovement\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils';\n/**\n * This plugin enables the two-step caret (phantom) movement behavior for\n * {@link module:typing/twostepcaretmovement~TwoStepCaretMovement#registerAttribute registered attributes}\n * on arrow right (<kbd>→</kbd>) and left (<kbd>←</kbd>) key press.\n *\n * Thanks to this (phantom) caret movement the user is able to type before/after as well as at the\n * beginning/end of an attribute.\n *\n * **Note:** This plugin support right–to–left (Arabic, Hebrew, etc.) content by mirroring its behavior\n * but for the sake of simplicity examples showcase only left–to–right use–cases.\n *\n * # Forward movement\n *\n * ## \"Entering\" an attribute:\n *\n * When this plugin is enabled and registered for the `a` attribute and the selection is right before it\n * (at the attribute boundary), pressing the right arrow key will not move the selection but update its\n * attributes accordingly:\n *\n * * When enabled:\n *\n * ```xml\n * foo{}<$text a=\"true\">bar</$text>\n * ```\n *\n * \t<kbd>→</kbd>\n *\n * ```xml\n * foo<$text a=\"true\">{}bar</$text>\n * ```\n *\n * * When disabled:\n *\n * ```xml\n * foo{}<$text a=\"true\">bar</$text>\n * ```\n *\n * \t<kbd>→</kbd>\n *\n * ```xml\n * foo<$text a=\"true\">b{}ar</$text>\n * ```\n *\n *\n * ## \"Leaving\" an attribute:\n *\n * * When enabled:\n *\n * ```xml\n * <$text a=\"true\">bar{}</$text>baz\n * ```\n *\n * \t<kbd>→</kbd>\n *\n * ```xml\n * <$text a=\"true\">bar</$text>{}baz\n * ```\n *\n * * When disabled:\n *\n * ```xml\n * <$text a=\"true\">bar{}</$text>baz\n * ```\n *\n * \t<kbd>→</kbd>\n *\n * ```xml\n * <$text a=\"true\">bar</$text>b{}az\n * ```\n *\n * # Backward movement\n *\n * * When enabled:\n *\n * ```xml\n * <$text a=\"true\">bar</$text>{}baz\n * ```\n *\n * \t<kbd>←</kbd>\n *\n * ```xml\n * <$text a=\"true\">bar{}</$text>baz\n * ```\n *\n * * When disabled:\n *\n * ```xml\n * <$text a=\"true\">bar</$text>{}baz\n * ```\n *\n * \t<kbd>←</kbd>\n *\n * ```xml\n * <$text a=\"true\">ba{}r</$text>b{}az\n * ```\n *\n * # Multiple attributes\n *\n * * When enabled and many attributes starts or ends at the same position:\n *\n * ```xml\n * <$text a=\"true\" b=\"true\">bar</$text>{}baz\n * ```\n *\n * \t<kbd>←</kbd>\n *\n * ```xml\n * <$text a=\"true\" b=\"true\">bar{}</$text>baz\n * ```\n *\n * * When enabled and one procedes another:\n *\n * ```xml\n * <$text a=\"true\">bar</$text><$text b=\"true\">{}bar</$text>\n * ```\n *\n * \t<kbd>←</kbd>\n *\n * ```xml\n * <$text a=\"true\">bar{}</$text><$text b=\"true\">bar</$text>\n * ```\n *\n */\nexport default class TwoStepCaretMovement extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'TwoStepCaretMovement';\n    }\n    /**\n     * @inheritDoc\n     */\n    constructor(editor) {\n        super(editor);\n        this.attributes = new Set();\n        this._overrideUid = null;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const locale = editor.locale;\n        const modelSelection = model.document.selection;\n        // Listen to keyboard events and handle the caret movement according to the 2-step caret logic.\n        this.listenTo(view.document, 'arrowKey', (evt, data) => {\n            // This implementation works only for collapsed selection.\n            if (!modelSelection.isCollapsed) {\n                return;\n            }\n            // When user tries to expand the selection or jump over the whole word or to the beginning/end then\n            // two-steps movement is not necessary.\n            if (data.shiftKey || data.altKey || data.ctrlKey) {\n                return;\n            }\n            const arrowRightPressed = data.keyCode == keyCodes.arrowright;\n            const arrowLeftPressed = data.keyCode == keyCodes.arrowleft;\n            // When neither left or right arrow has been pressed then do noting.\n            if (!arrowRightPressed && !arrowLeftPressed) {\n                return;\n            }\n            const contentDirection = locale.contentLanguageDirection;\n            let isMovementHandled = false;\n            if ((contentDirection === 'ltr' && arrowRightPressed) || (contentDirection === 'rtl' && arrowLeftPressed)) {\n                isMovementHandled = this._handleForwardMovement(data);\n            }\n            else {\n                isMovementHandled = this._handleBackwardMovement(data);\n            }\n            // Stop the keydown event if the two-step caret movement handled it. Avoid collisions\n            // with other features which may also take over the caret movement (e.g. Widget).\n            if (isMovementHandled === true) {\n                evt.stop();\n            }\n        }, { context: '$text', priority: 'highest' });\n        this._isNextGravityRestorationSkipped = false;\n        // The automatic gravity restoration logic.\n        this.listenTo(modelSelection, 'change:range', (evt, data) => {\n            // Skipping the automatic restoration is needed if the selection should change\n            // but the gravity must remain overridden afterwards. See the #handleBackwardMovement\n            // to learn more.\n            if (this._isNextGravityRestorationSkipped) {\n                this._isNextGravityRestorationSkipped = false;\n                return;\n            }\n            // Skip automatic restore when the gravity is not overridden — simply, there's nothing to restore\n            // at this moment.\n            if (!this._isGravityOverridden) {\n                return;\n            }\n            // Skip automatic restore when the change is indirect AND the selection is at the attribute boundary.\n            // It means that e.g. if the change was external (collaboration) and the user had their\n            // selection around the link, its gravity should remain intact in this change:range event.\n            if (!data.directChange && isBetweenDifferentAttributes(modelSelection.getFirstPosition(), this.attributes)) {\n                return;\n            }\n            this._restoreGravity();\n        });\n    }\n    /**\n     * Registers a given attribute for the two-step caret movement.\n     *\n     * @param attribute Name of the attribute to handle.\n     */\n    registerAttribute(attribute) {\n        this.attributes.add(attribute);\n    }\n    /**\n     * Updates the document selection and the view according to the two–step caret movement state\n     * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n     *\n     * @param data Data of the key press.\n     * @returns `true` when the handler prevented caret movement.\n     */\n    _handleForwardMovement(data) {\n        const attributes = this.attributes;\n        const model = this.editor.model;\n        const selection = model.document.selection;\n        const position = selection.getFirstPosition();\n        // DON'T ENGAGE 2-SCM if gravity is already overridden. It means that we just entered\n        //\n        // \t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n        //\n        // or left the attribute\n        //\n        // \t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n        //\n        // and the gravity will be restored automatically.\n        if (this._isGravityOverridden) {\n            return false;\n        }\n        // DON'T ENGAGE 2-SCM when the selection is at the beginning of the block AND already has the\n        // attribute:\n        // * when the selection was initially set there using the mouse,\n        // * when the editor has just started\n        //\n        //\t\t<paragraph><$text attribute>{}bar</$text>baz</paragraph>\n        //\n        if (position.isAtStart && hasAnyAttribute(selection, attributes)) {\n            return false;\n        }\n        // ENGAGE 2-SCM When at least one of the observed attributes changes its value (incl. starts, ends).\n        //\n        //\t\t<paragraph>foo<$text attribute>bar{}</$text>baz</paragraph>\n        //\t\t<paragraph>foo<$text attribute>bar{}</$text><$text otherAttribute>baz</$text></paragraph>\n        //\t\t<paragraph>foo<$text attribute=1>bar{}</$text><$text attribute=2>baz</$text></paragraph>\n        //\t\t<paragraph>foo{}<$text attribute>bar</$text>baz</paragraph>\n        //\n        if (isBetweenDifferentAttributes(position, attributes)) {\n            preventCaretMovement(data);\n            this._overrideGravity();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Updates the document selection and the view according to the two–step caret movement state\n     * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n     *\n     * @param data Data of the key press.\n     * @returns `true` when the handler prevented caret movement\n     */\n    _handleBackwardMovement(data) {\n        const attributes = this.attributes;\n        const model = this.editor.model;\n        const selection = model.document.selection;\n        const position = selection.getFirstPosition();\n        // When the gravity is already overridden (by this plugin), it means we are on the two-step position.\n        // Prevent the movement, restore the gravity and update selection attributes.\n        //\n        //\t\t<paragraph>foo<$text attribute=1>bar</$text><$text attribute=2>{}baz</$text></paragraph>\n        //\t\t<paragraph>foo<$text attribute>bar</$text><$text otherAttribute>{}baz</$text></paragraph>\n        //\t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n        //\t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n        //\n        if (this._isGravityOverridden) {\n            preventCaretMovement(data);\n            this._restoreGravity();\n            setSelectionAttributesFromTheNodeBefore(model, attributes, position);\n            return true;\n        }\n        else {\n            // REMOVE SELECTION ATTRIBUTE when restoring gravity towards a non-existent content at the\n            // beginning of the block.\n            //\n            // \t\t<paragraph>{}<$text attribute>bar</$text></paragraph>\n            //\n            if (position.isAtStart) {\n                if (hasAnyAttribute(selection, attributes)) {\n                    preventCaretMovement(data);\n                    setSelectionAttributesFromTheNodeBefore(model, attributes, position);\n                    return true;\n                }\n                return false;\n            }\n            // When we are moving from natural gravity, to the position of the 2SCM, we need to override the gravity,\n            // and make sure it won't be restored. Unless it's at the end of the block and an observed attribute.\n            // We need to check if the caret is a one position before the attribute boundary:\n            //\n            //\t\t<paragraph>foo<$text attribute=1>bar</$text><$text attribute=2>b{}az</$text></paragraph>\n            //\t\t<paragraph>foo<$text attribute>bar</$text><$text otherAttribute>b{}az</$text></paragraph>\n            //\t\t<paragraph>foo<$text attribute>b{}ar</$text>baz</paragraph>\n            //\t\t<paragraph>foo<$text attribute>bar</$text>b{}az</paragraph>\n            //\n            if (isStepAfterAnyAttributeBoundary(position, attributes)) {\n                // ENGAGE 2-SCM if the selection has no attribute. This may happen when the user\n                // left the attribute using a FORWARD 2-SCM.\n                //\n                // \t\t<paragraph><$text attribute>bar</$text>{}</paragraph>\n                //\n                if (position.isAtEnd &&\n                    !hasAnyAttribute(selection, attributes) &&\n                    isBetweenDifferentAttributes(position, attributes)) {\n                    preventCaretMovement(data);\n                    setSelectionAttributesFromTheNodeBefore(model, attributes, position);\n                    return true;\n                }\n                // Skip the automatic gravity restore upon the next selection#change:range event.\n                // If not skipped, it would automatically restore the gravity, which should remain\n                // overridden.\n                this._isNextGravityRestorationSkipped = true;\n                this._overrideGravity();\n                // Don't return \"true\" here because we didn't call _preventCaretMovement.\n                // Returning here will destabilize the filler logic, which also listens to\n                // keydown (and the event would be stopped).\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * `true` when the gravity is overridden for the plugin.\n     */\n    get _isGravityOverridden() {\n        return !!this._overrideUid;\n    }\n    /**\n     * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}\n     * and stores the information about this fact in the {@link #_overrideUid}.\n     *\n     * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.\n     */\n    _overrideGravity() {\n        this._overrideUid = this.editor.model.change(writer => {\n            return writer.overrideSelectionGravity();\n        });\n    }\n    /**\n     * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.\n     *\n     * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.\n     */\n    _restoreGravity() {\n        this.editor.model.change(writer => {\n            writer.restoreSelectionGravity(this._overrideUid);\n            this._overrideUid = null;\n        });\n    }\n}\n/**\n * Checks whether the selection has any of given attributes.\n */\nfunction hasAnyAttribute(selection, attributes) {\n    for (const observedAttribute of attributes) {\n        if (selection.hasAttribute(observedAttribute)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Applies the given attributes to the current selection using using the\n * values from the node before the current position. Uses\n * the {@link module:engine/model/writer~Writer model writer}.\n */\nfunction setSelectionAttributesFromTheNodeBefore(model, attributes, position) {\n    const nodeBefore = position.nodeBefore;\n    model.change(writer => {\n        if (nodeBefore) {\n            const attributes = [];\n            const isInlineObject = model.schema.isObject(nodeBefore) && model.schema.isInline(nodeBefore);\n            for (const [key, value] of nodeBefore.getAttributes()) {\n                if (model.schema.checkAttribute('$text', key) &&\n                    (!isInlineObject || model.schema.getAttributeProperties(key).copyFromObject !== false)) {\n                    attributes.push([key, value]);\n                }\n            }\n            writer.setSelectionAttribute(attributes);\n        }\n        else {\n            writer.removeSelectionAttribute(attributes);\n        }\n    });\n}\n/**\n * Prevents the caret movement in the view by calling `preventDefault` on the event data.\n *\n * @alias data.preventDefault\n */\nfunction preventCaretMovement(data) {\n    data.preventDefault();\n}\n/**\n * Checks whether the step before `isBetweenDifferentAttributes()`.\n */\nfunction isStepAfterAnyAttributeBoundary(position, attributes) {\n    const positionBefore = position.getShiftedBy(-1);\n    return isBetweenDifferentAttributes(positionBefore, attributes);\n}\n/**\n * Checks whether the given position is between different values of given attributes.\n */\nfunction isBetweenDifferentAttributes(position, attributes) {\n    const { nodeBefore, nodeAfter } = position;\n    for (const observedAttribute of attributes) {\n        const attrBefore = nodeBefore ? nodeBefore.getAttribute(observedAttribute) : undefined;\n        const attrAfter = nodeAfter ? nodeAfter.getAttribute(observedAttribute) : undefined;\n        if (attrAfter !== attrBefore) {\n            return true;\n        }\n    }\n    return false;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Returns a model range that covers all consecutive nodes with the same `attributeName` and its `value`\n * that intersect the given `position`.\n *\n * It can be used e.g. to get the entire range on which the `linkHref` attribute needs to be changed when having a\n * selection inside a link.\n *\n * @param position The start position.\n * @param attributeName The attribute name.\n * @param value The attribute value.\n * @param model The model instance.\n * @returns The link range.\n */\nexport default function findAttributeRange(position, attributeName, value, model) {\n    return model.createRange(findAttributeRangeBound(position, attributeName, value, true, model), findAttributeRangeBound(position, attributeName, value, false, model));\n}\n/**\n * Walks forward or backward (depends on the `lookBack` flag), node by node, as long as they have the same attribute value\n * and returns a position just before or after (depends on the `lookBack` flag) the last matched node.\n *\n * @param position The start position.\n * @param attributeName The attribute name.\n * @param value The attribute value.\n * @param lookBack Whether the walk direction is forward (`false`) or backward (`true`).\n * @returns The position just before the last matched node.\n */\nexport function findAttributeRangeBound(position, attributeName, value, lookBack, model) {\n    // Get node before or after position (depends on `lookBack` flag).\n    // When position is inside text node then start searching from text node.\n    let node = position.textNode || (lookBack ? position.nodeBefore : position.nodeAfter);\n    let lastNode = null;\n    while (node && node.getAttribute(attributeName) == value) {\n        lastNode = node;\n        node = lookBack ? node.previousSibling : node.nextSibling;\n    }\n    return lastNode ? model.createPositionAt(lastNode, lookBack ? 'before' : 'after') : position;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/utils/inlinehighlight\n */\nimport findAttributeRange from './findattributerange';\n/**\n * Adds a visual highlight style to an attribute element in which the selection is anchored.\n * Together with two-step caret movement, they indicate that the user is typing inside the element.\n *\n * Highlight is turned on by adding the given class to the attribute element in the view:\n *\n * * The class is removed before the conversion has started, as callbacks added with the `'highest'` priority\n * to {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} events.\n * * The class is added in the view post fixer, after other changes in the model tree were converted to the view.\n *\n * This way, adding and removing the highlight does not interfere with conversion.\n *\n * Usage:\n *\n * ```ts\n * import inlineHighlight from '@ckeditor/ckeditor5-typing/src/utils/inlinehighlight';\n *\n * // Make `ck-link_selected` class be applied on an `a` element\n * // whenever the corresponding `linkHref` attribute element is selected.\n * inlineHighlight( editor, 'linkHref', 'a', 'ck-link_selected' );\n * ```\n *\n * @param editor The editor instance.\n * @param attributeName The attribute name to check.\n * @param tagName The tagName of a view item.\n * @param className The class name to apply in the view.\n */\nexport default function inlineHighlight(editor, attributeName, tagName, className) {\n    const view = editor.editing.view;\n    const highlightedElements = new Set();\n    // Adding the class.\n    view.document.registerPostFixer(writer => {\n        const selection = editor.model.document.selection;\n        let changed = false;\n        if (selection.hasAttribute(attributeName)) {\n            const modelRange = findAttributeRange(selection.getFirstPosition(), attributeName, selection.getAttribute(attributeName), editor.model);\n            const viewRange = editor.editing.mapper.toViewRange(modelRange);\n            // There might be multiple view elements in the `viewRange`, for example, when the `a` element is\n            // broken by a UIElement.\n            for (const item of viewRange.getItems()) {\n                if (item.is('element', tagName) && !item.hasClass(className)) {\n                    writer.addClass(className, item);\n                    highlightedElements.add(item);\n                    changed = true;\n                }\n            }\n        }\n        return changed;\n    });\n    // Removing the class.\n    editor.conversion.for('editingDowncast').add(dispatcher => {\n        // Make sure the highlight is removed on every possible event, before conversion is started.\n        dispatcher.on('insert', removeHighlight, { priority: 'highest' });\n        dispatcher.on('remove', removeHighlight, { priority: 'highest' });\n        dispatcher.on('attribute', removeHighlight, { priority: 'highest' });\n        dispatcher.on('selection', removeHighlight, { priority: 'highest' });\n        function removeHighlight() {\n            view.change(writer => {\n                for (const item of highlightedElements.values()) {\n                    writer.removeClass(className, item);\n                    highlightedElements.delete(item);\n                }\n            });\n        }\n    });\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/texttransformation\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport TextWatcher from './textwatcher';\nimport { escapeRegExp } from 'lodash-es';\n// All named transformations.\nconst TRANSFORMATIONS = {\n    // Common symbols:\n    copyright: { from: '(c)', to: '©' },\n    registeredTrademark: { from: '(r)', to: '®' },\n    trademark: { from: '(tm)', to: '™' },\n    // Mathematical:\n    oneHalf: { from: /(^|[^/a-z0-9])(1\\/2)([^/a-z0-9])$/i, to: [null, '½', null] },\n    oneThird: { from: /(^|[^/a-z0-9])(1\\/3)([^/a-z0-9])$/i, to: [null, '⅓', null] },\n    twoThirds: { from: /(^|[^/a-z0-9])(2\\/3)([^/a-z0-9])$/i, to: [null, '⅔', null] },\n    oneForth: { from: /(^|[^/a-z0-9])(1\\/4)([^/a-z0-9])$/i, to: [null, '¼', null] },\n    threeQuarters: { from: /(^|[^/a-z0-9])(3\\/4)([^/a-z0-9])$/i, to: [null, '¾', null] },\n    lessThanOrEqual: { from: '<=', to: '≤' },\n    greaterThanOrEqual: { from: '>=', to: '≥' },\n    notEqual: { from: '!=', to: '≠' },\n    arrowLeft: { from: '<-', to: '←' },\n    arrowRight: { from: '->', to: '→' },\n    // Typography:\n    horizontalEllipsis: { from: '...', to: '…' },\n    enDash: { from: /(^| )(--)( )$/, to: [null, '–', null] },\n    emDash: { from: /(^| )(---)( )$/, to: [null, '—', null] },\n    // Quotations:\n    // English, US\n    quotesPrimary: { from: buildQuotesRegExp('\"'), to: [null, '“', null, '”'] },\n    quotesSecondary: { from: buildQuotesRegExp('\\''), to: [null, '‘', null, '’'] },\n    // English, UK\n    quotesPrimaryEnGb: { from: buildQuotesRegExp('\\''), to: [null, '‘', null, '’'] },\n    quotesSecondaryEnGb: { from: buildQuotesRegExp('\"'), to: [null, '“', null, '”'] },\n    // Polish\n    quotesPrimaryPl: { from: buildQuotesRegExp('\"'), to: [null, '„', null, '”'] },\n    quotesSecondaryPl: { from: buildQuotesRegExp('\\''), to: [null, '‚', null, '’'] }\n};\n// Transformation groups.\nconst TRANSFORMATION_GROUPS = {\n    symbols: ['copyright', 'registeredTrademark', 'trademark'],\n    mathematical: [\n        'oneHalf', 'oneThird', 'twoThirds', 'oneForth', 'threeQuarters',\n        'lessThanOrEqual', 'greaterThanOrEqual', 'notEqual',\n        'arrowLeft', 'arrowRight'\n    ],\n    typography: ['horizontalEllipsis', 'enDash', 'emDash'],\n    quotes: ['quotesPrimary', 'quotesSecondary']\n};\n// A set of default transformations provided by the feature.\nconst DEFAULT_TRANSFORMATIONS = [\n    'symbols',\n    'mathematical',\n    'typography',\n    'quotes'\n];\n/**\n * The text transformation plugin.\n */\nexport default class TextTransformation extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return ['Delete', 'Input'];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'TextTransformation';\n    }\n    /**\n     * @inheritDoc\n     */\n    constructor(editor) {\n        super(editor);\n        editor.config.define('typing', {\n            transformations: {\n                include: DEFAULT_TRANSFORMATIONS\n            }\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const model = this.editor.model;\n        const modelSelection = model.document.selection;\n        modelSelection.on('change:range', () => {\n            // Disable plugin when selection is inside a code block.\n            this.isEnabled = !modelSelection.anchor.parent.is('element', 'codeBlock');\n        });\n        this._enableTransformationWatchers();\n    }\n    /**\n     * Create new TextWatcher listening to the editor for typing and selection events.\n     */\n    _enableTransformationWatchers() {\n        const editor = this.editor;\n        const model = editor.model;\n        const deletePlugin = editor.plugins.get('Delete');\n        const normalizedTransformations = normalizeTransformations(editor.config.get('typing.transformations'));\n        const testCallback = (text) => {\n            for (const normalizedTransformation of normalizedTransformations) {\n                const from = normalizedTransformation.from;\n                const match = from.test(text);\n                if (match) {\n                    return { normalizedTransformation };\n                }\n            }\n        };\n        const watcher = new TextWatcher(editor.model, testCallback);\n        watcher.on('matched:data', (evt, data) => {\n            if (!data.batch.isTyping) {\n                return;\n            }\n            const { from, to } = data.normalizedTransformation;\n            const matches = from.exec(data.text);\n            const replaces = to(matches.slice(1));\n            const matchedRange = data.range;\n            let changeIndex = matches.index;\n            model.enqueueChange(writer => {\n                for (let i = 1; i < matches.length; i++) {\n                    const match = matches[i];\n                    const replaceWith = replaces[i - 1];\n                    if (replaceWith == null) {\n                        changeIndex += match.length;\n                        continue;\n                    }\n                    const replacePosition = matchedRange.start.getShiftedBy(changeIndex);\n                    const replaceRange = model.createRange(replacePosition, replacePosition.getShiftedBy(match.length));\n                    const attributes = getTextAttributesAfterPosition(replacePosition);\n                    model.insertContent(writer.createText(replaceWith, attributes), replaceRange);\n                    changeIndex += replaceWith.length;\n                }\n                model.enqueueChange(() => {\n                    deletePlugin.requestUndoOnBackspace();\n                });\n            });\n        });\n        watcher.bind('isEnabled').to(this);\n    }\n}\n/**\n * Normalizes the configuration `from` parameter value.\n * The normalized value for the `from` parameter is a RegExp instance. If the passed `from` is already a RegExp instance,\n * it is returned unchanged.\n */\nfunction normalizeFrom(from) {\n    if (typeof from == 'string') {\n        return new RegExp(`(${escapeRegExp(from)})$`);\n    }\n    // `from` is already a regular expression.\n    return from;\n}\n/**\n * Normalizes the configuration `to` parameter value.\n * The normalized value for the `to` parameter is a function that takes an array and returns an array. See more in the\n * configuration description. If the passed `to` is already a function, it is returned unchanged.\n */\nfunction normalizeTo(to) {\n    if (typeof to == 'string') {\n        return () => [to];\n    }\n    else if (to instanceof Array) {\n        return () => to;\n    }\n    // `to` is already a function.\n    return to;\n}\n/**\n * For given `position` returns attributes for the text that is after that position.\n * The text can be in the same text node as the position (`foo[]bar`) or in the next text node (`foo[]<$text bold=\"true\">bar</$text>`).\n */\nfunction getTextAttributesAfterPosition(position) {\n    const textNode = position.textNode ? position.textNode : position.nodeAfter;\n    return textNode.getAttributes();\n}\n/**\n * Returns a RegExp pattern string that detects a sentence inside a quote.\n *\n * @param quoteCharacter The character to create a pattern for.\n */\nfunction buildQuotesRegExp(quoteCharacter) {\n    return new RegExp(`(^|\\\\s)(${quoteCharacter})([^${quoteCharacter}]*)(${quoteCharacter})$`);\n}\n/**\n * Reads text transformation config and returns normalized array of transformations objects.\n */\nfunction normalizeTransformations(config) {\n    const extra = config.extra || [];\n    const remove = config.remove || [];\n    const isNotRemoved = (transformation) => !remove.includes(transformation);\n    const configured = config.include.concat(extra).filter(isNotRemoved);\n    return expandGroupsAndRemoveDuplicates(configured)\n        .filter(isNotRemoved) // Filter out 'remove' transformations as they might be set in group.\n        .map(transformation => (typeof transformation == 'string' && TRANSFORMATIONS[transformation] ? TRANSFORMATIONS[transformation] : transformation))\n        // Filter out transformations set as string that has not been found.\n        .filter((transformation) => typeof transformation === 'object')\n        .map(transformation => ({\n        from: normalizeFrom(transformation.from),\n        to: normalizeTo(transformation.to)\n    }));\n}\n/**\n * Reads definitions and expands named groups if needed to transformation names.\n * This method also removes duplicated named transformations if any.\n */\nfunction expandGroupsAndRemoveDuplicates(definitions) {\n    // Set is using to make sure that transformation names are not duplicated.\n    const definedTransformations = new Set();\n    for (const transformationOrGroup of definitions) {\n        if (typeof transformationOrGroup == 'string' && TRANSFORMATION_GROUPS[transformationOrGroup]) {\n            for (const transformation of TRANSFORMATION_GROUPS[transformationOrGroup]) {\n                definedTransformations.add(transformation);\n            }\n        }\n        else {\n            definedTransformations.add(transformationOrGroup);\n        }\n    }\n    return Array.from(definedTransformations);\n}\n"],
  "mappings": "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",
  "names": ["count", "attributes"]
}
