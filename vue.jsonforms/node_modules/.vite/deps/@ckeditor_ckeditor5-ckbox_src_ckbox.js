import {
  FileRepository
} from "./chunk-P3DP7CWK.js";
import "./chunk-DEIZSOIF.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  ButtonView
} from "./chunk-SGTDNT4V.js";
import "./chunk-6LVMAMLV.js";
import {
  CKEditorError,
  Command,
  Plugin,
  Range,
  createElement,
  logError,
  toMap
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-ckbox/src/ckboxui.js
import browseFilesIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ckbox/theme/icons/browse-files.svg";
var CKBoxUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CKBoxUI";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const editor = this.editor;
    const command = editor.commands.get("ckbox");
    if (!command) {
      return;
    }
    const t = editor.t;
    const componentFactory = editor.ui.componentFactory;
    componentFactory.add("ckbox", (locale) => {
      const button = new ButtonView(locale);
      button.set({
        label: t("Open file manager"),
        icon: browseFilesIcon,
        tooltip: true
      });
      button.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
      button.on("execute", () => {
        editor.execute("ckbox");
      });
      return button;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ckbox/src/utils.js
function getImageUrls(imageUrls) {
  const responsiveUrls = [];
  let maxWidth = 0;
  for (const key in imageUrls) {
    const width = parseInt(key, 10);
    if (!isNaN(width)) {
      if (width > maxWidth) {
        maxWidth = width;
      }
      responsiveUrls.push(`${imageUrls[key]} ${key}w`);
    }
  }
  const imageSources = [{
    srcset: responsiveUrls.join(","),
    sizes: `(max-width: ${maxWidth}px) 100vw, ${maxWidth}px`,
    type: "image/webp"
  }];
  return {
    imageFallbackUrl: imageUrls.default,
    imageSources
  };
}
function getWorkspaceId(token, defaultWorkspaceId) {
  const [, binaryTokenPayload] = token.value.split(".");
  const payload = JSON.parse(atob(binaryTokenPayload));
  const workspaces = payload.auth && payload.auth.ckbox && payload.auth.ckbox.workspaces || [payload.aud];
  if (!defaultWorkspaceId) {
    return workspaces[0];
  }
  const role = payload.auth && payload.auth.ckbox && payload.auth.ckbox.role;
  if (role == "superadmin" || workspaces.includes(defaultWorkspaceId)) {
    return defaultWorkspaceId;
  }
  return null;
}

// node_modules/@ckeditor/ckeditor5-ckbox/src/ckboxcommand.js
var ASSET_INSERTION_WAIT_TIMEOUT = 1e3;
var CKBoxCommand = class extends Command {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._chosenAssets = /* @__PURE__ */ new Set();
    this._wrapper = null;
    this._initListeners();
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.value = this._getValue();
    this.isEnabled = this._checkEnabled();
  }
  /**
   * @inheritDoc
   */
  execute() {
    this.fire("ckbox:open");
  }
  /**
   * Indicates if the CKBox dialog is already opened.
   *
   * @protected
   * @returns {Boolean}
   */
  _getValue() {
    return this._wrapper !== null;
  }
  /**
   * Checks whether the command can be enabled in the current context.
   */
  _checkEnabled() {
    const imageCommand = this.editor.commands.get("insertImage");
    const linkCommand = this.editor.commands.get("link");
    if (!imageCommand.isEnabled && !linkCommand.isEnabled) {
      return false;
    }
    return true;
  }
  /**
   * Creates the options object for the CKBox dialog.
   *
   * @returns The object with properties:
   * - theme The theme for CKBox dialog.
   * - language The language for CKBox dialog.
   * - tokenUrl The token endpoint URL.
   * - serviceOrigin The base URL of the API service.
   * - dialog.onClose The callback function invoked after closing the CKBox dialog.
   * - assets.onChoose The callback function invoked after choosing the assets.
   */
  _prepareOptions() {
    const editor = this.editor;
    const ckboxConfig = editor.config.get("ckbox");
    return {
      theme: ckboxConfig.theme,
      language: ckboxConfig.language,
      tokenUrl: ckboxConfig.tokenUrl,
      serviceOrigin: ckboxConfig.serviceOrigin,
      dialog: {
        onClose: () => this.fire("ckbox:close")
      },
      assets: {
        onChoose: (assets) => this.fire("ckbox:choose", assets)
      }
    };
  }
  /**
   * Initializes various event listeners for the `ckbox:*` events, because all functionality of the `ckbox` command is event-based.
   */
  _initListeners() {
    const editor = this.editor;
    const model = editor.model;
    const shouldInsertDataId = !editor.config.get("ckbox.ignoreDataId");
    this.on("ckbox", () => {
      this.refresh();
    }, { priority: "low" });
    this.on("ckbox:open", () => {
      if (!this.isEnabled || this.value) {
        return;
      }
      this._wrapper = createElement(document, "div", { class: "ck ckbox-wrapper" });
      document.body.appendChild(this._wrapper);
      window.CKBox.mount(this._wrapper, this._prepareOptions());
      const MAX_NUMBER_OF_ATTEMPTS_TO_FOCUS = 50;
      focusCKBoxItem(MAX_NUMBER_OF_ATTEMPTS_TO_FOCUS);
    });
    this.on("ckbox:close", () => {
      if (!this.value) {
        return;
      }
      this._wrapper.remove();
      this._wrapper = null;
    });
    this.on("ckbox:choose", (evt, assets) => {
      if (!this.isEnabled) {
        return;
      }
      const imageCommand = editor.commands.get("insertImage");
      const linkCommand = editor.commands.get("link");
      const assetsToProcess = prepareAssets({
        assets,
        isImageAllowed: imageCommand.isEnabled,
        isLinkAllowed: linkCommand.isEnabled
      });
      if (assetsToProcess.length === 0) {
        return;
      }
      model.change((writer) => {
        for (const asset of assetsToProcess) {
          const isLastAsset = asset === assetsToProcess[assetsToProcess.length - 1];
          this._insertAsset(asset, isLastAsset, writer);
          if (shouldInsertDataId) {
            setTimeout(() => this._chosenAssets.delete(asset), ASSET_INSERTION_WAIT_TIMEOUT);
            this._chosenAssets.add(asset);
          }
        }
      });
    });
    this.listenTo(editor, "destroy", () => {
      this.fire("ckbox:close");
      this._chosenAssets.clear();
    });
  }
  /**
   * Inserts the asset into the model.
   *
   * @param asset The asset to be inserted.
   * @param isLastAsset Indicates if the current asset is the last one from the chosen set.
   * @param writer An instance of the model writer.
   */
  _insertAsset(asset, isLastAsset, writer) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    writer.removeSelectionAttribute("linkHref");
    if (asset.type === "image") {
      this._insertImage(asset);
    } else {
      this._insertLink(asset, writer);
    }
    if (!isLastAsset) {
      writer.setSelection(selection.getLastPosition());
    }
  }
  /**
   * Inserts the image by calling the `insertImage` command.
   *
   * @param asset The asset to be inserted.
   */
  _insertImage(asset) {
    const editor = this.editor;
    const { imageFallbackUrl, imageSources, imageTextAlternative } = asset.attributes;
    editor.execute("insertImage", {
      source: {
        src: imageFallbackUrl,
        sources: imageSources,
        alt: imageTextAlternative
      }
    });
  }
  /**
   * Inserts the link to the asset by calling the `link` command.
   *
   * @param asset The asset to be inserted.
   * @param writer An instance of the model writer.
   */
  _insertLink(asset, writer) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const { linkName, linkHref } = asset.attributes;
    if (selection.isCollapsed) {
      const selectionAttributes = toMap(selection.getAttributes());
      const textNode = writer.createText(linkName, selectionAttributes);
      const range = model.insertContent(textNode);
      writer.setSelection(range);
    }
    editor.execute("link", linkHref);
  }
};
function prepareAssets({ assets, isImageAllowed, isLinkAllowed }) {
  return assets.map((asset) => isImage(asset) ? {
    id: asset.data.id,
    type: "image",
    attributes: prepareImageAssetAttributes(asset)
  } : {
    id: asset.data.id,
    type: "link",
    attributes: prepareLinkAssetAttributes(asset)
  }).filter((asset) => asset.type === "image" ? isImageAllowed : isLinkAllowed);
}
function prepareImageAssetAttributes(asset) {
  const { imageFallbackUrl, imageSources } = getImageUrls(asset.data.imageUrls);
  return {
    imageFallbackUrl,
    imageSources,
    imageTextAlternative: asset.data.metadata.description || ""
  };
}
function prepareLinkAssetAttributes(asset) {
  return {
    linkName: asset.data.name,
    linkHref: getAssetUrl(asset)
  };
}
function isImage(asset) {
  const metadata = asset.data.metadata;
  if (!metadata) {
    return false;
  }
  return metadata.width && metadata.height;
}
function getAssetUrl(asset) {
  const url = new URL(asset.data.url);
  url.searchParams.set("download", "true");
  return url.toString();
}
function focusCKBoxItem(limiter) {
  setTimeout(() => {
    if (limiter === 0) {
      return;
    }
    const ckboxGalleryFirstItem = document.querySelector(".ckbox-gallery .ckbox-gallery-item");
    const uploadButton = document.querySelector(".ckbox-empty-view .ckbox-btn");
    if (uploadButton && uploadButton instanceof HTMLElement) {
      uploadButton.focus();
      return;
    }
    if (ckboxGalleryFirstItem && ckboxGalleryFirstItem instanceof HTMLElement) {
      ckboxGalleryFirstItem.focus();
    } else {
      focusCKBoxItem(limiter - 1);
    }
  }, 100);
}

// node_modules/@ckeditor/ckeditor5-ckbox/src/ckboxuploadadapter.js
var CKBoxUploadAdapter = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return ["ImageUploadEditing", "ImageUploadProgress", FileRepository, CKBoxEditing];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CKBoxUploadAdapter";
  }
  /**
   * @inheritDoc
   */
  async afterInit() {
    const editor = this.editor;
    const hasConfiguration = !!editor.config.get("ckbox");
    const isLibraryLoaded = !!window.CKBox;
    if (!hasConfiguration && !isLibraryLoaded) {
      return;
    }
    const fileRepository = editor.plugins.get(FileRepository);
    const ckboxEditing = editor.plugins.get(CKBoxEditing);
    fileRepository.createUploadAdapter = (loader) => {
      return new Adapter(loader, ckboxEditing.getToken(), editor);
    };
    const shouldInsertDataId = !editor.config.get("ckbox.ignoreDataId");
    const imageUploadEditing = editor.plugins.get("ImageUploadEditing");
    if (shouldInsertDataId) {
      imageUploadEditing.on("uploadComplete", (evt, { imageElement, data }) => {
        editor.model.change((writer) => {
          writer.setAttribute("ckboxImageId", data.ckboxImageId, imageElement);
        });
      });
    }
  }
};
var Adapter = class {
  /**
   * Creates a new adapter instance.
   */
  constructor(loader, token, editor) {
    this.loader = loader;
    this.token = token;
    this.editor = editor;
    this.controller = new AbortController();
    this.serviceOrigin = editor.config.get("ckbox.serviceOrigin");
  }
  /**
   * The ID of workspace to use.
   */
  getWorkspaceId() {
    const t = this.editor.t;
    const cannotAccessDefaultWorkspaceError = t("Cannot access default workspace.");
    const defaultWorkspaceId = this.editor.config.get("ckbox.defaultUploadWorkspaceId");
    const workspaceId = getWorkspaceId(this.token, defaultWorkspaceId);
    if (workspaceId == null) {
      logError("ckbox-access-default-workspace-error");
      throw cannotAccessDefaultWorkspaceError;
    }
    return workspaceId;
  }
  /**
   * Resolves a promise with an array containing available categories with which the uploaded file can be associated.
   *
   * If the API returns limited results, the method will collect all items.
   */
  async getAvailableCategories(offset = 0) {
    const ITEMS_PER_REQUEST = 50;
    const categoryUrl = new URL("categories", this.serviceOrigin);
    categoryUrl.searchParams.set("limit", ITEMS_PER_REQUEST.toString());
    categoryUrl.searchParams.set("offset", offset.toString());
    categoryUrl.searchParams.set("workspaceId", this.getWorkspaceId());
    return this._sendHttpRequest({ url: categoryUrl }).then(async (data) => {
      const remainingItems = data.totalCount - (offset + ITEMS_PER_REQUEST);
      if (remainingItems > 0) {
        const offsetItems = await this.getAvailableCategories(offset + ITEMS_PER_REQUEST);
        return [
          ...data.items,
          ...offsetItems
        ];
      }
      return data.items;
    }).catch(() => {
      this.controller.signal.throwIfAborted();
      logError("ckbox-fetch-category-http-error");
    });
  }
  /**
   * Resolves a promise with an object containing a category with which the uploaded file is associated or an error code.
   */
  async getCategoryIdForFile(file) {
    const extension = getFileExtension(file.name);
    const allCategories = await this.getAvailableCategories();
    if (!allCategories) {
      return null;
    }
    const defaultCategories = this.editor.config.get("ckbox.defaultUploadCategories");
    if (defaultCategories) {
      const userCategory = Object.keys(defaultCategories).find((category2) => {
        return defaultCategories[category2].find((e) => e.toLowerCase() == extension);
      });
      if (userCategory) {
        const serverCategory = allCategories.find((category2) => category2.id === userCategory || category2.name === userCategory);
        if (!serverCategory) {
          return null;
        }
        return serverCategory.id;
      }
    }
    const category = allCategories.find((category2) => category2.extensions.find((e) => e.toLowerCase() == extension));
    if (!category) {
      return null;
    }
    return category.id;
  }
  /**
   * Starts the upload process.
   *
   * @see module:upload/filerepository~UploadAdapter#upload
   */
  async upload() {
    const t = this.editor.t;
    const cannotFindCategoryError = t("Cannot determine a category for the uploaded file.");
    const file = await this.loader.file;
    const category = await this.getCategoryIdForFile(file);
    if (!category) {
      return Promise.reject(cannotFindCategoryError);
    }
    const uploadUrl = new URL("assets", this.serviceOrigin);
    const formData = new FormData();
    uploadUrl.searchParams.set("workspaceId", this.getWorkspaceId());
    formData.append("categoryId", category);
    formData.append("file", file);
    const requestConfig = {
      method: "POST",
      url: uploadUrl,
      data: formData,
      onUploadProgress: (evt) => {
        if (evt.lengthComputable) {
          this.loader.uploadTotal = evt.total;
          this.loader.uploaded = evt.loaded;
        }
      }
    };
    return this._sendHttpRequest(requestConfig).then(async (data) => {
      const imageUrls = getImageUrls(data.imageUrls);
      return {
        ckboxImageId: data.id,
        default: imageUrls.imageFallbackUrl,
        sources: imageUrls.imageSources
      };
    }).catch(() => {
      const genericError = t("Cannot upload file:") + ` ${file.name}.`;
      return Promise.reject(genericError);
    });
  }
  /**
   * Aborts the upload process.
   *
   * @see module:upload/filerepository~UploadAdapter#abort
   */
  abort() {
    this.controller.abort();
  }
  /**
   * Sends the HTTP request.
   *
   * @param config.url the URL where the request will be sent.
   * @param config.method The HTTP method.
   * @param config.data Additional data to send.
   * @param config.onUploadProgress A callback informing about the upload progress.
   */
  _sendHttpRequest({ url, method = "GET", data, onUploadProgress }) {
    const signal = this.controller.signal;
    const xhr = new XMLHttpRequest();
    xhr.open(method, url.toString(), true);
    xhr.setRequestHeader("Authorization", this.token.value);
    xhr.setRequestHeader("CKBox-Version", "CKEditor 5");
    xhr.responseType = "json";
    const abortCallback = () => {
      xhr.abort();
    };
    return new Promise((resolve, reject) => {
      signal.addEventListener("abort", abortCallback);
      xhr.addEventListener("loadstart", () => {
        signal.addEventListener("abort", abortCallback);
      });
      xhr.addEventListener("loadend", () => {
        signal.removeEventListener("abort", abortCallback);
      });
      xhr.addEventListener("error", () => {
        reject();
      });
      xhr.addEventListener("abort", () => {
        reject();
      });
      xhr.addEventListener("load", async () => {
        const response = xhr.response;
        if (!response || response.statusCode >= 400) {
          return reject(response && response.message);
        }
        return resolve(response);
      });
      if (onUploadProgress) {
        xhr.upload.addEventListener("progress", (evt) => {
          onUploadProgress(evt);
        });
      }
      xhr.send(data);
    });
  }
};
function getFileExtension(value) {
  const extensionRegExp = /\.(?<ext>[^.]+)$/;
  const match = value.match(extensionRegExp);
  return match.groups.ext.toLowerCase();
}

// node_modules/@ckeditor/ckeditor5-ckbox/src/ckboxediting.js
var CKBoxEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CKBoxEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return ["CloudServices", "LinkEditing", "PictureEditing", CKBoxUploadAdapter];
  }
  /**
   * @inheritDoc
   */
  async init() {
    const editor = this.editor;
    const hasConfiguration = !!editor.config.get("ckbox");
    const isLibraryLoaded = !!window.CKBox;
    if (!hasConfiguration && !isLibraryLoaded) {
      return;
    }
    this._initConfig();
    const cloudServicesCore = editor.plugins.get("CloudServicesCore");
    const ckboxTokenUrl = editor.config.get("ckbox.tokenUrl");
    const cloudServicesTokenUrl = editor.config.get("cloudServices.tokenUrl");
    if (ckboxTokenUrl === cloudServicesTokenUrl) {
      const cloudServices = editor.plugins.get("CloudServices");
      this._token = cloudServices.token;
    } else {
      this._token = await cloudServicesCore.createToken(ckboxTokenUrl).init();
    }
    if (!editor.config.get("ckbox.ignoreDataId")) {
      this._initSchema();
      this._initConversion();
      this._initFixers();
    }
    if (isLibraryLoaded) {
      editor.commands.add("ckbox", new CKBoxCommand(editor));
    }
  }
  /**
   * Returns a token used by the CKBox plugin for communication with the CKBox service.
   */
  getToken() {
    return this._token;
  }
  /**
   * Initializes the `ckbox` editor configuration.
   */
  _initConfig() {
    const editor = this.editor;
    editor.config.define("ckbox", {
      serviceOrigin: "https://api.ckbox.io",
      defaultUploadCategories: null,
      ignoreDataId: false,
      language: editor.locale.uiLanguage,
      theme: "default",
      tokenUrl: editor.config.get("cloudServices.tokenUrl")
    });
    const tokenUrl = editor.config.get("ckbox.tokenUrl");
    if (!tokenUrl) {
      throw new CKEditorError("ckbox-plugin-missing-token-url", this);
    }
    if (!editor.plugins.has("ImageBlockEditing") && !editor.plugins.has("ImageInlineEditing")) {
      logError("ckbox-plugin-image-feature-missing", editor);
    }
  }
  /**
   * Extends the schema to allow the `ckboxImageId` and `ckboxLinkId` attributes for links and images.
   */
  _initSchema() {
    const editor = this.editor;
    const schema = editor.model.schema;
    schema.extend("$text", { allowAttributes: "ckboxLinkId" });
    if (schema.isRegistered("imageBlock")) {
      schema.extend("imageBlock", { allowAttributes: ["ckboxImageId", "ckboxLinkId"] });
    }
    if (schema.isRegistered("imageInline")) {
      schema.extend("imageInline", { allowAttributes: ["ckboxImageId", "ckboxLinkId"] });
    }
    schema.addAttributeCheck((context, attributeName) => {
      const isLink = !!context.last.getAttribute("linkHref");
      if (!isLink && attributeName === "ckboxLinkId") {
        return false;
      }
    });
  }
  /**
   * Configures the upcast and downcast conversions for the `ckboxImageId` and `ckboxLinkId` attributes.
   */
  _initConversion() {
    const editor = this.editor;
    editor.conversion.for("downcast").add((dispatcher) => {
      dispatcher.on("attribute:ckboxLinkId:imageBlock", (evt, data, conversionApi) => {
        const { writer, mapper, consumable } = conversionApi;
        if (!consumable.consume(data.item, evt.name)) {
          return;
        }
        const viewFigure = mapper.toViewElement(data.item);
        const linkInImage = [...viewFigure.getChildren()].find((child) => child.name === "a");
        if (!linkInImage) {
          return;
        }
        if (data.item.hasAttribute("ckboxLinkId")) {
          writer.setAttribute("data-ckbox-resource-id", data.item.getAttribute("ckboxLinkId"), linkInImage);
        } else {
          writer.removeAttribute("data-ckbox-resource-id", linkInImage);
        }
      }, { priority: "low" });
      dispatcher.on("attribute:ckboxLinkId", (evt, data, conversionApi) => {
        const { writer, mapper, consumable } = conversionApi;
        if (!consumable.consume(data.item, evt.name)) {
          return;
        }
        if (data.attributeOldValue) {
          const viewElement = createLinkElement(writer, data.attributeOldValue);
          writer.unwrap(mapper.toViewRange(data.range), viewElement);
        }
        if (data.attributeNewValue) {
          const viewElement = createLinkElement(writer, data.attributeNewValue);
          if (data.item.is("selection")) {
            const viewSelection = writer.document.selection;
            writer.wrap(viewSelection.getFirstRange(), viewElement);
          } else {
            writer.wrap(mapper.toViewRange(data.range), viewElement);
          }
        }
      }, { priority: "low" });
    });
    editor.conversion.for("upcast").add((dispatcher) => {
      dispatcher.on("element:a", (evt, data, conversionApi) => {
        const { writer, consumable } = conversionApi;
        if (!data.viewItem.getAttribute("href")) {
          return;
        }
        const consumableAttributes = { attributes: ["data-ckbox-resource-id"] };
        if (!consumable.consume(data.viewItem, consumableAttributes)) {
          return;
        }
        const attributeValue = data.viewItem.getAttribute("data-ckbox-resource-id");
        if (!attributeValue) {
          return;
        }
        if (data.modelRange) {
          for (let item of data.modelRange.getItems()) {
            if (item.is("$textProxy")) {
              item = item.textNode;
            }
            if (shouldUpcastAttributeForNode(item)) {
              writer.setAttribute("ckboxLinkId", attributeValue, item);
            }
          }
        } else {
          const modelElement = data.modelCursor.nodeBefore || data.modelCursor.parent;
          writer.setAttribute("ckboxLinkId", attributeValue, modelElement);
        }
      }, { priority: "low" });
    });
    editor.conversion.for("downcast").attributeToAttribute({
      model: "ckboxImageId",
      view: "data-ckbox-resource-id"
    });
    editor.conversion.for("upcast").elementToAttribute({
      model: {
        key: "ckboxImageId",
        value: (viewElement) => viewElement.getAttribute("data-ckbox-resource-id")
      },
      view: {
        attributes: {
          "data-ckbox-resource-id": /[\s\S]+/
        }
      }
    });
  }
  /**
   * Registers post-fixers that add or remove the `ckboxLinkId` and `ckboxImageId` attributes.
   */
  _initFixers() {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    model.document.registerPostFixer(syncDataIdPostFixer(editor));
    model.document.registerPostFixer(injectSelectionPostFixer(selection));
  }
};
function syncDataIdPostFixer(editor) {
  return (writer) => {
    let changed = false;
    const model = editor.model;
    const ckboxCommand = editor.commands.get("ckbox");
    if (!ckboxCommand) {
      return changed;
    }
    for (const entry of model.document.differ.getChanges()) {
      if (entry.type !== "insert" && entry.type !== "attribute") {
        continue;
      }
      const range = entry.type === "insert" ? new Range(entry.position, entry.position.getShiftedBy(entry.length)) : entry.range;
      const isLinkHrefAttributeRemoval = entry.type === "attribute" && entry.attributeKey === "linkHref" && entry.attributeNewValue === null;
      for (const item of range.getItems()) {
        if (isLinkHrefAttributeRemoval && item.hasAttribute("ckboxLinkId")) {
          writer.removeAttribute("ckboxLinkId", item);
          changed = true;
          continue;
        }
        const assets = findAssetsForItem(item, ckboxCommand._chosenAssets);
        for (const asset of assets) {
          const attributeName = asset.type === "image" ? "ckboxImageId" : "ckboxLinkId";
          if (asset.id === item.getAttribute(attributeName)) {
            continue;
          }
          writer.setAttribute(attributeName, asset.id, item);
          changed = true;
        }
      }
    }
    return changed;
  };
}
function injectSelectionPostFixer(selection) {
  return (writer) => {
    const shouldRemoveLinkIdAttribute = !selection.hasAttribute("linkHref") && selection.hasAttribute("ckboxLinkId");
    if (shouldRemoveLinkIdAttribute) {
      writer.removeSelectionAttribute("ckboxLinkId");
      return true;
    }
    return false;
  };
}
function findAssetsForItem(item, assets) {
  const isImageElement = item.is("element", "imageInline") || item.is("element", "imageBlock");
  const isLinkElement = item.hasAttribute("linkHref");
  return [...assets].filter((asset) => {
    if (asset.type === "image" && isImageElement) {
      return asset.attributes.imageFallbackUrl === item.getAttribute("src");
    }
    if (asset.type === "link" && isLinkElement) {
      return asset.attributes.linkHref === item.getAttribute("linkHref");
    }
  });
}
function createLinkElement(writer, id) {
  const viewElement = writer.createAttributeElement("a", { "data-ckbox-resource-id": id }, { priority: 5 });
  writer.setCustomProperty("link", true, viewElement);
  return viewElement;
}
function shouldUpcastAttributeForNode(node) {
  if (node.is("$text")) {
    return true;
  }
  if (node.is("element", "imageInline") || node.is("element", "imageBlock")) {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-ckbox/src/ckbox.js
var CKBox = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "CKBox";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [CKBoxEditing, CKBoxUI];
  }
};
export {
  CKBox as default
};
/*! Bundled license information:

@ckeditor/ckeditor5-ckbox/src/ckboxui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ckbox/src/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ckbox/src/ckboxcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ckbox/src/ckboxuploadadapter.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-ckbox/src/ckboxediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ckbox/src/ckbox.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-ckbox_src_ckbox.js.map
