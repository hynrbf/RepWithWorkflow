import {
  Enter
} from "./chunk-GGCPNJOL.js";
import {
  BalloonPanelView,
  ContextualBalloon,
  IconView,
  Template,
  ToolbarView,
  View
} from "./chunk-SGTDNT4V.js";
import {
  Delete
} from "./chunk-4MFML76R.js";
import {
  CKEditorError,
  DomEmitterMixin,
  EmitterMixin,
  MouseObserver,
  ObservableMixin,
  Plugin,
  Rect,
  compareArrays,
  env_default,
  findOptimalInsertionRange,
  getLocalizedArrowKeyCodeDirection,
  global_default,
  isForwardArrowKeyCode,
  keyCodes,
  logWarning,
  toArray
} from "./chunk-JI2V5GJZ.js";
import {
  throttle_default
} from "./chunk-6DXDGCMU.js";

// node_modules/@ckeditor/ckeditor5-widget/src/highlightstack.js
var HighlightStack = class extends EmitterMixin() {
  constructor() {
    super(...arguments);
    this._stack = [];
  }
  /**
   * Adds highlight descriptor to the stack.
   *
   * @fires change:top
   */
  add(descriptor, writer) {
    const stack = this._stack;
    const oldTop = stack[0];
    this._insertDescriptor(descriptor);
    const newTop = stack[0];
    if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
      this.fire("change:top", {
        oldDescriptor: oldTop,
        newDescriptor: newTop,
        writer
      });
    }
  }
  /**
   * Removes highlight descriptor from the stack.
   *
   * @fires change:top
   * @param id Id of the descriptor to remove.
   */
  remove(id, writer) {
    const stack = this._stack;
    const oldTop = stack[0];
    this._removeDescriptor(id);
    const newTop = stack[0];
    if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
      this.fire("change:top", {
        oldDescriptor: oldTop,
        newDescriptor: newTop,
        writer
      });
    }
  }
  /**
   * Inserts a given descriptor in correct place in the stack. It also takes care about updating information
   * when descriptor with same id is already present.
   */
  _insertDescriptor(descriptor) {
    const stack = this._stack;
    const index = stack.findIndex((item) => item.id === descriptor.id);
    if (compareDescriptors(descriptor, stack[index])) {
      return;
    }
    if (index > -1) {
      stack.splice(index, 1);
    }
    let i = 0;
    while (stack[i] && shouldABeBeforeB(stack[i], descriptor)) {
      i++;
    }
    stack.splice(i, 0, descriptor);
  }
  /**
   * Removes descriptor with given id from the stack.
   *
   * @param id Descriptor's id.
   */
  _removeDescriptor(id) {
    const stack = this._stack;
    const index = stack.findIndex((item) => item.id === id);
    if (index > -1) {
      stack.splice(index, 1);
    }
  }
};
function compareDescriptors(a, b) {
  return a && b && a.priority == b.priority && classesToString(a.classes) == classesToString(b.classes);
}
function shouldABeBeforeB(a, b) {
  if (a.priority > b.priority) {
    return true;
  } else if (a.priority < b.priority) {
    return false;
  }
  return classesToString(a.classes) > classesToString(b.classes);
}
function classesToString(classes) {
  return Array.isArray(classes) ? classes.sort().join(",") : classes;
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgettypearound/utils.js
var TYPE_AROUND_SELECTION_ATTRIBUTE = "widget-type-around";
function isTypeAroundWidget(viewElement, modelElement, schema) {
  return !!viewElement && isWidget(viewElement) && !schema.isInline(modelElement);
}
function getClosestTypeAroundDomButton(domElement) {
  return domElement.closest(".ck-widget__type-around__button");
}
function getTypeAroundButtonPosition(domElement) {
  return domElement.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
}
function getClosestWidgetViewElement(domElement, domConverter) {
  const widgetDomElement = domElement.closest(".ck-widget");
  return domConverter.mapDomToView(widgetDomElement);
}
function getTypeAroundFakeCaretPosition(selection) {
  return selection.getAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
}

// node_modules/@ckeditor/ckeditor5-widget/src/utils.js
import dragHandleIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-widget/theme/icons/drag-handle.svg";
var WIDGET_CLASS_NAME = "ck-widget";
var WIDGET_SELECTED_CLASS_NAME = "ck-widget_selected";
function isWidget(node) {
  if (!node.is("element")) {
    return false;
  }
  return !!node.getCustomProperty("widget");
}
function toWidget(element, writer, options = {}) {
  if (!element.is("containerElement")) {
    throw new CKEditorError("widget-to-widget-wrong-element-type", null, { element });
  }
  writer.setAttribute("contenteditable", "false", element);
  writer.addClass(WIDGET_CLASS_NAME, element);
  writer.setCustomProperty("widget", true, element);
  element.getFillerOffset = getFillerOffset;
  writer.setCustomProperty("widgetLabel", [], element);
  if (options.label) {
    setLabel(element, options.label);
  }
  if (options.hasSelectionHandle) {
    addSelectionHandle(element, writer);
  }
  setHighlightHandling(element, writer);
  return element;
}
function addHighlight(element, descriptor, writer) {
  if (descriptor.classes) {
    writer.addClass(toArray(descriptor.classes), element);
  }
  if (descriptor.attributes) {
    for (const key in descriptor.attributes) {
      writer.setAttribute(key, descriptor.attributes[key], element);
    }
  }
}
function removeHighlight(element, descriptor, writer) {
  if (descriptor.classes) {
    writer.removeClass(toArray(descriptor.classes), element);
  }
  if (descriptor.attributes) {
    for (const key in descriptor.attributes) {
      writer.removeAttribute(key, element);
    }
  }
}
function setHighlightHandling(element, writer, add = addHighlight, remove = removeHighlight) {
  const stack = new HighlightStack();
  stack.on("change:top", (evt, data) => {
    if (data.oldDescriptor) {
      remove(element, data.oldDescriptor, data.writer);
    }
    if (data.newDescriptor) {
      add(element, data.newDescriptor, data.writer);
    }
  });
  const addHighlightCallback = (element2, descriptor, writer2) => stack.add(descriptor, writer2);
  const removeHighlightCallback = (element2, id, writer2) => stack.remove(id, writer2);
  writer.setCustomProperty("addHighlight", addHighlightCallback, element);
  writer.setCustomProperty("removeHighlight", removeHighlightCallback, element);
}
function setLabel(element, labelOrCreator) {
  const widgetLabel = element.getCustomProperty("widgetLabel");
  widgetLabel.push(labelOrCreator);
}
function getLabel(element) {
  const widgetLabel = element.getCustomProperty("widgetLabel");
  return widgetLabel.reduce((prev, current) => {
    if (typeof current === "function") {
      return prev ? prev + ". " + current() : current();
    } else {
      return prev ? prev + ". " + current : current;
    }
  }, "");
}
function toWidgetEditable(editable, writer, options = {}) {
  writer.addClass(["ck-editor__editable", "ck-editor__nested-editable"], editable);
  writer.setAttribute("role", "textbox", editable);
  if (options.label) {
    writer.setAttribute("aria-label", options.label, editable);
  }
  writer.setAttribute("contenteditable", editable.isReadOnly ? "false" : "true", editable);
  editable.on("change:isReadOnly", (evt, property, is) => {
    writer.setAttribute("contenteditable", is ? "false" : "true", editable);
  });
  editable.on("change:isFocused", (evt, property, is) => {
    if (is) {
      writer.addClass("ck-editor__nested-editable_focused", editable);
    } else {
      writer.removeClass("ck-editor__nested-editable_focused", editable);
    }
  });
  setHighlightHandling(editable, writer);
  return editable;
}
function findOptimalInsertionRange2(selection, model) {
  const selectedElement = selection.getSelectedElement();
  if (selectedElement) {
    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(selection);
    if (typeAroundFakeCaretPosition) {
      return model.createRange(model.createPositionAt(selectedElement, typeAroundFakeCaretPosition));
    }
  }
  return findOptimalInsertionRange(selection, model);
}
function getFillerOffset() {
  return null;
}
function addSelectionHandle(widgetElement, writer) {
  const selectionHandle = writer.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(domDocument) {
    const domElement = this.toDomElement(domDocument);
    const icon = new IconView();
    icon.set("content", dragHandleIcon);
    icon.render();
    domElement.appendChild(icon.element);
    return domElement;
  });
  writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandle);
  writer.addClass(["ck-widget_with-selection-handle"], widgetElement);
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js
import returnIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-widget/theme/icons/return-arrow.svg";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css";
var POSSIBLE_INSERTION_POSITIONS = ["before", "after"];
var RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, "image/svg+xml").firstChild;
var PLUGIN_DISABLED_EDITING_ROOT_CLASS = "ck-widget__type-around_disabled";
var WidgetTypeAround = class extends Plugin {
  constructor() {
    super(...arguments);
    this._currentFakeCaretModelElement = null;
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetTypeAround";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Enter, Delete];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    this.on("change:isEnabled", (evt, data, isEnabled) => {
      editingView.change((writer) => {
        for (const root of editingView.document.roots) {
          if (isEnabled) {
            writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);
          } else {
            writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);
          }
        }
      });
      if (!isEnabled) {
        editor.model.change((writer) => {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
        });
      }
    });
    this._enableTypeAroundUIInjection();
    this._enableInsertingParagraphsOnButtonClick();
    this._enableInsertingParagraphsOnEnterKeypress();
    this._enableInsertingParagraphsOnTypingKeystroke();
    this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
    this._enableDeleteIntegration();
    this._enableInsertContentIntegration();
    this._enableInsertObjectIntegration();
    this._enableDeleteContentIntegration();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this._currentFakeCaretModelElement = null;
  }
  /**
   * Inserts a new paragraph next to a widget element with the selection anchored in it.
   *
   * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll
   * the viewport to the selection in the inserted paragraph.
   *
   * @param widgetModelElement The model widget element next to which a paragraph is inserted.
   * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.
   */
  _insertParagraph(widgetModelElement, position) {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const attributesToCopy = editor.model.schema.getAttributesWithProperty(widgetModelElement, "copyOnReplace", true);
    editor.execute("insertParagraph", {
      position: editor.model.createPositionAt(widgetModelElement, position),
      attributes: attributesToCopy
    });
    editingView.focus();
    editingView.scrollToTheSelection();
  }
  /**
   * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only
   * when the plugin {@link #isEnabled is enabled}.
   *
   * @param emitter The object that fires the event.
   * @param event The name of the event.
   * @param callback The function to be called on event.
   * @param options Additional options.
   * @param options.priority The priority of this event callback. The higher the priority value the sooner
   * the callback will be fired. Events having the same priority are called in the order they were added.
   */
  _listenToIfEnabled(emitter, event, callback, options) {
    this.listenTo(emitter, event, (...args) => {
      if (this.isEnabled) {
        callback(...args);
      }
    }, options);
  }
  /**
   * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it
   * does not expect a position. Instead, it performs the insertion next to a selected widget
   * according to the `widget-type-around` model selection attribute value (fake caret position).
   *
   * Because this method requires the `widget-type-around` attribute to be set,
   * the insertion can only happen when the widget's fake caret is active (e.g. activated
   * using the keyboard).
   *
   * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.
   */
  _insertParagraphAccordingToFakeCaretPosition() {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
    if (!typeAroundFakeCaretPosition) {
      return false;
    }
    const selectedModelElement = modelSelection.getSelectedElement();
    this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);
    return true;
  }
  /**
   * Creates a listener in the editing conversion pipeline that injects the widget type around
   * UI into every single widget instance created in the editor.
   *
   * The UI is delivered as a {@link module:engine/view/uielement~UIElement}
   * wrapper which renders DOM buttons that users can use to insert paragraphs.
   */
  _enableTypeAroundUIInjection() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const t = editor.locale.t;
    const buttonTitles = {
      before: t("Insert paragraph before block"),
      after: t("Insert paragraph after block")
    };
    editor.editing.downcastDispatcher.on("insert", (evt, data, conversionApi) => {
      const viewElement = conversionApi.mapper.toViewElement(data.item);
      if (!viewElement) {
        return;
      }
      if (isTypeAroundWidget(viewElement, data.item, schema)) {
        injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);
        const widgetLabel = viewElement.getCustomProperty("widgetLabel");
        widgetLabel.push(() => {
          return this.isEnabled ? t("Press Enter to type after or press Shift + Enter to type before the widget") : "";
        });
      }
    }, { priority: "low" });
  }
  /**
   * Brings support for the fake caret that appears when either:
   *
   * * the selection moves to a widget from a position next to it using arrow keys,
   * * the arrow key is pressed when the widget is already selected.
   *
   * The fake caret lets the user know that they can start typing or just press
   * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.
   *
   * The fake caret disappears when the user changes the selection or the editor
   * gets blurred.
   *
   * The whole idea is as follows:
   *
   * 1. A user does one of the 2 scenarios described at the beginning.
   * 2. The "keydown" listener is executed and the decision is made whether to show or hide the fake caret.
   * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating
   *    on which side of the widget it should appear.
   * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the
   *    fake caret on the view widget.
   * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher
   *    does the CSS class clean-up in the view.
   * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection
   *    attribute (the former also removes widget CSS classes).
   */
  _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const schema = model.schema;
    const editingView = editor.editing.view;
    this._listenToIfEnabled(editingView.document, "arrowKey", (evt, domEventData) => {
      this._handleArrowKeyPress(evt, domEventData);
    }, { context: [isWidget, "$text"], priority: "high" });
    this._listenToIfEnabled(modelSelection, "change:range", (evt, data) => {
      if (!data.directChange) {
        return;
      }
      editor.model.change((writer) => {
        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
      });
    });
    this._listenToIfEnabled(model.document, "change:data", () => {
      const selectedModelElement = modelSelection.getSelectedElement();
      if (selectedModelElement) {
        const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
          return;
        }
      }
      editor.model.change((writer) => {
        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
      });
    });
    this._listenToIfEnabled(editor.editing.downcastDispatcher, "selection", (evt, data, conversionApi) => {
      const writer = conversionApi.writer;
      if (this._currentFakeCaretModelElement) {
        const selectedViewElement2 = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);
        if (selectedViewElement2) {
          writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement2);
          this._currentFakeCaretModelElement = null;
        }
      }
      const selectedModelElement = data.selection.getSelectedElement();
      if (!selectedModelElement) {
        return;
      }
      const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);
      if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement);
      this._currentFakeCaretModelElement = selectedModelElement;
    });
    this._listenToIfEnabled(editor.ui.focusTracker, "change:isFocused", (evt, name, isFocused) => {
      if (!isFocused) {
        editor.model.change((writer) => {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
        });
      }
    });
    function positionToWidgetCssClass(position) {
      return `ck-widget_type-around_show-fake-caret_${position}`;
    }
  }
  /**
   * A listener executed on each "keydown" in the view document, a part of
   * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.
   *
   * It decides whether the arrow keypress should activate the fake caret or not (also whether it should
   * be deactivated).
   *
   * The fake caret activation is done by setting the `widget-type-around` model selection attribute
   * in this listener, and stopping and preventing the event that would normally be handled by the widget
   * plugin that is responsible for the regular keyboard navigation near/across all widgets (that
   * includes inline widgets, which are ignored by the widget type around plugin).
   */
  _handleArrowKeyPress(evt, domEventData) {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const schema = model.schema;
    const editingView = editor.editing.view;
    const keyCode = domEventData.keyCode;
    const isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);
    const selectedViewElement = editingView.document.selection.getSelectedElement();
    const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);
    let shouldStopAndPreventDefault;
    if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
      shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);
    } else if (modelSelection.isCollapsed) {
      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);
    } else if (!domEventData.shiftKey) {
      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);
    }
    if (shouldStopAndPreventDefault) {
      domEventData.preventDefault();
      evt.stop();
    }
  }
  /**
   * Handles the keyboard navigation on "keydown" when a widget is currently selected and activates or deactivates
   * the fake caret for that widget, depending on the current value of the `widget-type-around` model
   * selection attribute and the direction of the pressed arrow key.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressOnSelectedWidget(isForward) {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
    return model.change((writer) => {
      if (typeAroundFakeCaretPosition) {
        const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? "after" : "before");
        if (!isLeavingWidget) {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
          return true;
        }
      } else {
        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
        return true;
      }
      return false;
    });
  }
  /**
   * Handles the keyboard navigation on "keydown" when **no** widget is selected but the selection is **directly** next
   * to one and upon the fake caret should become active for this widget upon arrow keypress
   * (AKA entering/selecting the widget).
   *
   * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.
   * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the
   * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {
    const editor = this.editor;
    const model = editor.model;
    const schema = model.schema;
    const widgetPlugin = editor.plugins.get("Widget");
    const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);
    const viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);
    if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {
      model.change((writer) => {
        widgetPlugin._setSelectionOverElement(modelElementNextToSelection);
        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "before" : "after");
      });
      return true;
    }
    return false;
  }
  /**
   * Handles the keyboard navigation on "keydown" when a widget is currently selected (together with some other content)
   * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {
    const editor = this.editor;
    const model = editor.model;
    const schema = model.schema;
    const mapper = editor.editing.mapper;
    const modelSelection = model.document.selection;
    const selectedModelNode = isForward ? modelSelection.getLastPosition().nodeBefore : modelSelection.getFirstPosition().nodeAfter;
    const selectedViewNode = mapper.toViewElement(selectedModelNode);
    if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {
      model.change((writer) => {
        writer.setSelection(selectedModelNode, "on");
        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
      });
      return true;
    }
    return false;
  }
  /**
   * Registers a `mousedown` listener for the view document which intercepts events
   * coming from the widget type around UI, which happens when a user clicks one of the buttons
   * that insert a paragraph next to a widget.
   */
  _enableInsertingParagraphsOnButtonClick() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    this._listenToIfEnabled(editingView.document, "mousedown", (evt, domEventData) => {
      const button = getClosestTypeAroundDomButton(domEventData.domTarget);
      if (!button) {
        return;
      }
      const buttonPosition = getTypeAroundButtonPosition(button);
      const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);
      const widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);
      this._insertParagraph(widgetModelElement, buttonPosition);
      domEventData.preventDefault();
      evt.stop();
    });
  }
  /**
   * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph
   * near the widget when either:
   *
   * * The fake caret was first activated using the arrow keys,
   * * The entire widget is selected in the model.
   *
   * In the first case, the new paragraph is inserted according to the `widget-type-around` selection
   * attribute (see {@link #_handleArrowKeyPress}).
   *
   * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke
   * was pressed or not.
   */
  _enableInsertingParagraphsOnEnterKeypress() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const editingView = editor.editing.view;
    this._listenToIfEnabled(editingView.document, "enter", (evt, domEventData) => {
      if (evt.eventPhase != "atTarget") {
        return;
      }
      const selectedModelElement = selection.getSelectedElement();
      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
      const schema = editor.model.schema;
      let wasHandled;
      if (this._insertParagraphAccordingToFakeCaretPosition()) {
        wasHandled = true;
      } else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
        this._insertParagraph(selectedModelElement, domEventData.isSoft ? "before" : "after");
        wasHandled = true;
      }
      if (wasHandled) {
        domEventData.preventDefault();
        evt.stop();
      }
    }, { context: isWidget });
  }
  /**
   * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user
   * to insert a paragraph next to a widget when the fake caret was activated using arrow
   * keys but it responds to typing instead of <kbd>Enter</kbd>.
   *
   * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`
   * model selection attribute as the user simply starts typing, which creates the impression that the fake caret
   * behaves like a real one rendered by the browser (AKA your text appears where the caret was).
   *
   * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command
   * and another one for actual typing. It is not a disaster but this may need to be fixed
   * sooner or later.
   */
  _enableInsertingParagraphsOnTypingKeystroke() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    this._listenToIfEnabled(viewDocument, "insertText", (evt, data) => {
      if (this._insertParagraphAccordingToFakeCaretPosition()) {
        data.selection = viewDocument.selection;
      }
    }, { priority: "high" });
    if (env_default.isAndroid) {
      this._listenToIfEnabled(viewDocument, "keydown", (evt, data) => {
        if (data.keyCode == 229) {
          this._insertParagraphAccordingToFakeCaretPosition();
        }
      });
    } else {
      this._listenToIfEnabled(viewDocument, "compositionstart", () => {
        this._insertParagraphAccordingToFakeCaretPosition();
      }, { priority: "high" });
    }
  }
  /**
   * It creates a "delete" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>
   * is pressed and the fake caret is currently active.
   *
   * The fake caret should create an illusion of a real browser caret so that when it appears before or after
   * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content
   * before or after a widget (depending on the content surrounding the widget).
   */
  _enableDeleteIntegration() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const model = editor.model;
    const schema = model.schema;
    this._listenToIfEnabled(editingView.document, "delete", (evt, domEventData) => {
      if (evt.eventPhase != "atTarget") {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      const direction = domEventData.direction;
      const selectedModelWidget = model.document.selection.getSelectedElement();
      const isFakeCaretBefore = typeAroundFakeCaretPosition === "before";
      const isDeleteForward = direction == "forward";
      const shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;
      if (shouldDeleteEntireWidget) {
        editor.execute("delete", {
          selection: model.createSelection(selectedModelWidget, "on")
        });
      } else {
        const range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction);
        if (range) {
          if (!range.isCollapsed) {
            model.change((writer) => {
              writer.setSelection(range);
              editor.execute(isDeleteForward ? "deleteForward" : "delete");
            });
          } else {
            const probe = model.createSelection(range.start);
            model.modifySelection(probe, { direction });
            if (!probe.focus.isEqual(range.start)) {
              model.change((writer) => {
                writer.setSelection(range);
                editor.execute(isDeleteForward ? "deleteForward" : "delete");
              });
            } else {
              const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);
              model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, "on"), {
                doNotAutoparagraph: true
              });
            }
          }
        }
      }
      domEventData.preventDefault();
      evt.stop();
    }, { context: isWidget });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste
   * content near a widget when the fake caret is first activated using the arrow keys.
   *
   * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
   */
  _enableInsertContentIntegration() {
    const editor = this.editor;
    const model = this.editor.model;
    const documentSelection = model.document.selection;
    this._listenToIfEnabled(editor.model, "insertContent", (evt, [content, selectable]) => {
      if (selectable && !selectable.is("documentSelection")) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      evt.stop();
      return model.change((writer) => {
        const selectedElement = documentSelection.getSelectedElement();
        const position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);
        const selection = writer.createSelection(position);
        const result = model.insertContent(content, selection);
        writer.setSelection(selection);
        return result;
      });
    }, { priority: "high" });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the
   * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element
   * to reflect user's intent of desired insertion position.
   *
   * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
   */
  _enableInsertObjectIntegration() {
    const editor = this.editor;
    const model = this.editor.model;
    const documentSelection = model.document.selection;
    this._listenToIfEnabled(editor.model, "insertObject", (evt, args) => {
      const [, selectable, options = {}] = args;
      if (selectable && !selectable.is("documentSelection")) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      options.findOptimalPosition = typeAroundFakeCaretPosition;
      args[3] = options;
    }, { priority: "high" });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake
   * caret is active.
   *
   * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}
   * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,
   * plain text pasting.
   */
  _enableDeleteContentIntegration() {
    const editor = this.editor;
    const model = this.editor.model;
    const documentSelection = model.document.selection;
    this._listenToIfEnabled(editor.model, "deleteContent", (evt, [selection]) => {
      if (selection && !selection.is("documentSelection")) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
      if (typeAroundFakeCaretPosition) {
        evt.stop();
      }
    }, { priority: "high" });
  }
};
function injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {
  const typeAroundWrapper = viewWriter.createUIElement("div", {
    class: "ck ck-reset_all ck-widget__type-around"
  }, function(domDocument) {
    const wrapperDomElement = this.toDomElement(domDocument);
    injectButtons(wrapperDomElement, buttonTitles);
    injectFakeCaret(wrapperDomElement);
    return wrapperDomElement;
  });
  viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, "end"), typeAroundWrapper);
}
function injectButtons(wrapperDomElement, buttonTitles) {
  for (const position of POSSIBLE_INSERTION_POSITIONS) {
    const buttonTemplate = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-widget__type-around__button",
          `ck-widget__type-around__button_${position}`
        ],
        title: buttonTitles[position],
        "aria-hidden": "true"
      },
      children: [
        wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)
      ]
    });
    wrapperDomElement.appendChild(buttonTemplate.render());
  }
}
function injectFakeCaret(wrapperDomElement) {
  const caretTemplate = new Template({
    tag: "div",
    attributes: {
      class: [
        "ck",
        "ck-widget__type-around__fake-caret"
      ]
    }
  });
  wrapperDomElement.appendChild(caretTemplate.render());
}
function getDeepestEmptyElementAncestor(schema, element) {
  let deepestEmptyAncestor = element;
  for (const ancestor of element.getAncestors({ parentFirst: true })) {
    if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {
      break;
    }
    deepestEmptyAncestor = ancestor;
  }
  return deepestEmptyAncestor;
}

// node_modules/@ckeditor/ckeditor5-widget/src/verticalnavigation.js
function verticalNavigationHandler(editing) {
  const model = editing.model;
  return (evt, data) => {
    const arrowUpPressed = data.keyCode == keyCodes.arrowup;
    const arrowDownPressed = data.keyCode == keyCodes.arrowdown;
    const expandSelection = data.shiftKey;
    const selection = model.document.selection;
    if (!arrowUpPressed && !arrowDownPressed) {
      return;
    }
    const isForward = arrowDownPressed;
    if (expandSelection && selectionWillShrink(selection, isForward)) {
      return;
    }
    const range = findTextRangeFromSelection(editing, selection, isForward);
    if (!range) {
      return;
    }
    if (range.isCollapsed) {
      if (selection.isCollapsed) {
        return;
      } else if (expandSelection) {
        return;
      }
    }
    if (range.isCollapsed || isSingleLineRange(editing, range, isForward)) {
      model.change((writer) => {
        const newPosition = isForward ? range.end : range.start;
        if (expandSelection) {
          const newSelection = model.createSelection(selection.anchor);
          newSelection.setFocus(newPosition);
          writer.setSelection(newSelection);
        } else {
          writer.setSelection(newPosition);
        }
      });
      evt.stop();
      data.preventDefault();
      data.stopPropagation();
    }
  };
}
function findTextRangeFromSelection(editing, selection, isForward) {
  const model = editing.model;
  if (isForward) {
    const startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();
    const endPosition = getNearestNonInlineLimit(model, startPosition, "forward");
    if (!endPosition) {
      return null;
    }
    const range = model.createRange(startPosition, endPosition);
    const lastRangePosition = getNearestTextPosition(model.schema, range, "backward");
    if (lastRangePosition) {
      return model.createRange(startPosition, lastRangePosition);
    }
    return null;
  } else {
    const endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();
    const startPosition = getNearestNonInlineLimit(model, endPosition, "backward");
    if (!startPosition) {
      return null;
    }
    const range = model.createRange(startPosition, endPosition);
    const firstRangePosition = getNearestTextPosition(model.schema, range, "forward");
    if (firstRangePosition) {
      return model.createRange(firstRangePosition, endPosition);
    }
    return null;
  }
}
function getNearestNonInlineLimit(model, startPosition, direction) {
  const schema = model.schema;
  const range = model.createRangeIn(startPosition.root);
  const walkerValueType = direction == "forward" ? "elementStart" : "elementEnd";
  for (const { previousPosition, item, type } of range.getWalker({ startPosition, direction })) {
    if (schema.isLimit(item) && !schema.isInline(item)) {
      return previousPosition;
    }
    if (type == walkerValueType && schema.isBlock(item)) {
      return null;
    }
  }
  return null;
}
function getNearestTextPosition(schema, range, direction) {
  const position = direction == "backward" ? range.end : range.start;
  if (schema.checkChild(position, "$text")) {
    return position;
  }
  for (const { nextPosition } of range.getWalker({ direction })) {
    if (schema.checkChild(nextPosition, "$text")) {
      return nextPosition;
    }
  }
  return null;
}
function isSingleLineRange(editing, modelRange, isForward) {
  const model = editing.model;
  const domConverter = editing.view.domConverter;
  if (isForward) {
    const probe = model.createSelection(modelRange.start);
    model.modifySelection(probe);
    if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {
      modelRange = model.createRange(probe.focus, modelRange.end);
    }
  }
  const viewRange = editing.mapper.toViewRange(modelRange);
  const domRange = domConverter.viewRangeToDom(viewRange);
  const rects = Rect.getDomRangeRects(domRange);
  let boundaryVerticalPosition;
  for (const rect of rects) {
    if (boundaryVerticalPosition === void 0) {
      boundaryVerticalPosition = Math.round(rect.bottom);
      continue;
    }
    if (Math.round(rect.top) >= boundaryVerticalPosition) {
      return false;
    }
    boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));
  }
  return true;
}
function selectionWillShrink(selection, isForward) {
  return !selection.isCollapsed && selection.isBackward == isForward;
}

// node_modules/@ckeditor/ckeditor5-widget/src/widget.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-widget/theme/widget.css";
var Widget = class extends Plugin {
  constructor() {
    super(...arguments);
    this._previouslySelected = /* @__PURE__ */ new Set();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Widget";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [WidgetTypeAround, Delete];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
      const viewWriter = conversionApi.writer;
      const modelSelection = data.selection;
      if (modelSelection.isCollapsed) {
        return;
      }
      const selectedModelElement = modelSelection.getSelectedElement();
      if (!selectedModelElement) {
        return;
      }
      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
      if (!isWidget(selectedViewElement)) {
        return;
      }
      if (!conversionApi.consumable.consume(modelSelection, "selection")) {
        return;
      }
      viewWriter.setSelection(viewWriter.createRangeOn(selectedViewElement), {
        fake: true,
        label: getLabel(selectedViewElement)
      });
    });
    this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
      this._clearPreviouslySelectedWidgets(conversionApi.writer);
      const viewWriter = conversionApi.writer;
      const viewSelection = viewWriter.document.selection;
      let lastMarked = null;
      for (const range of viewSelection.getRanges()) {
        for (const value of range) {
          const node = value.item;
          if (isWidget(node) && !isChild(node, lastMarked)) {
            viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);
            this._previouslySelected.add(node);
            lastMarked = node;
          }
        }
      }
    }, { priority: "low" });
    view.addObserver(MouseObserver);
    this.listenTo(viewDocument, "mousedown", (...args) => this._onMousedown(...args));
    this.listenTo(viewDocument, "arrowKey", (...args) => {
      this._handleSelectionChangeOnArrowKeyPress(...args);
    }, { context: [isWidget, "$text"] });
    this.listenTo(viewDocument, "arrowKey", (...args) => {
      this._preventDefaultOnArrowKeyPress(...args);
    }, { context: "$root" });
    this.listenTo(viewDocument, "arrowKey", verticalNavigationHandler(this.editor.editing), { context: "$text" });
    this.listenTo(viewDocument, "delete", (evt, data) => {
      if (this._handleDelete(data.direction == "forward")) {
        data.preventDefault();
        evt.stop();
      }
    }, { context: "$root" });
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.
   */
  _onMousedown(eventInfo, domEventData) {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    let element = domEventData.target;
    if (isInsideNestedEditable(element)) {
      if ((env_default.isSafari || env_default.isGecko) && domEventData.domEvent.detail >= 3) {
        const mapper = editor.editing.mapper;
        const viewElement = element.is("attributeElement") ? element.findAncestor((element2) => !element2.is("attributeElement")) : element;
        const modelElement2 = mapper.toModelElement(viewElement);
        domEventData.preventDefault();
        this.editor.model.change((writer) => {
          writer.setSelection(modelElement2, "in");
        });
      }
      return;
    }
    if (!isWidget(element)) {
      element = element.findAncestor(isWidget);
      if (!element) {
        return;
      }
    }
    if (env_default.isAndroid) {
      domEventData.preventDefault();
    }
    if (!viewDocument.isFocused) {
      view.focus();
    }
    const modelElement = editor.editing.mapper.toModelElement(element);
    this._setSelectionOverElement(modelElement);
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes
   * the model selection when:
   *
   * * arrow key is pressed when the widget is selected,
   * * the selection is next to a widget and the widget should become selected upon the arrow key press.
   *
   * See {@link #_preventDefaultOnArrowKeyPress}.
   */
  _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {
    const keyCode = domEventData.keyCode;
    const model = this.editor.model;
    const schema = model.schema;
    const modelSelection = model.document.selection;
    const objectElement = modelSelection.getSelectedElement();
    const direction = getLocalizedArrowKeyCodeDirection(keyCode, this.editor.locale.contentLanguageDirection);
    const isForward = direction == "down" || direction == "right";
    const isVerticalNavigation = direction == "up" || direction == "down";
    if (objectElement && schema.isObject(objectElement)) {
      const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();
      const newRange = schema.getNearestSelectionRange(position, isForward ? "forward" : "backward");
      if (newRange) {
        model.change((writer) => {
          writer.setSelection(newRange);
        });
        domEventData.preventDefault();
        eventInfo.stop();
      }
      return;
    }
    if (!modelSelection.isCollapsed && !domEventData.shiftKey) {
      const firstPosition = modelSelection.getFirstPosition();
      const lastPosition = modelSelection.getLastPosition();
      const firstSelectedNode = firstPosition.nodeAfter;
      const lastSelectedNode = lastPosition.nodeBefore;
      if (firstSelectedNode && schema.isObject(firstSelectedNode) || lastSelectedNode && schema.isObject(lastSelectedNode)) {
        model.change((writer) => {
          writer.setSelection(isForward ? lastPosition : firstPosition);
        });
        domEventData.preventDefault();
        eventInfo.stop();
      }
      return;
    }
    if (!modelSelection.isCollapsed) {
      return;
    }
    const objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);
    if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {
      if (schema.isInline(objectElementNextToSelection) && isVerticalNavigation) {
        return;
      }
      this._setSelectionOverElement(objectElementNextToSelection);
      domEventData.preventDefault();
      eventInfo.stop();
    }
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents
   * the default browser behavior to make sure the fake selection is not being moved from a fake selection
   * container.
   *
   * See {@link #_handleSelectionChangeOnArrowKeyPress}.
   */
  _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {
    const model = this.editor.model;
    const schema = model.schema;
    const objectElement = model.document.selection.getSelectedElement();
    if (objectElement && schema.isObject(objectElement)) {
      domEventData.preventDefault();
      eventInfo.stop();
    }
  }
  /**
   * Handles delete keys: backspace and delete.
   *
   * @param isForward Set to true if delete was performed in forward direction.
   * @returns Returns `true` if keys were handled correctly.
   */
  _handleDelete(isForward) {
    const modelDocument = this.editor.model.document;
    const modelSelection = modelDocument.selection;
    if (!this.editor.model.canEditAt(modelSelection)) {
      return;
    }
    if (!modelSelection.isCollapsed) {
      return;
    }
    const objectElement = this._getObjectElementNextToSelection(isForward);
    if (objectElement) {
      this.editor.model.change((writer) => {
        let previousNode = modelSelection.anchor.parent;
        while (previousNode.isEmpty) {
          const nodeToRemove = previousNode;
          previousNode = nodeToRemove.parent;
          writer.remove(nodeToRemove);
        }
        this._setSelectionOverElement(objectElement);
      });
      return true;
    }
  }
  /**
   * Sets {@link module:engine/model/selection~Selection document's selection} over given element.
   *
   * @internal
   */
  _setSelectionOverElement(element) {
    this.editor.model.change((writer) => {
      writer.setSelection(writer.createRangeOn(element));
    });
  }
  /**
   * Checks if {@link module:engine/model/element~Element element} placed next to the current
   * {@link module:engine/model/selection~Selection model selection} exists and is marked in
   * {@link module:engine/model/schema~Schema schema} as `object`.
   *
   * @internal
   * @param forward Direction of checking.
   */
  _getObjectElementNextToSelection(forward) {
    const model = this.editor.model;
    const schema = model.schema;
    const modelSelection = model.document.selection;
    const probe = model.createSelection(modelSelection);
    model.modifySelection(probe, { direction: forward ? "forward" : "backward" });
    if (probe.isEqual(modelSelection)) {
      return null;
    }
    const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;
    if (!!objectElement && schema.isObject(objectElement)) {
      return objectElement;
    }
    return null;
  }
  /**
   * Removes CSS class from previously selected widgets.
   */
  _clearPreviouslySelectedWidgets(writer) {
    for (const widget of this._previouslySelected) {
      writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);
    }
    this._previouslySelected.clear();
  }
};
function isInsideNestedEditable(element) {
  let currentElement = element;
  while (currentElement) {
    if (currentElement.is("editableElement") && !currentElement.is("rootElement")) {
      return true;
    }
    if (isWidget(currentElement)) {
      return false;
    }
    currentElement = currentElement.parent;
  }
  return false;
}
function isChild(element, parent) {
  if (!parent) {
    return false;
  }
  return Array.from(element.getAncestors()).includes(parent);
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgettoolbarrepository.js
var WidgetToolbarRepository = class extends Plugin {
  constructor() {
    super(...arguments);
    this._toolbarDefinitions = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ContextualBalloon];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetToolbarRepository";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    if (editor.plugins.has("BalloonToolbar")) {
      const balloonToolbar = editor.plugins.get("BalloonToolbar");
      this.listenTo(balloonToolbar, "show", (evt) => {
        if (isWidgetSelected(editor.editing.view.document.selection)) {
          evt.stop();
        }
      }, { priority: "high" });
    }
    this._balloon = this.editor.plugins.get("ContextualBalloon");
    this.on("change:isEnabled", () => {
      this._updateToolbarsVisibility();
    });
    this.listenTo(editor.ui, "update", () => {
      this._updateToolbarsVisibility();
    });
    this.listenTo(editor.ui.focusTracker, "change:isFocused", () => {
      this._updateToolbarsVisibility();
    }, { priority: "low" });
  }
  destroy() {
    super.destroy();
    for (const toolbarConfig of this._toolbarDefinitions.values()) {
      toolbarConfig.view.destroy();
    }
  }
  /**
   * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked
   * `getRelatedElement` function. Toolbar items are gathered from `items` array.
   * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.
   *
   * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}
   * callback (or later) to make sure that the given toolbar items were already registered by other plugins.
   *
   * @param toolbarId An id for the toolbar. Used to
   * @param options.ariaLabel Label used by assistive technologies to describe this toolbar element.
   * @param options.items Array of toolbar items.
   * @param options.getRelatedElement Callback which returns an element the toolbar should be attached to.
   * @param options.balloonClassName CSS class for the widget balloon.
   */
  register(toolbarId, { ariaLabel, items, getRelatedElement, balloonClassName = "ck-toolbar-container" }) {
    if (!items.length) {
      logWarning("widget-toolbar-no-items", { toolbarId });
      return;
    }
    const editor = this.editor;
    const t = editor.t;
    const toolbarView = new ToolbarView(editor.locale);
    toolbarView.ariaLabel = ariaLabel || t("Widget toolbar");
    if (this._toolbarDefinitions.has(toolbarId)) {
      throw new CKEditorError("widget-toolbar-duplicated", this, { toolbarId });
    }
    const toolbarDefinition = {
      view: toolbarView,
      getRelatedElement,
      balloonClassName,
      itemsConfig: items,
      initialized: false
    };
    editor.ui.addToolbar(toolbarView, {
      isContextual: true,
      beforeFocus: () => {
        const relatedElement = getRelatedElement(editor.editing.view.document.selection);
        if (relatedElement) {
          this._showToolbar(toolbarDefinition, relatedElement);
        }
      },
      afterBlur: () => {
        this._hideToolbar(toolbarDefinition);
      }
    });
    this._toolbarDefinitions.set(toolbarId, toolbarDefinition);
  }
  /**
   * Iterates over stored toolbars and makes them visible or hidden.
   */
  _updateToolbarsVisibility() {
    let maxRelatedElementDepth = 0;
    let deepestRelatedElement = null;
    let deepestToolbarDefinition = null;
    for (const definition of this._toolbarDefinitions.values()) {
      const relatedElement = definition.getRelatedElement(this.editor.editing.view.document.selection);
      if (!this.isEnabled || !relatedElement) {
        if (this._isToolbarInBalloon(definition)) {
          this._hideToolbar(definition);
        }
      } else if (!this.editor.ui.focusTracker.isFocused) {
        if (this._isToolbarVisible(definition)) {
          this._hideToolbar(definition);
        }
      } else {
        const relatedElementDepth = relatedElement.getAncestors().length;
        if (relatedElementDepth > maxRelatedElementDepth) {
          maxRelatedElementDepth = relatedElementDepth;
          deepestRelatedElement = relatedElement;
          deepestToolbarDefinition = definition;
        }
      }
    }
    if (deepestToolbarDefinition) {
      this._showToolbar(deepestToolbarDefinition, deepestRelatedElement);
    }
  }
  /**
   * Hides the given toolbar.
   */
  _hideToolbar(toolbarDefinition) {
    this._balloon.remove(toolbarDefinition.view);
    this.stopListening(this._balloon, "change:visibleView");
  }
  /**
   * Shows up the toolbar if the toolbar is not visible.
   * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.
   *
   * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view
   * should be still visible after the {@link module:ui/editorui/editorui~EditorUI#event:update}.
   */
  _showToolbar(toolbarDefinition, relatedElement) {
    if (this._isToolbarVisible(toolbarDefinition)) {
      repositionContextualBalloon(this.editor, relatedElement);
    } else if (!this._isToolbarInBalloon(toolbarDefinition)) {
      if (!toolbarDefinition.initialized) {
        toolbarDefinition.initialized = true;
        toolbarDefinition.view.fillFromConfig(toolbarDefinition.itemsConfig, this.editor.ui.componentFactory);
      }
      this._balloon.add({
        view: toolbarDefinition.view,
        position: getBalloonPositionData(this.editor, relatedElement),
        balloonClassName: toolbarDefinition.balloonClassName
      });
      this.listenTo(this._balloon, "change:visibleView", () => {
        for (const definition of this._toolbarDefinitions.values()) {
          if (this._isToolbarVisible(definition)) {
            const relatedElement2 = definition.getRelatedElement(this.editor.editing.view.document.selection);
            repositionContextualBalloon(this.editor, relatedElement2);
          }
        }
      });
    }
  }
  _isToolbarVisible(toolbar) {
    return this._balloon.visibleView === toolbar.view;
  }
  _isToolbarInBalloon(toolbar) {
    return this._balloon.hasView(toolbar.view);
  }
};
function repositionContextualBalloon(editor, relatedElement) {
  const balloon = editor.plugins.get("ContextualBalloon");
  const position = getBalloonPositionData(editor, relatedElement);
  balloon.updatePosition(position);
}
function getBalloonPositionData(editor, relatedElement) {
  const editingView = editor.editing.view;
  const defaultPositions = BalloonPanelView.defaultPositions;
  return {
    target: editingView.domConverter.mapViewToDom(relatedElement),
    positions: [
      defaultPositions.northArrowSouth,
      defaultPositions.northArrowSouthWest,
      defaultPositions.northArrowSouthEast,
      defaultPositions.southArrowNorth,
      defaultPositions.southArrowNorthWest,
      defaultPositions.southArrowNorthEast,
      defaultPositions.viewportStickyNorth
    ]
  };
}
function isWidgetSelected(selection) {
  const viewElement = selection.getSelectedElement();
  return !!(viewElement && isWidget(viewElement));
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize/resizerstate.js
var ResizeState = class extends ObservableMixin() {
  /**
   * @param options Resizer options.
   */
  constructor(options) {
    super();
    this.set("activeHandlePosition", null);
    this.set("proposedWidthPercents", null);
    this.set("proposedWidth", null);
    this.set("proposedHeight", null);
    this.set("proposedHandleHostWidth", null);
    this.set("proposedHandleHostHeight", null);
    this._options = options;
    this._referenceCoordinates = null;
  }
  /**
   * The original width (pixels) of the resized object when the resize process was started.
   */
  get originalWidth() {
    return this._originalWidth;
  }
  /**
   * The original height (pixels) of the resized object when the resize process was started.
   */
  get originalHeight() {
    return this._originalHeight;
  }
  /**
   * The original width (percents) of the resized object when the resize process was started.
   */
  get originalWidthPercents() {
    return this._originalWidthPercents;
  }
  /**
   * A width to height ratio of the resized image.
   */
  get aspectRatio() {
    return this._aspectRatio;
  }
  /**
   *
   * @param domResizeHandle The handle used to calculate the reference point.
   */
  begin(domResizeHandle, domHandleHost, domResizeHost) {
    const clientRect = new Rect(domHandleHost);
    this.activeHandlePosition = getHandlePosition(domResizeHandle);
    this._referenceCoordinates = getAbsoluteBoundaryPoint(domHandleHost, getOppositePosition(this.activeHandlePosition));
    this._originalWidth = clientRect.width;
    this._originalHeight = clientRect.height;
    this._aspectRatio = clientRect.width / clientRect.height;
    const widthStyle = domResizeHost.style.width;
    if (widthStyle && widthStyle.match(/^\d+(\.\d*)?%$/)) {
      this._originalWidthPercents = parseFloat(widthStyle);
    } else {
      this._originalWidthPercents = calculateHostPercentageWidth(domResizeHost, clientRect);
    }
  }
  update(newSize) {
    this.proposedWidth = newSize.width;
    this.proposedHeight = newSize.height;
    this.proposedWidthPercents = newSize.widthPercents;
    this.proposedHandleHostWidth = newSize.handleHostWidth;
    this.proposedHandleHostHeight = newSize.handleHostHeight;
  }
};
function calculateHostPercentageWidth(domResizeHost, resizeHostRect) {
  const domResizeHostParent = domResizeHost.parentElement;
  let parentWidth = parseFloat(domResizeHostParent.ownerDocument.defaultView.getComputedStyle(domResizeHostParent).width);
  const ancestorLevelLimit = 5;
  let currentLevel = 0;
  let checkedElement = domResizeHostParent;
  while (isNaN(parentWidth)) {
    checkedElement = checkedElement.parentElement;
    if (++currentLevel > ancestorLevelLimit) {
      return 0;
    }
    parentWidth = parseFloat(domResizeHostParent.ownerDocument.defaultView.getComputedStyle(checkedElement).width);
  }
  return resizeHostRect.width / parentWidth * 100;
}
function getAbsoluteBoundaryPoint(element, resizerPosition) {
  const elementRect = new Rect(element);
  const positionParts = resizerPosition.split("-");
  const ret = {
    x: positionParts[1] == "right" ? elementRect.right : elementRect.left,
    y: positionParts[0] == "bottom" ? elementRect.bottom : elementRect.top
  };
  ret.x += element.ownerDocument.defaultView.scrollX;
  ret.y += element.ownerDocument.defaultView.scrollY;
  return ret;
}
function getResizerHandleClass(resizerPosition) {
  return `ck-widget__resizer__handle-${resizerPosition}`;
}
function getHandlePosition(domHandle) {
  const resizerPositions = ["top-left", "top-right", "bottom-right", "bottom-left"];
  for (const position of resizerPositions) {
    if (domHandle.classList.contains(getResizerHandleClass(position))) {
      return position;
    }
  }
}
function getOppositePosition(position) {
  const parts = position.split("-");
  const replacements = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  return `${replacements[parts[0]]}-${replacements[parts[1]]}`;
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize/sizeview.js
var SizeView = class extends View {
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-size-view",
          bind.to("_viewPosition", (value) => value ? `ck-orientation-${value}` : "")
        ],
        style: {
          display: bind.if("_isVisible", "none", (visible) => !visible)
        }
      },
      children: [{
        text: bind.to("_label")
      }]
    });
  }
  /**
   * A method used for binding the `SizeView` instance properties to the `ResizeState` instance observable properties.
   *
   * @internal
   * @param options An object defining the resizer options, used for setting the proper size label.
   * @param resizeState The `ResizeState` class instance, used for keeping the `SizeView` state up to date.
   */
  _bindToState(options, resizeState) {
    this.bind("_isVisible").to(resizeState, "proposedWidth", resizeState, "proposedHeight", (width, height) => width !== null && height !== null);
    this.bind("_label").to(resizeState, "proposedHandleHostWidth", resizeState, "proposedHandleHostHeight", resizeState, "proposedWidthPercents", (width, height, widthPercents) => {
      if (options.unit === "px") {
        return `${width}×${height}`;
      } else {
        return `${widthPercents}%`;
      }
    });
    this.bind("_viewPosition").to(
      resizeState,
      "activeHandlePosition",
      resizeState,
      "proposedHandleHostWidth",
      resizeState,
      "proposedHandleHostHeight",
      // If the widget is too small to contain the size label, display the label above.
      (position, width, height) => width < 50 || height < 50 ? "above-center" : position
    );
  }
  /**
   * A method used for cleaning up. It removes the bindings and hides the view.
   *
   * @internal
   */
  _dismiss() {
    this.unbind();
    this._isVisible = false;
  }
};

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize/resizer.js
var Resizer = class extends ObservableMixin() {
  /**
   * @param options Resizer options.
   */
  constructor(options) {
    super();
    this._viewResizerWrapper = null;
    this._options = options;
    this.set("isEnabled", true);
    this.set("isSelected", false);
    this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (isEnabled, isSelected) => isEnabled && isSelected);
    this.decorate("begin");
    this.decorate("cancel");
    this.decorate("commit");
    this.decorate("updateSize");
    this.on("commit", (event) => {
      if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
        this._cleanup();
        event.stop();
      }
    }, { priority: "high" });
  }
  /**
   * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.
   *
   * Note that a new state is created for each resize transaction.
   */
  get state() {
    return this._state;
  }
  /**
   * Makes resizer visible in the UI.
   */
  show() {
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.removeClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Hides resizer in the UI.
   */
  hide() {
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.addClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Attaches the resizer to the DOM.
   */
  attach() {
    const that = this;
    const widgetElement = this._options.viewElement;
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      const viewResizerWrapper = writer.createUIElement("div", {
        class: "ck ck-reset_all ck-widget__resizer"
      }, function(domDocument) {
        const domElement = this.toDomElement(domDocument);
        that._appendHandles(domElement);
        that._appendSizeUI(domElement);
        return domElement;
      });
      writer.insert(writer.createPositionAt(widgetElement, "end"), viewResizerWrapper);
      writer.addClass("ck-widget_with-resizer", widgetElement);
      this._viewResizerWrapper = viewResizerWrapper;
      if (!this.isVisible) {
        this.hide();
      }
    });
    this.on("change:isVisible", () => {
      if (this.isVisible) {
        this.show();
        this.redraw();
      } else {
        this.hide();
      }
    });
  }
  /**
   * Starts the resizing process.
   *
   * Creates a new {@link #state} for the current process.
   *
   * @fires begin
   * @param domResizeHandle Clicked handle.
   */
  begin(domResizeHandle) {
    this._state = new ResizeState(this._options);
    this._sizeView._bindToState(this._options, this.state);
    this._initialViewWidth = this._options.viewElement.getStyle("width");
    this.state.begin(domResizeHandle, this._getHandleHost(), this._getResizeHost());
  }
  /**
   * Updates the proposed size based on `domEventData`.
   *
   * @fires updateSize
   */
  updateSize(domEventData) {
    const newSize = this._proposeNewSize(domEventData);
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      const unit = this._options.unit || "%";
      const newWidth = (unit === "%" ? newSize.widthPercents : newSize.width) + unit;
      writer.setStyle("width", newWidth, this._options.viewElement);
    });
    const domHandleHost = this._getHandleHost();
    const domHandleHostRect = new Rect(domHandleHost);
    const handleHostWidth = Math.round(domHandleHostRect.width);
    const handleHostHeight = Math.round(domHandleHostRect.height);
    const domResizeHostRect = new Rect(domHandleHost);
    newSize.width = Math.round(domResizeHostRect.width);
    newSize.height = Math.round(domResizeHostRect.height);
    this.redraw(domHandleHostRect);
    this.state.update({
      ...newSize,
      handleHostWidth,
      handleHostHeight
    });
  }
  /**
   * Applies the geometry proposed with the resizer.
   *
   * @fires commit
   */
  commit() {
    const unit = this._options.unit || "%";
    const newValue = (unit === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + unit;
    this._options.editor.editing.view.change(() => {
      this._cleanup();
      this._options.onCommit(newValue);
    });
  }
  /**
   * Cancels and rejects the proposed resize dimensions, hiding the UI.
   *
   * @fires cancel
   */
  cancel() {
    this._cleanup();
  }
  /**
   * Destroys the resizer.
   */
  destroy() {
    this.cancel();
  }
  /**
   * Redraws the resizer.
   *
   * @param handleHostRect Handle host rectangle might be given to improve performance.
   */
  redraw(handleHostRect) {
    const domWrapper = this._domResizerWrapper;
    if (!existsInDom(domWrapper)) {
      return;
    }
    const widgetWrapper = domWrapper.parentElement;
    const handleHost = this._getHandleHost();
    const resizerWrapper = this._viewResizerWrapper;
    const currentDimensions = [
      resizerWrapper.getStyle("width"),
      resizerWrapper.getStyle("height"),
      resizerWrapper.getStyle("left"),
      resizerWrapper.getStyle("top")
    ];
    let newDimensions;
    if (widgetWrapper.isSameNode(handleHost)) {
      const clientRect = handleHostRect || new Rect(handleHost);
      newDimensions = [
        clientRect.width + "px",
        clientRect.height + "px",
        void 0,
        void 0
      ];
    } else {
      newDimensions = [
        handleHost.offsetWidth + "px",
        handleHost.offsetHeight + "px",
        handleHost.offsetLeft + "px",
        handleHost.offsetTop + "px"
      ];
    }
    if (compareArrays(currentDimensions, newDimensions) !== "same") {
      this._options.editor.editing.view.change((writer) => {
        writer.setStyle({
          width: newDimensions[0],
          height: newDimensions[1],
          left: newDimensions[2],
          top: newDimensions[3]
        }, resizerWrapper);
      });
    }
  }
  containsHandle(domElement) {
    return this._domResizerWrapper.contains(domElement);
  }
  static isResizeHandle(domElement) {
    return domElement.classList.contains("ck-widget__resizer__handle");
  }
  /**
   * Cleans up the context state.
   */
  _cleanup() {
    this._sizeView._dismiss();
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.setStyle("width", this._initialViewWidth, this._options.viewElement);
    });
  }
  /**
   * Calculates the proposed size as the resize handles are dragged.
   *
   * @param domEventData Event data that caused the size update request. It should be used to calculate the proposed size.
   */
  _proposeNewSize(domEventData) {
    const state = this.state;
    const currentCoordinates = extractCoordinates(domEventData);
    const isCentered = this._options.isCentered ? this._options.isCentered(this) : true;
    const enlargement = {
      x: state._referenceCoordinates.x - (currentCoordinates.x + state.originalWidth),
      y: currentCoordinates.y - state.originalHeight - state._referenceCoordinates.y
    };
    if (isCentered && state.activeHandlePosition.endsWith("-right")) {
      enlargement.x = currentCoordinates.x - (state._referenceCoordinates.x + state.originalWidth);
    }
    if (isCentered) {
      enlargement.x *= 2;
    }
    let width = Math.abs(state.originalWidth + enlargement.x);
    let height = Math.abs(state.originalHeight + enlargement.y);
    const dominant = width / state.aspectRatio > height ? "width" : "height";
    if (dominant == "width") {
      height = width / state.aspectRatio;
    } else {
      width = height * state.aspectRatio;
    }
    return {
      width: Math.round(width),
      height: Math.round(height),
      widthPercents: Math.min(Math.round(state.originalWidthPercents / state.originalWidth * width * 100) / 100, 100)
    };
  }
  /**
   * Obtains the resize host.
   *
   * Resize host is an object that receives dimensions which are the result of resizing.
   */
  _getResizeHost() {
    const widgetWrapper = this._domResizerWrapper.parentElement;
    return this._options.getResizeHost(widgetWrapper);
  }
  /**
   * Obtains the handle host.
   *
   * Handle host is an object that the handles are aligned to.
   *
   * Handle host will not always be an entire widget itself. Take an image as an example. The image widget
   * contains an image and a caption. Only the image should be surrounded with handles.
   */
  _getHandleHost() {
    const widgetWrapper = this._domResizerWrapper.parentElement;
    return this._options.getHandleHost(widgetWrapper);
  }
  /**
   * DOM container of the entire resize UI.
   *
   * Note that this property will have a value only after the element bound with the resizer is rendered
   * (otherwise `null`).
   */
  get _domResizerWrapper() {
    return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
  }
  /**
   * Renders the resize handles in the DOM.
   *
   * @param domElement The resizer wrapper.
   */
  _appendHandles(domElement) {
    const resizerPositions = ["top-left", "top-right", "bottom-right", "bottom-left"];
    for (const currentPosition of resizerPositions) {
      domElement.appendChild(new Template({
        tag: "div",
        attributes: {
          class: `ck-widget__resizer__handle ${getResizerClass(currentPosition)}`
        }
      }).render());
    }
  }
  /**
   * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.
   */
  _appendSizeUI(domElement) {
    this._sizeView = new SizeView();
    this._sizeView.render();
    domElement.appendChild(this._sizeView.element);
  }
};
function getResizerClass(resizerPosition) {
  return `ck-widget__resizer__handle-${resizerPosition}`;
}
function extractCoordinates(event) {
  return {
    x: event.pageX,
    y: event.pageY
  };
}
function existsInDom(element) {
  return element && element.ownerDocument && element.ownerDocument.contains(element);
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css";
var WidgetResize = class extends Plugin {
  constructor() {
    super(...arguments);
    this._resizers = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetResize";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editing = this.editor.editing;
    const domDocument = global_default.window.document;
    this.set("selectedResizer", null);
    this.set("_activeResizer", null);
    editing.view.addObserver(MouseObserver);
    this._observer = new (DomEmitterMixin())();
    this.listenTo(editing.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" });
    this._observer.listenTo(domDocument, "mousemove", this._mouseMoveListener.bind(this));
    this._observer.listenTo(domDocument, "mouseup", this._mouseUpListener.bind(this));
    this._redrawSelectedResizerThrottled = throttle_default(() => this.redrawSelectedResizer(), 200);
    this.editor.ui.on("update", this._redrawSelectedResizerThrottled);
    this.editor.model.document.on("change", () => {
      for (const [viewElement, resizer] of this._resizers) {
        if (!viewElement.isAttached()) {
          this._resizers.delete(viewElement);
          resizer.destroy();
        }
      }
    }, { priority: "lowest" });
    this._observer.listenTo(global_default.window, "resize", this._redrawSelectedResizerThrottled);
    const viewSelection = this.editor.editing.view.document.selection;
    viewSelection.on("change", () => {
      const selectedElement = viewSelection.getSelectedElement();
      const resizer = this.getResizerByViewElement(selectedElement) || null;
      if (resizer) {
        this.select(resizer);
      } else {
        this.deselect();
      }
    });
  }
  /**
   * Redraws the selected resizer if there is any selected resizer and if it is visible.
   */
  redrawSelectedResizer() {
    if (this.selectedResizer && this.selectedResizer.isVisible) {
      this.selectedResizer.redraw();
    }
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this._observer.stopListening();
    for (const resizer of this._resizers.values()) {
      resizer.destroy();
    }
    this._redrawSelectedResizerThrottled.cancel();
  }
  /**
   * Marks resizer as selected.
   */
  select(resizer) {
    this.deselect();
    this.selectedResizer = resizer;
    this.selectedResizer.isSelected = true;
  }
  /**
   * Deselects currently set resizer.
   */
  deselect() {
    if (this.selectedResizer) {
      this.selectedResizer.isSelected = false;
    }
    this.selectedResizer = null;
  }
  /**
   * @param options Resizer options.
   */
  attachTo(options) {
    const resizer = new Resizer(options);
    const plugins = this.editor.plugins;
    resizer.attach();
    if (plugins.has("WidgetToolbarRepository")) {
      const widgetToolbarRepository = plugins.get("WidgetToolbarRepository");
      resizer.on("begin", () => {
        widgetToolbarRepository.forceDisabled("resize");
      }, { priority: "lowest" });
      resizer.on("cancel", () => {
        widgetToolbarRepository.clearForceDisabled("resize");
      }, { priority: "highest" });
      resizer.on("commit", () => {
        widgetToolbarRepository.clearForceDisabled("resize");
      }, { priority: "highest" });
    }
    this._resizers.set(options.viewElement, resizer);
    const viewSelection = this.editor.editing.view.document.selection;
    const selectedElement = viewSelection.getSelectedElement();
    if (this.getResizerByViewElement(selectedElement) == resizer) {
      this.select(resizer);
    }
    return resizer;
  }
  /**
   * Returns a resizer created for a given view element (widget element).
   *
   * @param viewElement View element associated with the resizer.
   */
  getResizerByViewElement(viewElement) {
    return this._resizers.get(viewElement);
  }
  /**
   * Returns a resizer that contains a given resize handle.
   */
  _getResizerByHandle(domResizeHandle) {
    for (const resizer of this._resizers.values()) {
      if (resizer.containsHandle(domResizeHandle)) {
        return resizer;
      }
    }
  }
  /**
   * @param domEventData Native DOM event.
   */
  _mouseDownListener(event, domEventData) {
    const resizeHandle = domEventData.domTarget;
    if (!Resizer.isResizeHandle(resizeHandle)) {
      return;
    }
    this._activeResizer = this._getResizerByHandle(resizeHandle) || null;
    if (this._activeResizer) {
      this._activeResizer.begin(resizeHandle);
      event.stop();
      domEventData.preventDefault();
    }
  }
  /**
   * @param domEventData Native DOM event.
   */
  _mouseMoveListener(event, domEventData) {
    if (this._activeResizer) {
      this._activeResizer.updateSize(domEventData);
    }
  }
  _mouseUpListener() {
    if (this._activeResizer) {
      this._activeResizer.commit();
      this._activeResizer = null;
    }
  }
};

export {
  isWidget,
  toWidget,
  setHighlightHandling,
  toWidgetEditable,
  findOptimalInsertionRange2 as findOptimalInsertionRange,
  Widget,
  WidgetToolbarRepository,
  WidgetResize
};
/*! Bundled license information:

@ckeditor/ckeditor5-widget/src/highlightstack.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgettypearound/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/verticalnavigation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widget.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgettoolbarrepository.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize/resizerstate.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize/sizeview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize/resizer.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-NMGSIING.js.map
