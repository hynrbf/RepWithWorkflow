import {
  BubblingEventInfo,
  Command,
  DomEventData,
  EventInfo,
  FocusObserver,
  ObservableMixin,
  Observer,
  Plugin,
  count,
  env_default,
  isInsideCombinedSymbol,
  isInsideEmojiSequence,
  isInsideSurrogatePair,
  keyCodes
} from "./chunk-JI2V5GJZ.js";

// node_modules/@ckeditor/ckeditor5-typing/src/utils/changebuffer.js
var ChangeBuffer = class {
  /**
   * Creates a new instance of the change buffer.
   *
   * @param limit The maximum number of atomic changes which can be contained in one batch.
   */
  constructor(model, limit = 20) {
    this._batch = null;
    this.model = model;
    this._size = 0;
    this.limit = limit;
    this._isLocked = false;
    this._changeCallback = (evt, batch) => {
      if (batch.isLocal && batch.isUndoable && batch !== this._batch) {
        this._reset(true);
      }
    };
    this._selectionChangeCallback = () => {
      this._reset();
    };
    this.model.document.on("change", this._changeCallback);
    this.model.document.selection.on("change:range", this._selectionChangeCallback);
    this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
  }
  /**
   * The current batch to which a feature should add its operations. Once the {@link #size}
   * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
   */
  get batch() {
    if (!this._batch) {
      this._batch = this.model.createBatch({ isTyping: true });
    }
    return this._batch;
  }
  /**
   * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
   * the {@link #batch batch} is set to a new one.
   */
  get size() {
    return this._size;
  }
  /**
   * The input number of changes into the buffer. Once the {@link #size} is
   * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
   *
   * @param changeCount The number of atomic changes to input.
   */
  input(changeCount) {
    this._size += changeCount;
    if (this._size >= this.limit) {
      this._reset(true);
    }
  }
  /**
   * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
   */
  get isLocked() {
    return this._isLocked;
  }
  /**
   * Locks the buffer.
   */
  lock() {
    this._isLocked = true;
  }
  /**
   * Unlocks the buffer.
   */
  unlock() {
    this._isLocked = false;
  }
  /**
   * Destroys the buffer.
   */
  destroy() {
    this.model.document.off("change", this._changeCallback);
    this.model.document.selection.off("change:range", this._selectionChangeCallback);
    this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
  }
  /**
   * Resets the change buffer.
   *
   * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.
   */
  _reset(ignoreLock = false) {
    if (!this.isLocked || ignoreLock) {
      this._batch = null;
      this._size = 0;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/inserttextcommand.js
var InsertTextCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param undoStepSize The maximum number of atomic changes
   * which can be contained in one batch in the command buffer.
   */
  constructor(editor, undoStepSize) {
    super(editor);
    this._buffer = new ChangeBuffer(editor.model, undoStepSize);
    this._isEnabledBasedOnSelection = false;
  }
  /**
   * The current change buffer.
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this._buffer.destroy();
  }
  /**
   * Executes the input command. It replaces the content within the given range with the given text.
   * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
   * at the beginning of the range (which after the removal is a collapsed range).
   *
   * @fires execute
   * @param options The command options.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const doc = model.document;
    const text = options.text || "";
    const textInsertions = text.length;
    let selection = doc.selection;
    if (options.selection) {
      selection = options.selection;
    } else if (options.range) {
      selection = model.createSelection(options.range);
    }
    if (!model.canEditAt(selection)) {
      return;
    }
    const resultRange = options.resultRange;
    model.enqueueChange(this._buffer.batch, (writer) => {
      this._buffer.lock();
      model.deleteContent(selection);
      if (text) {
        model.insertContent(writer.createText(text, doc.selection.getAttributes()), selection);
      }
      if (resultRange) {
        writer.setSelection(resultRange);
      } else if (!selection.is("documentSelection")) {
        writer.setSelection(selection);
      }
      this._buffer.unlock();
      this._buffer.input(textInsertions);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/inserttextobserver.js
var TYPING_INPUT_TYPES = [
  // For collapsed range:
  //	- This one is a regular typing (all browsers, all systems).
  //	- This one is used by Chrome when typing accented letter – 2nd step when the user selects the accent (Mac).
  // For non-collapsed range:
  //	- This one is used by Chrome when typing accented letter – when the selection box first appears (Mac).
  //	- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).
  "insertText",
  // This one is used by Safari when typing accented letter (Mac).
  // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).
  "insertReplacementText"
];
var InsertTextObserver = class extends Observer {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    this.focusObserver = view.getObserver(FocusObserver);
    if (env_default.isAndroid) {
      TYPING_INPUT_TYPES.push("insertCompositionText");
    }
    const viewDocument = view.document;
    viewDocument.on("beforeinput", (evt, data) => {
      if (!this.isEnabled) {
        return;
      }
      const { data: text, targetRanges, inputType, domEvent } = data;
      if (!TYPING_INPUT_TYPES.includes(inputType)) {
        return;
      }
      this.focusObserver.flush();
      const eventInfo = new EventInfo(viewDocument, "insertText");
      viewDocument.fire(eventInfo, new DomEventData(view, domEvent, {
        text,
        selection: view.createSelection(targetRanges)
      }));
      if (eventInfo.stop.called) {
        evt.stop();
      }
    });
    viewDocument.on("compositionend", (evt, { data, domEvent }) => {
      if (!this.isEnabled || env_default.isAndroid) {
        return;
      }
      if (!data) {
        return;
      }
      viewDocument.fire("insertText", new DomEventData(view, domEvent, {
        text: data,
        selection: viewDocument.selection
      }));
    }, { priority: "lowest" });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/input.js
var Input = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Input";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const modelSelection = model.document.selection;
    view.addObserver(InsertTextObserver);
    const insertTextCommand = new InsertTextCommand(editor, editor.config.get("typing.undoStep") || 20);
    editor.commands.add("insertText", insertTextCommand);
    editor.commands.add("input", insertTextCommand);
    this.listenTo(view.document, "insertText", (evt, data) => {
      if (!view.document.isComposing) {
        data.preventDefault();
      }
      const { text, selection: viewSelection, resultRange: viewResultRange } = data;
      const modelRanges = Array.from(viewSelection.getRanges()).map((viewRange) => {
        return editor.editing.mapper.toModelRange(viewRange);
      });
      let insertText = text;
      if (env_default.isAndroid) {
        const selectedText = Array.from(modelRanges[0].getItems()).reduce((rangeText, node) => {
          return rangeText + (node.is("$textProxy") ? node.data : "");
        }, "");
        if (selectedText) {
          if (selectedText.length <= insertText.length) {
            if (insertText.startsWith(selectedText)) {
              insertText = insertText.substring(selectedText.length);
              modelRanges[0].start = modelRanges[0].start.getShiftedBy(selectedText.length);
            }
          } else {
            if (selectedText.startsWith(insertText)) {
              modelRanges[0].start = modelRanges[0].start.getShiftedBy(insertText.length);
              insertText = "";
            }
          }
        }
      }
      const insertTextCommandData = {
        text: insertText,
        selection: model.createSelection(modelRanges)
      };
      if (viewResultRange) {
        insertTextCommandData.resultRange = editor.editing.mapper.toModelRange(viewResultRange);
      }
      editor.execute("insertText", insertTextCommandData);
      view.scrollToTheSelection();
    });
    if (env_default.isAndroid) {
      this.listenTo(view.document, "keydown", (evt, data) => {
        if (modelSelection.isCollapsed || data.keyCode != 229 || !view.document.isComposing) {
          return;
        }
        deleteSelectionContent(model, insertTextCommand);
      });
    } else {
      this.listenTo(view.document, "compositionstart", () => {
        if (modelSelection.isCollapsed) {
          return;
        }
        deleteSelectionContent(model, insertTextCommand);
      });
    }
  }
};
function deleteSelectionContent(model, insertTextCommand) {
  if (!insertTextCommand.isEnabled) {
    return;
  }
  const buffer = insertTextCommand.buffer;
  buffer.lock();
  model.enqueueChange(buffer.batch, () => {
    model.deleteContent(model.document.selection);
  });
  buffer.unlock();
}

// node_modules/@ckeditor/ckeditor5-typing/src/deletecommand.js
var DeleteCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param direction The directionality of the delete describing in what direction it
   * should consume the content when the selection is collapsed.
   */
  constructor(editor, direction) {
    super(editor);
    this.direction = direction;
    this._buffer = new ChangeBuffer(editor.model, editor.config.get("typing.undoStep"));
    this._isEnabledBasedOnSelection = false;
  }
  /**
   * The current change buffer.
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
   * or a piece of content in the {@link #direction defined direction}.
   *
   * @fires execute
   * @param options The command options.
   * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
   * @param options.sequence A number describing which subsequent delete event it is without the key being released.
   * See the {@link module:engine/view/document~Document#event:delete} event data.
   * @param options.selection Selection to remove. If not set, current model selection will be used.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const doc = model.document;
    model.enqueueChange(this._buffer.batch, (writer) => {
      this._buffer.lock();
      const selection = writer.createSelection(options.selection || doc.selection);
      if (!model.canEditAt(selection)) {
        return;
      }
      const sequence = options.sequence || 1;
      const doNotResetEntireContent = selection.isCollapsed;
      if (selection.isCollapsed) {
        model.modifySelection(selection, {
          direction: this.direction,
          unit: options.unit,
          treatEmojiAsSingleUnit: true
        });
      }
      if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {
        this._replaceEntireContentWithParagraph(writer);
        return;
      }
      if (this._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {
        this.editor.execute("paragraph", { selection });
        return;
      }
      if (selection.isCollapsed) {
        return;
      }
      let changeCount = 0;
      selection.getFirstRange().getMinimalFlatRanges().forEach((range) => {
        changeCount += count(range.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));
      });
      model.deleteContent(selection, {
        doNotResetEntireContent,
        direction: this.direction
      });
      this._buffer.input(changeCount);
      writer.setSelection(selection);
      this._buffer.unlock();
    });
  }
  /**
   * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
   * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
   * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
   *
   * But, if the user pressed the key in an empty editable for the first time,
   * we want to replace the entire content with a paragraph if:
   *
   * * the current limit element is empty,
   * * the paragraph is allowed in the limit element,
   * * the limit doesn't already have a paragraph inside.
   *
   * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
   *
   * @param sequence A number describing which subsequent delete event it is without the key being released.
   */
  _shouldEntireContentBeReplacedWithParagraph(sequence) {
    if (sequence > 1) {
      return false;
    }
    const model = this.editor.model;
    const doc = model.document;
    const selection = doc.selection;
    const limitElement = model.schema.getLimitElement(selection);
    const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);
    if (!limitElementIsEmpty) {
      return false;
    }
    if (!model.schema.checkChild(limitElement, "paragraph")) {
      return false;
    }
    const limitElementFirstChild = limitElement.getChild(0);
    if (limitElementFirstChild && limitElementFirstChild.is("element", "paragraph")) {
      return false;
    }
    return true;
  }
  /**
   * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
   *
   * @param writer The model writer.
   */
  _replaceEntireContentWithParagraph(writer) {
    const model = this.editor.model;
    const doc = model.document;
    const selection = doc.selection;
    const limitElement = model.schema.getLimitElement(selection);
    const paragraph = writer.createElement("paragraph");
    writer.remove(writer.createRangeIn(limitElement));
    writer.insert(paragraph, limitElement);
    writer.setSelection(paragraph, 0);
  }
  /**
   * Checks if the selection is inside an empty element that is the first child of the limit element
   * and should be replaced with a paragraph.
   *
   * @param selection The selection.
   * @param sequence A number describing which subsequent delete event it is without the key being released.
   */
  _shouldReplaceFirstBlockWithParagraph(selection, sequence) {
    const model = this.editor.model;
    if (sequence > 1 || this.direction != "backward") {
      return false;
    }
    if (!selection.isCollapsed) {
      return false;
    }
    const position = selection.getFirstPosition();
    const limitElement = model.schema.getLimitElement(position);
    const limitElementFirstChild = limitElement.getChild(0);
    if (position.parent != limitElementFirstChild) {
      return false;
    }
    if (!selection.containsEntireContent(limitElementFirstChild)) {
      return false;
    }
    if (!model.schema.checkChild(limitElement, "paragraph")) {
      return false;
    }
    if (limitElementFirstChild.name == "paragraph") {
      return false;
    }
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/deleteobserver.js
var DELETE_CHARACTER = "character";
var DELETE_WORD = "word";
var DELETE_CODE_POINT = "codePoint";
var DELETE_SELECTION = "selection";
var DELETE_BACKWARD = "backward";
var DELETE_FORWARD = "forward";
var DELETE_EVENT_TYPES = {
  // --------------------------------------- Backward delete types -----------------------------------------------------
  // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.
  deleteContent: {
    unit: DELETE_SELECTION,
    // According to the Input Events Level 2 spec, this delete type has no direction
    // but to keep things simple, let's default to backward.
    direction: DELETE_BACKWARD
  },
  // Chrome and Safari on Mac: Backspace or Ctrl + H
  deleteContentBackward: {
    // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.
    // Take for instance "👨‍👩‍👧‍👧", it equals:
    //
    //	* [ "👨", "ZERO WIDTH JOINER", "👩", "ZERO WIDTH JOINER", "👧", "ZERO WIDTH JOINER", "👧" ]
    //	* or simply "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}"
    //
    // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user
    // intention when deleting backwards ("👨‍👩‍👧‍👧[]", then backspace) is gradual "decomposition" (first to "👨‍👩‍👧‍[]",
    // then to "👨‍👩‍[]", etc.).
    //
    //	* "👨‍👩‍👧‍👧[]" + backward delete (by code point)  -> results in "👨‍👩‍👧[]", removed the last "👧" 👍
    //	* "👨‍👩‍👧‍👧[]" + backward delete (by character)  -> results in "[]", removed the whole grapheme 👎
    //
    // Deleting by code-point is simply a better UX. See "deleteContentForward" to learn more.
    unit: DELETE_CODE_POINT,
    direction: DELETE_BACKWARD
  },
  // On Mac: Option + Backspace.
  // On iOS: Hold the backspace for a while and the whole words will start to disappear.
  deleteWordBackward: {
    unit: DELETE_WORD,
    direction: DELETE_BACKWARD
  },
  // Safari on Mac: Cmd + Backspace
  deleteHardLineBackward: {
    unit: DELETE_SELECTION,
    direction: DELETE_BACKWARD
  },
  // Chrome on Mac: Cmd + Backspace.
  deleteSoftLineBackward: {
    unit: DELETE_SELECTION,
    direction: DELETE_BACKWARD
  },
  // --------------------------------------- Forward delete types -----------------------------------------------------
  // Chrome on Mac: Fn + Backspace or Ctrl + D
  // Safari on Mac: Ctrl + K or Ctrl + D
  deleteContentForward: {
    // Unlike backward delete, this delete must be performed by character instead of by code point, which
    // provides the best UX for working with accented letters.
    // Take, for example "b̂" ("\u0062\u0302", or [ "LATIN SMALL LETTER B", "COMBINING CIRCUMFLEX ACCENT" ]):
    //
    //	* "b̂[]" + backward delete (by code point)  -> results in "b[]", removed the combining mark 👍
    //	* "[]b̂" + forward delete (by code point)   -> results in "[]^", a bare combining mark does that not make sense when alone 👎
    //	* "[]b̂" + forward delete (by character)    -> results in "[]", removed both "b" and the combining mark 👍
    //
    // See: "deleteContentBackward" to learn more.
    unit: DELETE_CHARACTER,
    direction: DELETE_FORWARD
  },
  // On Mac: Fn + Option + Backspace.
  deleteWordForward: {
    unit: DELETE_WORD,
    direction: DELETE_FORWARD
  },
  // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)
  // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing
  // on Apple's webpage.
  deleteHardLineForward: {
    unit: DELETE_SELECTION,
    direction: DELETE_FORWARD
  },
  // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with
  // deleteSoftLineBackward.
  deleteSoftLineForward: {
    unit: DELETE_SELECTION,
    direction: DELETE_FORWARD
  }
};
var DeleteObserver = class extends Observer {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    const document = view.document;
    let sequence = 0;
    document.on("keydown", () => {
      sequence++;
    });
    document.on("keyup", () => {
      sequence = 0;
    });
    document.on("beforeinput", (evt, data) => {
      if (!this.isEnabled) {
        return;
      }
      const { targetRanges, domEvent, inputType } = data;
      const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
      if (!deleteEventSpec) {
        return;
      }
      const deleteData = {
        direction: deleteEventSpec.direction,
        unit: deleteEventSpec.unit,
        sequence
      };
      if (deleteData.unit == DELETE_SELECTION) {
        deleteData.selectionToRemove = view.createSelection(targetRanges[0]);
      }
      if (inputType === "deleteContentBackward") {
        if (env_default.isAndroid) {
          deleteData.sequence = 1;
        }
        if (shouldUseTargetRanges(targetRanges)) {
          deleteData.unit = DELETE_SELECTION;
          deleteData.selectionToRemove = view.createSelection(targetRanges);
        }
      }
      const eventInfo = new BubblingEventInfo(document, "delete", targetRanges[0]);
      document.fire(eventInfo, new DomEventData(view, domEvent, deleteData));
      if (eventInfo.stop.called) {
        evt.stop();
      }
    });
    if (env_default.isBlink) {
      enableChromeWorkaround(this);
    }
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
};
function enableChromeWorkaround(observer) {
  const view = observer.view;
  const document = view.document;
  let pressedKeyCode = null;
  let beforeInputReceived = false;
  document.on("keydown", (evt, { keyCode }) => {
    pressedKeyCode = keyCode;
    beforeInputReceived = false;
  });
  document.on("keyup", (evt, { keyCode, domEvent }) => {
    const selection = document.selection;
    const shouldFireDeleteEvent = observer.isEnabled && keyCode == pressedKeyCode && isDeleteKeyCode(keyCode) && !selection.isCollapsed && !beforeInputReceived;
    pressedKeyCode = null;
    if (shouldFireDeleteEvent) {
      const targetRange = selection.getFirstRange();
      const eventInfo = new BubblingEventInfo(document, "delete", targetRange);
      const deleteData = {
        unit: DELETE_SELECTION,
        direction: getDeleteDirection(keyCode),
        selectionToRemove: selection
      };
      document.fire(eventInfo, new DomEventData(view, domEvent, deleteData));
    }
  });
  document.on("beforeinput", (evt, { inputType }) => {
    const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
    const isMatchingBeforeInput = isDeleteKeyCode(pressedKeyCode) && deleteEventSpec && deleteEventSpec.direction == getDeleteDirection(pressedKeyCode);
    if (isMatchingBeforeInput) {
      beforeInputReceived = true;
    }
  }, { priority: "high" });
  document.on("beforeinput", (evt, { inputType, data }) => {
    const shouldIgnoreBeforeInput = pressedKeyCode == keyCodes.delete && inputType == "insertText" && data == "";
    if (shouldIgnoreBeforeInput) {
      evt.stop();
    }
  }, { priority: "high" });
  function isDeleteKeyCode(keyCode) {
    return keyCode == keyCodes.backspace || keyCode == keyCodes.delete;
  }
  function getDeleteDirection(keyCode) {
    return keyCode == keyCodes.backspace ? DELETE_BACKWARD : DELETE_FORWARD;
  }
}
function shouldUseTargetRanges(targetRanges) {
  if (targetRanges.length != 1 || targetRanges[0].isCollapsed) {
    return false;
  }
  const walker = targetRanges[0].getWalker({
    direction: "backward",
    singleCharacters: true,
    ignoreElementEnd: true
  });
  let count2 = 0;
  for (const { nextPosition } of walker) {
    if (!nextPosition.parent.is("$text")) {
      count2++;
    } else {
      const data = nextPosition.parent.data;
      const offset = nextPosition.offset;
      if (isInsideSurrogatePair(data, offset) || isInsideCombinedSymbol(data, offset) || isInsideEmojiSequence(data, offset)) {
        continue;
      }
      count2++;
    }
    if (count2 > 1) {
      return true;
    }
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-typing/src/delete.js
var Delete = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Delete";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const modelDocument = editor.model.document;
    view.addObserver(DeleteObserver);
    this._undoOnBackspace = false;
    const deleteForwardCommand = new DeleteCommand(editor, "forward");
    editor.commands.add("deleteForward", deleteForwardCommand);
    editor.commands.add("forwardDelete", deleteForwardCommand);
    editor.commands.add("delete", new DeleteCommand(editor, "backward"));
    this.listenTo(viewDocument, "delete", (evt, data) => {
      if (!viewDocument.isComposing) {
        data.preventDefault();
      }
      const { direction, sequence, selectionToRemove, unit } = data;
      const commandName = direction === "forward" ? "deleteForward" : "delete";
      const commandData = { sequence };
      if (unit == "selection") {
        const modelRanges = Array.from(selectionToRemove.getRanges()).map((viewRange) => {
          return editor.editing.mapper.toModelRange(viewRange);
        });
        commandData.selection = editor.model.createSelection(modelRanges);
      } else {
        commandData.unit = unit;
      }
      editor.execute(commandName, commandData);
      view.scrollToTheSelection();
    }, { priority: "low" });
    if (this.editor.plugins.has("UndoEditing")) {
      this.listenTo(viewDocument, "delete", (evt, data) => {
        if (this._undoOnBackspace && data.direction == "backward" && data.sequence == 1 && data.unit == "codePoint") {
          this._undoOnBackspace = false;
          editor.execute("undo");
          data.preventDefault();
          evt.stop();
        }
      }, { context: "$capture" });
      this.listenTo(modelDocument, "change", () => {
        this._undoOnBackspace = false;
      });
    }
  }
  /**
   * If the next user action after calling this method is pressing backspace, it would undo the last change.
   *
   * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.
   */
  requestUndoOnBackspace() {
    if (this.editor.plugins.has("UndoEditing")) {
      this._undoOnBackspace = true;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/typing.js
var Typing = class extends Plugin {
  static get requires() {
    return [Input, Delete];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Typing";
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/utils/getlasttextline.js
function getLastTextLine(range, model) {
  let start = range.start;
  const text = Array.from(range.getWalker({ ignoreElementEnd: false })).reduce((rangeText, { item }) => {
    if (!(item.is("$text") || item.is("$textProxy"))) {
      start = model.createPositionAfter(item);
      return "";
    }
    return rangeText + item.data;
  }, "");
  return { text, range: model.createRange(start, range.end) };
}

// node_modules/@ckeditor/ckeditor5-typing/src/textwatcher.js
var TextWatcher = class extends ObservableMixin() {
  /**
   * Creates a text watcher instance.
   *
   * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
   */
  constructor(model, testCallback) {
    super();
    this.model = model;
    this.testCallback = testCallback;
    this._hasMatch = false;
    this.set("isEnabled", true);
    this.on("change:isEnabled", () => {
      if (this.isEnabled) {
        this._startListening();
      } else {
        this.stopListening(model.document.selection);
        this.stopListening(model.document);
      }
    });
    this._startListening();
  }
  /**
   * Flag indicating whether there is a match currently.
   */
  get hasMatch() {
    return this._hasMatch;
  }
  /**
   * Starts listening to the editor for typing and selection events.
   */
  _startListening() {
    const model = this.model;
    const document = model.document;
    this.listenTo(document.selection, "change:range", (evt, { directChange }) => {
      if (!directChange) {
        return;
      }
      if (!document.selection.isCollapsed) {
        if (this.hasMatch) {
          this.fire("unmatched");
          this._hasMatch = false;
        }
        return;
      }
      this._evaluateTextBeforeSelection("selection");
    });
    this.listenTo(document, "change:data", (evt, batch) => {
      if (batch.isUndo || !batch.isLocal) {
        return;
      }
      this._evaluateTextBeforeSelection("data", { batch });
    });
  }
  /**
   * Checks the editor content for matched text.
   *
   * @fires matched:data
   * @fires matched:selection
   * @fires unmatched
   *
   * @param suffix A suffix used for generating the event name.
   * @param data Data object for event.
   */
  _evaluateTextBeforeSelection(suffix, data = {}) {
    const model = this.model;
    const document = model.document;
    const selection = document.selection;
    const rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);
    const { text, range } = getLastTextLine(rangeBeforeSelection, model);
    const testResult = this.testCallback(text);
    if (!testResult && this.hasMatch) {
      this.fire("unmatched");
    }
    this._hasMatch = !!testResult;
    if (testResult) {
      const eventData = Object.assign(data, { text, range });
      if (typeof testResult == "object") {
        Object.assign(eventData, testResult);
      }
      this.fire(`matched:${suffix}`, eventData);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/twostepcaretmovement.js
var TwoStepCaretMovement = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TwoStepCaretMovement";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this.attributes = /* @__PURE__ */ new Set();
    this._overrideUid = null;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const locale = editor.locale;
    const modelSelection = model.document.selection;
    this.listenTo(view.document, "arrowKey", (evt, data) => {
      if (!modelSelection.isCollapsed) {
        return;
      }
      if (data.shiftKey || data.altKey || data.ctrlKey) {
        return;
      }
      const arrowRightPressed = data.keyCode == keyCodes.arrowright;
      const arrowLeftPressed = data.keyCode == keyCodes.arrowleft;
      if (!arrowRightPressed && !arrowLeftPressed) {
        return;
      }
      const contentDirection = locale.contentLanguageDirection;
      let isMovementHandled = false;
      if (contentDirection === "ltr" && arrowRightPressed || contentDirection === "rtl" && arrowLeftPressed) {
        isMovementHandled = this._handleForwardMovement(data);
      } else {
        isMovementHandled = this._handleBackwardMovement(data);
      }
      if (isMovementHandled === true) {
        evt.stop();
      }
    }, { context: "$text", priority: "highest" });
    this._isNextGravityRestorationSkipped = false;
    this.listenTo(modelSelection, "change:range", (evt, data) => {
      if (this._isNextGravityRestorationSkipped) {
        this._isNextGravityRestorationSkipped = false;
        return;
      }
      if (!this._isGravityOverridden) {
        return;
      }
      if (!data.directChange && isBetweenDifferentAttributes(modelSelection.getFirstPosition(), this.attributes)) {
        return;
      }
      this._restoreGravity();
    });
  }
  /**
   * Registers a given attribute for the two-step caret movement.
   *
   * @param attribute Name of the attribute to handle.
   */
  registerAttribute(attribute) {
    this.attributes.add(attribute);
  }
  /**
   * Updates the document selection and the view according to the two–step caret movement state
   * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
   *
   * @param data Data of the key press.
   * @returns `true` when the handler prevented caret movement.
   */
  _handleForwardMovement(data) {
    const attributes = this.attributes;
    const model = this.editor.model;
    const selection = model.document.selection;
    const position = selection.getFirstPosition();
    if (this._isGravityOverridden) {
      return false;
    }
    if (position.isAtStart && hasAnyAttribute(selection, attributes)) {
      return false;
    }
    if (isBetweenDifferentAttributes(position, attributes)) {
      preventCaretMovement(data);
      this._overrideGravity();
      return true;
    }
    return false;
  }
  /**
   * Updates the document selection and the view according to the two–step caret movement state
   * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
   *
   * @param data Data of the key press.
   * @returns `true` when the handler prevented caret movement
   */
  _handleBackwardMovement(data) {
    const attributes = this.attributes;
    const model = this.editor.model;
    const selection = model.document.selection;
    const position = selection.getFirstPosition();
    if (this._isGravityOverridden) {
      preventCaretMovement(data);
      this._restoreGravity();
      setSelectionAttributesFromTheNodeBefore(model, attributes, position);
      return true;
    } else {
      if (position.isAtStart) {
        if (hasAnyAttribute(selection, attributes)) {
          preventCaretMovement(data);
          setSelectionAttributesFromTheNodeBefore(model, attributes, position);
          return true;
        }
        return false;
      }
      if (isStepAfterAnyAttributeBoundary(position, attributes)) {
        if (position.isAtEnd && !hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes)) {
          preventCaretMovement(data);
          setSelectionAttributesFromTheNodeBefore(model, attributes, position);
          return true;
        }
        this._isNextGravityRestorationSkipped = true;
        this._overrideGravity();
        return false;
      }
    }
    return false;
  }
  /**
   * `true` when the gravity is overridden for the plugin.
   */
  get _isGravityOverridden() {
    return !!this._overrideUid;
  }
  /**
   * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}
   * and stores the information about this fact in the {@link #_overrideUid}.
   *
   * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
   */
  _overrideGravity() {
    this._overrideUid = this.editor.model.change((writer) => {
      return writer.overrideSelectionGravity();
    });
  }
  /**
   * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.
   *
   * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.
   */
  _restoreGravity() {
    this.editor.model.change((writer) => {
      writer.restoreSelectionGravity(this._overrideUid);
      this._overrideUid = null;
    });
  }
};
function hasAnyAttribute(selection, attributes) {
  for (const observedAttribute of attributes) {
    if (selection.hasAttribute(observedAttribute)) {
      return true;
    }
  }
  return false;
}
function setSelectionAttributesFromTheNodeBefore(model, attributes, position) {
  const nodeBefore = position.nodeBefore;
  model.change((writer) => {
    if (nodeBefore) {
      const attributes2 = [];
      const isInlineObject = model.schema.isObject(nodeBefore) && model.schema.isInline(nodeBefore);
      for (const [key, value] of nodeBefore.getAttributes()) {
        if (model.schema.checkAttribute("$text", key) && (!isInlineObject || model.schema.getAttributeProperties(key).copyFromObject !== false)) {
          attributes2.push([key, value]);
        }
      }
      writer.setSelectionAttribute(attributes2);
    } else {
      writer.removeSelectionAttribute(attributes);
    }
  });
}
function preventCaretMovement(data) {
  data.preventDefault();
}
function isStepAfterAnyAttributeBoundary(position, attributes) {
  const positionBefore = position.getShiftedBy(-1);
  return isBetweenDifferentAttributes(positionBefore, attributes);
}
function isBetweenDifferentAttributes(position, attributes) {
  const { nodeBefore, nodeAfter } = position;
  for (const observedAttribute of attributes) {
    const attrBefore = nodeBefore ? nodeBefore.getAttribute(observedAttribute) : void 0;
    const attrAfter = nodeAfter ? nodeAfter.getAttribute(observedAttribute) : void 0;
    if (attrAfter !== attrBefore) {
      return true;
    }
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-typing/src/utils/findattributerange.js
function findAttributeRange(position, attributeName, value, model) {
  return model.createRange(findAttributeRangeBound(position, attributeName, value, true, model), findAttributeRangeBound(position, attributeName, value, false, model));
}
function findAttributeRangeBound(position, attributeName, value, lookBack, model) {
  let node = position.textNode || (lookBack ? position.nodeBefore : position.nodeAfter);
  let lastNode = null;
  while (node && node.getAttribute(attributeName) == value) {
    lastNode = node;
    node = lookBack ? node.previousSibling : node.nextSibling;
  }
  return lastNode ? model.createPositionAt(lastNode, lookBack ? "before" : "after") : position;
}

// node_modules/@ckeditor/ckeditor5-typing/src/utils/inlinehighlight.js
function inlineHighlight(editor, attributeName, tagName, className) {
  const view = editor.editing.view;
  const highlightedElements = /* @__PURE__ */ new Set();
  view.document.registerPostFixer((writer) => {
    const selection = editor.model.document.selection;
    let changed = false;
    if (selection.hasAttribute(attributeName)) {
      const modelRange = findAttributeRange(selection.getFirstPosition(), attributeName, selection.getAttribute(attributeName), editor.model);
      const viewRange = editor.editing.mapper.toViewRange(modelRange);
      for (const item of viewRange.getItems()) {
        if (item.is("element", tagName) && !item.hasClass(className)) {
          writer.addClass(className, item);
          highlightedElements.add(item);
          changed = true;
        }
      }
    }
    return changed;
  });
  editor.conversion.for("editingDowncast").add((dispatcher) => {
    dispatcher.on("insert", removeHighlight, { priority: "highest" });
    dispatcher.on("remove", removeHighlight, { priority: "highest" });
    dispatcher.on("attribute", removeHighlight, { priority: "highest" });
    dispatcher.on("selection", removeHighlight, { priority: "highest" });
    function removeHighlight() {
      view.change((writer) => {
        for (const item of highlightedElements.values()) {
          writer.removeClass(className, item);
          highlightedElements.delete(item);
        }
      });
    }
  });
}

// node_modules/@ckeditor/ckeditor5-typing/src/texttransformation.js
var TRANSFORMATIONS = {
  // Common symbols:
  copyright: { from: "(c)", to: "©" },
  registeredTrademark: { from: "(r)", to: "®" },
  trademark: { from: "(tm)", to: "™" },
  // Mathematical:
  oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] },
  oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] },
  twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] },
  oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] },
  threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] },
  lessThanOrEqual: { from: "<=", to: "≤" },
  greaterThanOrEqual: { from: ">=", to: "≥" },
  notEqual: { from: "!=", to: "≠" },
  arrowLeft: { from: "<-", to: "←" },
  arrowRight: { from: "->", to: "→" },
  // Typography:
  horizontalEllipsis: { from: "...", to: "…" },
  enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] },
  emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] },
  // Quotations:
  // English, US
  quotesPrimary: { from: buildQuotesRegExp('"'), to: [null, "“", null, "”"] },
  quotesSecondary: { from: buildQuotesRegExp("'"), to: [null, "‘", null, "’"] },
  // English, UK
  quotesPrimaryEnGb: { from: buildQuotesRegExp("'"), to: [null, "‘", null, "’"] },
  quotesSecondaryEnGb: { from: buildQuotesRegExp('"'), to: [null, "“", null, "”"] },
  // Polish
  quotesPrimaryPl: { from: buildQuotesRegExp('"'), to: [null, "„", null, "”"] },
  quotesSecondaryPl: { from: buildQuotesRegExp("'"), to: [null, "‚", null, "’"] }
};
function buildQuotesRegExp(quoteCharacter) {
  return new RegExp(`(^|\\s)(${quoteCharacter})([^${quoteCharacter}]*)(${quoteCharacter})$`);
}

export {
  Input,
  Delete,
  Typing,
  getLastTextLine,
  TextWatcher,
  TwoStepCaretMovement,
  findAttributeRange,
  inlineHighlight
};
/*! Bundled license information:

@ckeditor/ckeditor5-typing/src/utils/changebuffer.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/inserttextcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/inserttextobserver.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/input.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/deletecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/deleteobserver.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/delete.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/typing.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/utils/getlasttextline.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/textwatcher.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/twostepcaretmovement.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/utils/findattributerange.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/utils/inlinehighlight.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/texttransformation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-4MFML76R.js.map
