import "./chunk-SX3YCKSJ.js";
import {
  Undo
} from "./chunk-5CZTTXVA.js";
import {
  Clipboard
} from "./chunk-74PGQAYV.js";
import {
  Widget,
  WidgetToolbarRepository,
  findOptimalInsertionRange,
  isWidget,
  toWidget
} from "./chunk-NMGSIING.js";
import "./chunk-DEIZSOIF.js";
import "./chunk-GGCPNJOL.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  ButtonView,
  CssTransitionDisablerMixin,
  FocusCycler,
  IconView,
  LabeledFieldView,
  Template,
  View,
  ViewCollection,
  createDropdown,
  createLabeledInputText,
  submitHandler
} from "./chunk-SGTDNT4V.js";
import "./chunk-W3CRWNYM.js";
import {
  Delete
} from "./chunk-4MFML76R.js";
import "./chunk-6LVMAMLV.js";
import {
  Command,
  FocusTracker,
  KeystrokeHandler,
  LivePosition,
  LiveRange,
  Plugin,
  first,
  global_default,
  icons,
  logWarning,
  toArray
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-media-embed/src/converters.js
function modelToViewUrlAttributeConverter(registry, options) {
  const converter = (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const url = data.attributeNewValue;
    const viewWriter = conversionApi.writer;
    const figure = conversionApi.mapper.toViewElement(data.item);
    const mediaContentElement = [...figure.getChildren()].find((child) => child.getCustomProperty("media-content"));
    viewWriter.remove(mediaContentElement);
    const mediaViewElement = registry.getMediaViewElement(viewWriter, url, options);
    viewWriter.insert(viewWriter.createPositionAt(figure, 0), mediaViewElement);
  };
  return (dispatcher) => {
    dispatcher.on("attribute:url:media", converter);
  };
}

// node_modules/@ckeditor/ckeditor5-media-embed/src/utils.js
function toMediaWidget(viewElement, writer, label) {
  writer.setCustomProperty("media", true, viewElement);
  return toWidget(viewElement, writer, { label });
}
function getSelectedMediaViewWidget(selection) {
  const viewElement = selection.getSelectedElement();
  if (viewElement && isMediaWidget(viewElement)) {
    return viewElement;
  }
  return null;
}
function isMediaWidget(viewElement) {
  return !!viewElement.getCustomProperty("media") && isWidget(viewElement);
}
function createMediaFigureElement(writer, registry, url, options) {
  return writer.createContainerElement("figure", { class: "media" }, [
    registry.getMediaViewElement(writer, url, options),
    writer.createSlot()
  ]);
}
function getSelectedMediaModelWidget(selection) {
  const selectedElement = selection.getSelectedElement();
  if (selectedElement && selectedElement.is("element", "media")) {
    return selectedElement;
  }
  return null;
}
function insertMedia(model, url, selectable, findOptimalPosition) {
  model.change((writer) => {
    const mediaElement = writer.createElement("media", { url });
    model.insertObject(mediaElement, selectable, null, {
      setSelection: "on",
      findOptimalPosition: findOptimalPosition ? "auto" : void 0
    });
  });
}

// node_modules/@ckeditor/ckeditor5-media-embed/src/mediaembedcommand.js
var MediaEmbedCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedMedia = getSelectedMediaModelWidget(selection);
    this.value = selectedMedia ? selectedMedia.getAttribute("url") : void 0;
    this.isEnabled = isMediaSelected(selection) || isAllowedInParent(selection, model);
  }
  /**
   * Executes the command, which either:
   *
   * * updates the URL of the selected media,
   * * inserts the new media into the editor and puts the selection around it.
   *
   * @fires execute
   * @param url The URL of the media.
   */
  execute(url) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedMedia = getSelectedMediaModelWidget(selection);
    if (selectedMedia) {
      model.change((writer) => {
        writer.setAttribute("url", url, selectedMedia);
      });
    } else {
      insertMedia(model, url, selection, true);
    }
  }
};
function isAllowedInParent(selection, model) {
  const insertionRange = findOptimalInsertionRange(selection, model);
  let parent = insertionRange.start.parent;
  if (parent.isEmpty && !model.schema.isLimit(parent)) {
    parent = parent.parent;
  }
  return model.schema.checkChild(parent, "media");
}
function isMediaSelected(selection) {
  const element = selection.getSelectedElement();
  return !!element && element.name === "media";
}

// node_modules/@ckeditor/ckeditor5-media-embed/src/mediaregistry.js
import mediaPlaceholderIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-media-embed/theme/icons/media-placeholder.svg";
var mediaPlaceholderIconViewBox = "0 0 64 42";
var MediaRegistry = class {
  /**
   * Creates an instance of the {@link module:media-embed/mediaregistry~MediaRegistry} class.
   *
   * @param locale The localization services instance.
   * @param config The configuration of the media embed feature.
   */
  constructor(locale, config) {
    const providers = config.providers;
    const extraProviders = config.extraProviders || [];
    const removedProviders = new Set(config.removeProviders);
    const providerDefinitions = providers.concat(extraProviders).filter((provider) => {
      const name = provider.name;
      if (!name) {
        logWarning("media-embed-no-provider-name", { provider });
        return false;
      }
      return !removedProviders.has(name);
    });
    this.locale = locale;
    this.providerDefinitions = providerDefinitions;
  }
  /**
   * Checks whether the passed URL is representing a certain media type allowed in the editor.
   *
   * @param url The URL to be checked
   */
  hasMedia(url) {
    return !!this._getMedia(url);
  }
  /**
   * For the given media URL string and options, it returns the {@link module:engine/view/element~Element view element}
   * representing that media.
   *
   * **Note:** If no URL is specified, an empty view element is returned.
   *
   * @param writer The view writer used to produce a view element.
   * @param url The URL to be translated into a view element.
   */
  getMediaViewElement(writer, url, options) {
    return this._getMedia(url).getViewElement(writer, options);
  }
  /**
   * Returns a `Media` instance for the given URL.
   *
   * @param url The URL of the media.
   * @returns The `Media` instance or `null` when there is none.
   */
  _getMedia(url) {
    if (!url) {
      return new Media(this.locale);
    }
    url = url.trim();
    for (const definition of this.providerDefinitions) {
      const previewRenderer = definition.html;
      const pattern = toArray(definition.url);
      for (const subPattern of pattern) {
        const match = this._getUrlMatches(url, subPattern);
        if (match) {
          return new Media(this.locale, url, match, previewRenderer);
        }
      }
    }
    return null;
  }
  /**
   * Tries to match `url` to `pattern`.
   *
   * @param url The URL of the media.
   * @param pattern The pattern that should accept the media URL.
   */
  _getUrlMatches(url, pattern) {
    let match = url.match(pattern);
    if (match) {
      return match;
    }
    let rawUrl = url.replace(/^https?:\/\//, "");
    match = rawUrl.match(pattern);
    if (match) {
      return match;
    }
    rawUrl = rawUrl.replace(/^www\./, "");
    match = rawUrl.match(pattern);
    if (match) {
      return match;
    }
    return null;
  }
};
var Media = class {
  constructor(locale, url, match, previewRenderer) {
    this.url = this._getValidUrl(url);
    this._locale = locale;
    this._match = match;
    this._previewRenderer = previewRenderer;
  }
  /**
   * Returns the view element representation of the media.
   *
   * @param writer The view writer used to produce a view element.
   */
  getViewElement(writer, options) {
    const attributes = {};
    let viewElement;
    if (options.renderForEditingView || options.renderMediaPreview && this.url && this._previewRenderer) {
      if (this.url) {
        attributes["data-oembed-url"] = this.url;
      }
      if (options.renderForEditingView) {
        attributes.class = "ck-media__wrapper";
      }
      const mediaHtml = this._getPreviewHtml(options);
      viewElement = writer.createRawElement("div", attributes, (domElement, domConverter) => {
        domConverter.setContentOf(domElement, mediaHtml);
      });
    } else {
      if (this.url) {
        attributes.url = this.url;
      }
      viewElement = writer.createEmptyElement(options.elementName, attributes);
    }
    writer.setCustomProperty("media-content", true, viewElement);
    return viewElement;
  }
  /**
   * Returns the HTML string of the media content preview.
   */
  _getPreviewHtml(options) {
    if (this._previewRenderer) {
      return this._previewRenderer(this._match);
    } else {
      if (this.url && options.renderForEditingView) {
        return this._getPlaceholderHtml();
      }
      return "";
    }
  }
  /**
   * Returns the placeholder HTML when the media has no content preview.
   */
  _getPlaceholderHtml() {
    const icon = new IconView();
    const t = this._locale.t;
    icon.content = mediaPlaceholderIcon;
    icon.viewBox = mediaPlaceholderIconViewBox;
    const placeholder = new Template({
      tag: "div",
      attributes: {
        class: "ck ck-reset_all ck-media__placeholder"
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: "ck-media__placeholder__icon"
          },
          children: [icon]
        },
        {
          tag: "a",
          attributes: {
            class: "ck-media__placeholder__url",
            target: "_blank",
            rel: "noopener noreferrer",
            href: this.url,
            "data-cke-tooltip-text": t("Open media in new tab")
          },
          children: [
            {
              tag: "span",
              attributes: {
                class: "ck-media__placeholder__url__text"
              },
              children: [this.url]
            }
          ]
        }
      ]
    }).render();
    return placeholder.outerHTML;
  }
  /**
   * Returns the full URL to the specified media.
   *
   * @param url The URL of the media.
   */
  _getValidUrl(url) {
    if (!url) {
      return null;
    }
    if (url.match(/^https?/)) {
      return url;
    }
    return "https://" + url;
  }
};

// node_modules/@ckeditor/ckeditor5-media-embed/src/mediaembedediting.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembedediting.css";
var MediaEmbedEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MediaEmbedEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("mediaEmbed", {
      elementName: "oembed",
      providers: [
        {
          name: "dailymotion",
          url: /^dailymotion\.com\/video\/(\w+)/,
          html: (match) => {
            const id = match[1];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${id}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`;
          }
        },
        {
          name: "spotify",
          url: [
            /^open\.spotify\.com\/(artist\/\w+)/,
            /^open\.spotify\.com\/(album\/\w+)/,
            /^open\.spotify\.com\/(track\/\w+)/
          ],
          html: (match) => {
            const id = match[1];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${id}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`;
          }
        },
        {
          name: "youtube",
          url: [
            /^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/,
            /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/,
            /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/,
            /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/
          ],
          html: (match) => {
            const id = match[1];
            const time = match[2];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${id}${time ? `?start=${time}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`;
          }
        },
        {
          name: "vimeo",
          url: [
            /^vimeo\.com\/(\d+)/,
            /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,
            /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,
            /^vimeo\.com\/channels\/[^/]+\/(\d+)/,
            /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,
            /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,
            /^player\.vimeo\.com\/video\/(\d+)/
          ],
          html: (match) => {
            const id = match[1];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${id}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`;
          }
        },
        {
          name: "instagram",
          url: /^instagram\.com\/p\/(\w+)/
        },
        {
          name: "twitter",
          url: /^twitter\.com/
        },
        {
          name: "googleMaps",
          url: [
            /^google\.com\/maps/,
            /^goo\.gl\/maps/,
            /^maps\.google\.com/,
            /^maps\.app\.goo\.gl/
          ]
        },
        {
          name: "flickr",
          url: /^flickr\.com/
        },
        {
          name: "facebook",
          url: /^facebook\.com/
        }
      ]
    });
    this.registry = new MediaRegistry(editor.locale, editor.config.get("mediaEmbed"));
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const t = editor.t;
    const conversion = editor.conversion;
    const renderMediaPreview = editor.config.get("mediaEmbed.previewsInData");
    const elementName = editor.config.get("mediaEmbed.elementName");
    const registry = this.registry;
    editor.commands.add("mediaEmbed", new MediaEmbedCommand(editor));
    schema.register("media", {
      inheritAllFrom: "$blockObject",
      allowAttributes: ["url"]
    });
    conversion.for("dataDowncast").elementToStructure({
      model: "media",
      view: (modelElement, { writer }) => {
        const url = modelElement.getAttribute("url");
        return createMediaFigureElement(writer, registry, url, {
          elementName,
          renderMediaPreview: !!url && renderMediaPreview
        });
      }
    });
    conversion.for("dataDowncast").add(modelToViewUrlAttributeConverter(registry, {
      elementName,
      renderMediaPreview
    }));
    conversion.for("editingDowncast").elementToStructure({
      model: "media",
      view: (modelElement, { writer }) => {
        const url = modelElement.getAttribute("url");
        const figure = createMediaFigureElement(writer, registry, url, {
          elementName,
          renderForEditingView: true
        });
        return toMediaWidget(figure, writer, t("media widget"));
      }
    });
    conversion.for("editingDowncast").add(modelToViewUrlAttributeConverter(registry, {
      elementName,
      renderForEditingView: true
    }));
    conversion.for("upcast").elementToElement({
      view: (element) => ["oembed", elementName].includes(element.name) && element.getAttribute("url") ? { name: true } : null,
      model: (viewMedia, { writer }) => {
        const url = viewMedia.getAttribute("url");
        if (registry.hasMedia(url)) {
          return writer.createElement("media", { url });
        }
        return null;
      }
    }).elementToElement({
      view: {
        name: "div",
        attributes: {
          "data-oembed-url": true
        }
      },
      model: (viewMedia, { writer }) => {
        const url = viewMedia.getAttribute("data-oembed-url");
        if (registry.hasMedia(url)) {
          return writer.createElement("media", { url });
        }
        return null;
      }
    }).add((dispatcher) => {
      const converter = (evt, data, conversionApi) => {
        if (!conversionApi.consumable.consume(data.viewItem, { name: true, classes: "media" })) {
          return;
        }
        const { modelRange, modelCursor } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
        data.modelRange = modelRange;
        data.modelCursor = modelCursor;
        const modelElement = first(modelRange.getItems());
        if (!modelElement) {
          conversionApi.consumable.revert(data.viewItem, { name: true, classes: "media" });
        }
      };
      dispatcher.on("element:figure", converter);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-media-embed/src/automediaembed.js
var URL_REGEXP = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
var AutoMediaEmbed = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Clipboard, Delete, Undo];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AutoMediaEmbed";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._timeoutId = null;
    this._positionToInsert = null;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const modelDocument = editor.model.document;
    const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
    this.listenTo(clipboardPipeline, "inputTransformation", () => {
      const firstRange = modelDocument.selection.getFirstRange();
      const leftLivePosition = LivePosition.fromPosition(firstRange.start);
      leftLivePosition.stickiness = "toPrevious";
      const rightLivePosition = LivePosition.fromPosition(firstRange.end);
      rightLivePosition.stickiness = "toNext";
      modelDocument.once("change:data", () => {
        this._embedMediaBetweenPositions(leftLivePosition, rightLivePosition);
        leftLivePosition.detach();
        rightLivePosition.detach();
      }, { priority: "high" });
    });
    const undoCommand = editor.commands.get("undo");
    undoCommand.on("execute", () => {
      if (this._timeoutId) {
        global_default.window.clearTimeout(this._timeoutId);
        this._positionToInsert.detach();
        this._timeoutId = null;
        this._positionToInsert = null;
      }
    }, { priority: "high" });
  }
  /**
   * Analyzes the part of the document between provided positions in search for a URL representing media.
   * When the URL is found, it is automatically converted into media.
   *
   * @param leftPosition Left position of the selection.
   * @param rightPosition Right position of the selection.
   */
  _embedMediaBetweenPositions(leftPosition, rightPosition) {
    const editor = this.editor;
    const mediaRegistry = editor.plugins.get(MediaEmbedEditing).registry;
    const urlRange = new LiveRange(leftPosition, rightPosition);
    const walker = urlRange.getWalker({ ignoreElementEnd: true });
    let url = "";
    for (const node of walker) {
      if (node.item.is("$textProxy")) {
        url += node.item.data;
      }
    }
    url = url.trim();
    if (!url.match(URL_REGEXP)) {
      urlRange.detach();
      return;
    }
    if (!mediaRegistry.hasMedia(url)) {
      urlRange.detach();
      return;
    }
    const mediaEmbedCommand = editor.commands.get("mediaEmbed");
    if (!mediaEmbedCommand.isEnabled) {
      urlRange.detach();
      return;
    }
    this._positionToInsert = LivePosition.fromPosition(leftPosition);
    this._timeoutId = global_default.window.setTimeout(() => {
      editor.model.change((writer) => {
        this._timeoutId = null;
        writer.remove(urlRange);
        urlRange.detach();
        let insertionPosition = null;
        if (this._positionToInsert.root.rootName !== "$graveyard") {
          insertionPosition = this._positionToInsert;
        }
        insertMedia(editor.model, url, insertionPosition, false);
        this._positionToInsert.detach();
        this._positionToInsert = null;
      });
      editor.plugins.get(Delete).requestUndoOnBackspace();
    }, 100);
  }
};

// node_modules/@ckeditor/ckeditor5-media-embed/src/ui/mediaformview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaform.css";
var MediaFormView = class extends View {
  /**
   * @param validators Form validators used by {@link #isValid}.
   * @param locale The localization services instance.
   */
  constructor(validators, locale) {
    super(locale);
    const t = locale.t;
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.set("mediaURLInputValue", "");
    this.urlInputView = this._createUrlInput();
    this.saveButtonView = this._createButton(t("Save"), icons.check, "ck-button-save");
    this.saveButtonView.type = "submit";
    this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (value) => !!value);
    this.cancelButtonView = this._createButton(t("Cancel"), icons.cancel, "ck-button-cancel", "cancel");
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    });
    this._validators = validators;
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-media-form",
          "ck-responsive-form"
        ],
        tabindex: "-1"
      },
      children: [
        this.urlInputView,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    const childViews = [
      this.urlInputView,
      this.saveButtonView,
      this.cancelButtonView
    ];
    childViews.forEach((v) => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });
    this.keystrokes.listenTo(this.element);
    const stopPropagation = (data) => data.stopPropagation();
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Focuses the fist {@link #_focusables} in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * The native DOM `value` of the {@link #urlInputView} element.
   *
   * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
   * which works one way only and may not represent the actual state of the component in the DOM.
   */
  get url() {
    return this.urlInputView.fieldView.element.value.trim();
  }
  set url(url) {
    this.urlInputView.fieldView.element.value = url.trim();
  }
  /**
   * Validates the form and returns `false` when some fields are invalid.
   */
  isValid() {
    this.resetFormStatus();
    for (const validator of this._validators) {
      const errorText = validator(this);
      if (errorText) {
        this.urlInputView.errorText = errorText;
        return false;
      }
    }
    return true;
  }
  /**
   * Cleans up the supplementary error and information text of the {@link #urlInputView}
   * bringing them back to the state when the form has been displayed for the first time.
   *
   * See {@link #isValid}.
   */
  resetFormStatus() {
    this.urlInputView.errorText = null;
    this.urlInputView.infoText = this._urlInputViewInfoDefault;
  }
  /**
   * Creates a labeled input view.
   *
   * @returns Labeled input view instance.
   */
  _createUrlInput() {
    const t = this.locale.t;
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
    const inputField = labeledInput.fieldView;
    this._urlInputViewInfoDefault = t("Paste the media URL in the input.");
    this._urlInputViewInfoTip = t("Tip: Paste the URL into the content to embed faster.");
    labeledInput.label = t("Media URL");
    labeledInput.infoText = this._urlInputViewInfoDefault;
    inputField.on("input", () => {
      labeledInput.infoText = inputField.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault;
      this.mediaURLInputValue = inputField.element.value.trim();
    });
    return labeledInput;
  }
  /**
   * Creates a button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   * @param className The additional button CSS class name.
   * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(label, icon, className, eventName) {
    const button = new ButtonView(this.locale);
    button.set({
      label,
      icon,
      tooltip: true
    });
    button.extendTemplate({
      attributes: {
        class: className
      }
    });
    if (eventName) {
      button.delegate("execute").to(this, eventName);
    }
    return button;
  }
};

// node_modules/@ckeditor/ckeditor5-media-embed/src/mediaembedui.js
import mediaIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-media-embed/theme/icons/media.svg";
var MediaEmbedUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [MediaEmbedEditing];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MediaEmbedUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const command = editor.commands.get("mediaEmbed");
    editor.ui.componentFactory.add("mediaEmbed", (locale) => {
      const dropdown = createDropdown(locale);
      this._setUpDropdown(dropdown, command);
      return dropdown;
    });
  }
  _setUpDropdown(dropdown, command) {
    const editor = this.editor;
    const t = editor.t;
    const button = dropdown.buttonView;
    const registry = editor.plugins.get(MediaEmbedEditing).registry;
    dropdown.once("change:isOpen", () => {
      const form = new (CssTransitionDisablerMixin(MediaFormView))(getFormValidators(editor.t, registry), editor.locale);
      dropdown.panelView.children.add(form);
      button.on("open", () => {
        form.disableCssTransitions();
        form.url = command.value || "";
        form.urlInputView.fieldView.select();
        form.enableCssTransitions();
      }, { priority: "low" });
      dropdown.on("submit", () => {
        if (form.isValid()) {
          editor.execute("mediaEmbed", form.url);
          editor.editing.view.focus();
        }
      });
      dropdown.on("change:isOpen", () => form.resetFormStatus());
      dropdown.on("cancel", () => {
        editor.editing.view.focus();
      });
      form.delegate("submit", "cancel").to(dropdown);
      form.urlInputView.fieldView.bind("value").to(command, "value");
      form.urlInputView.bind("isEnabled").to(command, "isEnabled");
    });
    dropdown.bind("isEnabled").to(command);
    button.set({
      label: t("Insert media"),
      icon: mediaIcon,
      tooltip: true
    });
  }
};
function getFormValidators(t, registry) {
  return [
    (form) => {
      if (!form.url.length) {
        return t("The URL must not be empty.");
      }
    },
    (form) => {
      if (!registry.hasMedia(form.url)) {
        return t("This media URL is not supported.");
      }
    }
  ];
}

// node_modules/@ckeditor/ckeditor5-media-embed/src/mediaembed.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembed.css";
var MediaEmbed = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [MediaEmbedEditing, MediaEmbedUI, AutoMediaEmbed, Widget];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MediaEmbed";
  }
};

// node_modules/@ckeditor/ckeditor5-media-embed/src/mediaembedtoolbar.js
var MediaEmbedToolbar = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [WidgetToolbarRepository];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "MediaEmbedToolbar";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const editor = this.editor;
    const t = editor.t;
    const widgetToolbarRepository = editor.plugins.get(WidgetToolbarRepository);
    widgetToolbarRepository.register("mediaEmbed", {
      ariaLabel: t("Media toolbar"),
      items: editor.config.get("mediaEmbed.toolbar") || [],
      getRelatedElement: getSelectedMediaViewWidget
    });
  }
};
export {
  AutoMediaEmbed,
  MediaEmbed,
  MediaEmbedEditing,
  MediaEmbedToolbar,
  MediaEmbedUI
};
/*! Bundled license information:

@ckeditor/ckeditor5-media-embed/src/converters.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/mediaembedcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/mediaregistry.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/mediaembedediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/automediaembed.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/ui/mediaformview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/mediaembedui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/mediaembed.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/mediaembedconfig.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/mediaembedtoolbar.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-media-embed/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-media-embed.js.map
