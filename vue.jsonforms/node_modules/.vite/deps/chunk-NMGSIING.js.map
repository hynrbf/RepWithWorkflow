{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-widget/src/highlightstack.js", "../../@ckeditor/ckeditor5-widget/src/widgettypearound/utils.js", "../../@ckeditor/ckeditor5-widget/src/utils.js", "../../@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js", "../../@ckeditor/ckeditor5-widget/src/verticalnavigation.js", "../../@ckeditor/ckeditor5-widget/src/widget.js", "../../@ckeditor/ckeditor5-widget/src/widgettoolbarrepository.js", "../../@ckeditor/ckeditor5-widget/src/widgetresize/resizerstate.js", "../../@ckeditor/ckeditor5-widget/src/widgetresize/sizeview.js", "../../@ckeditor/ckeditor5-widget/src/widgetresize/resizer.js", "../../@ckeditor/ckeditor5-widget/src/widgetresize.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/highlightstack\n */\nimport { EmitterMixin } from '@ckeditor/ckeditor5-utils';\n/**\n * Class used to handle the correct order of highlights on elements.\n *\n * When different highlights are applied to same element the correct order should be preserved:\n *\n * * highlight with highest priority should be applied,\n * * if two highlights have same priority - sort by CSS class provided in\n * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n *\n * This way, highlight will be applied with the same rules it is applied on texts.\n */\nexport default class HighlightStack extends EmitterMixin() {\n    constructor() {\n        super(...arguments);\n        this._stack = [];\n    }\n    /**\n     * Adds highlight descriptor to the stack.\n     *\n     * @fires change:top\n     */\n    add(descriptor, writer) {\n        const stack = this._stack;\n        // Save top descriptor and insert new one. If top is changed - fire event.\n        const oldTop = stack[0];\n        this._insertDescriptor(descriptor);\n        const newTop = stack[0];\n        // When new object is at the top and stores different information.\n        if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {\n            this.fire('change:top', {\n                oldDescriptor: oldTop,\n                newDescriptor: newTop,\n                writer\n            });\n        }\n    }\n    /**\n     * Removes highlight descriptor from the stack.\n     *\n     * @fires change:top\n     * @param id Id of the descriptor to remove.\n     */\n    remove(id, writer) {\n        const stack = this._stack;\n        const oldTop = stack[0];\n        this._removeDescriptor(id);\n        const newTop = stack[0];\n        // When new object is at the top and stores different information.\n        if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {\n            this.fire('change:top', {\n                oldDescriptor: oldTop,\n                newDescriptor: newTop,\n                writer\n            });\n        }\n    }\n    /**\n     * Inserts a given descriptor in correct place in the stack. It also takes care about updating information\n     * when descriptor with same id is already present.\n     */\n    _insertDescriptor(descriptor) {\n        const stack = this._stack;\n        const index = stack.findIndex(item => item.id === descriptor.id);\n        // Inserting exact same descriptor - do nothing.\n        if (compareDescriptors(descriptor, stack[index])) {\n            return;\n        }\n        // If descriptor with same id but with different information is on the stack - remove it.\n        if (index > -1) {\n            stack.splice(index, 1);\n        }\n        // Find correct place to insert descriptor in the stack.\n        // It has different information (for example priority) so it must be re-inserted in correct place.\n        let i = 0;\n        while (stack[i] && shouldABeBeforeB(stack[i], descriptor)) {\n            i++;\n        }\n        stack.splice(i, 0, descriptor);\n    }\n    /**\n     * Removes descriptor with given id from the stack.\n     *\n     * @param id Descriptor's id.\n     */\n    _removeDescriptor(id) {\n        const stack = this._stack;\n        const index = stack.findIndex(item => item.id === id);\n        // If descriptor with same id is on the list - remove it.\n        if (index > -1) {\n            stack.splice(index, 1);\n        }\n    }\n}\n/**\n * Compares two descriptors by checking their priority and class list.\n *\n * @returns Returns true if both descriptors are defined and have same priority and classes.\n */\nfunction compareDescriptors(a, b) {\n    return a && b && a.priority == b.priority && classesToString(a.classes) == classesToString(b.classes);\n}\n/**\n * Checks whenever first descriptor should be placed in the stack before second one.\n */\nfunction shouldABeBeforeB(a, b) {\n    if (a.priority > b.priority) {\n        return true;\n    }\n    else if (a.priority < b.priority) {\n        return false;\n    }\n    // When priorities are equal and names are different - use classes to compare.\n    return classesToString(a.classes) > classesToString(b.classes);\n}\n/**\n * Converts CSS classes passed with {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} to\n * sorted string.\n */\nfunction classesToString(classes) {\n    return Array.isArray(classes) ? classes.sort().join(',') : classes;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgettypearound/utils\n */\nimport { isWidget } from '../utils';\n/**\n * The name of the type around model selection attribute responsible for\n * displaying a fake caret next to a selected widget.\n */\nexport const TYPE_AROUND_SELECTION_ATTRIBUTE = 'widget-type-around';\n/**\n * Checks if an element is a widget that qualifies to get the widget type around UI.\n */\nexport function isTypeAroundWidget(viewElement, modelElement, schema) {\n    return !!viewElement && isWidget(viewElement) && !schema.isInline(modelElement);\n}\n/**\n * For the passed HTML element, this helper finds the closest widget type around button ancestor.\n */\nexport function getClosestTypeAroundDomButton(domElement) {\n    return domElement.closest('.ck-widget__type-around__button');\n}\n/**\n * For the passed widget type around button element, this helper determines at which position\n * the paragraph would be inserted into the content if, for instance, the button was\n * clicked by the user.\n *\n * @returns The position of the button.\n */\nexport function getTypeAroundButtonPosition(domElement) {\n    return domElement.classList.contains('ck-widget__type-around__button_before') ? 'before' : 'after';\n}\n/**\n * For the passed HTML element, this helper returns the closest view widget ancestor.\n */\nexport function getClosestWidgetViewElement(domElement, domConverter) {\n    const widgetDomElement = domElement.closest('.ck-widget');\n    return domConverter.mapDomToView(widgetDomElement);\n}\n/**\n * For the passed selection instance, it returns the position of the fake caret displayed next to a widget.\n *\n * **Note**: If the fake caret is not currently displayed, `null` is returned.\n *\n * @returns The position of the fake caret or `null` when none is present.\n */\nexport function getTypeAroundFakeCaretPosition(selection) {\n    return selection.getAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/utils\n */\nimport { CKEditorError, toArray } from '@ckeditor/ckeditor5-utils';\nimport { findOptimalInsertionRange as engineFindOptimalInsertionRange } from '@ckeditor/ckeditor5-engine';\nimport { IconView } from '@ckeditor/ckeditor5-ui';\nimport HighlightStack from './highlightstack';\nimport { getTypeAroundFakeCaretPosition } from './widgettypearound/utils';\nimport dragHandleIcon from '../theme/icons/drag-handle.svg';\n/**\n * CSS class added to each widget element.\n */\nexport const WIDGET_CLASS_NAME = 'ck-widget';\n/**\n * CSS class added to currently selected widget element.\n */\nexport const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n */\nexport function isWidget(node) {\n    if (!node.is('element')) {\n        return false;\n    }\n    return !!node.getCustomProperty('widget');\n}\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"false\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n * ```ts\n * editor.conversion.for( 'editingDowncast' )\n * \t.elementToElement( {\n * \t\tmodel: 'widget',\n * \t\tview: ( modelItem, { writer } ) => {\n * \t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n * \t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n * \t\t}\n * \t} );\n *\n * editor.conversion.for( 'dataDowncast' )\n * \t.elementToElement( {\n * \t\tmodel: 'widget',\n * \t\tview: ( modelItem, { writer } ) => {\n * \t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n * \t\t}\n * \t} );\n * ```\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param options Additional options.\n * @param options.label Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param options.hasSelectionHandle If `true`, the widget will have a selection handle added.\n * @returns Returns the same element.\n */\nexport function toWidget(element, writer, options = {}) {\n    if (!element.is('containerElement')) {\n        /**\n         * The element passed to `toWidget()` must be a {@link module:engine/view/containerelement~ContainerElement}\n         * instance.\n         *\n         * @error widget-to-widget-wrong-element-type\n         * @param element The view element passed to `toWidget()`.\n         */\n        throw new CKEditorError('widget-to-widget-wrong-element-type', null, { element });\n    }\n    writer.setAttribute('contenteditable', 'false', element);\n    writer.addClass(WIDGET_CLASS_NAME, element);\n    writer.setCustomProperty('widget', true, element);\n    element.getFillerOffset = getFillerOffset;\n    writer.setCustomProperty('widgetLabel', [], element);\n    if (options.label) {\n        setLabel(element, options.label);\n    }\n    if (options.hasSelectionHandle) {\n        addSelectionHandle(element, writer);\n    }\n    setHighlightHandling(element, writer);\n    return element;\n}\n/**\n * Default handler for adding a highlight on a widget.\n * It adds CSS class and attributes basing on the given highlight descriptor.\n */\nfunction addHighlight(element, descriptor, writer) {\n    if (descriptor.classes) {\n        writer.addClass(toArray(descriptor.classes), element);\n    }\n    if (descriptor.attributes) {\n        for (const key in descriptor.attributes) {\n            writer.setAttribute(key, descriptor.attributes[key], element);\n        }\n    }\n}\n/**\n * Default handler for removing a highlight from a widget.\n * It removes CSS class and attributes basing on the given highlight descriptor.\n */\nfunction removeHighlight(element, descriptor, writer) {\n    if (descriptor.classes) {\n        writer.removeClass(toArray(descriptor.classes), element);\n    }\n    if (descriptor.attributes) {\n        for (const key in descriptor.attributes) {\n            writer.removeAttribute(key, element);\n        }\n    }\n}\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n */\nexport function setHighlightHandling(element, writer, add = addHighlight, remove = removeHighlight) {\n    const stack = new HighlightStack();\n    stack.on('change:top', (evt, data) => {\n        if (data.oldDescriptor) {\n            remove(element, data.oldDescriptor, data.writer);\n        }\n        if (data.newDescriptor) {\n            add(element, data.newDescriptor, data.writer);\n        }\n    });\n    const addHighlightCallback = (element, descriptor, writer) => stack.add(descriptor, writer);\n    const removeHighlightCallback = (element, id, writer) => stack.remove(id, writer);\n    writer.setCustomProperty('addHighlight', addHighlightCallback, element);\n    writer.setCustomProperty('removeHighlight', removeHighlightCallback, element);\n}\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n */\nexport function setLabel(element, labelOrCreator) {\n    const widgetLabel = element.getCustomProperty('widgetLabel');\n    widgetLabel.push(labelOrCreator);\n}\n/**\n * Returns the label of the provided element.\n */\nexport function getLabel(element) {\n    const widgetLabel = element.getCustomProperty('widgetLabel');\n    return widgetLabel.reduce((prev, current) => {\n        if (typeof current === 'function') {\n            return prev ? prev + '. ' + current() : current();\n        }\n        else {\n            return prev ? prev + '. ' + current : current;\n        }\n    }, '');\n}\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n * * implements the {@link ~setHighlightHandling view highlight on widget's editable}.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `editingDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n * ```ts\n * editor.conversion.for( 'editingDowncast' )\n * \t.elementToElement( {\n * \t\tmodel: 'nested',\n * \t\tview: ( modelItem, { writer } ) => {\n * \t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n * \t\t\treturn toWidgetEditable( nested, writer, { label: 'label for editable' } );\n * \t\t}\n * \t} );\n *\n * editor.conversion.for( 'dataDowncast' )\n * \t.elementToElement( {\n * \t\tmodel: 'nested',\n * \t\tview: ( modelItem, { writer } ) => {\n * \t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n * \t\t}\n * \t} );\n * ```\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param options Additional options.\n * @param options.label Editable's label used by assistive technologies (e.g. screen readers).\n * @returns Returns the same element that was provided in the `editable` parameter\n */\nexport function toWidgetEditable(editable, writer, options = {}) {\n    writer.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], editable);\n    writer.setAttribute('role', 'textbox', editable);\n    if (options.label) {\n        writer.setAttribute('aria-label', options.label, editable);\n    }\n    // Set initial contenteditable value.\n    writer.setAttribute('contenteditable', editable.isReadOnly ? 'false' : 'true', editable);\n    // Bind the contenteditable property to element#isReadOnly.\n    editable.on('change:isReadOnly', (evt, property, is) => {\n        writer.setAttribute('contenteditable', is ? 'false' : 'true', editable);\n    });\n    editable.on('change:isFocused', (evt, property, is) => {\n        if (is) {\n            writer.addClass('ck-editor__nested-editable_focused', editable);\n        }\n        else {\n            writer.removeClass('ck-editor__nested-editable_focused', editable);\n        }\n    });\n    setHighlightHandling(editable, writer);\n    return editable;\n}\n/**\n * Returns a model range which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the collapsed range after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range\n * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced\n * by the inserted widget block.\n *\n * @param selection The selection based on which the insertion position should be calculated.\n * @param model Model instance.\n * @returns The optimal range.\n */\nexport function findOptimalInsertionRange(selection, model) {\n    const selectedElement = selection.getSelectedElement();\n    if (selectedElement) {\n        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(selection);\n        // If the WidgetTypeAround \"fake caret\" is displayed, use its position for the insertion\n        // to provide the most predictable UX (https://github.com/ckeditor/ckeditor5/issues/7438).\n        if (typeAroundFakeCaretPosition) {\n            return model.createRange(model.createPositionAt(selectedElement, typeAroundFakeCaretPosition));\n        }\n    }\n    return engineFindOptimalInsertionRange(selection, model);\n}\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n * ```\n * // Model:\n * <placeholder type=\"name\"></placeholder>\n *\n * // View:\n * <span class=\"placeholder\">name</span>\n * ```\n *\n * In such case, view positions inside `<span>` cannot be correctly mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n * ```ts\n * editor.editing.mapper.on(\n * \t'viewToModelPosition',\n * \tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n * );\n * ```\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n * ```\n * // View:\n * <p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n * // Model:\n * <paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n * ```\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n * ```\n * // View:\n * <p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n * // Model:\n * <paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n * ```\n *\n * @param model Model instance on which the callback operates.\n * @param viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n */\nexport function viewToModelPositionOutsideModelElement(model, viewElementMatcher) {\n    return (evt, data) => {\n        const { mapper, viewPosition } = data;\n        const viewParent = mapper.findMappedViewAncestor(viewPosition);\n        if (!viewElementMatcher(viewParent)) {\n            return;\n        }\n        const modelParent = mapper.toModelElement(viewParent);\n        data.modelPosition = model.createPositionAt(modelParent, viewPosition.isAtStart ? 'before' : 'after');\n    };\n}\n/**\n * Default filler offset function applied to all widget elements.\n */\nfunction getFillerOffset() {\n    return null;\n}\n/**\n * Adds a drag handle to the widget.\n */\nfunction addSelectionHandle(widgetElement, writer) {\n    const selectionHandle = writer.createUIElement('div', { class: 'ck ck-widget__selection-handle' }, function (domDocument) {\n        const domElement = this.toDomElement(domDocument);\n        // Use the IconView from the ui library.\n        const icon = new IconView();\n        icon.set('content', dragHandleIcon);\n        // Render the icon view right away to append its #element to the selectionHandle DOM element.\n        icon.render();\n        domElement.appendChild(icon.element);\n        return domElement;\n    });\n    // Append the selection handle into the widget wrapper.\n    writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandle);\n    writer.addClass(['ck-widget_with-selection-handle'], widgetElement);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* global DOMParser */\n/**\n * @module widget/widgettypearound/widgettypearound\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { Template } from '@ckeditor/ckeditor5-ui';\nimport { Enter } from '@ckeditor/ckeditor5-enter';\nimport { Delete } from '@ckeditor/ckeditor5-typing';\nimport { env, isForwardArrowKeyCode } from '@ckeditor/ckeditor5-utils';\nimport { isTypeAroundWidget, getClosestTypeAroundDomButton, getTypeAroundButtonPosition, getClosestWidgetViewElement, getTypeAroundFakeCaretPosition, TYPE_AROUND_SELECTION_ATTRIBUTE } from './utils';\nimport { isWidget } from '../utils';\nimport returnIcon from '../../theme/icons/return-arrow.svg';\nimport '../../theme/widgettypearound.css';\nconst POSSIBLE_INSERTION_POSITIONS = ['before', 'after'];\n// Do the SVG parsing once and then clone the result <svg> DOM element for each new button.\nconst RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, 'image/svg+xml').firstChild;\nconst PLUGIN_DISABLED_EDITING_ROOT_CLASS = 'ck-widget__type-around_disabled';\n/**\n * A plugin that allows users to type around widgets where normally it is impossible to place the caret due\n * to limitations of web browsers. These \"tight spots\" occur, for instance, before (or after) a widget being\n * the first (or last) child of its parent or between two block widgets.\n *\n * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects the user interface\n * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the\n * user if the widget is next to the \"tight spot\". Once clicked, a paragraph is created with the selection anchored\n * in it so that users can type (or insert content, paste, etc.) straight away.\n */\nexport default class WidgetTypeAround extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * A reference to the model widget element that has the fake caret active\n         * on either side of it. It is later used to remove CSS classes associated with the fake caret\n         * when the widget no longer needs it.\n         */\n        this._currentFakeCaretModelElement = null;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'WidgetTypeAround';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [Enter, Delete];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const editingView = editor.editing.view;\n        // Set a CSS class on the view editing root when the plugin is disabled so all the buttons\n        // and lines visually disappear. All the interactions are disabled in individual plugin methods.\n        this.on('change:isEnabled', (evt, data, isEnabled) => {\n            editingView.change(writer => {\n                for (const root of editingView.document.roots) {\n                    if (isEnabled) {\n                        writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n                    }\n                    else {\n                        writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n                    }\n                }\n            });\n            if (!isEnabled) {\n                editor.model.change(writer => {\n                    writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n                });\n            }\n        });\n        this._enableTypeAroundUIInjection();\n        this._enableInsertingParagraphsOnButtonClick();\n        this._enableInsertingParagraphsOnEnterKeypress();\n        this._enableInsertingParagraphsOnTypingKeystroke();\n        this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();\n        this._enableDeleteIntegration();\n        this._enableInsertContentIntegration();\n        this._enableInsertObjectIntegration();\n        this._enableDeleteContentIntegration();\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        this._currentFakeCaretModelElement = null;\n    }\n    /**\n     * Inserts a new paragraph next to a widget element with the selection anchored in it.\n     *\n     * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll\n     * the viewport to the selection in the inserted paragraph.\n     *\n     * @param widgetModelElement The model widget element next to which a paragraph is inserted.\n     * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.\n     */\n    _insertParagraph(widgetModelElement, position) {\n        const editor = this.editor;\n        const editingView = editor.editing.view;\n        const attributesToCopy = editor.model.schema.getAttributesWithProperty(widgetModelElement, 'copyOnReplace', true);\n        editor.execute('insertParagraph', {\n            position: editor.model.createPositionAt(widgetModelElement, position),\n            attributes: attributesToCopy\n        });\n        editingView.focus();\n        editingView.scrollToTheSelection();\n    }\n    /**\n     * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only\n     * when the plugin {@link #isEnabled is enabled}.\n     *\n     * @param emitter The object that fires the event.\n     * @param event The name of the event.\n     * @param callback The function to be called on event.\n     * @param options Additional options.\n     * @param options.priority The priority of this event callback. The higher the priority value the sooner\n     * the callback will be fired. Events having the same priority are called in the order they were added.\n     */\n    _listenToIfEnabled(emitter, event, callback, options) {\n        this.listenTo(emitter, event, (...args) => {\n            // Do not respond if the plugin is disabled.\n            if (this.isEnabled) {\n                callback(...args);\n            }\n        }, options);\n    }\n    /**\n     * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it\n     * does not expect a position. Instead, it performs the insertion next to a selected widget\n     * according to the `widget-type-around` model selection attribute value (fake caret position).\n     *\n     * Because this method requires the `widget-type-around` attribute to be set,\n     * the insertion can only happen when the widget's fake caret is active (e.g. activated\n     * using the keyboard).\n     *\n     * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.\n     */\n    _insertParagraphAccordingToFakeCaretPosition() {\n        const editor = this.editor;\n        const model = editor.model;\n        const modelSelection = model.document.selection;\n        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n        if (!typeAroundFakeCaretPosition) {\n            return false;\n        }\n        // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n        // @if CK_DEBUG_TYPING // \tconsole.info( '%c[WidgetTypeAround]%c Fake caret -> insert paragraph',\n        // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green', ''\n        // @if CK_DEBUG_TYPING // \t);\n        // @if CK_DEBUG_TYPING // }\n        const selectedModelElement = modelSelection.getSelectedElement();\n        this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);\n        return true;\n    }\n    /**\n     * Creates a listener in the editing conversion pipeline that injects the widget type around\n     * UI into every single widget instance created in the editor.\n     *\n     * The UI is delivered as a {@link module:engine/view/uielement~UIElement}\n     * wrapper which renders DOM buttons that users can use to insert paragraphs.\n     */\n    _enableTypeAroundUIInjection() {\n        const editor = this.editor;\n        const schema = editor.model.schema;\n        const t = editor.locale.t;\n        const buttonTitles = {\n            before: t('Insert paragraph before block'),\n            after: t('Insert paragraph after block')\n        };\n        editor.editing.downcastDispatcher.on('insert', (evt, data, conversionApi) => {\n            const viewElement = conversionApi.mapper.toViewElement(data.item);\n            if (!viewElement) {\n                return;\n            }\n            // Filter out non-widgets and inline widgets.\n            if (isTypeAroundWidget(viewElement, data.item, schema)) {\n                injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);\n                const widgetLabel = viewElement.getCustomProperty('widgetLabel');\n                widgetLabel.push(() => {\n                    return this.isEnabled ? t('Press Enter to type after or press Shift + Enter to type before the widget') : '';\n                });\n            }\n        }, { priority: 'low' });\n    }\n    /**\n     * Brings support for the fake caret that appears when either:\n     *\n     * * the selection moves to a widget from a position next to it using arrow keys,\n     * * the arrow key is pressed when the widget is already selected.\n     *\n     * The fake caret lets the user know that they can start typing or just press\n     * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.\n     *\n     * The fake caret disappears when the user changes the selection or the editor\n     * gets blurred.\n     *\n     * The whole idea is as follows:\n     *\n     * 1. A user does one of the 2 scenarios described at the beginning.\n     * 2. The \"keydown\" listener is executed and the decision is made whether to show or hide the fake caret.\n     * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating\n     *    on which side of the widget it should appear.\n     * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the\n     *    fake caret on the view widget.\n     * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher\n     *    does the CSS class clean-up in the view.\n     * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection\n     *    attribute (the former also removes widget CSS classes).\n     */\n    _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {\n        const editor = this.editor;\n        const model = editor.model;\n        const modelSelection = model.document.selection;\n        const schema = model.schema;\n        const editingView = editor.editing.view;\n        // This is the main listener responsible for the fake caret.\n        // Note: The priority must precede the default Widget class keydown handler (\"high\").\n        this._listenToIfEnabled(editingView.document, 'arrowKey', (evt, domEventData) => {\n            this._handleArrowKeyPress(evt, domEventData);\n        }, { context: [isWidget, '$text'], priority: 'high' });\n        // This listener makes sure the widget type around selection attribute will be gone from the model\n        // selection as soon as the model range changes. This attribute only makes sense when a widget is selected\n        // (and the \"fake horizontal caret\" is visible) so whenever the range changes (e.g. selection moved somewhere else),\n        // let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.\n        this._listenToIfEnabled(modelSelection, 'change:range', (evt, data) => {\n            // Do not reset the selection attribute when the change was indirect.\n            if (!data.directChange) {\n                return;\n            }\n            // Get rid of the widget type around attribute of the selection on every change:range.\n            // If the range changes, it means for sure, the user is no longer in the active (\"fake horizontal caret\") mode.\n            editor.model.change(writer => {\n                writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n            });\n        });\n        // Get rid of the widget type around attribute of the selection on every document change\n        // that makes widget not selected any more (i.e. widget was removed).\n        this._listenToIfEnabled(model.document, 'change:data', () => {\n            const selectedModelElement = modelSelection.getSelectedElement();\n            if (selectedModelElement) {\n                const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n                if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n                    return;\n                }\n            }\n            editor.model.change(writer => {\n                writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n            });\n        });\n        // React to changes of the model selection attribute made by the arrow keys listener.\n        // If the block widget is selected and the attribute changes, downcast the attribute to special\n        // CSS classes associated with the active (\"fake horizontal caret\") mode of the widget.\n        this._listenToIfEnabled(editor.editing.downcastDispatcher, 'selection', (evt, data, conversionApi) => {\n            const writer = conversionApi.writer;\n            if (this._currentFakeCaretModelElement) {\n                const selectedViewElement = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);\n                if (selectedViewElement) {\n                    // Get rid of CSS classes associated with the active (\"fake horizontal caret\") mode from the view widget.\n                    writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement);\n                    this._currentFakeCaretModelElement = null;\n                }\n            }\n            const selectedModelElement = data.selection.getSelectedElement();\n            if (!selectedModelElement) {\n                return;\n            }\n            const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);\n            if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);\n            if (!typeAroundFakeCaretPosition) {\n                return;\n            }\n            writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement);\n            // Remember the view widget that got the \"fake-caret\" CSS class. This class should be removed ASAP when the\n            // selection changes\n            this._currentFakeCaretModelElement = selectedModelElement;\n        });\n        this._listenToIfEnabled(editor.ui.focusTracker, 'change:isFocused', (evt, name, isFocused) => {\n            if (!isFocused) {\n                editor.model.change(writer => {\n                    writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n                });\n            }\n        });\n        function positionToWidgetCssClass(position) {\n            return `ck-widget_type-around_show-fake-caret_${position}`;\n        }\n    }\n    /**\n     * A listener executed on each \"keydown\" in the view document, a part of\n     * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.\n     *\n     * It decides whether the arrow keypress should activate the fake caret or not (also whether it should\n     * be deactivated).\n     *\n     * The fake caret activation is done by setting the `widget-type-around` model selection attribute\n     * in this listener, and stopping and preventing the event that would normally be handled by the widget\n     * plugin that is responsible for the regular keyboard navigation near/across all widgets (that\n     * includes inline widgets, which are ignored by the widget type around plugin).\n     */\n    _handleArrowKeyPress(evt, domEventData) {\n        const editor = this.editor;\n        const model = editor.model;\n        const modelSelection = model.document.selection;\n        const schema = model.schema;\n        const editingView = editor.editing.view;\n        const keyCode = domEventData.keyCode;\n        const isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);\n        const selectedViewElement = editingView.document.selection.getSelectedElement();\n        const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);\n        let shouldStopAndPreventDefault;\n        // Handle keyboard navigation when a type-around-compatible widget is currently selected.\n        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n            shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);\n        }\n        // Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget\n        // and the widget is about to be selected.\n        else if (modelSelection.isCollapsed) {\n            shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);\n        }\n        // Handle collapsing a non-collapsed selection that is wider than on a single widget.\n        else if (!domEventData.shiftKey) {\n            shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);\n        }\n        if (shouldStopAndPreventDefault) {\n            domEventData.preventDefault();\n            evt.stop();\n        }\n    }\n    /**\n     * Handles the keyboard navigation on \"keydown\" when a widget is currently selected and activates or deactivates\n     * the fake caret for that widget, depending on the current value of the `widget-type-around` model\n     * selection attribute and the direction of the pressed arrow key.\n     *\n     * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n     * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should\n     * process the event any further. Returns `false` otherwise.\n     */\n    _handleArrowKeyPressOnSelectedWidget(isForward) {\n        const editor = this.editor;\n        const model = editor.model;\n        const modelSelection = model.document.selection;\n        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n        return model.change(writer => {\n            // If the fake caret is displayed...\n            if (typeAroundFakeCaretPosition) {\n                const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? 'after' : 'before');\n                // If the keyboard arrow works against the value of the selection attribute...\n                // then remove the selection attribute but prevent default DOM actions\n                // and do not let the Widget plugin listener move the selection. This brings\n                // the widget back to the state, for instance, like if was selected using the mouse.\n                //\n                // **Note**: If leaving the widget when the fake caret is active, then the default\n                // Widget handler will change the selection and, in turn, this will automatically discard\n                // the selection attribute.\n                if (!isLeavingWidget) {\n                    writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n                    return true;\n                }\n            }\n            // If the fake caret wasn't displayed, let's set it now according to the direction of the arrow\n            // key press. This also means we cannot let the Widget plugin listener move the selection.\n            else {\n                writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n                return true;\n            }\n            return false;\n        });\n    }\n    /**\n     * Handles the keyboard navigation on \"keydown\" when **no** widget is selected but the selection is **directly** next\n     * to one and upon the fake caret should become active for this widget upon arrow keypress\n     * (AKA entering/selecting the widget).\n     *\n     * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.\n     * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the\n     * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.\n     *\n     * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n     * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should\n     * process the event any further. Returns `false` otherwise.\n     */\n    _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {\n        const editor = this.editor;\n        const model = editor.model;\n        const schema = model.schema;\n        const widgetPlugin = editor.plugins.get('Widget');\n        // This is the widget the selection is about to be set on.\n        const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);\n        const viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);\n        if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {\n            model.change(writer => {\n                widgetPlugin._setSelectionOverElement(modelElementNextToSelection);\n                writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after');\n            });\n            // The change() block above does the same job as the Widget plugin. The event can\n            // be safely canceled.\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Handles the keyboard navigation on \"keydown\" when a widget is currently selected (together with some other content)\n     * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.\n     *\n     * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n     * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should\n     * process the event any further. Returns `false` otherwise.\n     */\n    _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {\n        const editor = this.editor;\n        const model = editor.model;\n        const schema = model.schema;\n        const mapper = editor.editing.mapper;\n        const modelSelection = model.document.selection;\n        const selectedModelNode = isForward ?\n            modelSelection.getLastPosition().nodeBefore :\n            modelSelection.getFirstPosition().nodeAfter;\n        const selectedViewNode = mapper.toViewElement(selectedModelNode);\n        // There is a widget at the collapse position so collapse the selection to the fake caret on it.\n        if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {\n            model.change(writer => {\n                writer.setSelection(selectedModelNode, 'on');\n                writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n            });\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Registers a `mousedown` listener for the view document which intercepts events\n     * coming from the widget type around UI, which happens when a user clicks one of the buttons\n     * that insert a paragraph next to a widget.\n     */\n    _enableInsertingParagraphsOnButtonClick() {\n        const editor = this.editor;\n        const editingView = editor.editing.view;\n        this._listenToIfEnabled(editingView.document, 'mousedown', (evt, domEventData) => {\n            const button = getClosestTypeAroundDomButton(domEventData.domTarget);\n            if (!button) {\n                return;\n            }\n            const buttonPosition = getTypeAroundButtonPosition(button);\n            const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);\n            const widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);\n            this._insertParagraph(widgetModelElement, buttonPosition);\n            domEventData.preventDefault();\n            evt.stop();\n        });\n    }\n    /**\n     * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph\n     * near the widget when either:\n     *\n     * * The fake caret was first activated using the arrow keys,\n     * * The entire widget is selected in the model.\n     *\n     * In the first case, the new paragraph is inserted according to the `widget-type-around` selection\n     * attribute (see {@link #_handleArrowKeyPress}).\n     *\n     * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke\n     * was pressed or not.\n     */\n    _enableInsertingParagraphsOnEnterKeypress() {\n        const editor = this.editor;\n        const selection = editor.model.document.selection;\n        const editingView = editor.editing.view;\n        this._listenToIfEnabled(editingView.document, 'enter', (evt, domEventData) => {\n            // This event could be triggered from inside the widget but we are interested\n            // only when the widget is selected itself.\n            if (evt.eventPhase != 'atTarget') {\n                return;\n            }\n            const selectedModelElement = selection.getSelectedElement();\n            const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n            const schema = editor.model.schema;\n            let wasHandled;\n            // First check if the widget is selected and there's a type around selection attribute associated\n            // with the fake caret that would tell where to insert a new paragraph.\n            if (this._insertParagraphAccordingToFakeCaretPosition()) {\n                wasHandled = true;\n            }\n            // Then, if there is no selection attribute associated with the fake caret, check if the widget\n            // simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.\n            else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n                this._insertParagraph(selectedModelElement, domEventData.isSoft ? 'before' : 'after');\n                wasHandled = true;\n            }\n            if (wasHandled) {\n                domEventData.preventDefault();\n                evt.stop();\n            }\n        }, { context: isWidget });\n    }\n    /**\n     * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user\n     * to insert a paragraph next to a widget when the fake caret was activated using arrow\n     * keys but it responds to typing instead of <kbd>Enter</kbd>.\n     *\n     * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`\n     * model selection attribute as the user simply starts typing, which creates the impression that the fake caret\n     * behaves like a real one rendered by the browser (AKA your text appears where the caret was).\n     *\n     * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command\n     * and another one for actual typing. It is not a disaster but this may need to be fixed\n     * sooner or later.\n     */\n    _enableInsertingParagraphsOnTypingKeystroke() {\n        const editor = this.editor;\n        const viewDocument = editor.editing.view.document;\n        // Note: The priority must precede the default Input plugin insertText handler.\n        this._listenToIfEnabled(viewDocument, 'insertText', (evt, data) => {\n            if (this._insertParagraphAccordingToFakeCaretPosition()) {\n                // The view selection in the event data contains the widget. If the new paragraph\n                // was inserted, modify the view selection passed along with the insertText event\n                // so the default event handler in the Input plugin starts typing inside the paragraph.\n                // Otherwise, the typing would be over the widget.\n                data.selection = viewDocument.selection;\n            }\n        }, { priority: 'high' });\n        if (env.isAndroid) {\n            // On Android with English keyboard, the composition starts just by putting caret\n            // at the word end or by selecting a table column. This is not a real composition started.\n            // Trigger delete content on first composition key pressed.\n            this._listenToIfEnabled(viewDocument, 'keydown', (evt, data) => {\n                if (data.keyCode == 229) {\n                    this._insertParagraphAccordingToFakeCaretPosition();\n                }\n            });\n        }\n        else {\n            // Note: The priority must precede the default Input plugin compositionstart handler (to call it before delete content).\n            this._listenToIfEnabled(viewDocument, 'compositionstart', () => {\n                this._insertParagraphAccordingToFakeCaretPosition();\n            }, { priority: 'high' });\n        }\n    }\n    /**\n     * It creates a \"delete\" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>\n     * is pressed and the fake caret is currently active.\n     *\n     * The fake caret should create an illusion of a real browser caret so that when it appears before or after\n     * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content\n     * before or after a widget (depending on the content surrounding the widget).\n     */\n    _enableDeleteIntegration() {\n        const editor = this.editor;\n        const editingView = editor.editing.view;\n        const model = editor.model;\n        const schema = model.schema;\n        this._listenToIfEnabled(editingView.document, 'delete', (evt, domEventData) => {\n            // This event could be triggered from inside the widget but we are interested\n            // only when the widget is selected itself.\n            if (evt.eventPhase != 'atTarget') {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection);\n            // This listener handles only these cases when the fake caret is active.\n            if (!typeAroundFakeCaretPosition) {\n                return;\n            }\n            const direction = domEventData.direction;\n            const selectedModelWidget = model.document.selection.getSelectedElement();\n            const isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';\n            const isDeleteForward = direction == 'forward';\n            const shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;\n            if (shouldDeleteEntireWidget) {\n                editor.execute('delete', {\n                    selection: model.createSelection(selectedModelWidget, 'on')\n                });\n            }\n            else {\n                const range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction);\n                // If there is somewhere to move selection to, then there will be something to delete.\n                if (range) {\n                    // If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).\n                    if (!range.isCollapsed) {\n                        model.change(writer => {\n                            writer.setSelection(range);\n                            editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n                        });\n                    }\n                    else {\n                        const probe = model.createSelection(range.start);\n                        model.modifySelection(probe, { direction });\n                        // If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.\n                        // If such range exists, use the editor command because it it safe for collaboration (it merges where it can).\n                        if (!probe.focus.isEqual(range.start)) {\n                            model.change(writer => {\n                                writer.setSelection(range);\n                                editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n                            });\n                        }\n                        // If there is no non-collapsed range to be deleted then we are sure that there is an empty element\n                        // next to a widget that should be removed. \"delete\" and \"deleteForward\" commands cannot get rid of it\n                        // so calling Model#deleteContent here manually.\n                        else {\n                            const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);\n                            model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, 'on'), {\n                                doNotAutoparagraph: true\n                            });\n                        }\n                    }\n                }\n            }\n            // If some content was deleted, don't let the handler from the Widget plugin kick in.\n            // If nothing was deleted, then the default handler will have nothing to do anyway.\n            domEventData.preventDefault();\n            evt.stop();\n        }, { context: isWidget });\n    }\n    /**\n     * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste\n     * content near a widget when the fake caret is first activated using the arrow keys.\n     *\n     * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n     */\n    _enableInsertContentIntegration() {\n        const editor = this.editor;\n        const model = this.editor.model;\n        const documentSelection = model.document.selection;\n        this._listenToIfEnabled(editor.model, 'insertContent', (evt, [content, selectable]) => {\n            if (selectable && !selectable.is('documentSelection')) {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n            if (!typeAroundFakeCaretPosition) {\n                return;\n            }\n            evt.stop();\n            return model.change(writer => {\n                const selectedElement = documentSelection.getSelectedElement();\n                const position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);\n                const selection = writer.createSelection(position);\n                const result = model.insertContent(content, selection);\n                writer.setSelection(selection);\n                return result;\n            });\n        }, { priority: 'high' });\n    }\n    /**\n     * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the\n     * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element\n     * to reflect user's intent of desired insertion position.\n     *\n     * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n     */\n    _enableInsertObjectIntegration() {\n        const editor = this.editor;\n        const model = this.editor.model;\n        const documentSelection = model.document.selection;\n        this._listenToIfEnabled(editor.model, 'insertObject', (evt, args) => {\n            const [, selectable, options = {}] = args;\n            if (selectable && !selectable.is('documentSelection')) {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n            if (!typeAroundFakeCaretPosition) {\n                return;\n            }\n            options.findOptimalPosition = typeAroundFakeCaretPosition;\n            args[3] = options;\n        }, { priority: 'high' });\n    }\n    /**\n     * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake\n     * caret is active.\n     *\n     * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n     * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,\n     * plain text pasting.\n     */\n    _enableDeleteContentIntegration() {\n        const editor = this.editor;\n        const model = this.editor.model;\n        const documentSelection = model.document.selection;\n        this._listenToIfEnabled(editor.model, 'deleteContent', (evt, [selection]) => {\n            if (selection && !selection.is('documentSelection')) {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n            // Disable removing the selection content while pasting plain text.\n            if (typeAroundFakeCaretPosition) {\n                evt.stop();\n            }\n        }, { priority: 'high' });\n    }\n}\n/**\n * Injects the type around UI into a view widget instance.\n */\nfunction injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {\n    const typeAroundWrapper = viewWriter.createUIElement('div', {\n        class: 'ck ck-reset_all ck-widget__type-around'\n    }, function (domDocument) {\n        const wrapperDomElement = this.toDomElement(domDocument);\n        injectButtons(wrapperDomElement, buttonTitles);\n        injectFakeCaret(wrapperDomElement);\n        return wrapperDomElement;\n    });\n    // Inject the type around wrapper into the widget's wrapper.\n    viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, 'end'), typeAroundWrapper);\n}\n/**\n * FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks\n * and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw\n * <svg> here.\n */\nfunction injectButtons(wrapperDomElement, buttonTitles) {\n    for (const position of POSSIBLE_INSERTION_POSITIONS) {\n        const buttonTemplate = new Template({\n            tag: 'div',\n            attributes: {\n                class: [\n                    'ck',\n                    'ck-widget__type-around__button',\n                    `ck-widget__type-around__button_${position}`\n                ],\n                title: buttonTitles[position],\n                'aria-hidden': 'true'\n            },\n            children: [\n                wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)\n            ]\n        });\n        wrapperDomElement.appendChild(buttonTemplate.render());\n    }\n}\nfunction injectFakeCaret(wrapperDomElement) {\n    const caretTemplate = new Template({\n        tag: 'div',\n        attributes: {\n            class: [\n                'ck',\n                'ck-widget__type-around__fake-caret'\n            ]\n        }\n    });\n    wrapperDomElement.appendChild(caretTemplate.render());\n}\n/**\n * Returns the ancestor of an element closest to the root which is empty. For instance,\n * for `<baz>`:\n *\n * ```\n * <foo>abc<bar><baz></baz></bar></foo>\n * ```\n *\n * it returns `<bar>`.\n */\nfunction getDeepestEmptyElementAncestor(schema, element) {\n    let deepestEmptyAncestor = element;\n    for (const ancestor of element.getAncestors({ parentFirst: true })) {\n        if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {\n            break;\n        }\n        deepestEmptyAncestor = ancestor;\n    }\n    return deepestEmptyAncestor;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/verticalnavigation\n */\nimport { keyCodes, Rect } from '@ckeditor/ckeditor5-utils';\n/**\n * Returns 'keydown' handler for up/down arrow keys that modifies the caret movement if it's in a text line next to an object.\n *\n * @param editing The editing controller.\n */\nexport default function verticalNavigationHandler(editing) {\n    const model = editing.model;\n    return (evt, data) => {\n        const arrowUpPressed = data.keyCode == keyCodes.arrowup;\n        const arrowDownPressed = data.keyCode == keyCodes.arrowdown;\n        const expandSelection = data.shiftKey;\n        const selection = model.document.selection;\n        if (!arrowUpPressed && !arrowDownPressed) {\n            return;\n        }\n        const isForward = arrowDownPressed;\n        // Navigation is in the opposite direction than the selection direction so this is shrinking of the selection.\n        // Selection for sure will not approach any object.\n        if (expandSelection && selectionWillShrink(selection, isForward)) {\n            return;\n        }\n        // Find a range between selection and closest limit element.\n        const range = findTextRangeFromSelection(editing, selection, isForward);\n        // There is no selection position inside the limit element.\n        if (!range) {\n            return;\n        }\n        // If already at the edge of a limit element.\n        if (range.isCollapsed) {\n            // A collapsed selection at limit edge - nothing more to do.\n            if (selection.isCollapsed) {\n                return;\n            }\n            // A non collapsed selection is at the limit edge while expanding the selection - let others do their stuff.\n            else if (expandSelection) {\n                return;\n            }\n        }\n        // If the range is a single line (there is no word wrapping) then move the selection to the position closest to the limit element.\n        //\n        // We can't move the selection directly to the isObject element (eg. table cell) because of dual position at the end/beginning\n        // of wrapped line (it's at the same time at the end of one line and at the start of the next line).\n        if (range.isCollapsed || isSingleLineRange(editing, range, isForward)) {\n            model.change(writer => {\n                const newPosition = isForward ? range.end : range.start;\n                if (expandSelection) {\n                    const newSelection = model.createSelection(selection.anchor);\n                    newSelection.setFocus(newPosition);\n                    writer.setSelection(newSelection);\n                }\n                else {\n                    writer.setSelection(newPosition);\n                }\n            });\n            evt.stop();\n            data.preventDefault();\n            data.stopPropagation();\n        }\n    };\n}\n/**\n * Finds the range between selection and closest limit element (in the direction of navigation).\n * The position next to limit element is adjusted to the closest allowed `$text` position.\n *\n * Returns `null` if, according to the schema, the resulting range cannot contain a `$text` element.\n *\n * @param editing The editing controller.\n * @param selection The current selection.\n * @param isForward The expected navigation direction.\n */\nfunction findTextRangeFromSelection(editing, selection, isForward) {\n    const model = editing.model;\n    if (isForward) {\n        const startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();\n        const endPosition = getNearestNonInlineLimit(model, startPosition, 'forward');\n        // There is no limit element, browser should handle this.\n        if (!endPosition) {\n            return null;\n        }\n        const range = model.createRange(startPosition, endPosition);\n        const lastRangePosition = getNearestTextPosition(model.schema, range, 'backward');\n        if (lastRangePosition) {\n            return model.createRange(startPosition, lastRangePosition);\n        }\n        return null;\n    }\n    else {\n        const endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();\n        const startPosition = getNearestNonInlineLimit(model, endPosition, 'backward');\n        // There is no limit element, browser should handle this.\n        if (!startPosition) {\n            return null;\n        }\n        const range = model.createRange(startPosition, endPosition);\n        const firstRangePosition = getNearestTextPosition(model.schema, range, 'forward');\n        if (firstRangePosition) {\n            return model.createRange(firstRangePosition, endPosition);\n        }\n        return null;\n    }\n}\n/**\n * Finds the limit element position that is closest to startPosition.\n *\n * @param direction Search direction.\n */\nfunction getNearestNonInlineLimit(model, startPosition, direction) {\n    const schema = model.schema;\n    const range = model.createRangeIn(startPosition.root);\n    const walkerValueType = direction == 'forward' ? 'elementStart' : 'elementEnd';\n    for (const { previousPosition, item, type } of range.getWalker({ startPosition, direction })) {\n        if (schema.isLimit(item) && !schema.isInline(item)) {\n            return previousPosition;\n        }\n        // Stop looking for isLimit element if the next element is a block element (it is for sure not single line).\n        if (type == walkerValueType && schema.isBlock(item)) {\n            return null;\n        }\n    }\n    return null;\n}\n/**\n * Basing on the provided range, finds the first or last (depending on `direction`) position inside the range\n * that can contain `$text` (according to schema).\n *\n * @param schema The schema.\n * @param range The range to find the position in.\n * @param direction Search direction.\n * @returns The nearest selection position.\n *\n */\nfunction getNearestTextPosition(schema, range, direction) {\n    const position = direction == 'backward' ? range.end : range.start;\n    if (schema.checkChild(position, '$text')) {\n        return position;\n    }\n    for (const { nextPosition } of range.getWalker({ direction })) {\n        if (schema.checkChild(nextPosition, '$text')) {\n            return nextPosition;\n        }\n    }\n    return null;\n}\n/**\n * Checks if the DOM range corresponding to the provided model range renders as a single line by analyzing DOMRects\n * (verifying if they visually wrap content to the next line).\n *\n * @param editing The editing controller.\n * @param modelRange The current table cell content range.\n * @param isForward The expected navigation direction.\n */\nfunction isSingleLineRange(editing, modelRange, isForward) {\n    const model = editing.model;\n    const domConverter = editing.view.domConverter;\n    // Wrapped lines contain exactly the same position at the end of current line\n    // and at the beginning of next line. That position's client rect is at the end\n    // of current line. In case of caret at first position of the last line that 'dual'\n    // position would be detected as it's not the last line.\n    if (isForward) {\n        const probe = model.createSelection(modelRange.start);\n        model.modifySelection(probe);\n        // If the new position is at the end of the container then we can't use this position\n        // because it would provide incorrect result for eg caption of image and selection\n        // just before end of it. Also in this case there is no \"dual\" position.\n        if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {\n            modelRange = model.createRange(probe.focus, modelRange.end);\n        }\n    }\n    const viewRange = editing.mapper.toViewRange(modelRange);\n    const domRange = domConverter.viewRangeToDom(viewRange);\n    const rects = Rect.getDomRangeRects(domRange);\n    let boundaryVerticalPosition;\n    for (const rect of rects) {\n        if (boundaryVerticalPosition === undefined) {\n            boundaryVerticalPosition = Math.round(rect.bottom);\n            continue;\n        }\n        // Let's check if this rect is in new line.\n        if (Math.round(rect.top) >= boundaryVerticalPosition) {\n            return false;\n        }\n        boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));\n    }\n    return true;\n}\nfunction selectionWillShrink(selection, isForward) {\n    return !selection.isCollapsed && selection.isBackward == isForward;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widget\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { MouseObserver } from '@ckeditor/ckeditor5-engine';\nimport { Delete } from '@ckeditor/ckeditor5-typing';\nimport { env, getLocalizedArrowKeyCodeDirection } from '@ckeditor/ckeditor5-utils';\nimport WidgetTypeAround from './widgettypearound/widgettypearound';\nimport verticalNavigationHandler from './verticalnavigation';\nimport { getLabel, isWidget, WIDGET_SELECTED_CLASS_NAME } from './utils';\nimport '../theme/widget.css';\n/**\n * The widget plugin. It enables base support for widgets.\n *\n * See {@glink api/widget package page} for more details and documentation.\n *\n * This plugin enables multiple behaviors required by widgets:\n *\n * * The model to view selection converter for the editing pipeline (it handles widget custom selection rendering).\n * If a converted selection wraps around a widget element, that selection is marked as\n * {@link module:engine/view/selection~Selection#isFake fake}. Additionally, the `ck-widget_selected` CSS class\n * is added to indicate that widget has been selected.\n * * The mouse and keyboard events handling on and around widget elements.\n */\nexport default class Widget extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * Holds previously selected widgets.\n         */\n        this._previouslySelected = new Set();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Widget';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [WidgetTypeAround, Delete];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        // Model to view selection converter.\n        // Converts selection placed over widget element to fake selection.\n        //\n        // By default, the selection is downcasted by the engine to surround the attribute element, even though its only\n        // child is an inline widget. A similar thing also happens when a collapsed marker is rendered as a UI element\n        // next to an inline widget: the view selection contains both the widget and the marker.\n        //\n        // This prevents creating a correct fake selection when this inline widget is selected. Normalize the selection\n        // in these cases based on the model:\n        //\n        //\t\t[<attributeElement><inlineWidget /></attributeElement>] -> <attributeElement>[<inlineWidget />]</attributeElement>\n        //\t\t[<uiElement></uiElement><inlineWidget />] -> <uiElement></uiElement>[<inlineWidget />]\n        //\n        // Thanks to this:\n        //\n        // * fake selection can be set correctly,\n        // * any logic depending on (View)Selection#getSelectedElement() also works OK.\n        //\n        // See https://github.com/ckeditor/ckeditor5/issues/9524.\n        this.editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n            const viewWriter = conversionApi.writer;\n            const modelSelection = data.selection;\n            // The collapsed selection can't contain any widget.\n            if (modelSelection.isCollapsed) {\n                return;\n            }\n            const selectedModelElement = modelSelection.getSelectedElement();\n            if (!selectedModelElement) {\n                return;\n            }\n            const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n            if (!isWidget(selectedViewElement)) {\n                return;\n            }\n            if (!conversionApi.consumable.consume(modelSelection, 'selection')) {\n                return;\n            }\n            viewWriter.setSelection(viewWriter.createRangeOn(selectedViewElement), {\n                fake: true,\n                label: getLabel(selectedViewElement)\n            });\n        });\n        // Mark all widgets inside the selection with the css class.\n        // This handler is registered at the 'low' priority so it's triggered after the real selection conversion.\n        this.editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n            // Remove selected class from previously selected widgets.\n            this._clearPreviouslySelectedWidgets(conversionApi.writer);\n            const viewWriter = conversionApi.writer;\n            const viewSelection = viewWriter.document.selection;\n            let lastMarked = null;\n            for (const range of viewSelection.getRanges()) {\n                // Note: There could be multiple selected widgets in a range but no fake selection.\n                // All of them must be marked as selected, for instance [<widget></widget><widget></widget>]\n                for (const value of range) {\n                    const node = value.item;\n                    // Do not mark nested widgets in selected one. See: #4594\n                    if (isWidget(node) && !isChild(node, lastMarked)) {\n                        viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);\n                        this._previouslySelected.add(node);\n                        lastMarked = node;\n                    }\n                }\n            }\n        }, { priority: 'low' });\n        // If mouse down is pressed on widget - create selection over whole widget.\n        view.addObserver(MouseObserver);\n        this.listenTo(viewDocument, 'mousedown', (...args) => this._onMousedown(...args));\n        // There are two keydown listeners working on different priorities. This allows other\n        // features such as WidgetTypeAround or TableKeyboard to attach their listeners in between\n        // and customize the behavior even further in different content/selection scenarios.\n        //\n        // * The first listener handles changing the selection on arrow key press\n        // if the widget is selected or if the selection is next to a widget and the widget\n        // should become selected upon the arrow key press.\n        //\n        // * The second (late) listener makes sure the default browser action on arrow key press is\n        // prevented when a widget is selected. This prevents the selection from being moved\n        // from a fake selection container.\n        this.listenTo(viewDocument, 'arrowKey', (...args) => {\n            this._handleSelectionChangeOnArrowKeyPress(...args);\n        }, { context: [isWidget, '$text'] });\n        this.listenTo(viewDocument, 'arrowKey', (...args) => {\n            this._preventDefaultOnArrowKeyPress(...args);\n        }, { context: '$root' });\n        this.listenTo(viewDocument, 'arrowKey', verticalNavigationHandler(this.editor.editing), { context: '$text' });\n        // Handle custom delete behaviour.\n        this.listenTo(viewDocument, 'delete', (evt, data) => {\n            if (this._handleDelete(data.direction == 'forward')) {\n                data.preventDefault();\n                evt.stop();\n            }\n        }, { context: '$root' });\n    }\n    /**\n     * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.\n     */\n    _onMousedown(eventInfo, domEventData) {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        let element = domEventData.target;\n        // Do nothing for single or double click inside nested editable.\n        if (isInsideNestedEditable(element)) {\n            // But at least triple click inside nested editable causes broken selection in Safari.\n            // For such event, we select the entire nested editable element.\n            // See: https://github.com/ckeditor/ckeditor5/issues/1463.\n            if ((env.isSafari || env.isGecko) && domEventData.domEvent.detail >= 3) {\n                const mapper = editor.editing.mapper;\n                const viewElement = element.is('attributeElement') ?\n                    element.findAncestor(element => !element.is('attributeElement')) : element;\n                const modelElement = mapper.toModelElement(viewElement);\n                domEventData.preventDefault();\n                this.editor.model.change(writer => {\n                    writer.setSelection(modelElement, 'in');\n                });\n            }\n            return;\n        }\n        // If target is not a widget element - check if one of the ancestors is.\n        if (!isWidget(element)) {\n            element = element.findAncestor(isWidget);\n            if (!element) {\n                return;\n            }\n        }\n        // On Android selection would jump to the first table cell, on other devices\n        // we can't block it (and don't need to) because of drag and drop support.\n        if (env.isAndroid) {\n            domEventData.preventDefault();\n        }\n        // Focus editor if is not focused already.\n        if (!viewDocument.isFocused) {\n            view.focus();\n        }\n        // Create model selection over widget.\n        const modelElement = editor.editing.mapper.toModelElement(element);\n        this._setSelectionOverElement(modelElement);\n    }\n    /**\n     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes\n     * the model selection when:\n     *\n     * * arrow key is pressed when the widget is selected,\n     * * the selection is next to a widget and the widget should become selected upon the arrow key press.\n     *\n     * See {@link #_preventDefaultOnArrowKeyPress}.\n     */\n    _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {\n        const keyCode = domEventData.keyCode;\n        const model = this.editor.model;\n        const schema = model.schema;\n        const modelSelection = model.document.selection;\n        const objectElement = modelSelection.getSelectedElement();\n        const direction = getLocalizedArrowKeyCodeDirection(keyCode, this.editor.locale.contentLanguageDirection);\n        const isForward = direction == 'down' || direction == 'right';\n        const isVerticalNavigation = direction == 'up' || direction == 'down';\n        // If object element is selected.\n        if (objectElement && schema.isObject(objectElement)) {\n            const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();\n            const newRange = schema.getNearestSelectionRange(position, isForward ? 'forward' : 'backward');\n            if (newRange) {\n                model.change(writer => {\n                    writer.setSelection(newRange);\n                });\n                domEventData.preventDefault();\n                eventInfo.stop();\n            }\n            return;\n        }\n        // Handle collapsing of the selection when there is any widget on the edge of selection.\n        // This is needed because browsers have problems with collapsing such selection.\n        if (!modelSelection.isCollapsed && !domEventData.shiftKey) {\n            const firstPosition = modelSelection.getFirstPosition();\n            const lastPosition = modelSelection.getLastPosition();\n            const firstSelectedNode = firstPosition.nodeAfter;\n            const lastSelectedNode = lastPosition.nodeBefore;\n            if (firstSelectedNode && schema.isObject(firstSelectedNode) || lastSelectedNode && schema.isObject(lastSelectedNode)) {\n                model.change(writer => {\n                    writer.setSelection(isForward ? lastPosition : firstPosition);\n                });\n                domEventData.preventDefault();\n                eventInfo.stop();\n            }\n            return;\n        }\n        // Return if not collapsed.\n        if (!modelSelection.isCollapsed) {\n            return;\n        }\n        // If selection is next to object element.\n        const objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);\n        if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {\n            // Do not select an inline widget while handling up/down arrow.\n            if (schema.isInline(objectElementNextToSelection) && isVerticalNavigation) {\n                return;\n            }\n            this._setSelectionOverElement(objectElementNextToSelection);\n            domEventData.preventDefault();\n            eventInfo.stop();\n        }\n    }\n    /**\n     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents\n     * the default browser behavior to make sure the fake selection is not being moved from a fake selection\n     * container.\n     *\n     * See {@link #_handleSelectionChangeOnArrowKeyPress}.\n     */\n    _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {\n        const model = this.editor.model;\n        const schema = model.schema;\n        const objectElement = model.document.selection.getSelectedElement();\n        // If object element is selected.\n        if (objectElement && schema.isObject(objectElement)) {\n            domEventData.preventDefault();\n            eventInfo.stop();\n        }\n    }\n    /**\n     * Handles delete keys: backspace and delete.\n     *\n     * @param isForward Set to true if delete was performed in forward direction.\n     * @returns Returns `true` if keys were handled correctly.\n     */\n    _handleDelete(isForward) {\n        const modelDocument = this.editor.model.document;\n        const modelSelection = modelDocument.selection;\n        // Do nothing when the read only mode is enabled.\n        if (!this.editor.model.canEditAt(modelSelection)) {\n            return;\n        }\n        // Do nothing on non-collapsed selection.\n        if (!modelSelection.isCollapsed) {\n            return;\n        }\n        const objectElement = this._getObjectElementNextToSelection(isForward);\n        if (objectElement) {\n            this.editor.model.change(writer => {\n                let previousNode = modelSelection.anchor.parent;\n                // Remove previous element if empty.\n                while (previousNode.isEmpty) {\n                    const nodeToRemove = previousNode;\n                    previousNode = nodeToRemove.parent;\n                    writer.remove(nodeToRemove);\n                }\n                this._setSelectionOverElement(objectElement);\n            });\n            return true;\n        }\n    }\n    /**\n     * Sets {@link module:engine/model/selection~Selection document's selection} over given element.\n     *\n     * @internal\n     */\n    _setSelectionOverElement(element) {\n        this.editor.model.change(writer => {\n            writer.setSelection(writer.createRangeOn(element));\n        });\n    }\n    /**\n     * Checks if {@link module:engine/model/element~Element element} placed next to the current\n     * {@link module:engine/model/selection~Selection model selection} exists and is marked in\n     * {@link module:engine/model/schema~Schema schema} as `object`.\n     *\n     * @internal\n     * @param forward Direction of checking.\n     */\n    _getObjectElementNextToSelection(forward) {\n        const model = this.editor.model;\n        const schema = model.schema;\n        const modelSelection = model.document.selection;\n        // Clone current selection to use it as a probe. We must leave default selection as it is so it can return\n        // to its current state after undo.\n        const probe = model.createSelection(modelSelection);\n        model.modifySelection(probe, { direction: forward ? 'forward' : 'backward' });\n        // The selection didn't change so there is nothing there.\n        if (probe.isEqual(modelSelection)) {\n            return null;\n        }\n        const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;\n        if (!!objectElement && schema.isObject(objectElement)) {\n            return objectElement;\n        }\n        return null;\n    }\n    /**\n     * Removes CSS class from previously selected widgets.\n     */\n    _clearPreviouslySelectedWidgets(writer) {\n        for (const widget of this._previouslySelected) {\n            writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);\n        }\n        this._previouslySelected.clear();\n    }\n}\n/**\n * Returns `true` when element is a nested editable or is placed inside one.\n */\nfunction isInsideNestedEditable(element) {\n    let currentElement = element;\n    while (currentElement) {\n        if (currentElement.is('editableElement') && !currentElement.is('rootElement')) {\n            return true;\n        }\n        // Click on nested widget should select it.\n        if (isWidget(currentElement)) {\n            return false;\n        }\n        currentElement = currentElement.parent;\n    }\n    return false;\n}\n/**\n * Checks whether the specified `element` is a child of the `parent` element.\n *\n * @param element An element to check.\n * @param parent A parent for the element.\n */\nfunction isChild(element, parent) {\n    if (!parent) {\n        return false;\n    }\n    return Array.from(element.getAncestors()).includes(parent);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgettoolbarrepository\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { BalloonPanelView, ContextualBalloon, ToolbarView } from '@ckeditor/ckeditor5-ui';\nimport { CKEditorError, logWarning } from '@ckeditor/ckeditor5-utils';\nimport { isWidget } from './utils';\n/**\n * Widget toolbar repository plugin. A central point for registering widget toolbars. This plugin handles the whole\n * toolbar rendering process and exposes a concise API.\n *\n * To add a toolbar for your widget use the {@link ~WidgetToolbarRepository#register `WidgetToolbarRepository#register()`} method.\n *\n * The following example comes from the {@link module:image/imagetoolbar~ImageToolbar} plugin:\n *\n * ```ts\n * class ImageToolbar extends Plugin {\n * \tstatic get requires() {\n * \t\treturn [ WidgetToolbarRepository ];\n * \t}\n *\n * \tafterInit() {\n * \t\tconst editor = this.editor;\n * \t\tconst widgetToolbarRepository = editor.plugins.get( WidgetToolbarRepository );\n *\n * \t\twidgetToolbarRepository.register( 'image', {\n * \t\t\titems: editor.config.get( 'image.toolbar' ),\n * \t\t\tgetRelatedElement: getClosestSelectedImageWidget\n * \t\t} );\n * \t}\n * }\n * ```\n */\nexport default class WidgetToolbarRepository extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * A map of toolbar definitions.\n         */\n        this._toolbarDefinitions = new Map();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ContextualBalloon];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'WidgetToolbarRepository';\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        // Disables the default balloon toolbar for all widgets.\n        if (editor.plugins.has('BalloonToolbar')) {\n            const balloonToolbar = editor.plugins.get('BalloonToolbar');\n            this.listenTo(balloonToolbar, 'show', evt => {\n                if (isWidgetSelected(editor.editing.view.document.selection)) {\n                    evt.stop();\n                }\n            }, { priority: 'high' });\n        }\n        this._balloon = this.editor.plugins.get('ContextualBalloon');\n        this.on('change:isEnabled', () => {\n            this._updateToolbarsVisibility();\n        });\n        this.listenTo(editor.ui, 'update', () => {\n            this._updateToolbarsVisibility();\n        });\n        // UI#update is not fired after focus is back in editor, we need to check if balloon panel should be visible.\n        this.listenTo(editor.ui.focusTracker, 'change:isFocused', () => {\n            this._updateToolbarsVisibility();\n        }, { priority: 'low' });\n    }\n    destroy() {\n        super.destroy();\n        for (const toolbarConfig of this._toolbarDefinitions.values()) {\n            toolbarConfig.view.destroy();\n        }\n    }\n    /**\n     * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked\n     * `getRelatedElement` function. Toolbar items are gathered from `items` array.\n     * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.\n     *\n     * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}\n     * callback (or later) to make sure that the given toolbar items were already registered by other plugins.\n     *\n     * @param toolbarId An id for the toolbar. Used to\n     * @param options.ariaLabel Label used by assistive technologies to describe this toolbar element.\n     * @param options.items Array of toolbar items.\n     * @param options.getRelatedElement Callback which returns an element the toolbar should be attached to.\n     * @param options.balloonClassName CSS class for the widget balloon.\n     */\n    register(toolbarId, { ariaLabel, items, getRelatedElement, balloonClassName = 'ck-toolbar-container' }) {\n        // Trying to register a toolbar without any item.\n        if (!items.length) {\n            /**\n             * When {@link module:widget/widgettoolbarrepository~WidgetToolbarRepository#register registering} a new widget toolbar, you\n             * need to provide a non-empty array with the items that will be inserted into the toolbar.\n             *\n             * If you see this error when integrating the editor, you likely forgot to configure one of the widget toolbars.\n             *\n             * See for instance:\n             *\n             * * {@link module:table/tableconfig~TableConfig#contentToolbar `config.table.contentToolbar`}\n             * * {@link module:image/imageconfig~ImageConfig#toolbar `config.image.toolbar`}\n             *\n             * @error widget-toolbar-no-items\n             * @param toolbarId The id of the toolbar that has not been configured correctly.\n             */\n            logWarning('widget-toolbar-no-items', { toolbarId });\n            return;\n        }\n        const editor = this.editor;\n        const t = editor.t;\n        const toolbarView = new ToolbarView(editor.locale);\n        toolbarView.ariaLabel = ariaLabel || t('Widget toolbar');\n        if (this._toolbarDefinitions.has(toolbarId)) {\n            /**\n             * Toolbar with the given id was already added.\n             *\n             * @error widget-toolbar-duplicated\n             * @param toolbarId Toolbar id.\n             */\n            throw new CKEditorError('widget-toolbar-duplicated', this, { toolbarId });\n        }\n        const toolbarDefinition = {\n            view: toolbarView,\n            getRelatedElement,\n            balloonClassName,\n            itemsConfig: items,\n            initialized: false\n        };\n        // Register the toolbar so it becomes available for Alt+F10 and Esc navigation.\n        editor.ui.addToolbar(toolbarView, {\n            isContextual: true,\n            beforeFocus: () => {\n                const relatedElement = getRelatedElement(editor.editing.view.document.selection);\n                if (relatedElement) {\n                    this._showToolbar(toolbarDefinition, relatedElement);\n                }\n            },\n            afterBlur: () => {\n                this._hideToolbar(toolbarDefinition);\n            }\n        });\n        this._toolbarDefinitions.set(toolbarId, toolbarDefinition);\n    }\n    /**\n     * Iterates over stored toolbars and makes them visible or hidden.\n     */\n    _updateToolbarsVisibility() {\n        let maxRelatedElementDepth = 0;\n        let deepestRelatedElement = null;\n        let deepestToolbarDefinition = null;\n        for (const definition of this._toolbarDefinitions.values()) {\n            const relatedElement = definition.getRelatedElement(this.editor.editing.view.document.selection);\n            if (!this.isEnabled || !relatedElement) {\n                if (this._isToolbarInBalloon(definition)) {\n                    this._hideToolbar(definition);\n                }\n            }\n            else if (!this.editor.ui.focusTracker.isFocused) {\n                if (this._isToolbarVisible(definition)) {\n                    this._hideToolbar(definition);\n                }\n            }\n            else {\n                const relatedElementDepth = relatedElement.getAncestors().length;\n                // Many toolbars can express willingness to be displayed but they do not know about\n                // each other. Figure out which toolbar is deepest in the view tree to decide which\n                // should be displayed. For instance, if a selected image is inside a table cell, display\n                // the ImageToolbar rather than the TableToolbar (#60).\n                if (relatedElementDepth > maxRelatedElementDepth) {\n                    maxRelatedElementDepth = relatedElementDepth;\n                    deepestRelatedElement = relatedElement;\n                    deepestToolbarDefinition = definition;\n                }\n            }\n        }\n        if (deepestToolbarDefinition) {\n            this._showToolbar(deepestToolbarDefinition, deepestRelatedElement);\n        }\n    }\n    /**\n     * Hides the given toolbar.\n     */\n    _hideToolbar(toolbarDefinition) {\n        this._balloon.remove(toolbarDefinition.view);\n        this.stopListening(this._balloon, 'change:visibleView');\n    }\n    /**\n     * Shows up the toolbar if the toolbar is not visible.\n     * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.\n     *\n     * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view\n     * should be still visible after the {@link module:ui/editorui/editorui~EditorUI#event:update}.\n     */\n    _showToolbar(toolbarDefinition, relatedElement) {\n        if (this._isToolbarVisible(toolbarDefinition)) {\n            repositionContextualBalloon(this.editor, relatedElement);\n        }\n        else if (!this._isToolbarInBalloon(toolbarDefinition)) {\n            if (!toolbarDefinition.initialized) {\n                toolbarDefinition.initialized = true;\n                toolbarDefinition.view.fillFromConfig(toolbarDefinition.itemsConfig, this.editor.ui.componentFactory);\n            }\n            this._balloon.add({\n                view: toolbarDefinition.view,\n                position: getBalloonPositionData(this.editor, relatedElement),\n                balloonClassName: toolbarDefinition.balloonClassName\n            });\n            // Update toolbar position each time stack with toolbar view is switched to visible.\n            // This is in a case target element has changed when toolbar was in invisible stack\n            // e.g. target image was wrapped by a block quote.\n            // See https://github.com/ckeditor/ckeditor5-widget/issues/92.\n            this.listenTo(this._balloon, 'change:visibleView', () => {\n                for (const definition of this._toolbarDefinitions.values()) {\n                    if (this._isToolbarVisible(definition)) {\n                        const relatedElement = definition.getRelatedElement(this.editor.editing.view.document.selection);\n                        repositionContextualBalloon(this.editor, relatedElement);\n                    }\n                }\n            });\n        }\n    }\n    _isToolbarVisible(toolbar) {\n        return this._balloon.visibleView === toolbar.view;\n    }\n    _isToolbarInBalloon(toolbar) {\n        return this._balloon.hasView(toolbar.view);\n    }\n}\nfunction repositionContextualBalloon(editor, relatedElement) {\n    const balloon = editor.plugins.get('ContextualBalloon');\n    const position = getBalloonPositionData(editor, relatedElement);\n    balloon.updatePosition(position);\n}\nfunction getBalloonPositionData(editor, relatedElement) {\n    const editingView = editor.editing.view;\n    const defaultPositions = BalloonPanelView.defaultPositions;\n    return {\n        target: editingView.domConverter.mapViewToDom(relatedElement),\n        positions: [\n            defaultPositions.northArrowSouth,\n            defaultPositions.northArrowSouthWest,\n            defaultPositions.northArrowSouthEast,\n            defaultPositions.southArrowNorth,\n            defaultPositions.southArrowNorthWest,\n            defaultPositions.southArrowNorthEast,\n            defaultPositions.viewportStickyNorth\n        ]\n    };\n}\nfunction isWidgetSelected(selection) {\n    const viewElement = selection.getSelectedElement();\n    return !!(viewElement && isWidget(viewElement));\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgetresize/resizerstate\n */\nimport { ObservableMixin, Rect } from '@ckeditor/ckeditor5-utils';\n/**\n * Stores the internal state of a single resizable object.\n */\nexport default class ResizeState extends ObservableMixin() {\n    /**\n     * @param options Resizer options.\n     */\n    constructor(options) {\n        super();\n        this.set('activeHandlePosition', null);\n        this.set('proposedWidthPercents', null);\n        this.set('proposedWidth', null);\n        this.set('proposedHeight', null);\n        this.set('proposedHandleHostWidth', null);\n        this.set('proposedHandleHostHeight', null);\n        this._options = options;\n        this._referenceCoordinates = null;\n    }\n    /**\n     * The original width (pixels) of the resized object when the resize process was started.\n     */\n    get originalWidth() {\n        return this._originalWidth;\n    }\n    /**\n     * The original height (pixels) of the resized object when the resize process was started.\n     */\n    get originalHeight() {\n        return this._originalHeight;\n    }\n    /**\n     * The original width (percents) of the resized object when the resize process was started.\n     */\n    get originalWidthPercents() {\n        return this._originalWidthPercents;\n    }\n    /**\n     * A width to height ratio of the resized image.\n     */\n    get aspectRatio() {\n        return this._aspectRatio;\n    }\n    /**\n     *\n     * @param domResizeHandle The handle used to calculate the reference point.\n     */\n    begin(domResizeHandle, domHandleHost, domResizeHost) {\n        const clientRect = new Rect(domHandleHost);\n        this.activeHandlePosition = getHandlePosition(domResizeHandle);\n        this._referenceCoordinates = getAbsoluteBoundaryPoint(domHandleHost, getOppositePosition(this.activeHandlePosition));\n        this._originalWidth = clientRect.width;\n        this._originalHeight = clientRect.height;\n        this._aspectRatio = clientRect.width / clientRect.height;\n        const widthStyle = domResizeHost.style.width;\n        if (widthStyle && widthStyle.match(/^\\d+(\\.\\d*)?%$/)) {\n            this._originalWidthPercents = parseFloat(widthStyle);\n        }\n        else {\n            this._originalWidthPercents = calculateHostPercentageWidth(domResizeHost, clientRect);\n        }\n    }\n    update(newSize) {\n        this.proposedWidth = newSize.width;\n        this.proposedHeight = newSize.height;\n        this.proposedWidthPercents = newSize.widthPercents;\n        this.proposedHandleHostWidth = newSize.handleHostWidth;\n        this.proposedHandleHostHeight = newSize.handleHostHeight;\n    }\n}\n/**\n * Calculates a relative width of a `domResizeHost` compared to its ancestor in percents.\n */\nfunction calculateHostPercentageWidth(domResizeHost, resizeHostRect) {\n    const domResizeHostParent = domResizeHost.parentElement;\n    // Need to use computed style as it properly excludes parent's paddings from the returned value.\n    let parentWidth = parseFloat(domResizeHostParent.ownerDocument.defaultView.getComputedStyle(domResizeHostParent).width);\n    // Sometimes parent width cannot be accessed. If that happens we should go up in the elements tree\n    // and try to get width from next ancestor.\n    // https://github.com/ckeditor/ckeditor5/issues/10776\n    const ancestorLevelLimit = 5;\n    let currentLevel = 0;\n    let checkedElement = domResizeHostParent;\n    while (isNaN(parentWidth)) {\n        checkedElement = checkedElement.parentElement;\n        if (++currentLevel > ancestorLevelLimit) {\n            return 0;\n        }\n        parentWidth = parseFloat(domResizeHostParent.ownerDocument.defaultView.getComputedStyle(checkedElement).width);\n    }\n    return resizeHostRect.width / parentWidth * 100;\n}\n/**\n * Returns coordinates of the top-left corner of an element, relative to the document's top-left corner.\n *\n * @param resizerPosition The position of the resize handle, e.g. `\"top-left\"`, `\"bottom-right\"`.\n */\nfunction getAbsoluteBoundaryPoint(element, resizerPosition) {\n    const elementRect = new Rect(element);\n    const positionParts = resizerPosition.split('-');\n    const ret = {\n        x: positionParts[1] == 'right' ? elementRect.right : elementRect.left,\n        y: positionParts[0] == 'bottom' ? elementRect.bottom : elementRect.top\n    };\n    ret.x += element.ownerDocument.defaultView.scrollX;\n    ret.y += element.ownerDocument.defaultView.scrollY;\n    return ret;\n}\n/**\n * @param resizerPosition The expected resizer position, like `\"top-left\"`, `\"bottom-right\"`.\n * @returns A prefixed HTML class name for the resizer element.\n */\nfunction getResizerHandleClass(resizerPosition) {\n    return `ck-widget__resizer__handle-${resizerPosition}`;\n}\n/**\n * Determines the position of a given resize handle.\n *\n * @param domHandle Handle used to calculate the reference point.\n * @returns Returns a string like `\"top-left\"` or `undefined` if not matched.\n */\nfunction getHandlePosition(domHandle) {\n    const resizerPositions = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];\n    for (const position of resizerPositions) {\n        if (domHandle.classList.contains(getResizerHandleClass(position))) {\n            return position;\n        }\n    }\n}\n/**\n * @param position Like `\"top-left\"`.\n * @returns Inverted `position`, e.g. it returns `\"bottom-right\"` if `\"top-left\"` was given as `position`.\n */\nfunction getOppositePosition(position) {\n    const parts = position.split('-');\n    const replacements = {\n        top: 'bottom',\n        bottom: 'top',\n        left: 'right',\n        right: 'left'\n    };\n    return `${replacements[parts[0]]}-${replacements[parts[1]]}`;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgetresize/sizeview\n */\nimport { View } from '@ckeditor/ckeditor5-ui';\n/**\n * A view displaying the proposed new element size during the resizing.\n */\nexport default class SizeView extends View {\n    constructor() {\n        super();\n        const bind = this.bindTemplate;\n        this.setTemplate({\n            tag: 'div',\n            attributes: {\n                class: [\n                    'ck',\n                    'ck-size-view',\n                    bind.to('_viewPosition', value => value ? `ck-orientation-${value}` : '')\n                ],\n                style: {\n                    display: bind.if('_isVisible', 'none', visible => !visible)\n                }\n            },\n            children: [{\n                    text: bind.to('_label')\n                }]\n        });\n    }\n    /**\n     * A method used for binding the `SizeView` instance properties to the `ResizeState` instance observable properties.\n     *\n     * @internal\n     * @param options An object defining the resizer options, used for setting the proper size label.\n     * @param resizeState The `ResizeState` class instance, used for keeping the `SizeView` state up to date.\n     */\n    _bindToState(options, resizeState) {\n        this.bind('_isVisible').to(resizeState, 'proposedWidth', resizeState, 'proposedHeight', (width, height) => width !== null && height !== null);\n        this.bind('_label').to(resizeState, 'proposedHandleHostWidth', resizeState, 'proposedHandleHostHeight', resizeState, 'proposedWidthPercents', (width, height, widthPercents) => {\n            if (options.unit === 'px') {\n                return `${width}×${height}`;\n            }\n            else {\n                return `${widthPercents}%`;\n            }\n        });\n        this.bind('_viewPosition').to(resizeState, 'activeHandlePosition', resizeState, 'proposedHandleHostWidth', resizeState, 'proposedHandleHostHeight', \n        // If the widget is too small to contain the size label, display the label above.\n        (position, width, height) => width < 50 || height < 50 ? 'above-center' : position);\n    }\n    /**\n     * A method used for cleaning up. It removes the bindings and hides the view.\n     *\n     * @internal\n     */\n    _dismiss() {\n        this.unbind();\n        this._isVisible = false;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgetresize/resizer\n */\nimport { Template } from '@ckeditor/ckeditor5-ui';\nimport { Rect, ObservableMixin, compareArrays } from '@ckeditor/ckeditor5-utils';\nimport ResizeState from './resizerstate';\nimport SizeView from './sizeview';\n/**\n * Represents a resizer for a single resizable object.\n */\nexport default class Resizer extends ObservableMixin() {\n    /**\n     * @param options Resizer options.\n     */\n    constructor(options) {\n        super();\n        /**\n         * A wrapper that is controlled by the resizer. This is usually a widget element.\n         */\n        this._viewResizerWrapper = null;\n        this._options = options;\n        this.set('isEnabled', true);\n        this.set('isSelected', false);\n        this.bind('isVisible').to(this, 'isEnabled', this, 'isSelected', (isEnabled, isSelected) => isEnabled && isSelected);\n        this.decorate('begin');\n        this.decorate('cancel');\n        this.decorate('commit');\n        this.decorate('updateSize');\n        this.on('commit', event => {\n            // State might not be initialized yet. In this case, prevent further handling and make sure that the resizer is\n            // cleaned up (#5195).\n            if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {\n                this._cleanup();\n                event.stop();\n            }\n        }, { priority: 'high' });\n    }\n    /**\n     * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.\n     *\n     * Note that a new state is created for each resize transaction.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Makes resizer visible in the UI.\n     */\n    show() {\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            writer.removeClass('ck-hidden', this._viewResizerWrapper);\n        });\n    }\n    /**\n     * Hides resizer in the UI.\n     */\n    hide() {\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            writer.addClass('ck-hidden', this._viewResizerWrapper);\n        });\n    }\n    /**\n     * Attaches the resizer to the DOM.\n     */\n    attach() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const that = this;\n        const widgetElement = this._options.viewElement;\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            const viewResizerWrapper = writer.createUIElement('div', {\n                class: 'ck ck-reset_all ck-widget__resizer'\n            }, function (domDocument) {\n                const domElement = this.toDomElement(domDocument);\n                that._appendHandles(domElement);\n                that._appendSizeUI(domElement);\n                return domElement;\n            });\n            // Append the resizer wrapper to the widget's wrapper.\n            writer.insert(writer.createPositionAt(widgetElement, 'end'), viewResizerWrapper);\n            writer.addClass('ck-widget_with-resizer', widgetElement);\n            this._viewResizerWrapper = viewResizerWrapper;\n            if (!this.isVisible) {\n                this.hide();\n            }\n        });\n        this.on('change:isVisible', () => {\n            if (this.isVisible) {\n                this.show();\n                this.redraw();\n            }\n            else {\n                this.hide();\n            }\n        });\n    }\n    /**\n     * Starts the resizing process.\n     *\n     * Creates a new {@link #state} for the current process.\n     *\n     * @fires begin\n     * @param domResizeHandle Clicked handle.\n     */\n    begin(domResizeHandle) {\n        this._state = new ResizeState(this._options);\n        this._sizeView._bindToState(this._options, this.state);\n        this._initialViewWidth = this._options.viewElement.getStyle('width');\n        this.state.begin(domResizeHandle, this._getHandleHost(), this._getResizeHost());\n    }\n    /**\n     * Updates the proposed size based on `domEventData`.\n     *\n     * @fires updateSize\n     */\n    updateSize(domEventData) {\n        const newSize = this._proposeNewSize(domEventData);\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            const unit = this._options.unit || '%';\n            const newWidth = (unit === '%' ? newSize.widthPercents : newSize.width) + unit;\n            writer.setStyle('width', newWidth, this._options.viewElement);\n        });\n        // Get an actual image width, and:\n        // * reflect this size to the resize wrapper\n        // * apply this **real** size to the state\n        const domHandleHost = this._getHandleHost();\n        const domHandleHostRect = new Rect(domHandleHost);\n        const handleHostWidth = Math.round(domHandleHostRect.width);\n        const handleHostHeight = Math.round(domHandleHostRect.height);\n        // Handle max-width limitation.\n        const domResizeHostRect = new Rect(domHandleHost);\n        newSize.width = Math.round(domResizeHostRect.width);\n        newSize.height = Math.round(domResizeHostRect.height);\n        this.redraw(domHandleHostRect);\n        this.state.update({\n            ...newSize,\n            handleHostWidth,\n            handleHostHeight\n        });\n    }\n    /**\n     * Applies the geometry proposed with the resizer.\n     *\n     * @fires commit\n     */\n    commit() {\n        const unit = this._options.unit || '%';\n        const newValue = (unit === '%' ? this.state.proposedWidthPercents : this.state.proposedWidth) + unit;\n        // Both cleanup and onCommit callback are very likely to make view changes. Ensure that it is made in a single step.\n        this._options.editor.editing.view.change(() => {\n            this._cleanup();\n            this._options.onCommit(newValue);\n        });\n    }\n    /**\n     * Cancels and rejects the proposed resize dimensions, hiding the UI.\n     *\n     * @fires cancel\n     */\n    cancel() {\n        this._cleanup();\n    }\n    /**\n     * Destroys the resizer.\n     */\n    destroy() {\n        this.cancel();\n    }\n    /**\n     * Redraws the resizer.\n     *\n     * @param handleHostRect Handle host rectangle might be given to improve performance.\n     */\n    redraw(handleHostRect) {\n        const domWrapper = this._domResizerWrapper;\n        // Refresh only if resizer exists in the DOM.\n        if (!existsInDom(domWrapper)) {\n            return;\n        }\n        const widgetWrapper = domWrapper.parentElement;\n        const handleHost = this._getHandleHost();\n        const resizerWrapper = this._viewResizerWrapper;\n        const currentDimensions = [\n            resizerWrapper.getStyle('width'),\n            resizerWrapper.getStyle('height'),\n            resizerWrapper.getStyle('left'),\n            resizerWrapper.getStyle('top')\n        ];\n        let newDimensions;\n        if (widgetWrapper.isSameNode(handleHost)) {\n            const clientRect = handleHostRect || new Rect(handleHost);\n            newDimensions = [\n                clientRect.width + 'px',\n                clientRect.height + 'px',\n                undefined,\n                undefined\n            ];\n        }\n        // In case a resizing host is not a widget wrapper, we need to compensate\n        // for any additional offsets the resize host might have. E.g. wrapper padding\n        // or simply another editable. By doing that the border and resizers are shown\n        // only around the resize host.\n        else {\n            newDimensions = [\n                handleHost.offsetWidth + 'px',\n                handleHost.offsetHeight + 'px',\n                handleHost.offsetLeft + 'px',\n                handleHost.offsetTop + 'px'\n            ];\n        }\n        // Make changes to the view only if the resizer should actually get new dimensions.\n        // Otherwise, if View#change() was always called, this would cause EditorUI#update\n        // loops because the WidgetResize plugin listens to EditorUI#update and updates\n        // the resizer.\n        // https://github.com/ckeditor/ckeditor5/issues/7633\n        if (compareArrays(currentDimensions, newDimensions) !== 'same') {\n            this._options.editor.editing.view.change(writer => {\n                writer.setStyle({\n                    width: newDimensions[0],\n                    height: newDimensions[1],\n                    left: newDimensions[2],\n                    top: newDimensions[3]\n                }, resizerWrapper);\n            });\n        }\n    }\n    containsHandle(domElement) {\n        return this._domResizerWrapper.contains(domElement);\n    }\n    static isResizeHandle(domElement) {\n        return domElement.classList.contains('ck-widget__resizer__handle');\n    }\n    /**\n     * Cleans up the context state.\n     */\n    _cleanup() {\n        this._sizeView._dismiss();\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            writer.setStyle('width', this._initialViewWidth, this._options.viewElement);\n        });\n    }\n    /**\n     * Calculates the proposed size as the resize handles are dragged.\n     *\n     * @param domEventData Event data that caused the size update request. It should be used to calculate the proposed size.\n     */\n    _proposeNewSize(domEventData) {\n        const state = this.state;\n        const currentCoordinates = extractCoordinates(domEventData);\n        const isCentered = this._options.isCentered ? this._options.isCentered(this) : true;\n        // Enlargement defines how much the resize host has changed in a given axis. Naturally it could be a negative number\n        // meaning that it has been shrunk.\n        //\n        // +----------------+--+\n        // |                |  |\n        // |       img      |  |\n        // |  /handle host  |  |\n        // +----------------+  | ^\n        // |                   | | - enlarge y\n        // +-------------------+ v\n        // \t\t\t\t\t<-->\n        // \t\t\t\t\t enlarge x\n        const enlargement = {\n            x: state._referenceCoordinates.x - (currentCoordinates.x + state.originalWidth),\n            y: (currentCoordinates.y - state.originalHeight) - state._referenceCoordinates.y\n        };\n        if (isCentered && state.activeHandlePosition.endsWith('-right')) {\n            enlargement.x = currentCoordinates.x - (state._referenceCoordinates.x + state.originalWidth);\n        }\n        // Objects needs to be resized twice as much in horizontal axis if centered, since enlargement is counted from\n        // one resized corner to your cursor. It needs to be duplicated to compensate for the other side too.\n        if (isCentered) {\n            enlargement.x *= 2;\n        }\n        // const resizeHost = this._getResizeHost();\n        // The size proposed by the user. It does not consider the aspect ratio.\n        let width = Math.abs(state.originalWidth + enlargement.x);\n        let height = Math.abs(state.originalHeight + enlargement.y);\n        // Dominant determination must take the ratio into account.\n        const dominant = width / state.aspectRatio > height ? 'width' : 'height';\n        if (dominant == 'width') {\n            height = width / state.aspectRatio;\n        }\n        else {\n            width = height * state.aspectRatio;\n        }\n        return {\n            width: Math.round(width),\n            height: Math.round(height),\n            widthPercents: Math.min(Math.round(state.originalWidthPercents / state.originalWidth * width * 100) / 100, 100)\n        };\n    }\n    /**\n     * Obtains the resize host.\n     *\n     * Resize host is an object that receives dimensions which are the result of resizing.\n     */\n    _getResizeHost() {\n        const widgetWrapper = this._domResizerWrapper.parentElement;\n        return this._options.getResizeHost(widgetWrapper);\n    }\n    /**\n     * Obtains the handle host.\n     *\n     * Handle host is an object that the handles are aligned to.\n     *\n     * Handle host will not always be an entire widget itself. Take an image as an example. The image widget\n     * contains an image and a caption. Only the image should be surrounded with handles.\n     */\n    _getHandleHost() {\n        const widgetWrapper = this._domResizerWrapper.parentElement;\n        return this._options.getHandleHost(widgetWrapper);\n    }\n    /**\n     * DOM container of the entire resize UI.\n     *\n     * Note that this property will have a value only after the element bound with the resizer is rendered\n     * (otherwise `null`).\n     */\n    get _domResizerWrapper() {\n        return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);\n    }\n    /**\n     * Renders the resize handles in the DOM.\n     *\n     * @param domElement The resizer wrapper.\n     */\n    _appendHandles(domElement) {\n        const resizerPositions = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];\n        for (const currentPosition of resizerPositions) {\n            domElement.appendChild((new Template({\n                tag: 'div',\n                attributes: {\n                    class: `ck-widget__resizer__handle ${getResizerClass(currentPosition)}`\n                }\n            }).render()));\n        }\n    }\n    /**\n     * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.\n     */\n    _appendSizeUI(domElement) {\n        this._sizeView = new SizeView();\n        // Make sure icon#element is rendered before passing to appendChild().\n        this._sizeView.render();\n        domElement.appendChild(this._sizeView.element);\n    }\n}\n/**\n * @param resizerPosition Expected resizer position like `\"top-left\"`, `\"bottom-right\"`.\n * @returns A prefixed HTML class name for the resizer element\n */\nfunction getResizerClass(resizerPosition) {\n    return `ck-widget__resizer__handle-${resizerPosition}`;\n}\nfunction extractCoordinates(event) {\n    return {\n        x: event.pageX,\n        y: event.pageY\n    };\n}\nfunction existsInDom(element) {\n    return element && element.ownerDocument && element.ownerDocument.contains(element);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgetresize\n */\nimport Resizer from './widgetresize/resizer';\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { MouseObserver } from '@ckeditor/ckeditor5-engine';\nimport { DomEmitterMixin, global } from '@ckeditor/ckeditor5-utils';\nimport { throttle } from 'lodash-es';\nimport '../theme/widgetresize.css';\n/**\n * The widget resize feature plugin.\n *\n * Use the {@link module:widget/widgetresize~WidgetResize#attachTo} method to create a resizer for the specified widget.\n */\nexport default class WidgetResize extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * A map of resizers created using this plugin instance.\n         */\n        this._resizers = new Map();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'WidgetResize';\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editing = this.editor.editing;\n        const domDocument = global.window.document;\n        this.set('selectedResizer', null);\n        this.set('_activeResizer', null);\n        editing.view.addObserver(MouseObserver);\n        this._observer = new (DomEmitterMixin())();\n        this.listenTo(editing.view.document, 'mousedown', this._mouseDownListener.bind(this), { priority: 'high' });\n        this._observer.listenTo(domDocument, 'mousemove', this._mouseMoveListener.bind(this));\n        this._observer.listenTo(domDocument, 'mouseup', this._mouseUpListener.bind(this));\n        this._redrawSelectedResizerThrottled = throttle(() => this.redrawSelectedResizer(), 200);\n        // Redrawing on any change of the UI of the editor (including content changes).\n        this.editor.ui.on('update', this._redrawSelectedResizerThrottled);\n        // Remove view widget-resizer mappings for widgets that have been removed from the document.\n        // https://github.com/ckeditor/ckeditor5/issues/10156\n        // https://github.com/ckeditor/ckeditor5/issues/10266\n        this.editor.model.document.on('change', () => {\n            for (const [viewElement, resizer] of this._resizers) {\n                if (!viewElement.isAttached()) {\n                    this._resizers.delete(viewElement);\n                    resizer.destroy();\n                }\n            }\n        }, { priority: 'lowest' });\n        // Resizers need to be redrawn upon window resize, because new window might shrink resize host.\n        this._observer.listenTo(global.window, 'resize', this._redrawSelectedResizerThrottled);\n        const viewSelection = this.editor.editing.view.document.selection;\n        viewSelection.on('change', () => {\n            const selectedElement = viewSelection.getSelectedElement();\n            const resizer = this.getResizerByViewElement(selectedElement) || null;\n            if (resizer) {\n                this.select(resizer);\n            }\n            else {\n                this.deselect();\n            }\n        });\n    }\n    /**\n     * Redraws the selected resizer if there is any selected resizer and if it is visible.\n     */\n    redrawSelectedResizer() {\n        if (this.selectedResizer && this.selectedResizer.isVisible) {\n            this.selectedResizer.redraw();\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        this._observer.stopListening();\n        for (const resizer of this._resizers.values()) {\n            resizer.destroy();\n        }\n        this._redrawSelectedResizerThrottled.cancel();\n    }\n    /**\n     * Marks resizer as selected.\n     */\n    select(resizer) {\n        this.deselect();\n        this.selectedResizer = resizer;\n        this.selectedResizer.isSelected = true;\n    }\n    /**\n     * Deselects currently set resizer.\n     */\n    deselect() {\n        if (this.selectedResizer) {\n            this.selectedResizer.isSelected = false;\n        }\n        this.selectedResizer = null;\n    }\n    /**\n     * @param options Resizer options.\n     */\n    attachTo(options) {\n        const resizer = new Resizer(options);\n        const plugins = this.editor.plugins;\n        resizer.attach();\n        if (plugins.has('WidgetToolbarRepository')) {\n            // Hiding widget toolbar to improve the performance\n            // (https://github.com/ckeditor/ckeditor5-widget/pull/112#issuecomment-564528765).\n            const widgetToolbarRepository = plugins.get('WidgetToolbarRepository');\n            resizer.on('begin', () => {\n                widgetToolbarRepository.forceDisabled('resize');\n            }, { priority: 'lowest' });\n            resizer.on('cancel', () => {\n                widgetToolbarRepository.clearForceDisabled('resize');\n            }, { priority: 'highest' });\n            resizer.on('commit', () => {\n                widgetToolbarRepository.clearForceDisabled('resize');\n            }, { priority: 'highest' });\n        }\n        this._resizers.set(options.viewElement, resizer);\n        const viewSelection = this.editor.editing.view.document.selection;\n        const selectedElement = viewSelection.getSelectedElement();\n        // If the element the resizer is created for is currently focused, it should become visible.\n        if (this.getResizerByViewElement(selectedElement) == resizer) {\n            this.select(resizer);\n        }\n        return resizer;\n    }\n    /**\n     * Returns a resizer created for a given view element (widget element).\n     *\n     * @param viewElement View element associated with the resizer.\n     */\n    getResizerByViewElement(viewElement) {\n        return this._resizers.get(viewElement);\n    }\n    /**\n     * Returns a resizer that contains a given resize handle.\n     */\n    _getResizerByHandle(domResizeHandle) {\n        for (const resizer of this._resizers.values()) {\n            if (resizer.containsHandle(domResizeHandle)) {\n                return resizer;\n            }\n        }\n    }\n    /**\n     * @param domEventData Native DOM event.\n     */\n    _mouseDownListener(event, domEventData) {\n        const resizeHandle = domEventData.domTarget;\n        if (!Resizer.isResizeHandle(resizeHandle)) {\n            return;\n        }\n        this._activeResizer = this._getResizerByHandle(resizeHandle) || null;\n        if (this._activeResizer) {\n            this._activeResizer.begin(resizeHandle);\n            // Do not call other events when resizing. See: #6755.\n            event.stop();\n            domEventData.preventDefault();\n        }\n    }\n    /**\n     * @param domEventData Native DOM event.\n     */\n    _mouseMoveListener(event, domEventData) {\n        if (this._activeResizer) {\n            this._activeResizer.updateSize(domEventData);\n        }\n    }\n    _mouseUpListener() {\n        if (this._activeResizer) {\n            this._activeResizer.commit();\n            this._activeResizer = null;\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["element", "writer", "findOptimalInsertionRange", "selectedViewElement", "element", "modelElement", "relatedElement"]
}
