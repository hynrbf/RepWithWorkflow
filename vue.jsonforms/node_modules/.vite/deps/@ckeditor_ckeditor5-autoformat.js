import "./chunk-DEIZSOIF.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-W3CRWNYM.js";
import {
  Delete
} from "./chunk-4MFML76R.js";
import "./chunk-6LVMAMLV.js";
import {
  LiveRange,
  Plugin,
  first
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-autoformat/src/blockautoformatediting.js
function blockAutoformatEditing(editor, plugin, pattern, callbackOrCommand) {
  let callback;
  let command = null;
  if (typeof callbackOrCommand == "function") {
    callback = callbackOrCommand;
  } else {
    command = editor.commands.get(callbackOrCommand);
    callback = () => {
      editor.execute(callbackOrCommand);
    };
  }
  editor.model.document.on("change:data", (evt, batch) => {
    if (command && !command.isEnabled || !plugin.isEnabled) {
      return;
    }
    const range = first(editor.model.document.selection.getRanges());
    if (!range.isCollapsed) {
      return;
    }
    if (batch.isUndo || !batch.isLocal) {
      return;
    }
    const changes = Array.from(editor.model.document.differ.getChanges());
    const entry = changes[0];
    if (changes.length != 1 || entry.type !== "insert" || entry.name != "$text" || entry.length != 1) {
      return;
    }
    const blockToFormat = entry.position.parent;
    if (blockToFormat.is("element", "codeBlock")) {
      return;
    }
    if (blockToFormat.is("element", "listItem") && typeof callbackOrCommand !== "function" && !["numberedList", "bulletedList", "todoList"].includes(callbackOrCommand)) {
      return;
    }
    if (command && command.value === true) {
      return;
    }
    const firstNode = blockToFormat.getChild(0);
    const firstNodeRange = editor.model.createRangeOn(firstNode);
    if (!firstNodeRange.containsRange(range) && !range.end.isEqual(firstNodeRange.end)) {
      return;
    }
    const match = pattern.exec(firstNode.data.substr(0, range.end.offset));
    if (!match) {
      return;
    }
    editor.model.enqueueChange((writer) => {
      const start = writer.createPositionAt(blockToFormat, 0);
      const end = writer.createPositionAt(blockToFormat, match[0].length);
      const range2 = new LiveRange(start, end);
      const wasChanged = callback({ match });
      if (wasChanged !== false) {
        writer.remove(range2);
        const selectionRange = editor.model.document.selection.getFirstRange();
        const blockRange = writer.createRangeIn(blockToFormat);
        if (blockToFormat.isEmpty && !blockRange.isEqual(selectionRange) && !blockRange.containsRange(selectionRange, true)) {
          writer.remove(blockToFormat);
        }
      }
      range2.detach();
      editor.model.enqueueChange(() => {
        const deletePlugin = editor.plugins.get("Delete");
        deletePlugin.requestUndoOnBackspace();
      });
    });
  });
}

// node_modules/@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js
function inlineAutoformatEditing(editor, plugin, testRegexpOrCallback, formatCallback) {
  let regExp;
  let testCallback;
  if (testRegexpOrCallback instanceof RegExp) {
    regExp = testRegexpOrCallback;
  } else {
    testCallback = testRegexpOrCallback;
  }
  testCallback = testCallback || ((text) => {
    let result;
    const remove = [];
    const format = [];
    while ((result = regExp.exec(text)) !== null) {
      if (result && result.length < 4) {
        break;
      }
      let { index, "1": leftDel, "2": content, "3": rightDel } = result;
      const found = leftDel + content + rightDel;
      index += result[0].length - found.length;
      const delStart = [
        index,
        index + leftDel.length
      ];
      const delEnd = [
        index + leftDel.length + content.length,
        index + leftDel.length + content.length + rightDel.length
      ];
      remove.push(delStart);
      remove.push(delEnd);
      format.push([index + leftDel.length, index + leftDel.length + content.length]);
    }
    return {
      remove,
      format
    };
  });
  editor.model.document.on("change:data", (evt, batch) => {
    if (batch.isUndo || !batch.isLocal || !plugin.isEnabled) {
      return;
    }
    const model = editor.model;
    const selection = model.document.selection;
    if (!selection.isCollapsed) {
      return;
    }
    const changes = Array.from(model.document.differ.getChanges());
    const entry = changes[0];
    if (changes.length != 1 || entry.type !== "insert" || entry.name != "$text" || entry.length != 1) {
      return;
    }
    const focus = selection.focus;
    const block = focus.parent;
    const { text, range } = getTextAfterCode(model.createRange(model.createPositionAt(block, 0), focus), model);
    const testOutput = testCallback(text);
    const rangesToFormat = testOutputToRanges(range.start, testOutput.format, model);
    const rangesToRemove = testOutputToRanges(range.start, testOutput.remove, model);
    if (!(rangesToFormat.length && rangesToRemove.length)) {
      return;
    }
    model.enqueueChange((writer) => {
      const hasChanged = formatCallback(writer, rangesToFormat);
      if (hasChanged === false) {
        return;
      }
      for (const range2 of rangesToRemove.reverse()) {
        writer.remove(range2);
      }
      model.enqueueChange(() => {
        const deletePlugin = editor.plugins.get("Delete");
        deletePlugin.requestUndoOnBackspace();
      });
    });
  });
}
function testOutputToRanges(start, arrays, model) {
  return arrays.filter((array) => array[0] !== void 0 && array[1] !== void 0).map((array) => {
    return model.createRange(start.getShiftedBy(array[0]), start.getShiftedBy(array[1]));
  });
}
function getTextAfterCode(range, model) {
  let start = range.start;
  const text = Array.from(range.getItems()).reduce((rangeText, node) => {
    if (!(node.is("$text") || node.is("$textProxy")) || node.getAttribute("code")) {
      start = model.createPositionAfter(node);
      return "";
    }
    return rangeText + node.data;
  }, "");
  return { text, range: model.createRange(start, range.end) };
}

// node_modules/@ckeditor/ckeditor5-autoformat/src/autoformat.js
var Autoformat = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Delete];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Autoformat";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    this._addListAutoformats();
    this._addBasicStylesAutoformats();
    this._addHeadingAutoformats();
    this._addBlockQuoteAutoformats();
    this._addCodeBlockAutoformats();
    this._addHorizontalLineAutoformats();
  }
  /**
   * Adds autoformatting related to the {@link module:list/list~List}.
   *
   * When typed:
   * - `* ` or `- ` &ndash; A paragraph will be changed into a bulleted list.
   * - `1. ` or `1) ` &ndash; A paragraph will be changed into a numbered list ("1" can be any digit or a list of digits).
   * - `[] ` or `[ ] ` &ndash; A paragraph will be changed into a to-do list.
   * - `[x] ` or `[ x ] ` &ndash; A paragraph will be changed into a checked to-do list.
   */
  _addListAutoformats() {
    const commands = this.editor.commands;
    if (commands.get("bulletedList")) {
      blockAutoformatEditing(this.editor, this, /^[*-]\s$/, "bulletedList");
    }
    if (commands.get("numberedList")) {
      blockAutoformatEditing(this.editor, this, /^1[.|)]\s$/, "numberedList");
    }
    if (commands.get("todoList")) {
      blockAutoformatEditing(this.editor, this, /^\[\s?\]\s$/, "todoList");
    }
    if (commands.get("checkTodoList")) {
      blockAutoformatEditing(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
        this.editor.execute("todoList");
        this.editor.execute("checkTodoList");
      });
    }
  }
  /**
   * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},
   * {@link module:basic-styles/italic~Italic}, {@link module:basic-styles/code~Code}
   * and {@link module:basic-styles/strikethrough~Strikethrough}
   *
   * When typed:
   * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,
   * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,
   * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,
   * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,
   * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code,
   * - `~~foobar~~` &ndash; `~~` characters are removed and `foobar` is set to strikethrough.
   */
  _addBasicStylesAutoformats() {
    const commands = this.editor.commands;
    if (commands.get("bold")) {
      const boldCallback = getCallbackFunctionForInlineAutoformat(this.editor, "bold");
      inlineAutoformatEditing(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, boldCallback);
      inlineAutoformatEditing(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, boldCallback);
    }
    if (commands.get("italic")) {
      const italicCallback = getCallbackFunctionForInlineAutoformat(this.editor, "italic");
      inlineAutoformatEditing(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, italicCallback);
      inlineAutoformatEditing(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, italicCallback);
    }
    if (commands.get("code")) {
      const codeCallback = getCallbackFunctionForInlineAutoformat(this.editor, "code");
      inlineAutoformatEditing(this.editor, this, /(`)([^`]+)(`)$/g, codeCallback);
    }
    if (commands.get("strikethrough")) {
      const strikethroughCallback = getCallbackFunctionForInlineAutoformat(this.editor, "strikethrough");
      inlineAutoformatEditing(this.editor, this, /(~~)([^~]+)(~~)$/g, strikethroughCallback);
    }
  }
  /**
   * Adds autoformatting related to {@link module:heading/heading~Heading}.
   *
   * It is using a number at the end of the command name to associate it with the proper trigger:
   *
   * * `heading` with a `heading1` value will be executed when typing `#`,
   * * `heading` with a `heading2` value will be executed when typing `##`,
   * * ... up to `heading6` for `######`.
   */
  _addHeadingAutoformats() {
    const command = this.editor.commands.get("heading");
    if (command) {
      command.modelElements.filter((name) => name.match(/^heading[1-6]$/)).forEach((modelName) => {
        const level = modelName[7];
        const pattern = new RegExp(`^(#{${level}})\\s$`);
        blockAutoformatEditing(this.editor, this, pattern, () => {
          if (!command.isEnabled || command.value === modelName) {
            return false;
          }
          this.editor.execute("heading", { value: modelName });
        });
      });
    }
  }
  /**
   * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.
   *
   * When typed:
   * * `> ` &ndash; A paragraph will be changed to a block quote.
   */
  _addBlockQuoteAutoformats() {
    if (this.editor.commands.get("blockQuote")) {
      blockAutoformatEditing(this.editor, this, /^>\s$/, "blockQuote");
    }
  }
  /**
   * Adds autoformatting related to {@link module:code-block/codeblock~CodeBlock}.
   *
   * When typed:
   * - `` ``` `` &ndash; A paragraph will be changed to a code block.
   */
  _addCodeBlockAutoformats() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    if (editor.commands.get("codeBlock")) {
      blockAutoformatEditing(editor, this, /^```$/, () => {
        if (selection.getFirstPosition().parent.is("element", "listItem")) {
          return false;
        }
        this.editor.execute("codeBlock", {
          usePreviousLanguageChoice: true
        });
      });
    }
  }
  /**
   * Adds autoformatting related to {@link module:horizontal-line/horizontalline~HorizontalLine}.
   *
   * When typed:
   * - `` --- `` &ndash; Will be replaced with a horizontal line.
   */
  _addHorizontalLineAutoformats() {
    if (this.editor.commands.get("horizontalLine")) {
      blockAutoformatEditing(this.editor, this, /^---$/, "horizontalLine");
    }
  }
};
function getCallbackFunctionForInlineAutoformat(editor, attributeKey) {
  return (writer, rangesToFormat) => {
    const command = editor.commands.get(attributeKey);
    if (!command.isEnabled) {
      return false;
    }
    const validRanges = editor.model.schema.getValidRanges(rangesToFormat, attributeKey);
    for (const range of validRanges) {
      writer.setAttribute(attributeKey, true, range);
    }
    writer.removeSelectionAttribute(attributeKey);
  };
}
export {
  Autoformat
};
/*! Bundled license information:

@ckeditor/ckeditor5-autoformat/src/blockautoformatediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-autoformat/src/autoformat.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-autoformat/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-autoformat/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-autoformat.js.map
