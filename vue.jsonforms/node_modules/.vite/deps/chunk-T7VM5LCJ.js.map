{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-watchdog/src/watchdog.js", "../../@ckeditor/ckeditor5-watchdog/src/utils/getsubnodes.js", "../../@ckeditor/ckeditor5-watchdog/src/utils/areconnectedthroughproperties.js", "../../@ckeditor/ckeditor5-watchdog/src/editorwatchdog.js", "../../@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * An abstract watchdog class that handles most of the error handling process and the state of the underlying component.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and how to use it.\n *\n * @internal\n */\nexport default class Watchdog {\n    /**\n     * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.\n     */\n    constructor(config) {\n        /**\n         * An array of crashes saved as an object with the following properties:\n         *\n         * * `message`: `String`,\n         * * `stack`: `String`,\n         * * `date`: `Number`,\n         * * `filename`: `String | undefined`,\n         * * `lineno`: `Number | undefined`,\n         * * `colno`: `Number | undefined`,\n         */\n        this.crashes = [];\n        /**\n         * Specifies the state of the item watched by the watchdog. The state can be one of the following values:\n         *\n         * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.\n         * * `ready` &ndash; A state when the user can interact with the item.\n         * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`\n         * depending on how many and how frequent errors have been caught recently.\n         * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,\n         * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.\n         */\n        this.state = 'initializing';\n        /**\n         * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular\n         * approaches like `sinon.useFakeTimers()` do not work well with error handling.\n         */\n        this._now = Date.now;\n        this.crashes = [];\n        this._crashNumberLimit = typeof config.crashNumberLimit === 'number' ? config.crashNumberLimit : 3;\n        this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === 'number' ? config.minimumNonErrorTimePeriod : 5000;\n        this._boundErrorHandler = evt => {\n            // `evt.error` is exposed by EventError while `evt.reason` is available in PromiseRejectionEvent.\n            const error = 'error' in evt ? evt.error : evt.reason;\n            // Note that `evt.reason` might be everything that is in the promise rejection.\n            // Similarly everything that is thrown lands in `evt.error`.\n            if (error instanceof Error) {\n                this._handleError(error, evt);\n            }\n        };\n        this._listeners = {};\n        if (!this._restart) {\n            throw new Error('The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' +\n                'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.');\n        }\n    }\n    /**\n     * Destroys the watchdog and releases the resources.\n     */\n    destroy() {\n        this._stopErrorHandling();\n        this._listeners = {};\n    }\n    /**\n     * Starts listening to a specific event name by registering a callback that will be executed\n     * whenever an event with a given name fires.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     *\n     * @param eventName The event name.\n     * @param callback A callback which will be added to event listeners.\n     */\n    on(eventName, callback) {\n        if (!this._listeners[eventName]) {\n            this._listeners[eventName] = [];\n        }\n        this._listeners[eventName].push(callback);\n    }\n    /**\n     * Stops listening to the specified event name by removing the callback from event listeners.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     *\n     * @param eventName The event name.\n     * @param callback A callback which will be removed from event listeners.\n     */\n    off(eventName, callback) {\n        this._listeners[eventName] = this._listeners[eventName]\n            .filter(cb => cb !== callback);\n    }\n    /**\n     * Fires an event with a given event name and arguments.\n     *\n     * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.\n     */\n    _fire(eventName, ...args) {\n        const callbacks = this._listeners[eventName] || [];\n        for (const callback of callbacks) {\n            callback.apply(this, [null, ...args]);\n        }\n    }\n    /**\n     * Starts error handling by attaching global error handlers.\n     */\n    _startErrorHandling() {\n        window.addEventListener('error', this._boundErrorHandler);\n        window.addEventListener('unhandledrejection', this._boundErrorHandler);\n    }\n    /**\n     * Stops error handling by detaching global error handlers.\n     */\n    _stopErrorHandling() {\n        window.removeEventListener('error', this._boundErrorHandler);\n        window.removeEventListener('unhandledrejection', this._boundErrorHandler);\n    }\n    /**\n     * Checks if an error comes from the watched item and restarts it.\n     * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.\n     *\n     * @fires error\n     * @param error Error.\n     * @param evt An error event.\n     */\n    _handleError(error, evt) {\n        // @if CK_DEBUG // const err = error as CKEditorError;\n        // @if CK_DEBUG // if ( err.is && err.is( 'CKEditorError' ) && err.context === undefined ) {\n        // @if CK_DEBUG // console.warn( 'The error is missing its context and Watchdog cannot restart the proper item.' );\n        // @if CK_DEBUG // }\n        if (this._shouldReactToError(error)) {\n            this.crashes.push({\n                message: error.message,\n                stack: error.stack,\n                // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events\n                filename: evt instanceof ErrorEvent ? evt.filename : undefined,\n                lineno: evt instanceof ErrorEvent ? evt.lineno : undefined,\n                colno: evt instanceof ErrorEvent ? evt.colno : undefined,\n                date: this._now()\n            });\n            const causesRestart = this._shouldRestart();\n            this.state = 'crashed';\n            this._fire('stateChange');\n            this._fire('error', { error, causesRestart });\n            if (causesRestart) {\n                this._restart();\n            }\n            else {\n                this.state = 'crashedPermanently';\n                this._fire('stateChange');\n            }\n        }\n    }\n    /**\n     * Checks whether an error should be handled by the watchdog.\n     *\n     * @param error An error that was caught by the error handling process.\n     */\n    _shouldReactToError(error) {\n        return (error.is &&\n            error.is('CKEditorError') &&\n            error.context !== undefined &&\n            // In some cases the watched item should not be restarted - e.g. during the item initialization.\n            // That's why the `null` was introduced as a correct error context which does cause restarting.\n            error.context !== null &&\n            // Do not react to errors if the watchdog is in states other than `ready`.\n            this.state === 'ready' &&\n            this._isErrorComingFromThisItem(error));\n    }\n    /**\n     * Checks if the watchdog should restart the underlying item.\n     */\n    _shouldRestart() {\n        if (this.crashes.length <= this._crashNumberLimit) {\n            return true;\n        }\n        const lastErrorTime = this.crashes[this.crashes.length - 1].date;\n        const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;\n        const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;\n        return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module watchdog/utils/getsubnodes\n */\n/* globals EventTarget, Event */\nexport default function getSubNodes(head, excludedProperties = new Set()) {\n    const nodes = [head];\n    // @if CK_DEBUG_WATCHDOG // const prevNodeMap = new Map();\n    // Nodes are stored to prevent infinite looping.\n    const subNodes = new Set();\n    let nodeIndex = 0;\n    while (nodes.length > nodeIndex) {\n        // Incrementing the iterator is much faster than changing size of the array with Array.prototype.shift().\n        const node = nodes[nodeIndex++];\n        if (subNodes.has(node) || !shouldNodeBeIncluded(node) || excludedProperties.has(node)) {\n            continue;\n        }\n        subNodes.add(node);\n        // Handle arrays, maps, sets, custom collections that implements `[ Symbol.iterator ]()`, etc.\n        if (Symbol.iterator in node) {\n            // The custom editor iterators might cause some problems if the editor is crashed.\n            try {\n                for (const n of node) {\n                    nodes.push(n);\n                    // @if CK_DEBUG_WATCHDOG // if ( !prevNodeMap.has( n ) ) {\n                    // @if CK_DEBUG_WATCHDOG // \tprevNodeMap.set( n, node );\n                    // @if CK_DEBUG_WATCHDOG // }\n                }\n            }\n            catch (err) {\n                // Do not log errors for broken structures\n                // since we are in the error handling process already.\n                // eslint-disable-line no-empty\n            }\n        }\n        else {\n            for (const key in node) {\n                // We share a reference via the protobuf library within the editors,\n                // hence the shared value should be skipped. Although, it's not a perfect\n                // solution since new places like that might occur in the future.\n                if (key === 'defaultValue') {\n                    continue;\n                }\n                nodes.push(node[key]);\n                // @if CK_DEBUG_WATCHDOG // if ( !prevNodeMap.has( node[ key ] ) ) {\n                // @if CK_DEBUG_WATCHDOG // \tprevNodeMap.set( node[ key ], node );\n                // @if CK_DEBUG_WATCHDOG // }\n            }\n        }\n    }\n    // @if CK_DEBUG_WATCHDOG // return { subNodes, prevNodeMap } as any;\n    return subNodes;\n}\nfunction shouldNodeBeIncluded(node) {\n    const type = Object.prototype.toString.call(node);\n    const typeOfNode = typeof node;\n    return !(typeOfNode === 'number' ||\n        typeOfNode === 'boolean' ||\n        typeOfNode === 'string' ||\n        typeOfNode === 'symbol' ||\n        typeOfNode === 'function' ||\n        type === '[object Date]' ||\n        type === '[object RegExp]' ||\n        type === '[object Module]' ||\n        node === undefined ||\n        node === null ||\n        // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,\n        // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround\n        // until a better solution is found.\n        // More in https://github.com/ckeditor/ckeditor5/issues/12292.\n        node._watchdogExcluded ||\n        // Skip native DOM objects, e.g. Window, nodes, events, etc.\n        node instanceof EventTarget ||\n        node instanceof Event);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module watchdog/utils/areconnectedthroughproperties\n */\n/* globals console */\nimport getSubNodes from './getsubnodes';\n/**\n * Traverses both structures to find out whether there is a reference that is shared between both structures.\n */\nexport default function areConnectedThroughProperties(target1, target2, excludedNodes = new Set()) {\n    if (target1 === target2 && isObject(target1)) {\n        return true;\n    }\n    // @if CK_DEBUG_WATCHDOG // return checkConnectionBetweenProps( target1, target2, excludedNodes );\n    const subNodes1 = getSubNodes(target1, excludedNodes);\n    const subNodes2 = getSubNodes(target2, excludedNodes);\n    for (const node of subNodes1) {\n        if (subNodes2.has(node)) {\n            return true;\n        }\n    }\n    return false;\n}\n/* istanbul ignore next -- @preserve */\n// eslint-disable-next-line\nfunction checkConnectionBetweenProps(target1, target2, excludedNodes) {\n    const { subNodes: subNodes1, prevNodeMap: prevNodeMap1 } = getSubNodes(target1, excludedNodes.subNodes);\n    const { subNodes: subNodes2, prevNodeMap: prevNodeMap2 } = getSubNodes(target2, excludedNodes.subNodes);\n    for (const sharedNode of subNodes1) {\n        if (subNodes2.has(sharedNode)) {\n            const connection = [];\n            connection.push(sharedNode);\n            let node = prevNodeMap1.get(sharedNode);\n            while (node && node !== target1) {\n                connection.push(node);\n                node = prevNodeMap1.get(node);\n            }\n            node = prevNodeMap2.get(sharedNode);\n            while (node && node !== target2) {\n                connection.unshift(node);\n                node = prevNodeMap2.get(node);\n            }\n            console.log('--------');\n            console.log({ target1 });\n            console.log({ sharedNode });\n            console.log({ target2 });\n            console.log({ connection });\n            return true;\n        }\n    }\n    return false;\n}\nfunction isObject(structure) {\n    return typeof structure === 'object' && structure !== null;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties';\nimport Watchdog from './watchdog';\nimport { throttle, cloneDeepWith, isElement } from 'lodash-es';\n/**\n * A watchdog for CKEditor 5 editors.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class EditorWatchdog extends Watchdog {\n    /**\n     * @param Editor The editor class.\n     * @param watchdogConfig The watchdog plugin configuration.\n     */\n    constructor(Editor, watchdogConfig = {}) {\n        super(watchdogConfig);\n        /**\n         * The current editor instance.\n         */\n        this._editor = null;\n        /**\n         * Specifies whether the editor was initialized using document data (`true`) or HTML elements (`false`).\n         */\n        this._initUsingData = true;\n        /**\n         * The latest record of the editor editable elements. Used to restart the editor.\n         */\n        this._editables = {};\n        // this._editorClass = Editor;\n        this._throttledSave = throttle(this._save.bind(this), typeof watchdogConfig.saveInterval === 'number' ? watchdogConfig.saveInterval : 5000);\n        // Set default creator and destructor functions:\n        if (Editor) {\n            this._creator = ((elementOrData, config) => Editor.create(elementOrData, config));\n        }\n        this._destructor = editor => editor.destroy();\n    }\n    /**\n     * The current editor instance.\n     */\n    get editor() {\n        return this._editor;\n    }\n    /**\n     * @internal\n     */\n    get _item() {\n        return this._editor;\n    }\n    /**\n     * Sets the function that is responsible for the editor creation.\n     * It expects a function that should return a promise.\n     *\n     * ```ts\n     * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );\n     * ```\n     */\n    setCreator(creator) {\n        this._creator = creator;\n    }\n    /**\n     * Sets the function that is responsible for the editor destruction.\n     * Overrides the default destruction function, which destroys only the editor instance.\n     * It expects a function that should return a promise or `undefined`.\n     *\n     * ```ts\n     * watchdog.setDestructor( editor => {\n     * \t// Do something before the editor is destroyed.\n     *\n     * \treturn editor\n     * \t\t.destroy()\n     * \t\t.then( () => {\n     * \t\t\t// Do something after the editor is destroyed.\n     * \t\t} );\n     * } );\n     * ```\n     */\n    setDestructor(destructor) {\n        this._destructor = destructor;\n    }\n    /**\n     * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes\n     * the state to `initializing`.\n     *\n     * @fires restart\n     */\n    _restart() {\n        return Promise.resolve()\n            .then(() => {\n            this.state = 'initializing';\n            this._fire('stateChange');\n            return this._destroy();\n        })\n            .catch(err => {\n            console.error('An error happened during the editor destroying.', err);\n        })\n            .then(() => {\n            // Pre-process some data from the original editor config.\n            // Our goal here is to make sure that the restarted editor will be reinitialized with correct set of roots.\n            // We are not interested in any data set in config or in `.create()` first parameter. It will be replaced anyway.\n            // But we need to set them correctly to make sure that proper roots are created.\n            //\n            // Since a different set of roots will be created, `lazyRoots` and `rootsAttributes` properties must be managed too.\n            // Keys are root names, values are ''. Used when the editor was initialized by setting the first parameter to document data.\n            const existingRoots = {};\n            // Keeps lazy roots. They may be different when compared to initial config if some of the roots were loaded.\n            const lazyRoots = [];\n            // Roots attributes from the old config. Will be referred when setting new attributes.\n            const oldRootsAttributes = this._config.rootsAttributes || {};\n            // New attributes to be set. Is filled only for roots that still exist in the document.\n            const rootsAttributes = {};\n            // Traverse through the roots saved when the editor crashed and set up the discussed values.\n            for (const [rootName, rootData] of Object.entries(this._data.roots)) {\n                if (rootData.isLoaded) {\n                    existingRoots[rootName] = '';\n                    rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};\n                }\n                else {\n                    lazyRoots.push(rootName);\n                }\n            }\n            const updatedConfig = {\n                ...this._config,\n                extraPlugins: this._config.extraPlugins || [],\n                lazyRoots,\n                rootsAttributes,\n                _watchdogInitialData: this._data\n            };\n            // Delete `initialData` as it is not needed. Data will be set by the watchdog based on `_watchdogInitialData`.\n            // First parameter of the editor `.create()` will be used to set up initial roots.\n            delete updatedConfig.initialData;\n            updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);\n            if (this._initUsingData) {\n                return this.create(existingRoots, updatedConfig, updatedConfig.context);\n            }\n            else {\n                // Set correct editables to make sure that proper roots are created and linked with DOM elements.\n                // No need to set initial data, as it would be discarded anyway.\n                //\n                // If one element was initially set in `elementOrData`, then use that original element to restart the editor.\n                // This is for compatibility purposes with single-root editor types.\n                if (isElement(this._elementOrData)) {\n                    return this.create(this._elementOrData, updatedConfig, updatedConfig.context);\n                }\n                else {\n                    return this.create(this._editables, updatedConfig, updatedConfig.context);\n                }\n            }\n        })\n            .then(() => {\n            this._fire('restart');\n        });\n    }\n    /**\n     * Creates the editor instance and keeps it running, using the defined creator and destructor.\n     *\n     * @param elementOrData The editor source element or the editor data.\n     * @param config The editor configuration.\n     * @param context A context for the editor.\n     */\n    create(elementOrData = this._elementOrData, config = this._config, context) {\n        return Promise.resolve()\n            .then(() => {\n            super._startErrorHandling();\n            this._elementOrData = elementOrData;\n            // Use document data in the first parameter of the editor `.create()` call only if it was used like this originally.\n            // Use document data if a string or object with strings was passed.\n            this._initUsingData = typeof elementOrData == 'string' ||\n                (Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == 'string');\n            // Clone configuration because it might be shared within multiple watchdog instances. Otherwise,\n            // when an error occurs in one of these editors, the watchdog will restart all of them.\n            this._config = this._cloneEditorConfiguration(config) || {};\n            this._config.context = context;\n            return this._creator(elementOrData, this._config);\n        })\n            .then(editor => {\n            this._editor = editor;\n            editor.model.document.on('change:data', this._throttledSave);\n            this._lastDocumentVersion = editor.model.document.version;\n            this._data = this._getData();\n            if (!this._initUsingData) {\n                this._editables = this._getEditables();\n            }\n            this.state = 'ready';\n            this._fire('stateChange');\n        });\n    }\n    /**\n     * Destroys the watchdog and the current editor instance. It fires the callback\n     * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.\n     * It also sets the state to `destroyed`.\n     */\n    destroy() {\n        return Promise.resolve()\n            .then(() => {\n            this.state = 'destroyed';\n            this._fire('stateChange');\n            super.destroy();\n            return this._destroy();\n        });\n    }\n    _destroy() {\n        return Promise.resolve()\n            .then(() => {\n            this._stopErrorHandling();\n            this._throttledSave.cancel();\n            const editor = this._editor;\n            this._editor = null;\n            // Remove the `change:data` listener before destroying the editor.\n            // Incorrectly written plugins may trigger firing `change:data` events during the editor destruction phase\n            // causing the watchdog to call `editor.getData()` when some parts of editor are already destroyed.\n            editor.model.document.off('change:data', this._throttledSave);\n            return this._destructor(editor);\n        });\n    }\n    /**\n     * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at\n     * the moment of the crash.\n     */\n    _save() {\n        const version = this._editor.model.document.version;\n        try {\n            this._data = this._getData();\n            if (!this._initUsingData) {\n                this._editables = this._getEditables();\n            }\n            this._lastDocumentVersion = version;\n        }\n        catch (err) {\n            console.error(err, 'An error happened during restoring editor data. ' +\n                'Editor will be restored from the previously saved data.');\n        }\n    }\n    /**\n     * @internal\n     */\n    _setExcludedProperties(props) {\n        this._excludedProps = props;\n    }\n    /**\n     * Gets all data that is required to reinitialize editor instance.\n     */\n    _getData() {\n        const editor = this._editor;\n        const roots = editor.model.document.roots.filter(root => root.isAttached() && root.rootName != '$graveyard');\n        const { plugins } = editor;\n        // `as any` to avoid linking from external private repo.\n        const commentsRepository = plugins.has('CommentsRepository') && plugins.get('CommentsRepository');\n        const trackChanges = plugins.has('TrackChanges') && plugins.get('TrackChanges');\n        const data = {\n            roots: {},\n            markers: {},\n            commentThreads: JSON.stringify([]),\n            suggestions: JSON.stringify([])\n        };\n        roots.forEach(root => {\n            data.roots[root.rootName] = {\n                content: JSON.stringify(Array.from(root.getChildren())),\n                attributes: JSON.stringify(Array.from(root.getAttributes())),\n                isLoaded: root._isLoaded\n            };\n        });\n        for (const marker of editor.model.markers) {\n            if (!marker._affectsData) {\n                continue;\n            }\n            data.markers[marker.name] = {\n                rangeJSON: marker.getRange().toJSON(),\n                usingOperation: marker._managedUsingOperations,\n                affectsData: marker._affectsData\n            };\n        }\n        if (commentsRepository) {\n            data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({ toJSON: true, skipNotAttached: true }));\n        }\n        if (trackChanges) {\n            data.suggestions = JSON.stringify(trackChanges.getSuggestions({ toJSON: true, skipNotAttached: true }));\n        }\n        return data;\n    }\n    /**\n     * For each attached model root, returns its HTML editable element (if available).\n     */\n    _getEditables() {\n        const editables = {};\n        for (const rootName of this.editor.model.document.getRootNames()) {\n            const editable = this.editor.ui.getEditableElement(rootName);\n            if (editable) {\n                editables[rootName] = editable;\n            }\n        }\n        return editables;\n    }\n    /**\n     * Traverses the error context and the current editor to find out whether these structures are connected\n     * to each other via properties.\n     *\n     * @internal\n     */\n    _isErrorComingFromThisItem(error) {\n        return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);\n    }\n    /**\n     * Clones the editor configuration.\n     */\n    _cloneEditorConfiguration(config) {\n        return cloneDeepWith(config, (value, key) => {\n            // Leave DOM references.\n            if (isElement(value)) {\n                return value;\n            }\n            if (key === 'context') {\n                return value;\n            }\n        });\n    }\n}\n/**\n * Internal plugin that is used to stop the default editor initialization and restoring the editor state\n * based on the `editor.config._watchdogInitialData` data.\n */\nclass EditorWatchdogInitPlugin {\n    constructor(editor) {\n        this.editor = editor;\n        this._data = editor.config.get('_watchdogInitialData');\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        // Stops the default editor initialization and use the saved data to restore the editor state.\n        // Some of data could not be initialize as a config properties. It is important to keep the data\n        // in the same form as it was before the restarting.\n        this.editor.data.on('init', evt => {\n            evt.stop();\n            this.editor.model.enqueueChange({ isUndoable: false }, writer => {\n                this._restoreCollaborationData();\n                this._restoreEditorData(writer);\n            });\n            this.editor.data.fire('ready');\n            // Keep priority `'high' - 1` to be sure that RTC initialization will be first.\n        }, { priority: 1000 - 1 });\n    }\n    /**\n     * Creates a model node (element or text) based on provided JSON.\n     */\n    _createNode(writer, jsonNode) {\n        if ('name' in jsonNode) {\n            // If child has name property, it is an Element.\n            const element = writer.createElement(jsonNode.name, jsonNode.attributes);\n            if (jsonNode.children) {\n                for (const child of jsonNode.children) {\n                    element._appendChild(this._createNode(writer, child));\n                }\n            }\n            return element;\n        }\n        else {\n            // Otherwise, it is a Text node.\n            return writer.createText(jsonNode.data, jsonNode.attributes);\n        }\n    }\n    /**\n     * Restores the editor by setting the document data, roots attributes and markers.\n     */\n    _restoreEditorData(writer) {\n        const editor = this.editor;\n        Object.entries(this._data.roots).forEach(([rootName, { content, attributes }]) => {\n            const parsedNodes = JSON.parse(content);\n            const parsedAttributes = JSON.parse(attributes);\n            const rootElement = editor.model.document.getRoot(rootName);\n            for (const [key, value] of parsedAttributes) {\n                writer.setAttribute(key, value, rootElement);\n            }\n            for (const child of parsedNodes) {\n                const node = this._createNode(writer, child);\n                writer.insert(node, rootElement, 'end');\n            }\n        });\n        Object.entries(this._data.markers).forEach(([markerName, markerOptions]) => {\n            const { document } = editor.model;\n            const { rangeJSON: { start, end }, ...options } = markerOptions;\n            const root = document.getRoot(start.root);\n            const startPosition = writer.createPositionFromPath(root, start.path, start.stickiness);\n            const endPosition = writer.createPositionFromPath(root, end.path, end.stickiness);\n            const range = writer.createRange(startPosition, endPosition);\n            writer.addMarker(markerName, {\n                range,\n                ...options\n            });\n        });\n    }\n    /**\n     * Restores the editor collaboration data - comment threads and suggestions.\n     */\n    _restoreCollaborationData() {\n        // `as any` to avoid linking from external private repo.\n        const parsedCommentThreads = JSON.parse(this._data.commentThreads);\n        const parsedSuggestions = JSON.parse(this._data.suggestions);\n        parsedCommentThreads.forEach(commentThreadData => {\n            const channelId = this.editor.config.get('collaboration.channelId');\n            const commentsRepository = this.editor.plugins.get('CommentsRepository');\n            if (commentsRepository.hasCommentThread(commentThreadData.threadId)) {\n                const commentThread = commentsRepository.getCommentThread(commentThreadData.threadId);\n                commentThread.remove();\n            }\n            commentsRepository.addCommentThread({ channelId, ...commentThreadData });\n        });\n        parsedSuggestions.forEach(suggestionData => {\n            const trackChangesEditing = this.editor.plugins.get('TrackChangesEditing');\n            if (trackChangesEditing.hasSuggestion(suggestionData.id)) {\n                const suggestion = trackChangesEditing.getSuggestion(suggestionData.id);\n                suggestion.attributes = suggestionData.attributes;\n            }\n            else {\n                trackChangesEditing.addSuggestionData(suggestionData);\n            }\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Watchdog from './watchdog';\nimport EditorWatchdog from './editorwatchdog';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties';\nimport getSubNodes from './utils/getsubnodes';\nconst mainQueueId = Symbol('MainQueueId');\n/**\n * A watchdog for the {@link module:core/context~Context} class.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class ContextWatchdog extends Watchdog {\n    /**\n     * The context watchdog class constructor.\n     *\n     * ```ts\n     * const watchdog = new ContextWatchdog( Context );\n     *\n     * await watchdog.create( contextConfiguration );\n     *\n     * await watchdog.add( item );\n     * ```\n     *\n     * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\n     *\n     * @param Context The {@link module:core/context~Context} class.\n     * @param watchdogConfig The watchdog configuration.\n     */\n    constructor(Context, watchdogConfig = {}) {\n        super(watchdogConfig);\n        /**\n         * A map of internal watchdogs for added items.\n         */\n        this._watchdogs = new Map();\n        /**\n         * The current context instance.\n         */\n        this._context = null;\n        /**\n         * Context properties (nodes/references) that are gathered during the initial context creation\n         * and are used to distinguish the origin of an error.\n         */\n        this._contextProps = new Set();\n        /**\n         * An action queue, which is used to handle async functions queuing.\n         */\n        this._actionQueues = new ActionQueues();\n        this._watchdogConfig = watchdogConfig;\n        // Default creator and destructor.\n        this._creator = contextConfig => Context.create(contextConfig);\n        this._destructor = context => context.destroy();\n        this._actionQueues.onEmpty(() => {\n            if (this.state === 'initializing') {\n                this.state = 'ready';\n                this._fire('stateChange');\n            }\n        });\n    }\n    /**\n     * Sets the function that is responsible for the context creation.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setCreator( config => Context.create( config ) );\n     * ```\n     */\n    setCreator(creator) {\n        this._creator = creator;\n    }\n    /**\n     * Sets the function that is responsible for the context destruction.\n     * Overrides the default destruction function, which destroys only the context instance.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setDestructor( context => {\n     * \t// Do something before the context is destroyed.\n     *\n     * \treturn context\n     * \t\t.destroy()\n     * \t\t.then( () => {\n     * \t\t\t// Do something after the context is destroyed.\n     * \t\t} );\n     * } );\n     * ```\n     */\n    setDestructor(destructor) {\n        this._destructor = destructor;\n    }\n    /**\n     * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\n     * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\n     */\n    get context() {\n        return this._context;\n    }\n    /**\n     * Initializes the context watchdog. Once it is created, the watchdog takes care about\n     * recreating the context and the provided items, and starts the error handling mechanism.\n     *\n     * ```ts\n     * await watchdog.create( {\n     * \tplugins: []\n     * } );\n     * ```\n     *\n     * @param contextConfig The context configuration. See {@link module:core/context~Context}.\n     */\n    create(contextConfig = {}) {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this._contextConfig = contextConfig;\n            return this._create();\n        });\n    }\n    /**\n     * Returns an item instance with the given `itemId`.\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * @param itemId The item ID.\n     * @returns The item instance or `undefined` if an item with a given ID has not been found.\n     */\n    getItem(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog._item;\n    }\n    /**\n     * Gets the state of the given item. See {@link #state} for a list of available states.\n     *\n     * ```ts\n     * const editor1State = watchdog.getItemState( 'editor1' );\n     * ```\n     *\n     * @param itemId Item ID.\n     * @returns The state of the item.\n     */\n    getItemState(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog.state;\n    }\n    /**\n     * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\n     *\n     * Items can be passed together as an array of objects:\n     *\n     * ```ts\n     * await watchdog.add( [ {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * } ] );\n     * ```\n     *\n     * Or one by one as objects:\n     *\n     * ```ts\n     * await watchdog.add( {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * ] );\n     * ```\n     *\n     * Then an instance can be retrieved using the {@link #getItem} method:\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * Note that this method can be called multiple times, but for performance reasons it is better\n     * to pass all items together.\n     *\n     * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\n     */\n    add(itemConfigurationOrItemConfigurations) {\n        const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n        return Promise.all(itemConfigurations.map(item => {\n            return this._actionQueues.enqueue(item.id, () => {\n                if (this.state === 'destroyed') {\n                    throw new Error('Cannot add items to destroyed watchdog.');\n                }\n                if (!this._context) {\n                    throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n                }\n                let watchdog;\n                if (this._watchdogs.has(item.id)) {\n                    throw new Error(`Item with the given id is already added: '${item.id}'.`);\n                }\n                if (item.type === 'editor') {\n                    watchdog = new EditorWatchdog(null, this._watchdogConfig);\n                    watchdog.setCreator(item.creator);\n                    watchdog._setExcludedProperties(this._contextProps);\n                    if (item.destructor) {\n                        watchdog.setDestructor(item.destructor);\n                    }\n                    this._watchdogs.set(item.id, watchdog);\n                    // Enqueue the internal watchdog errors within the main queue.\n                    // And propagate the internal `error` events as `itemError` event.\n                    watchdog.on('error', (evt, { error, causesRestart }) => {\n                        this._fire('itemError', { itemId: item.id, error });\n                        // Do not enqueue the item restart action if the item will not restart.\n                        if (!causesRestart) {\n                            return;\n                        }\n                        this._actionQueues.enqueue(item.id, () => new Promise(res => {\n                            const rethrowRestartEventOnce = () => {\n                                watchdog.off('restart', rethrowRestartEventOnce);\n                                this._fire('itemRestart', { itemId: item.id });\n                                res();\n                            };\n                            watchdog.on('restart', rethrowRestartEventOnce);\n                        }));\n                    });\n                    return watchdog.create(item.sourceElementOrData, item.config, this._context);\n                }\n                else {\n                    throw new Error(`Not supported item type: '${item.type}'.`);\n                }\n            });\n        }));\n    }\n    /**\n     * Removes and destroys item(s) with given ID(s).\n     *\n     * ```ts\n     * await watchdog.remove( 'editor1' );\n     * ```\n     *\n     * Or\n     *\n     * ```ts\n     * await watchdog.remove( [ 'editor1', 'editor2' ] );\n     * ```\n     *\n     * @param itemIdOrItemIds Item ID or an array of item IDs.\n     */\n    remove(itemIdOrItemIds) {\n        const itemIds = toArray(itemIdOrItemIds);\n        return Promise.all(itemIds.map(itemId => {\n            return this._actionQueues.enqueue(itemId, () => {\n                const watchdog = this._getWatchdog(itemId);\n                this._watchdogs.delete(itemId);\n                return watchdog.destroy();\n            });\n        }));\n    }\n    /**\n     * Destroys the context watchdog and all added items.\n     * Once the context watchdog is destroyed, new items cannot be added.\n     *\n     * ```ts\n     * await watchdog.destroy();\n     * ```\n     */\n    destroy() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'destroyed';\n            this._fire('stateChange');\n            super.destroy();\n            return this._destroy();\n        });\n    }\n    /**\n     * Restarts the context watchdog.\n     */\n    _restart() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'initializing';\n            this._fire('stateChange');\n            return this._destroy()\n                .catch(err => {\n                console.error('An error happened during destroying the context or items.', err);\n            })\n                .then(() => this._create())\n                .then(() => this._fire('restart'));\n        });\n    }\n    /**\n     * Initializes the context watchdog.\n     */\n    _create() {\n        return Promise.resolve()\n            .then(() => {\n            this._startErrorHandling();\n            return this._creator(this._contextConfig);\n        })\n            .then(context => {\n            this._context = context;\n            this._contextProps = getSubNodes(this._context);\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => {\n                watchdog._setExcludedProperties(this._contextProps);\n                return watchdog.create(undefined, undefined, this._context);\n            }));\n        });\n    }\n    /**\n     * Destroys the context instance and all added items.\n     */\n    _destroy() {\n        return Promise.resolve()\n            .then(() => {\n            this._stopErrorHandling();\n            const context = this._context;\n            this._context = null;\n            this._contextProps = new Set();\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => watchdog.destroy()))\n                // Context destructor destroys each editor.\n                .then(() => this._destructor(context));\n        });\n    }\n    /**\n     * Returns the watchdog for a given item ID.\n     *\n     * @param itemId Item ID.\n     */\n    _getWatchdog(itemId) {\n        const watchdog = this._watchdogs.get(itemId);\n        if (!watchdog) {\n            throw new Error(`Item with the given id was not registered: ${itemId}.`);\n        }\n        return watchdog;\n    }\n    /**\n     * Checks whether an error comes from the context instance and not from the item instances.\n     *\n     * @internal\n     */\n    _isErrorComingFromThisItem(error) {\n        for (const watchdog of this._watchdogs.values()) {\n            if (watchdog._isErrorComingFromThisItem(error)) {\n                return false;\n            }\n        }\n        return areConnectedThroughProperties(this._context, error.context);\n    }\n}\n/**\n * Manager of action queues that allows queuing async functions.\n */\nclass ActionQueues {\n    constructor() {\n        this._onEmptyCallbacks = [];\n        this._queues = new Map();\n        this._activeActions = 0;\n    }\n    /**\n     * Used to register callbacks that will be run when the queue becomes empty.\n     *\n     * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\n     */\n    onEmpty(onEmptyCallback) {\n        this._onEmptyCallbacks.push(onEmptyCallback);\n    }\n    /**\n     * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\n     *\n     * @param queueId The action queue ID.\n     * @param action A function that should be enqueued.\n     */\n    enqueue(queueId, action) {\n        const isMainAction = queueId === mainQueueId;\n        this._activeActions++;\n        if (!this._queues.get(queueId)) {\n            this._queues.set(queueId, Promise.resolve());\n        }\n        // List all sources of actions that the current action needs to await for.\n        // For the main action wait for all other actions.\n        // For the item action wait only for the item queue and the main queue.\n        const awaitedActions = isMainAction ?\n            Promise.all(this._queues.values()) :\n            Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n        const queueWithAction = awaitedActions.then(action);\n        // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n        const nonErrorQueue = queueWithAction.catch(() => { });\n        this._queues.set(queueId, nonErrorQueue);\n        return queueWithAction.finally(() => {\n            this._activeActions--;\n            if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n                this._onEmptyCallbacks.forEach(cb => cb());\n            }\n        });\n    }\n}\n/**\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\n *\n * @param elementOrArray The value to transform to an array.\n * @returns An array created from data.\n */\nfunction toArray(elementOrArray) {\n    return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}\n"],
  "mappings": "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",
  "names": []
}
