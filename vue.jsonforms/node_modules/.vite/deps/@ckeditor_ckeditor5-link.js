import "./chunk-SX3YCKSJ.js";
import {
  ClipboardPipeline
} from "./chunk-74PGQAYV.js";
import {
  isWidget
} from "./chunk-NMGSIING.js";
import "./chunk-DEIZSOIF.js";
import "./chunk-GGCPNJOL.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  ButtonView,
  ContextualBalloon,
  CssTransitionDisablerMixin,
  FocusCycler,
  LabeledFieldView,
  SwitchButtonView,
  View,
  ViewCollection,
  clickOutsideHandler,
  createLabeledInputText,
  submitHandler
} from "./chunk-SGTDNT4V.js";
import "./chunk-W3CRWNYM.js";
import {
  Delete,
  Input,
  TextWatcher,
  TwoStepCaretMovement,
  findAttributeRange,
  getLastTextLine,
  inlineHighlight
} from "./chunk-4MFML76R.js";
import "./chunk-6LVMAMLV.js";
import {
  ClickObserver,
  Collection,
  Command,
  FocusTracker,
  KeystrokeHandler,
  Matcher,
  MouseObserver,
  ObservableMixin,
  Plugin,
  env_default,
  first,
  icons,
  keyCodes,
  toMap
} from "./chunk-JI2V5GJZ.js";
import {
  upperFirst_default
} from "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-link/src/utils/automaticdecorators.js
var AutomaticDecorators = class {
  constructor() {
    this._definitions = /* @__PURE__ */ new Set();
  }
  /**
   * Gives information about the number of decorators stored in the {@link module:link/utils/automaticdecorators~AutomaticDecorators}
   * instance.
   */
  get length() {
    return this._definitions.size;
  }
  /**
   * Adds automatic decorator objects or an array with them to be used during downcasting.
   *
   * @param item A configuration object of automatic rules for decorating links. It might also be an array of such objects.
   */
  add(item) {
    if (Array.isArray(item)) {
      item.forEach((item2) => this._definitions.add(item2));
    } else {
      this._definitions.add(item);
    }
  }
  /**
   * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method.
   *
   * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
   */
  getDispatcher() {
    return (dispatcher) => {
      dispatcher.on("attribute:linkHref", (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.item, "attribute:linkHref")) {
          return;
        }
        if (!(data.item.is("selection") || conversionApi.schema.isInline(data.item))) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const viewSelection = viewWriter.document.selection;
        for (const item of this._definitions) {
          const viewElement = viewWriter.createAttributeElement("a", item.attributes, {
            priority: 5
          });
          if (item.classes) {
            viewWriter.addClass(item.classes, viewElement);
          }
          for (const key in item.styles) {
            viewWriter.setStyle(key, item.styles[key], viewElement);
          }
          viewWriter.setCustomProperty("link", true, viewElement);
          if (item.callback(data.attributeNewValue)) {
            if (data.item.is("selection")) {
              viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
            } else {
              viewWriter.wrap(conversionApi.mapper.toViewRange(data.range), viewElement);
            }
          } else {
            viewWriter.unwrap(conversionApi.mapper.toViewRange(data.range), viewElement);
          }
        }
      }, { priority: "high" });
    };
  }
  /**
   * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method
   * when linking images.
   *
   * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
   */
  getDispatcherForLinkedImage() {
    return (dispatcher) => {
      dispatcher.on("attribute:linkHref:imageBlock", (evt, data, { writer, mapper }) => {
        const viewFigure = mapper.toViewElement(data.item);
        const linkInImage = Array.from(viewFigure.getChildren()).find((child) => child.is("element", "a"));
        for (const item of this._definitions) {
          const attributes = toMap(item.attributes);
          if (item.callback(data.attributeNewValue)) {
            for (const [key, val] of attributes) {
              if (key === "class") {
                writer.addClass(val, linkInImage);
              } else {
                writer.setAttribute(key, val, linkInImage);
              }
            }
            if (item.classes) {
              writer.addClass(item.classes, linkInImage);
            }
            for (const key in item.styles) {
              writer.setStyle(key, item.styles[key], linkInImage);
            }
          } else {
            for (const [key, val] of attributes) {
              if (key === "class") {
                writer.removeClass(val, linkInImage);
              } else {
                writer.removeAttribute(key, linkInImage);
              }
            }
            if (item.classes) {
              writer.removeClass(item.classes, linkInImage);
            }
            for (const key in item.styles) {
              writer.removeStyle(key, linkInImage);
            }
          }
        }
      });
    };
  }
};

// node_modules/@ckeditor/ckeditor5-link/src/utils.js
var ATTRIBUTE_WHITESPACES = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var SAFE_URL = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
var EMAIL_REG_EXP = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
var PROTOCOL_REG_EXP = /^((\w+:(\/{2,})?)|(\W))/i;
var LINK_KEYSTROKE = "Ctrl+K";
function isLinkElement(node) {
  return node.is("attributeElement") && !!node.getCustomProperty("link");
}
function createLinkElement(href, { writer }) {
  const linkElement = writer.createAttributeElement("a", { href }, { priority: 5 });
  writer.setCustomProperty("link", true, linkElement);
  return linkElement;
}
function ensureSafeUrl(url) {
  const urlString = String(url);
  return isSafeUrl(urlString) ? urlString : "#";
}
function isSafeUrl(url) {
  const normalizedUrl = url.replace(ATTRIBUTE_WHITESPACES, "");
  return !!normalizedUrl.match(SAFE_URL);
}
function getLocalizedDecorators(t, decorators) {
  const localizedDecoratorsLabels = {
    "Open in a new tab": t("Open in a new tab"),
    "Downloadable": t("Downloadable")
  };
  decorators.forEach((decorator) => {
    if ("label" in decorator && localizedDecoratorsLabels[decorator.label]) {
      decorator.label = localizedDecoratorsLabels[decorator.label];
    }
    return decorator;
  });
  return decorators;
}
function normalizeDecorators(decorators) {
  const retArray = [];
  if (decorators) {
    for (const [key, value] of Object.entries(decorators)) {
      const decorator = Object.assign({}, value, { id: `link${upperFirst_default(key)}` });
      retArray.push(decorator);
    }
  }
  return retArray;
}
function isLinkableElement(element, schema) {
  if (!element) {
    return false;
  }
  return schema.checkAttribute(element.name, "linkHref");
}
function isEmail(value) {
  return EMAIL_REG_EXP.test(value);
}
function addLinkProtocolIfApplicable(link, defaultProtocol) {
  const protocol = isEmail(link) ? "mailto:" : defaultProtocol;
  const isProtocolNeeded = !!protocol && !linkHasProtocol(link);
  return link && isProtocolNeeded ? protocol + link : link;
}
function linkHasProtocol(link) {
  return PROTOCOL_REG_EXP.test(link);
}
function openLink(link) {
  window.open(link, "_blank", "noopener");
}

// node_modules/@ckeditor/ckeditor5-link/src/linkcommand.js
var LinkCommand = class extends Command {
  constructor() {
    super(...arguments);
    this.manualDecorators = new Collection();
    this.automaticDecorators = new AutomaticDecorators();
  }
  /**
   * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.
   */
  restoreManualDecoratorStates() {
    for (const manualDecorator of this.manualDecorators) {
      manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
    }
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedElement = selection.getSelectedElement() || first(selection.getSelectedBlocks());
    if (isLinkableElement(selectedElement, model.schema)) {
      this.value = selectedElement.getAttribute("linkHref");
      this.isEnabled = model.schema.checkAttribute(selectedElement, "linkHref");
    } else {
      this.value = selection.getAttribute("linkHref");
      this.isEnabled = model.schema.checkAttributeInSelection(selection, "linkHref");
    }
    for (const manualDecorator of this.manualDecorators) {
      manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
    }
  }
  /**
   * Executes the command.
   *
   * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
   * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
   *
   * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a
   * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but
   * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
   * The selection will be updated to wrap the just inserted text node.
   *
   * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
   *
   * # Decorators and model attribute management
   *
   * There is an optional argument to this command that applies or removes model
   * {@glink framework/architecture/editing-engine#text-attributes text attributes} brought by
   * {@link module:link/utils/manualdecorator~ManualDecorator manual link decorators}.
   *
   * Text attribute names in the model correspond to the entries in the {@link module:link/linkconfig~LinkConfig#decorators
   * configuration}.
   * For every decorator configured, a model text attribute exists with the "link" prefix. For example, a `'linkMyDecorator'` attribute
   * corresponds to `'myDecorator'` in the configuration.
   *
   * To learn more about link decorators, check out the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`}
   * documentation.
   *
   * Here is how to manage decorator attributes with the link command:
   *
   * ```ts
   * const linkCommand = editor.commands.get( 'link' );
   *
   * // Adding a new decorator attribute.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: true
   * } );
   *
   * // Removing a decorator attribute from the selection.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: false
   * } );
   *
   * // Adding multiple decorator attributes at the same time.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: true,
   * 	linkIsDownloadable: true,
   * } );
   *
   * // Removing and adding decorator attributes at the same time.
   * linkCommand.execute( 'http://example.com', {
   * 	linkIsExternal: false,
   * 	linkFoo: true,
   * 	linkIsDownloadable: false,
   * } );
   * ```
   *
   * **Note**: If the decorator attribute name is not specified, its state remains untouched.
   *
   * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all
   * decorator attributes.
   *
   * @fires execute
   * @param href Link destination.
   * @param manualDecoratorIds The information about manual decorator attributes to be applied or removed upon execution.
   */
  execute(href, manualDecoratorIds = {}) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const truthyManualDecorators = [];
    const falsyManualDecorators = [];
    for (const name in manualDecoratorIds) {
      if (manualDecoratorIds[name]) {
        truthyManualDecorators.push(name);
      } else {
        falsyManualDecorators.push(name);
      }
    }
    model.change((writer) => {
      if (selection.isCollapsed) {
        const position = selection.getFirstPosition();
        if (selection.hasAttribute("linkHref")) {
          const linkText = extractTextFromSelection(selection);
          let linkRange = findAttributeRange(position, "linkHref", selection.getAttribute("linkHref"), model);
          if (selection.getAttribute("linkHref") === linkText) {
            linkRange = this._updateLinkContent(model, writer, linkRange, href);
          }
          writer.setAttribute("linkHref", href, linkRange);
          truthyManualDecorators.forEach((item) => {
            writer.setAttribute(item, true, linkRange);
          });
          falsyManualDecorators.forEach((item) => {
            writer.removeAttribute(item, linkRange);
          });
          writer.setSelection(writer.createPositionAfter(linkRange.end.nodeBefore));
        } else if (href !== "") {
          const attributes = toMap(selection.getAttributes());
          attributes.set("linkHref", href);
          truthyManualDecorators.forEach((item) => {
            attributes.set(item, true);
          });
          const { end: positionAfter } = model.insertContent(writer.createText(href, attributes), position);
          writer.setSelection(positionAfter);
        }
        ["linkHref", ...truthyManualDecorators, ...falsyManualDecorators].forEach((item) => {
          writer.removeSelectionAttribute(item);
        });
      } else {
        const ranges = model.schema.getValidRanges(selection.getRanges(), "linkHref");
        const allowedRanges = [];
        for (const element of selection.getSelectedBlocks()) {
          if (model.schema.checkAttribute(element, "linkHref")) {
            allowedRanges.push(writer.createRangeOn(element));
          }
        }
        const rangesToUpdate = allowedRanges.slice();
        for (const range of ranges) {
          if (this._isRangeToUpdate(range, allowedRanges)) {
            rangesToUpdate.push(range);
          }
        }
        for (const range of rangesToUpdate) {
          let linkRange = range;
          if (rangesToUpdate.length === 1) {
            const linkText = extractTextFromSelection(selection);
            if (selection.getAttribute("linkHref") === linkText) {
              linkRange = this._updateLinkContent(model, writer, range, href);
              writer.setSelection(writer.createSelection(linkRange));
            }
          }
          writer.setAttribute("linkHref", href, linkRange);
          truthyManualDecorators.forEach((item) => {
            writer.setAttribute(item, true, linkRange);
          });
          falsyManualDecorators.forEach((item) => {
            writer.removeAttribute(item, linkRange);
          });
        }
      }
    });
  }
  /**
   * Provides information whether a decorator with a given name is present in the currently processed selection.
   *
   * @param decoratorName The name of the manual decorator used in the model
   * @returns The information whether a given decorator is currently present in the selection.
   */
  _getDecoratorStateFromModel(decoratorName) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (isLinkableElement(selectedElement, model.schema)) {
      return selectedElement.getAttribute(decoratorName);
    }
    return selection.getAttribute(decoratorName);
  }
  /**
   * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.
   *
   * @param range A range to check.
   * @param allowedRanges An array of ranges created on elements where the attribute is accepted.
   */
  _isRangeToUpdate(range, allowedRanges) {
    for (const allowedRange of allowedRanges) {
      if (allowedRange.containsRange(range)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Updates selected link with a new value as its content and as its href attribute.
   *
   * @param model Model is need to insert content.
   * @param writer Writer is need to create text element in model.
   * @param range A range where should be inserted content.
   * @param href A link value which should be in the href attribute and in the content.
   */
  _updateLinkContent(model, writer, range, href) {
    const text = writer.createText(href, { linkHref: href });
    return model.insertContent(text, range);
  }
};
function extractTextFromSelection(selection) {
  if (selection.isCollapsed) {
    const firstPosition = selection.getFirstPosition();
    return firstPosition.textNode && firstPosition.textNode.data;
  } else {
    const rangeItems = Array.from(selection.getFirstRange().getItems());
    if (rangeItems.length > 1) {
      return null;
    }
    const firstNode = rangeItems[0];
    if (firstNode.is("$text") || firstNode.is("$textProxy")) {
      return firstNode.data;
    }
    return null;
  }
}

// node_modules/@ckeditor/ckeditor5-link/src/unlinkcommand.js
var UnlinkCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (isLinkableElement(selectedElement, model.schema)) {
      this.isEnabled = model.schema.checkAttribute(selectedElement, "linkHref");
    } else {
      this.isEnabled = model.schema.checkAttributeInSelection(selection, "linkHref");
    }
  }
  /**
   * Executes the command.
   *
   * When the selection is collapsed, it removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
   * When the selection is non-collapsed, it removes the `linkHref` attribute from each node in selected ranges.
   *
   * # Decorators
   *
   * If {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} is specified,
   * all configured decorators are removed together with the `linkHref` attribute.
   *
   * @fires execute
   */
  execute() {
    const editor = this.editor;
    const model = this.editor.model;
    const selection = model.document.selection;
    const linkCommand = editor.commands.get("link");
    model.change((writer) => {
      const rangesToUnlink = selection.isCollapsed ? [findAttributeRange(selection.getFirstPosition(), "linkHref", selection.getAttribute("linkHref"), model)] : model.schema.getValidRanges(selection.getRanges(), "linkHref");
      for (const range of rangesToUnlink) {
        writer.removeAttribute("linkHref", range);
        if (linkCommand) {
          for (const manualDecorator of linkCommand.manualDecorators) {
            writer.removeAttribute(manualDecorator.id, range);
          }
        }
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-link/src/utils/manualdecorator.js
var ManualDecorator = class extends ObservableMixin() {
  /**
   * Creates a new instance of {@link module:link/utils/manualdecorator~ManualDecorator}.
   *
   * @param config.id The name of the attribute used in the model that represents a given manual decorator.
   * For example: `'linkIsExternal'`.
   * @param config.label The label used in the user interface to toggle the manual decorator.
   * @param config.attributes A set of attributes added to output data when the decorator is active for a specific link.
   * Attributes should keep the format of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
   * @param [config.defaultValue] Controls whether the decorator is "on" by default.
   */
  constructor({ id, label, attributes, classes, styles, defaultValue }) {
    super();
    this.id = id;
    this.set("value", void 0);
    this.defaultValue = defaultValue;
    this.label = label;
    this.attributes = attributes;
    this.classes = classes;
    this.styles = styles;
  }
  /**
   * Returns {@link module:engine/view/matcher~MatcherPattern} with decorator attributes.
   *
   * @internal
   */
  _createPattern() {
    return {
      attributes: this.attributes,
      classes: this.classes,
      styles: this.styles
    };
  }
};

// node_modules/@ckeditor/ckeditor5-link/src/linkediting.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-link/theme/link.css";
var HIGHLIGHT_CLASS = "ck-link_selected";
var DECORATOR_AUTOMATIC = "automatic";
var DECORATOR_MANUAL = "manual";
var EXTERNAL_LINKS_REGEXP = /^(https?:)?\/\//;
var LinkEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TwoStepCaretMovement, Input, ClipboardPipeline];
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("link", {
      addTargetToExternalLinks: false
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    editor.model.schema.extend("$text", { allowAttributes: "linkHref" });
    editor.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: createLinkElement });
    editor.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (href, conversionApi) => {
      return createLinkElement(ensureSafeUrl(href), conversionApi);
    } });
    editor.conversion.for("upcast").elementToAttribute({
      view: {
        name: "a",
        attributes: {
          href: true
        }
      },
      model: {
        key: "linkHref",
        value: (viewElement) => viewElement.getAttribute("href")
      }
    });
    editor.commands.add("link", new LinkCommand(editor));
    editor.commands.add("unlink", new UnlinkCommand(editor));
    const linkDecorators = getLocalizedDecorators(editor.t, normalizeDecorators(editor.config.get("link.decorators")));
    this._enableAutomaticDecorators(linkDecorators.filter((item) => item.mode === DECORATOR_AUTOMATIC));
    this._enableManualDecorators(linkDecorators.filter((item) => item.mode === DECORATOR_MANUAL));
    const twoStepCaretMovementPlugin = editor.plugins.get(TwoStepCaretMovement);
    twoStepCaretMovementPlugin.registerAttribute("linkHref");
    inlineHighlight(editor, "linkHref", "a", HIGHLIGHT_CLASS);
    this._enableLinkOpen();
    this._enableInsertContentSelectionAttributesFixer();
    this._enableClickingAfterLink();
    this._enableTypingOverLink();
    this._handleDeleteContentAfterLink();
    this._enableClipboardIntegration();
  }
  /**
   * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}
   * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}
   * for each one of them. Downcast dispatchers are obtained using the
   * {@link module:link/utils/automaticdecorators~AutomaticDecorators#getDispatcher} method.
   *
   * **Note**: This method also activates the automatic external link decorator if enabled with
   * {@link module:link/linkconfig~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.
   */
  _enableAutomaticDecorators(automaticDecoratorDefinitions) {
    const editor = this.editor;
    const command = editor.commands.get("link");
    const automaticDecorators = command.automaticDecorators;
    if (editor.config.get("link.addTargetToExternalLinks")) {
      automaticDecorators.add({
        id: "linkIsExternal",
        mode: DECORATOR_AUTOMATIC,
        callback: (url) => !!url && EXTERNAL_LINKS_REGEXP.test(url),
        attributes: {
          target: "_blank",
          rel: "noopener noreferrer"
        }
      });
    }
    automaticDecorators.add(automaticDecoratorDefinitions);
    if (automaticDecorators.length) {
      editor.conversion.for("downcast").add(automaticDecorators.getDispatcher());
    }
  }
  /**
   * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorManualDefinition manual decorators},
   * transforms them into {@link module:link/utils/manualdecorator~ManualDecorator} instances and stores them in the
   * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).
   *
   * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}
   * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}
   * with adequate model attributes.
   */
  _enableManualDecorators(manualDecoratorDefinitions) {
    if (!manualDecoratorDefinitions.length) {
      return;
    }
    const editor = this.editor;
    const command = editor.commands.get("link");
    const manualDecorators = command.manualDecorators;
    manualDecoratorDefinitions.forEach((decoratorDefinition) => {
      editor.model.schema.extend("$text", { allowAttributes: decoratorDefinition.id });
      const decorator = new ManualDecorator(decoratorDefinition);
      manualDecorators.add(decorator);
      editor.conversion.for("downcast").attributeToElement({
        model: decorator.id,
        view: (manualDecoratorValue, { writer, schema }, { item }) => {
          if (!(item.is("selection") || schema.isInline(item))) {
            return;
          }
          if (manualDecoratorValue) {
            const element = writer.createAttributeElement("a", decorator.attributes, { priority: 5 });
            if (decorator.classes) {
              writer.addClass(decorator.classes, element);
            }
            for (const key in decorator.styles) {
              writer.setStyle(key, decorator.styles[key], element);
            }
            writer.setCustomProperty("link", true, element);
            return element;
          }
        }
      });
      editor.conversion.for("upcast").elementToAttribute({
        view: {
          name: "a",
          ...decorator._createPattern()
        },
        model: {
          key: decorator.id
        }
      });
    });
  }
  /**
   * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and
   * {@link module:engine/view/document~Document#event:click} to enable link following.
   */
  _enableLinkOpen() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    this.listenTo(viewDocument, "click", (evt, data) => {
      const shouldOpen = env_default.isMac ? data.domEvent.metaKey : data.domEvent.ctrlKey;
      if (!shouldOpen) {
        return;
      }
      let clickedElement = data.domTarget;
      if (clickedElement.tagName.toLowerCase() != "a") {
        clickedElement = clickedElement.closest("a");
      }
      if (!clickedElement) {
        return;
      }
      const url = clickedElement.getAttribute("href");
      if (!url) {
        return;
      }
      evt.stop();
      data.preventDefault();
      openLink(url);
    }, { context: "$capture" });
    this.listenTo(viewDocument, "keydown", (evt, data) => {
      const linkCommand = editor.commands.get("link");
      const url = linkCommand.value;
      const shouldOpen = !!url && data.keyCode === keyCodes.enter && data.altKey;
      if (!shouldOpen) {
        return;
      }
      evt.stop();
      openLink(url);
    });
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model
   * selection attributes if the selection is at the end of a link after inserting the content.
   *
   * The purpose of this action is to improve the overall UX because the user is no longer "trapped" by the
   * `linkHref` attribute of the selection and they can type a "clean" (`linkHref`â€“less) text right away.
   *
   * See https://github.com/ckeditor/ckeditor5/issues/6053.
   */
  _enableInsertContentSelectionAttributesFixer() {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    this.listenTo(model, "insertContent", () => {
      const nodeBefore = selection.anchor.nodeBefore;
      const nodeAfter = selection.anchor.nodeAfter;
      if (!selection.hasAttribute("linkHref")) {
        return;
      }
      if (!nodeBefore) {
        return;
      }
      if (!nodeBefore.hasAttribute("linkHref")) {
        return;
      }
      if (nodeAfter && nodeAfter.hasAttribute("linkHref")) {
        return;
      }
      model.change((writer) => {
        removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));
      });
    }, { priority: "low" });
  }
  /**
   * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and
   * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a link node
   * if clicked at the beginning/ending of the link.
   *
   * The purpose of this action is to allow typing around the link node directly after a click.
   *
   * See https://github.com/ckeditor/ckeditor5/issues/1016.
   */
  _enableClickingAfterLink() {
    const editor = this.editor;
    const model = editor.model;
    editor.editing.view.addObserver(MouseObserver);
    let clicked = false;
    this.listenTo(editor.editing.view.document, "mousedown", () => {
      clicked = true;
    });
    this.listenTo(editor.editing.view.document, "selectionChange", () => {
      if (!clicked) {
        return;
      }
      clicked = false;
      const selection = model.document.selection;
      if (!selection.isCollapsed) {
        return;
      }
      if (!selection.hasAttribute("linkHref")) {
        return;
      }
      const position = selection.getFirstPosition();
      const linkRange = findAttributeRange(position, "linkHref", selection.getAttribute("linkHref"), model);
      if (position.isTouching(linkRange.start) || position.isTouching(linkRange.end)) {
        model.change((writer) => {
          removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));
        });
      }
    });
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and {@link module:engine/model/model~Model#insertContent}
   * and checks whether typing over the link. If so, attributes of removed text are preserved and applied to the inserted text.
   *
   * The purpose of this action is to allow modifying a text without loosing the `linkHref` attribute (and other).
   *
   * See https://github.com/ckeditor/ckeditor5/issues/4762.
   */
  _enableTypingOverLink() {
    const editor = this.editor;
    const view = editor.editing.view;
    let selectionAttributes = null;
    let deletedContent = false;
    this.listenTo(view.document, "delete", () => {
      deletedContent = true;
    }, { priority: "high" });
    this.listenTo(editor.model, "deleteContent", () => {
      const selection = editor.model.document.selection;
      if (selection.isCollapsed) {
        return;
      }
      if (deletedContent) {
        deletedContent = false;
        return;
      }
      if (!isTyping(editor)) {
        return;
      }
      if (shouldCopyAttributes(editor.model)) {
        selectionAttributes = selection.getAttributes();
      }
    }, { priority: "high" });
    this.listenTo(editor.model, "insertContent", (evt, [element]) => {
      deletedContent = false;
      if (!isTyping(editor)) {
        return;
      }
      if (!selectionAttributes) {
        return;
      }
      editor.model.change((writer) => {
        for (const [attribute, value] of selectionAttributes) {
          writer.setAttribute(attribute, value, element);
        }
      });
      selectionAttributes = null;
    }, { priority: "high" });
  }
  /**
   * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether
   * removing a content right after the "linkHref" attribute.
   *
   * If so, the selection should not preserve the `linkHref` attribute. However, if
   * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and
   * the selection has the "linkHref" attribute due to overriden gravity (at the end), the `linkHref` attribute should stay untouched.
   *
   * The purpose of this action is to allow removing the link text and keep the selection outside the link.
   *
   * See https://github.com/ckeditor/ckeditor5/issues/7521.
   */
  _handleDeleteContentAfterLink() {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const view = editor.editing.view;
    let shouldPreserveAttributes = false;
    let hasBackspacePressed = false;
    this.listenTo(view.document, "delete", (evt, data) => {
      hasBackspacePressed = data.direction === "backward";
    }, { priority: "high" });
    this.listenTo(model, "deleteContent", () => {
      shouldPreserveAttributes = false;
      const position = selection.getFirstPosition();
      const linkHref = selection.getAttribute("linkHref");
      if (!linkHref) {
        return;
      }
      const linkRange = findAttributeRange(position, "linkHref", linkHref, model);
      shouldPreserveAttributes = linkRange.containsPosition(position) || linkRange.end.isEqual(position);
    }, { priority: "high" });
    this.listenTo(model, "deleteContent", () => {
      if (!hasBackspacePressed) {
        return;
      }
      hasBackspacePressed = false;
      if (shouldPreserveAttributes) {
        return;
      }
      editor.model.enqueueChange((writer) => {
        removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));
      });
    }, { priority: "low" });
  }
  /**
   * Enables URL fixing on pasting.
   */
  _enableClipboardIntegration() {
    const editor = this.editor;
    const model = editor.model;
    const defaultProtocol = this.editor.config.get("link.defaultProtocol");
    if (!defaultProtocol) {
      return;
    }
    this.listenTo(editor.plugins.get("ClipboardPipeline"), "contentInsertion", (evt, data) => {
      model.change((writer) => {
        const range = writer.createRangeIn(data.content);
        for (const item of range.getItems()) {
          if (item.hasAttribute("linkHref")) {
            const newLink = addLinkProtocolIfApplicable(item.getAttribute("linkHref"), defaultProtocol);
            writer.setAttribute("linkHref", newLink, item);
          }
        }
      });
    });
  }
};
function removeLinkAttributesFromSelection(writer, linkAttributes) {
  writer.removeSelectionAttribute("linkHref");
  for (const attribute of linkAttributes) {
    writer.removeSelectionAttribute(attribute);
  }
}
function shouldCopyAttributes(model) {
  const selection = model.document.selection;
  const firstPosition = selection.getFirstPosition();
  const lastPosition = selection.getLastPosition();
  const nodeAtFirstPosition = firstPosition.nodeAfter;
  if (!nodeAtFirstPosition) {
    return false;
  }
  if (!nodeAtFirstPosition.is("$text")) {
    return false;
  }
  if (!nodeAtFirstPosition.hasAttribute("linkHref")) {
    return false;
  }
  const nodeAtLastPosition = lastPosition.textNode || lastPosition.nodeBefore;
  if (nodeAtFirstPosition === nodeAtLastPosition) {
    return true;
  }
  const linkRange = findAttributeRange(firstPosition, "linkHref", nodeAtFirstPosition.getAttribute("linkHref"), model);
  return linkRange.containsRange(model.createRange(firstPosition, lastPosition), true);
}
function isTyping(editor) {
  const currentBatch = editor.model.change((writer) => writer.batch);
  return currentBatch.isTyping;
}
function getLinkAttributesAllowedOnText(schema) {
  const textAttributes = schema.getDefinition("$text").allowAttributes;
  return textAttributes.filter((attribute) => attribute.startsWith("link"));
}

// node_modules/@ckeditor/ckeditor5-link/src/ui/linkformview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-link/theme/linkform.css";
var LinkFormView = class extends View {
  /**
   * Creates an instance of the {@link module:link/ui/linkformview~LinkFormView} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   * @param linkCommand Reference to {@link module:link/linkcommand~LinkCommand}.
   */
  constructor(locale, linkCommand) {
    super(locale);
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusables = new ViewCollection();
    const t = locale.t;
    this.urlInputView = this._createUrlInput();
    this.saveButtonView = this._createButton(t("Save"), icons.check, "ck-button-save");
    this.saveButtonView.type = "submit";
    this.cancelButtonView = this._createButton(t("Cancel"), icons.cancel, "ck-button-cancel", "cancel");
    this._manualDecoratorSwitches = this._createManualDecoratorSwitches(linkCommand);
    this.children = this._createFormChildren(linkCommand.manualDecorators);
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    const classList = ["ck", "ck-link-form", "ck-responsive-form"];
    if (linkCommand.manualDecorators.length) {
      classList.push("ck-link-form_layout-vertical", "ck-vertical-form");
    }
    this.setTemplate({
      tag: "form",
      attributes: {
        class: classList,
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * Obtains the state of the {@link module:ui/button/switchbuttonview~SwitchButtonView switch buttons} representing
   * {@link module:link/linkcommand~LinkCommand#manualDecorators manual link decorators}
   * in the {@link module:link/ui/linkformview~LinkFormView}.
   *
   * @returns Key-value pairs, where the key is the name of the decorator and the value is its state.
   */
  getDecoratorSwitchesState() {
    return Array.from(this._manualDecoratorSwitches).reduce((accumulator, switchButton) => {
      accumulator[switchButton.name] = switchButton.isOn;
      return accumulator;
    }, {});
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    const childViews = [
      this.urlInputView,
      ...this._manualDecoratorSwitches,
      this.saveButtonView,
      this.cancelButtonView
    ];
    childViews.forEach((v) => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Focuses the fist {@link #_focusables} in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Creates a labeled input view.
   *
   * @returns Labeled field view instance.
   */
  _createUrlInput() {
    const t = this.locale.t;
    const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
    labeledInput.label = t("Link URL");
    return labeledInput;
  }
  /**
   * Creates a button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   * @param className The additional button CSS class name.
   * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(label, icon, className, eventName) {
    const button = new ButtonView(this.locale);
    button.set({
      label,
      icon,
      tooltip: true
    });
    button.extendTemplate({
      attributes: {
        class: className
      }
    });
    if (eventName) {
      button.delegate("execute").to(this, eventName);
    }
    return button;
  }
  /**
   * Populates {@link module:ui/viewcollection~ViewCollection} of {@link module:ui/button/switchbuttonview~SwitchButtonView}
   * made based on {@link module:link/linkcommand~LinkCommand#manualDecorators}.
   *
   * @param linkCommand A reference to the link command.
   * @returns ViewCollection of switch buttons.
   */
  _createManualDecoratorSwitches(linkCommand) {
    const switches = this.createCollection();
    for (const manualDecorator of linkCommand.manualDecorators) {
      const switchButton = new SwitchButtonView(this.locale);
      switchButton.set({
        name: manualDecorator.id,
        label: manualDecorator.label,
        withText: true
      });
      switchButton.bind("isOn").toMany([manualDecorator, linkCommand], "value", (decoratorValue, commandValue) => {
        return commandValue === void 0 && decoratorValue === void 0 ? !!manualDecorator.defaultValue : !!decoratorValue;
      });
      switchButton.on("execute", () => {
        manualDecorator.set("value", !switchButton.isOn);
      });
      switches.add(switchButton);
    }
    return switches;
  }
  /**
   * Populates the {@link #children} collection of the form.
   *
   * If {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators} are configured in the editor, it creates an
   * additional `View` wrapping all {@link #_manualDecoratorSwitches} switch buttons corresponding
   * to these decorators.
   *
   * @param manualDecorators A reference to
   * the collection of manual decorators stored in the link command.
   * @returns The children of link form view.
   */
  _createFormChildren(manualDecorators) {
    const children = this.createCollection();
    children.add(this.urlInputView);
    if (manualDecorators.length) {
      const additionalButtonsView = new View();
      additionalButtonsView.setTemplate({
        tag: "ul",
        children: this._manualDecoratorSwitches.map((switchButton) => ({
          tag: "li",
          children: [switchButton],
          attributes: {
            class: [
              "ck",
              "ck-list__item"
            ]
          }
        })),
        attributes: {
          class: [
            "ck",
            "ck-reset",
            "ck-list"
          ]
        }
      });
      children.add(additionalButtonsView);
    }
    children.add(this.saveButtonView);
    children.add(this.cancelButtonView);
    return children;
  }
};

// node_modules/@ckeditor/ckeditor5-link/src/ui/linkactionsview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css";
import unlinkIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-link/theme/icons/unlink.svg";
var LinkActionsView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusables = new ViewCollection();
    const t = locale.t;
    this.previewButtonView = this._createPreviewButton();
    this.unlinkButtonView = this._createButton(t("Unlink"), unlinkIcon, "unlink");
    this.editButtonView = this._createButton(t("Edit link"), icons.pencil, "edit");
    this.set("href", void 0);
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-link-actions",
          "ck-responsive-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: [
        this.previewButtonView,
        this.editButtonView,
        this.unlinkButtonView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    const childViews = [
      this.previewButtonView,
      this.editButtonView,
      this.unlinkButtonView
    ];
    childViews.forEach((v) => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Focuses the fist {@link #_focusables} in the actions.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Creates a button view.
   *
   * @param label The button label.
   * @param icon The button icon.
   * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
   * @returns The button view instance.
   */
  _createButton(label, icon, eventName) {
    const button = new ButtonView(this.locale);
    button.set({
      label,
      icon,
      tooltip: true
    });
    button.delegate("execute").to(this, eventName);
    return button;
  }
  /**
   * Creates a link href preview button.
   *
   * @returns The button view instance.
   */
  _createPreviewButton() {
    const button = new ButtonView(this.locale);
    const bind = this.bindTemplate;
    const t = this.t;
    button.set({
      withText: true,
      tooltip: t("Open link in new tab")
    });
    button.extendTemplate({
      attributes: {
        class: [
          "ck",
          "ck-link-actions__preview"
        ],
        href: bind.to("href", (href) => href && ensureSafeUrl(href)),
        target: "_blank",
        rel: "noopener noreferrer"
      }
    });
    button.bind("label").to(this, "href", (href) => {
      return href || t("This link has no URL");
    });
    button.bind("isEnabled").to(this, "href", (href) => !!href);
    button.template.tag = "a";
    button.template.eventListeners = {};
    return button;
  }
};

// node_modules/@ckeditor/ckeditor5-link/src/linkui.js
import linkIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-link/theme/icons/link.svg";
var VISUAL_SELECTION_MARKER_NAME = "link-ui";
var LinkUI = class extends Plugin {
  constructor() {
    super(...arguments);
    this.actionsView = null;
    this.formView = null;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ContextualBalloon];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    editor.editing.view.addObserver(ClickObserver);
    this._balloon = editor.plugins.get(ContextualBalloon);
    this._createToolbarLinkButton();
    this._enableBalloonActivators();
    editor.conversion.for("editingDowncast").markerToHighlight({
      model: VISUAL_SELECTION_MARKER_NAME,
      view: {
        classes: ["ck-fake-link-selection"]
      }
    });
    editor.conversion.for("editingDowncast").markerToElement({
      model: VISUAL_SELECTION_MARKER_NAME,
      view: {
        name: "span",
        classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]
      }
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    if (this.formView) {
      this.formView.destroy();
    }
    if (this.actionsView) {
      this.actionsView.destroy();
    }
  }
  /**
   * Creates views.
   */
  _createViews() {
    this.actionsView = this._createActionsView();
    this.formView = this._createFormView();
    this._enableUserBalloonInteractions();
  }
  /**
   * Creates the {@link module:link/ui/linkactionsview~LinkActionsView} instance.
   */
  _createActionsView() {
    const editor = this.editor;
    const actionsView = new LinkActionsView(editor.locale);
    const linkCommand = editor.commands.get("link");
    const unlinkCommand = editor.commands.get("unlink");
    actionsView.bind("href").to(linkCommand, "value");
    actionsView.editButtonView.bind("isEnabled").to(linkCommand);
    actionsView.unlinkButtonView.bind("isEnabled").to(unlinkCommand);
    this.listenTo(actionsView, "edit", () => {
      this._addFormView();
    });
    this.listenTo(actionsView, "unlink", () => {
      editor.execute("unlink");
      this._hideUI();
    });
    actionsView.keystrokes.set("Esc", (data, cancel) => {
      this._hideUI();
      cancel();
    });
    actionsView.keystrokes.set(LINK_KEYSTROKE, (data, cancel) => {
      this._addFormView();
      cancel();
    });
    return actionsView;
  }
  /**
   * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
   */
  _createFormView() {
    const editor = this.editor;
    const linkCommand = editor.commands.get("link");
    const defaultProtocol = editor.config.get("link.defaultProtocol");
    const formView = new (CssTransitionDisablerMixin(LinkFormView))(editor.locale, linkCommand);
    formView.urlInputView.fieldView.bind("value").to(linkCommand, "value");
    formView.urlInputView.bind("isEnabled").to(linkCommand, "isEnabled");
    formView.saveButtonView.bind("isEnabled").to(linkCommand);
    this.listenTo(formView, "submit", () => {
      const { value } = formView.urlInputView.fieldView.element;
      const parsedUrl = addLinkProtocolIfApplicable(value, defaultProtocol);
      editor.execute("link", parsedUrl, formView.getDecoratorSwitchesState());
      this._closeFormView();
    });
    this.listenTo(formView, "cancel", () => {
      this._closeFormView();
    });
    formView.keystrokes.set("Esc", (data, cancel) => {
      this._closeFormView();
      cancel();
    });
    return formView;
  }
  /**
   * Creates a toolbar Link button. Clicking this button will show
   * a {@link #_balloon} attached to the selection.
   */
  _createToolbarLinkButton() {
    const editor = this.editor;
    const linkCommand = editor.commands.get("link");
    const t = editor.t;
    editor.ui.componentFactory.add("link", (locale) => {
      const button = new ButtonView(locale);
      button.isEnabled = true;
      button.label = t("Link");
      button.icon = linkIcon;
      button.keystroke = LINK_KEYSTROKE;
      button.tooltip = true;
      button.isToggleable = true;
      button.bind("isEnabled").to(linkCommand, "isEnabled");
      button.bind("isOn").to(linkCommand, "value", (value) => !!value);
      this.listenTo(button, "execute", () => this._showUI(true));
      return button;
    });
  }
  /**
   * Attaches actions that control whether the balloon panel containing the
   * {@link #formView} should be displayed.
   */
  _enableBalloonActivators() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    this.listenTo(viewDocument, "click", () => {
      const parentLink = this._getSelectedLinkElement();
      if (parentLink) {
        this._showUI();
      }
    });
    editor.keystrokes.set(LINK_KEYSTROKE, (keyEvtData, cancel) => {
      cancel();
      if (editor.commands.get("link").isEnabled) {
        this._showUI(true);
      }
    });
  }
  /**
   * Attaches actions that control whether the balloon panel containing the
   * {@link #formView} is visible or not.
   */
  _enableUserBalloonInteractions() {
    this.editor.keystrokes.set("Tab", (data, cancel) => {
      if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
        this.actionsView.focus();
        cancel();
      }
    }, {
      // Use the high priority because the link UI navigation is more important
      // than other feature's actions, e.g. list indentation.
      // https://github.com/ckeditor/ckeditor5-link/issues/146
      priority: "high"
    });
    this.editor.keystrokes.set("Esc", (data, cancel) => {
      if (this._isUIVisible) {
        this._hideUI();
        cancel();
      }
    });
    clickOutsideHandler({
      emitter: this.formView,
      activator: () => this._isUIInPanel,
      contextElements: () => [this._balloon.view.element],
      callback: () => this._hideUI()
    });
  }
  /**
   * Adds the {@link #actionsView} to the {@link #_balloon}.
   *
   * @internal
   */
  _addActionsView() {
    if (!this.actionsView) {
      this._createViews();
    }
    if (this._areActionsInPanel) {
      return;
    }
    this._balloon.add({
      view: this.actionsView,
      position: this._getBalloonPositionData()
    });
  }
  /**
   * Adds the {@link #formView} to the {@link #_balloon}.
   */
  _addFormView() {
    if (!this.formView) {
      this._createViews();
    }
    if (this._isFormInPanel) {
      return;
    }
    const editor = this.editor;
    const linkCommand = editor.commands.get("link");
    this.formView.disableCssTransitions();
    this._balloon.add({
      view: this.formView,
      position: this._getBalloonPositionData()
    });
    if (this._balloon.visibleView === this.formView) {
      this.formView.urlInputView.fieldView.select();
    }
    this.formView.enableCssTransitions();
    this.formView.urlInputView.fieldView.element.value = linkCommand.value || "";
  }
  /**
   * Closes the form view. Decides whether the balloon should be hidden completely or if the action view should be shown. This is
   * decided upon the link command value (which has a value if the document selection is in the link).
   *
   * Additionally, if any {@link module:link/linkconfig~LinkConfig#decorators} are defined in the editor configuration, the state of
   * switch buttons responsible for manual decorator handling is restored.
   */
  _closeFormView() {
    const linkCommand = this.editor.commands.get("link");
    linkCommand.restoreManualDecoratorStates();
    if (linkCommand.value !== void 0) {
      this._removeFormView();
    } else {
      this._hideUI();
    }
  }
  /**
   * Removes the {@link #formView} from the {@link #_balloon}.
   */
  _removeFormView() {
    if (this._isFormInPanel) {
      this.formView.saveButtonView.focus();
      this._balloon.remove(this.formView);
      this.editor.editing.view.focus();
      this._hideFakeVisualSelection();
    }
  }
  /**
   * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
   *
   * @internal
   */
  _showUI(forceVisible = false) {
    if (!this.formView) {
      this._createViews();
    }
    if (!this._getSelectedLinkElement()) {
      this._showFakeVisualSelection();
      this._addActionsView();
      if (forceVisible) {
        this._balloon.showStack("main");
      }
      this._addFormView();
    } else {
      if (this._areActionsVisible) {
        this._addFormView();
      } else {
        this._addActionsView();
      }
      if (forceVisible) {
        this._balloon.showStack("main");
      }
    }
    this._startUpdatingUI();
  }
  /**
   * Removes the {@link #formView} from the {@link #_balloon}.
   *
   * See {@link #_addFormView}, {@link #_addActionsView}.
   */
  _hideUI() {
    if (!this._isUIInPanel) {
      return;
    }
    const editor = this.editor;
    this.stopListening(editor.ui, "update");
    this.stopListening(this._balloon, "change:visibleView");
    editor.editing.view.focus();
    this._removeFormView();
    this._balloon.remove(this.actionsView);
    this._hideFakeVisualSelection();
  }
  /**
   * Makes the UI react to the {@link module:ui/editorui/editorui~EditorUI#event:update} event to
   * reposition itself when the editor UI should be refreshed.
   *
   * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
   */
  _startUpdatingUI() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    let prevSelectedLink = this._getSelectedLinkElement();
    let prevSelectionParent = getSelectionParent();
    const update = () => {
      const selectedLink = this._getSelectedLinkElement();
      const selectionParent = getSelectionParent();
      if (prevSelectedLink && !selectedLink || !prevSelectedLink && selectionParent !== prevSelectionParent) {
        this._hideUI();
      } else if (this._isUIVisible) {
        this._balloon.updatePosition(this._getBalloonPositionData());
      }
      prevSelectedLink = selectedLink;
      prevSelectionParent = selectionParent;
    };
    function getSelectionParent() {
      return viewDocument.selection.focus.getAncestors().reverse().find((node) => node.is("element"));
    }
    this.listenTo(editor.ui, "update", update);
    this.listenTo(this._balloon, "change:visibleView", update);
  }
  /**
   * Returns `true` when {@link #formView} is in the {@link #_balloon}.
   */
  get _isFormInPanel() {
    return !!this.formView && this._balloon.hasView(this.formView);
  }
  /**
   * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
   */
  get _areActionsInPanel() {
    return !!this.actionsView && this._balloon.hasView(this.actionsView);
  }
  /**
   * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
   * currently visible.
   */
  get _areActionsVisible() {
    return !!this.actionsView && this._balloon.visibleView === this.actionsView;
  }
  /**
   * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
   */
  get _isUIInPanel() {
    return this._isFormInPanel || this._areActionsInPanel;
  }
  /**
   * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
   * currently visible.
   */
  get _isUIVisible() {
    const visibleView = this._balloon.visibleView;
    return !!this.formView && visibleView == this.formView || this._areActionsVisible;
  }
  /**
   * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
   * to the target element or selection.
   *
   * If the selection is collapsed and inside a link element, the panel will be attached to the
   * entire link element. Otherwise, it will be attached to the selection.
   */
  _getBalloonPositionData() {
    const view = this.editor.editing.view;
    const model = this.editor.model;
    const viewDocument = view.document;
    let target;
    if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
      const markerViewElements = Array.from(this.editor.editing.mapper.markerNameToElements(VISUAL_SELECTION_MARKER_NAME));
      const newRange = view.createRange(view.createPositionBefore(markerViewElements[0]), view.createPositionAfter(markerViewElements[markerViewElements.length - 1]));
      target = view.domConverter.viewRangeToDom(newRange);
    } else {
      target = () => {
        const targetLink = this._getSelectedLinkElement();
        return targetLink ? (
          // When selection is inside link element, then attach panel to this element.
          view.domConverter.mapViewToDom(targetLink)
        ) : (
          // Otherwise attach panel to the selection.
          view.domConverter.viewRangeToDom(viewDocument.selection.getFirstRange())
        );
      };
    }
    return { target };
  }
  /**
   * Returns the link {@link module:engine/view/attributeelement~AttributeElement} under
   * the {@link module:engine/view/document~Document editing view's} selection or `null`
   * if there is none.
   *
   * **Note**: For a nonâ€“collapsed selection, the link element is returned when **fully**
   * selected and the **only** element within the selection boundaries, or when
   * a linked widget is selected.
   */
  _getSelectedLinkElement() {
    const view = this.editor.editing.view;
    const selection = view.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (selection.isCollapsed || selectedElement && isWidget(selectedElement)) {
      return findLinkElementAncestor(selection.getFirstPosition());
    } else {
      const range = selection.getFirstRange().getTrimmed();
      const startLink = findLinkElementAncestor(range.start);
      const endLink = findLinkElementAncestor(range.end);
      if (!startLink || startLink != endLink) {
        return null;
      }
      if (view.createRangeIn(startLink).getTrimmed().isEqual(range)) {
        return startLink;
      } else {
        return null;
      }
    }
  }
  /**
   * Displays a fake visual selection when the contextual balloon is displayed.
   *
   * This adds a 'link-ui' marker into the document that is rendered as a highlight on selected text fragment.
   */
  _showFakeVisualSelection() {
    const model = this.editor.model;
    model.change((writer) => {
      const range = model.document.selection.getFirstRange();
      if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
        writer.updateMarker(VISUAL_SELECTION_MARKER_NAME, { range });
      } else {
        if (range.start.isAtEnd) {
          const startPosition = range.start.getLastMatchingPosition(({ item }) => !model.schema.isContent(item), { boundaries: range });
          writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
            usingOperation: false,
            affectsData: false,
            range: writer.createRange(startPosition, range.end)
          });
        } else {
          writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
            usingOperation: false,
            affectsData: false,
            range
          });
        }
      }
    });
  }
  /**
   * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
   */
  _hideFakeVisualSelection() {
    const model = this.editor.model;
    if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
      model.change((writer) => {
        writer.removeMarker(VISUAL_SELECTION_MARKER_NAME);
      });
    }
  }
};
function findLinkElementAncestor(position) {
  return position.getAncestors().find((ancestor) => isLinkElement(ancestor)) || null;
}

// node_modules/@ckeditor/ckeditor5-link/src/autolink.js
var MIN_LINK_LENGTH_WITH_SPACE_AT_END = 4;
var URL_REG_EXP = new RegExp(
  // Group 1: Line start or after a space.
  "(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
  "i"
);
var URL_GROUP_IN_MATCH = 2;
var AutoLink = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Delete];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AutoLink";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    selection.on("change:range", () => {
      this.isEnabled = !selection.anchor.parent.is("element", "codeBlock");
    });
    this._enableTypingHandling();
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    this._enableEnterHandling();
    this._enableShiftEnterHandling();
  }
  /**
   * Enables autolinking on typing.
   */
  _enableTypingHandling() {
    const editor = this.editor;
    const watcher = new TextWatcher(editor.model, (text) => {
      if (!isSingleSpaceAtTheEnd(text)) {
        return;
      }
      const url = getUrlAtTextEnd(text.substr(0, text.length - 1));
      if (url) {
        return { url };
      }
    });
    watcher.on("matched:data", (evt, data) => {
      const { batch, range, url } = data;
      if (!batch.isTyping) {
        return;
      }
      const linkEnd = range.end.getShiftedBy(-1);
      const linkStart = linkEnd.getShiftedBy(-url.length);
      const linkRange = editor.model.createRange(linkStart, linkEnd);
      this._applyAutoLink(url, linkRange);
    });
    watcher.bind("isEnabled").to(this);
  }
  /**
   * Enables autolinking on the <kbd>Enter</kbd> key.
   */
  _enableEnterHandling() {
    const editor = this.editor;
    const model = editor.model;
    const enterCommand = editor.commands.get("enter");
    if (!enterCommand) {
      return;
    }
    enterCommand.on("execute", () => {
      const position = model.document.selection.getFirstPosition();
      if (!position.parent.previousSibling) {
        return;
      }
      const rangeToCheck = model.createRangeIn(position.parent.previousSibling);
      this._checkAndApplyAutoLinkOnRange(rangeToCheck);
    });
  }
  /**
   * Enables autolinking on the <kbd>Shift</kbd>+<kbd>Enter</kbd> keyboard shortcut.
   */
  _enableShiftEnterHandling() {
    const editor = this.editor;
    const model = editor.model;
    const shiftEnterCommand = editor.commands.get("shiftEnter");
    if (!shiftEnterCommand) {
      return;
    }
    shiftEnterCommand.on("execute", () => {
      const position = model.document.selection.getFirstPosition();
      const rangeToCheck = model.createRange(model.createPositionAt(position.parent, 0), position.getShiftedBy(-1));
      this._checkAndApplyAutoLinkOnRange(rangeToCheck);
    });
  }
  /**
   * Checks if the passed range contains a linkable text.
   */
  _checkAndApplyAutoLinkOnRange(rangeToCheck) {
    const model = this.editor.model;
    const { text, range } = getLastTextLine(rangeToCheck, model);
    const url = getUrlAtTextEnd(text);
    if (url) {
      const linkRange = model.createRange(range.end.getShiftedBy(-url.length), range.end);
      this._applyAutoLink(url, linkRange);
    }
  }
  /**
   * Applies a link on a given range if the link should be applied.
   *
   * @param url The URL to link.
   * @param range The text range to apply the link attribute to.
   */
  _applyAutoLink(url, range) {
    const model = this.editor.model;
    const defaultProtocol = this.editor.config.get("link.defaultProtocol");
    const fullUrl = addLinkProtocolIfApplicable(url, defaultProtocol);
    if (!this.isEnabled || !isLinkAllowedOnRange(range, model) || !linkHasProtocol(fullUrl) || linkIsAlreadySet(range)) {
      return;
    }
    this._persistAutoLink(fullUrl, range);
  }
  /**
   * Enqueues autolink changes in the model.
   *
   * @param url The URL to link.
   * @param range The text range to apply the link attribute to.
   */
  _persistAutoLink(url, range) {
    const model = this.editor.model;
    const deletePlugin = this.editor.plugins.get("Delete");
    model.enqueueChange((writer) => {
      writer.setAttribute("linkHref", url, range);
      model.enqueueChange(() => {
        deletePlugin.requestUndoOnBackspace();
      });
    });
  }
};
function isSingleSpaceAtTheEnd(text) {
  return text.length > MIN_LINK_LENGTH_WITH_SPACE_AT_END && text[text.length - 1] === " " && text[text.length - 2] !== " ";
}
function getUrlAtTextEnd(text) {
  const match = URL_REG_EXP.exec(text);
  return match ? match[URL_GROUP_IN_MATCH] : null;
}
function isLinkAllowedOnRange(range, model) {
  return model.schema.checkAttributeInSelection(model.createSelection(range), "linkHref");
}
function linkIsAlreadySet(range) {
  const item = range.start.nodeAfter;
  return !!item && item.hasAttribute("linkHref");
}

// node_modules/@ckeditor/ckeditor5-link/src/link.js
var Link = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [LinkEditing, LinkUI, AutoLink];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Link";
  }
};

// node_modules/@ckeditor/ckeditor5-link/src/linkimageediting.js
var LinkImageEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return ["ImageEditing", "ImageUtils", LinkEditing];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkImageEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    if (editor.plugins.has("ImageBlockEditing")) {
      schema.extend("imageBlock", { allowAttributes: ["linkHref"] });
    }
    editor.conversion.for("upcast").add(upcastLink(editor));
    editor.conversion.for("downcast").add(downcastImageLink(editor));
    this._enableAutomaticDecorators();
    this._enableManualDecorators();
  }
  /**
   * Processes {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators} definitions and
   * attaches proper converters that will work when linking an image.`
   */
  _enableAutomaticDecorators() {
    const editor = this.editor;
    const command = editor.commands.get("link");
    const automaticDecorators = command.automaticDecorators;
    if (automaticDecorators.length) {
      editor.conversion.for("downcast").add(automaticDecorators.getDispatcherForLinkedImage());
    }
  }
  /**
   * Processes transformed {@link module:link/utils/manualdecorator~ManualDecorator} instances and attaches proper converters
   * that will work when linking an image.
   */
  _enableManualDecorators() {
    const editor = this.editor;
    const command = editor.commands.get("link");
    for (const decorator of command.manualDecorators) {
      if (editor.plugins.has("ImageBlockEditing")) {
        editor.model.schema.extend("imageBlock", { allowAttributes: decorator.id });
      }
      if (editor.plugins.has("ImageInlineEditing")) {
        editor.model.schema.extend("imageInline", { allowAttributes: decorator.id });
      }
      editor.conversion.for("downcast").add(downcastImageLinkManualDecorator(decorator));
      editor.conversion.for("upcast").add(upcastImageLinkManualDecorator(editor, decorator));
    }
  }
};
function upcastLink(editor) {
  const isImageInlinePluginLoaded = editor.plugins.has("ImageInlineEditing");
  const imageUtils = editor.plugins.get("ImageUtils");
  return (dispatcher) => {
    dispatcher.on("element:a", (evt, data, conversionApi) => {
      const viewLink = data.viewItem;
      const imageInLink = imageUtils.findViewImgElement(viewLink);
      if (!imageInLink) {
        return;
      }
      const blockImageView = imageInLink.findAncestor((element) => imageUtils.isBlockImageView(element));
      if (isImageInlinePluginLoaded && !blockImageView) {
        return;
      }
      const consumableAttributes = { attributes: ["href"] };
      if (!conversionApi.consumable.consume(viewLink, consumableAttributes)) {
        return;
      }
      const linkHref = viewLink.getAttribute("href");
      if (!linkHref) {
        return;
      }
      let modelElement = data.modelCursor.parent;
      if (!modelElement.is("element", "imageBlock")) {
        const conversionResult = conversionApi.convertItem(imageInLink, data.modelCursor);
        data.modelRange = conversionResult.modelRange;
        data.modelCursor = conversionResult.modelCursor;
        modelElement = data.modelCursor.nodeBefore;
      }
      if (modelElement && modelElement.is("element", "imageBlock")) {
        conversionApi.writer.setAttribute("linkHref", linkHref, modelElement);
      }
    }, { priority: "high" });
  };
}
function downcastImageLink(editor) {
  const imageUtils = editor.plugins.get("ImageUtils");
  return (dispatcher) => {
    dispatcher.on("attribute:linkHref:imageBlock", (evt, data, conversionApi) => {
      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }
      const viewFigure = conversionApi.mapper.toViewElement(data.item);
      const writer = conversionApi.writer;
      const linkInImage = Array.from(viewFigure.getChildren()).find((child) => child.is("element", "a"));
      const viewImage = imageUtils.findViewImgElement(viewFigure);
      const viewImgOrPicture = viewImage.parent.is("element", "picture") ? viewImage.parent : viewImage;
      if (linkInImage) {
        if (data.attributeNewValue) {
          writer.setAttribute("href", data.attributeNewValue, linkInImage);
        } else {
          writer.move(writer.createRangeOn(viewImgOrPicture), writer.createPositionAt(viewFigure, 0));
          writer.remove(linkInImage);
        }
      } else {
        const linkElement = writer.createContainerElement("a", { href: data.attributeNewValue });
        writer.insert(writer.createPositionAt(viewFigure, 0), linkElement);
        writer.move(writer.createRangeOn(viewImgOrPicture), writer.createPositionAt(linkElement, 0));
      }
    }, { priority: "high" });
  };
}
function downcastImageLinkManualDecorator(decorator) {
  return (dispatcher) => {
    dispatcher.on(`attribute:${decorator.id}:imageBlock`, (evt, data, conversionApi) => {
      const viewFigure = conversionApi.mapper.toViewElement(data.item);
      const linkInImage = Array.from(viewFigure.getChildren()).find((child) => child.is("element", "a"));
      if (!linkInImage) {
        return;
      }
      for (const [key, val] of toMap(decorator.attributes)) {
        conversionApi.writer.setAttribute(key, val, linkInImage);
      }
      if (decorator.classes) {
        conversionApi.writer.addClass(decorator.classes, linkInImage);
      }
      for (const key in decorator.styles) {
        conversionApi.writer.setStyle(key, decorator.styles[key], linkInImage);
      }
    });
  };
}
function upcastImageLinkManualDecorator(editor, decorator) {
  const isImageInlinePluginLoaded = editor.plugins.has("ImageInlineEditing");
  const imageUtils = editor.plugins.get("ImageUtils");
  return (dispatcher) => {
    dispatcher.on("element:a", (evt, data, conversionApi) => {
      const viewLink = data.viewItem;
      const imageInLink = imageUtils.findViewImgElement(viewLink);
      if (!imageInLink) {
        return;
      }
      const blockImageView = imageInLink.findAncestor((element) => imageUtils.isBlockImageView(element));
      if (isImageInlinePluginLoaded && !blockImageView) {
        return;
      }
      const matcher = new Matcher(decorator._createPattern());
      const result = matcher.match(viewLink);
      if (!result) {
        return;
      }
      if (!conversionApi.consumable.consume(viewLink, result.match)) {
        return;
      }
      const modelElement = data.modelCursor.nodeBefore || data.modelCursor.parent;
      conversionApi.writer.setAttribute(decorator.id, true, modelElement);
    }, { priority: "high" });
  };
}

// node_modules/@ckeditor/ckeditor5-link/src/linkimageui.js
import linkIcon2 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-link/theme/icons/link.svg";
var LinkImageUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [LinkEditing, LinkUI, "ImageBlockEditing"];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkImageUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    this.listenTo(viewDocument, "click", (evt, data) => {
      if (this._isSelectedLinkedImage(editor.model.document.selection)) {
        data.preventDefault();
        evt.stop();
      }
    }, { priority: "high" });
    this._createToolbarLinkImageButton();
  }
  /**
   * Creates a `LinkImageUI` button view.
   *
   * Clicking this button shows a {@link module:link/linkui~LinkUI#_balloon} attached to the selection.
   * When an image is already linked, the view shows {@link module:link/linkui~LinkUI#actionsView} or
   * {@link module:link/linkui~LinkUI#formView} if it is not.
   */
  _createToolbarLinkImageButton() {
    const editor = this.editor;
    const t = editor.t;
    editor.ui.componentFactory.add("linkImage", (locale) => {
      const button = new ButtonView(locale);
      const plugin = editor.plugins.get("LinkUI");
      const linkCommand = editor.commands.get("link");
      button.set({
        isEnabled: true,
        label: t("Link image"),
        icon: linkIcon2,
        keystroke: LINK_KEYSTROKE,
        tooltip: true,
        isToggleable: true
      });
      button.bind("isEnabled").to(linkCommand, "isEnabled");
      button.bind("isOn").to(linkCommand, "value", (value) => !!value);
      this.listenTo(button, "execute", () => {
        if (this._isSelectedLinkedImage(editor.model.document.selection)) {
          plugin._addActionsView();
        } else {
          plugin._showUI(true);
        }
      });
      return button;
    });
  }
  /**
   * Returns true if a linked image (either block or inline) is the only selected element
   * in the model document.
   */
  _isSelectedLinkedImage(selection) {
    const selectedModelElement = selection.getSelectedElement();
    const imageUtils = this.editor.plugins.get("ImageUtils");
    return imageUtils.isImage(selectedModelElement) && selectedModelElement.hasAttribute("linkHref");
  }
};

// node_modules/@ckeditor/ckeditor5-link/src/linkimage.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-link/theme/linkimage.css";
var LinkImage = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [LinkImageEditing, LinkImageUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "LinkImage";
  }
};
export {
  AutoLink,
  Link,
  LinkCommand,
  LinkEditing,
  LinkImage,
  LinkImageEditing,
  LinkImageUI,
  LinkUI,
  UnlinkCommand
};
/*! Bundled license information:

@ckeditor/ckeditor5-link/src/utils/automaticdecorators.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/linkcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/unlinkcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/utils/manualdecorator.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/linkediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/ui/linkformview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/ui/linkactionsview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/linkui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/autolink.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/link.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/linkimageediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/linkimageui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/linkimage.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-link/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-link.js.map
