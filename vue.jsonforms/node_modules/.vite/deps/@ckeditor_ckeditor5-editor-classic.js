import {
  ContextWatchdog,
  EditorWatchdog
} from "./chunk-T7VM5LCJ.js";
import "./chunk-DEIZSOIF.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  BoxedEditorUIView,
  EditorUI,
  InlineEditableUIView,
  StickyPanelView,
  ToolbarView,
  normalizeToolbarConfig
} from "./chunk-SGTDNT4V.js";
import "./chunk-6LVMAMLV.js";
import {
  CKEditorError,
  Context,
  DataApiMixin,
  Editor,
  ElementApiMixin,
  ElementReplacer,
  Rect,
  attachToForm,
  enablePlaceholder,
  getDataFromElement
} from "./chunk-JI2V5GJZ.js";
import {
  isElement_default
} from "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditorui.js
var ClassicEditorUI = class extends EditorUI {
  /**
   * Creates an instance of the classic editor UI class.
   *
   * @param editor The editor instance.
   * @param view The view of the UI.
   */
  constructor(editor, view) {
    super(editor);
    this.view = view;
    this._toolbarConfig = normalizeToolbarConfig(editor.config.get("toolbar"));
    this._elementReplacer = new ElementReplacer();
    this.listenTo(editor.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this));
  }
  /**
   * @inheritDoc
   */
  get element() {
    return this.view.element;
  }
  /**
   * Initializes the UI.
   *
   * @param replacementElement The DOM element that will be the source for the created editor.
   */
  init(replacementElement) {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    view.editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    if (replacementElement) {
      this._elementReplacer.replace(replacementElement, this.element);
    }
    this._initPlaceholder();
    this._initToolbar();
    this.fire("ready");
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    this._elementReplacer.restore();
    editingView.detachDomRoot(view.editable.name);
    view.destroy();
  }
  /**
   * Initializes the editor toolbar.
   */
  _initToolbar() {
    const view = this.view;
    view.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
    view.stickyPanel.limiterElement = view.element;
    view.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top }) => top || 0);
    view.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
    this.addToolbar(view.toolbar);
  }
  /**
   * Enable the placeholder text on the editing root.
   */
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const sourceElement = editor.sourceElement;
    let placeholderText;
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      placeholderText = typeof placeholder === "string" ? placeholder : placeholder[this.view.editable.name];
    }
    if (!placeholderText && sourceElement && sourceElement.tagName.toLowerCase() === "textarea") {
      placeholderText = sourceElement.getAttribute("placeholder");
    }
    if (placeholderText) {
      editingRoot.placeholder = placeholderText;
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
  /**
   * Provides an integration between the sticky toolbar and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
   * It allows the UI-agnostic engine method to consider the geometry of the
   * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel} that pins to the
   * edge of the viewport and can obscure the user caret after scrolling the window.
   *
   * @param evt The `scrollToTheSelection` event info.
   * @param data The payload carried by the `scrollToTheSelection` event.
   * @param originalArgs The original arguments passed to `scrollViewportToShowTarget()` method (see implementation to learn more).
   */
  _handleScrollToTheSelectionWithStickyPanel(evt, data, originalArgs) {
    const stickyPanel = this.view.stickyPanel;
    if (stickyPanel.isSticky) {
      const stickyPanelHeight = new Rect(stickyPanel.element).height;
      data.viewportOffset.top += stickyPanelHeight;
    } else {
      const scrollViewportOnPanelGettingSticky = () => {
        this.editor.editing.view.scrollToTheSelection(originalArgs);
      };
      this.listenTo(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
      setTimeout(() => {
        this.stopListening(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
      }, 20);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditoruiview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css";
var ClassicEditorUIView = class extends BoxedEditorUIView {
  /**
   * Creates an instance of the classic editor UI view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param editingView The editing view instance this view is related to.
   * @param options Configuration options for the view instance.
   * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
   * in the main {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#toolbar toolbar}.
   * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
   */
  constructor(locale, editingView, options = {}) {
    super(locale);
    this.stickyPanel = new StickyPanelView(locale);
    this.toolbar = new ToolbarView(locale, {
      shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
    });
    this.editable = new InlineEditableUIView(locale, editingView);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.stickyPanel.content.add(this.toolbar);
    this.top.add(this.stickyPanel);
    this.main.add(this.editable);
  }
};

// node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditor.js
var ClassicEditor = class extends DataApiMixin(ElementApiMixin(Editor)) {
  /**
   * Creates an instance of the classic editor.
   *
   * **Note:** do not use the constructor to create editor instances. Use the static
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data. For more information see
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
   * @param config The editor configuration.
   */
  constructor(sourceElementOrData, config = {}) {
    if (!isElement(sourceElementOrData) && config.initialData !== void 0) {
      throw new CKEditorError("editor-create-initial-data", null);
    }
    super(config);
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData(sourceElementOrData));
    }
    if (isElement(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
    }
    this.model.document.createRoot();
    const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
    const view = new ClassicEditorUIView(this.locale, this.editing.view, {
      shouldToolbarGroupWhenFull
    });
    this.ui = new ClassicEditorUI(this, view);
    attachToForm(this);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * Updates the original editor element with the data if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
   * configuration option is set to `true`.
   */
  destroy() {
    if (this.sourceElement) {
      this.updateSourceElement();
    }
    this.ui.destroy();
    return super.destroy();
  }
  /**
   * Creates a new classic editor instance.
   *
   * There are three ways how the editor can be initialized.
   *
   * # Replacing a DOM element (and loading data from it)
   *
   * You can initialize the editor using an existing DOM element:
   *
   * ```ts
   * ClassicEditor
   * 	.create( document.querySelector( '#editor' ) )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * The element's content will be used as the editor data and the element will be replaced by the editor UI.
   *
   * # Creating a detached editor
   *
   * Alternatively, you can initialize the editor by passing the initial data directly as a string.
   * In this case, the editor will render an element that must be inserted into the DOM:
   *
   * ```ts
   * ClassicEditor
   * 	.create( '<p>Hello world!</p>' )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   *
   * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
   * 		document.body.appendChild( editor.ui.element );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
   * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
   *
   * # Replacing a DOM element (and data provided in `config.initialData`)
   *
   * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
   *
   * ```ts
   * ClassicEditor
   * 	.create( document.querySelector( '#editor' ), {
   * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
   * 	} )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
   * makes it difficult to set the content of the source element.
   *
   * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
   *
   * # Configuring the editor
   *
   * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
   * customizing plugins, toolbar and more.
   *
   * # Using the editor from source
   *
   * The code samples listed in the previous sections of this documentation assume that you are using an
   * {@glink installation/getting-started/predefined-builds editor build} (for example – `@ckeditor/ckeditor5-build-classic`).
   *
   * If you want to use the classic editor from source (`@ckeditor/ckeditor5-editor-classic/src/classiceditor`),
   * you need to define the list of
   * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
   * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}. Read more about using the editor from
   * source in the {@glink installation/advanced/alternative-setups/integrating-from-source-webpack dedicated guide}.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data.
   *
   * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization
   * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element
   * in the DOM (the original one will be hidden and the editor will be injected next to it).
   *
   * If the {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
   * option is set to `true`, the editor data will be set back to the original element once the editor is destroyed and when a form,
   * in which this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration
   * with native web forms.
   *
   * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
   * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.
   *
   * @param config The editor configuration.
   * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
   */
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init(isElement(sourceElementOrData) ? sourceElementOrData : null)).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
ClassicEditor.Context = Context;
ClassicEditor.EditorWatchdog = EditorWatchdog;
ClassicEditor.ContextWatchdog = ContextWatchdog;
function getInitialData(sourceElementOrData) {
  return isElement(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement(value) {
  return isElement_default(value);
}
export {
  ClassicEditor
};
/*! Bundled license information:

@ckeditor/ckeditor5-editor-classic/src/classiceditorui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-classic/src/classiceditoruiview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/watchdog.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-classic/src/classiceditor.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-classic/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-editor-classic.js.map
