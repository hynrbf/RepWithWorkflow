{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-paste-from-office/src/filters/list.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/image.js", "../../@ckeditor/ckeditor5-paste-from-office/src/normalizers/mswordnormalizer.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removeboldwrapper.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/br.js", "../../@ckeditor/ckeditor5-paste-from-office/src/normalizers/googledocsnormalizer.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removexmlns.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removegooglesheetstag.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removeinvalidtablewidth.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/removestyleblock.js", "../../@ckeditor/ckeditor5-paste-from-office/src/normalizers/googlesheetsnormalizer.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/space.js", "../../@ckeditor/ckeditor5-paste-from-office/src/filters/parse.js", "../../@ckeditor/ckeditor5-paste-from-office/src/pastefromoffice.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/list\n */\nimport { Matcher, UpcastWriter } from 'ckeditor5/src/engine';\n/**\n * Transforms Word specific list-like elements to the semantic HTML lists.\n *\n * Lists in Word are represented by block elements with special attributes like:\n *\n * ```xml\n * <p class=MsoListParagraphCxSpFirst style='mso-list:l1 level1 lfo1'>...</p> // Paragraph based list.\n * <h1 style='mso-list:l0 level1 lfo1'>...</h1> // Heading 1 based list.\n * ```\n *\n * @param documentFragment The view structure to be transformed.\n * @param stylesString Styles from which list-like elements styling will be extracted.\n */\nexport function transformListItemLikeElementsIntoLists(documentFragment, stylesString) {\n    if (!documentFragment.childCount) {\n        return;\n    }\n    const writer = new UpcastWriter(documentFragment.document);\n    const itemLikeElements = findAllItemLikeElements(documentFragment, writer);\n    if (!itemLikeElements.length) {\n        return;\n    }\n    let currentList = null;\n    let currentIndentation = 1;\n    itemLikeElements.forEach((itemLikeElement, i) => {\n        const isDifferentList = isNewListNeeded(itemLikeElements[i - 1], itemLikeElement);\n        const previousItemLikeElement = isDifferentList ? null : itemLikeElements[i - 1];\n        const indentationDifference = getIndentationDifference(previousItemLikeElement, itemLikeElement);\n        if (isDifferentList) {\n            currentList = null;\n            currentIndentation = 1;\n        }\n        if (!currentList || indentationDifference !== 0) {\n            const listStyle = detectListStyle(itemLikeElement, stylesString);\n            if (!currentList) {\n                currentList = insertNewEmptyList(listStyle, itemLikeElement.element, writer);\n            }\n            else if (itemLikeElement.indent > currentIndentation) {\n                const lastListItem = currentList.getChild(currentList.childCount - 1);\n                const lastListItemChild = lastListItem.getChild(lastListItem.childCount - 1);\n                currentList = insertNewEmptyList(listStyle, lastListItemChild, writer);\n                currentIndentation += 1;\n            }\n            else if (itemLikeElement.indent < currentIndentation) {\n                const differentIndentation = currentIndentation - itemLikeElement.indent;\n                currentList = findParentListAtLevel(currentList, differentIndentation);\n                currentIndentation = itemLikeElement.indent;\n            }\n            if (itemLikeElement.indent <= currentIndentation) {\n                if (!currentList.is('element', listStyle.type)) {\n                    currentList = writer.rename(listStyle.type, currentList);\n                }\n            }\n        }\n        const listItem = transformElementIntoListItem(itemLikeElement.element, writer);\n        writer.appendChild(listItem, currentList);\n    });\n}\n/**\n * Removes paragraph wrapping content inside a list item.\n */\nexport function unwrapParagraphInListItem(documentFragment, writer) {\n    for (const value of writer.createRangeIn(documentFragment)) {\n        const element = value.item;\n        if (element.is('element', 'li')) {\n            // Google Docs allows for single paragraph inside LI.\n            const firstChild = element.getChild(0);\n            if (firstChild && firstChild.is('element', 'p')) {\n                writer.unwrapElement(firstChild);\n            }\n        }\n    }\n}\n/**\n * Finds all list-like elements in a given document fragment.\n *\n * @param documentFragment Document fragment in which to look for list-like nodes.\n * @returns Array of found list-like items. Each item is an object containing:\n */\nfunction findAllItemLikeElements(documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    // Matcher for finding list-like elements.\n    const itemLikeElementsMatcher = new Matcher({\n        name: /^p|h\\d+$/,\n        styles: {\n            'mso-list': /.*/\n        }\n    });\n    const itemLikeElements = [];\n    for (const value of range) {\n        if (value.type === 'elementStart' && itemLikeElementsMatcher.match(value.item)) {\n            const itemData = getListItemData(value.item);\n            itemLikeElements.push({\n                element: value.item,\n                id: itemData.id,\n                order: itemData.order,\n                indent: itemData.indent\n            });\n        }\n    }\n    return itemLikeElements;\n}\n/**\n * Extracts list item style from the provided CSS.\n *\n * List item style is extracted from the CSS stylesheet. Each list with its specific style attribute\n * value (`mso-list:l1 level1 lfo1`) has its dedicated properties in a CSS stylesheet defined with a selector like:\n *\n * ```css\n * @list l1:level1 { ... }\n * ```\n *\n * It contains `mso-level-number-format` property which defines list numbering/bullet style. If this property\n * is not defined it means default `decimal` numbering.\n *\n * Here CSS string representation is used as `mso-level-number-format` property is an invalid CSS property\n * and will be removed during CSS parsing.\n *\n * @param listLikeItem List-like item for which list style will be searched for. Usually\n * a result of `findAllItemLikeElements()` function.\n * @param stylesString CSS stylesheet.\n * @returns An object with properties:\n *\n * * type - List type, could be `ul` or `ol`.\n * * startIndex - List start index, valid only for ordered lists.\n * * style - List style, for example: `decimal`, `lower-roman`, etc. It is extracted\n *     directly from Word stylesheet and adjusted to represent proper values for the CSS `list-style-type` property.\n *     If it cannot be adjusted, the `null` value is returned.\n */\nfunction detectListStyle(listLikeItem, stylesString) {\n    const listStyleRegexp = new RegExp(`@list l${listLikeItem.id}:level${listLikeItem.indent}\\\\s*({[^}]*)`, 'gi');\n    const listStyleTypeRegex = /mso-level-number-format:([^;]{0,100});/gi;\n    const listStartIndexRegex = /mso-level-start-at:\\s{0,100}([0-9]{0,10})\\s{0,100};/gi;\n    const listStyleMatch = listStyleRegexp.exec(stylesString);\n    let listStyleType = 'decimal'; // Decimal is default one.\n    let type = 'ol'; // <ol> is default list.\n    let startIndex = null;\n    if (listStyleMatch && listStyleMatch[1]) {\n        const listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);\n        if (listStyleTypeMatch && listStyleTypeMatch[1]) {\n            listStyleType = listStyleTypeMatch[1].trim();\n            type = listStyleType !== 'bullet' && listStyleType !== 'image' ? 'ol' : 'ul';\n        }\n        // Styles for the numbered lists are always defined in the Word CSS stylesheet.\n        // Unordered lists MAY contain a value for the Word CSS definition `mso-level-text` but sometimes\n        // this tag is missing. And because of that, we cannot depend on that. We need to predict the list style value\n        // based on the list style marker element.\n        if (listStyleType === 'bullet') {\n            const bulletedStyle = findBulletedListStyle(listLikeItem.element);\n            if (bulletedStyle) {\n                listStyleType = bulletedStyle;\n            }\n        }\n        else {\n            const listStartIndexMatch = listStartIndexRegex.exec(listStyleMatch[1]);\n            if (listStartIndexMatch && listStartIndexMatch[1]) {\n                startIndex = parseInt(listStartIndexMatch[1]);\n            }\n        }\n    }\n    return {\n        type,\n        startIndex,\n        style: mapListStyleDefinition(listStyleType)\n    };\n}\n/**\n * Tries to extract the `list-style-type` value based on the marker element for bulleted list.\n */\nfunction findBulletedListStyle(element) {\n    const listMarkerElement = findListMarkerNode(element);\n    if (!listMarkerElement) {\n        return null;\n    }\n    const listMarker = listMarkerElement._data;\n    if (listMarker === 'o') {\n        return 'circle';\n    }\n    else if (listMarker === '·') {\n        return 'disc';\n    }\n    // Word returns '§' instead of '■' for the square list style.\n    else if (listMarker === '§') {\n        return 'square';\n    }\n    return null;\n}\n/**\n * Tries to find a text node that represents the marker element (list-style-type).\n */\nfunction findListMarkerNode(element) {\n    // If the first child is a text node, it is the data for the element.\n    // The list-style marker is not present here.\n    if (element.getChild(0).is('$text')) {\n        return null;\n    }\n    for (const childNode of element.getChildren()) {\n        // The list-style marker will be inside the `<span>` element. Let's ignore all non-span elements.\n        // It may happen that the `<a>` element is added as the first child. Most probably, it's an anchor element.\n        if (!childNode.is('element', 'span')) {\n            continue;\n        }\n        const textNodeOrElement = childNode.getChild(0);\n        if (!textNodeOrElement) {\n            continue;\n        }\n        // If already found the marker element, use it.\n        if (textNodeOrElement.is('$text')) {\n            return textNodeOrElement;\n        }\n        return textNodeOrElement.getChild(0);\n    }\n    /* istanbul ignore next -- @preserve */\n    return null;\n}\n/**\n * Parses the `list-style-type` value extracted directly from the Word CSS stylesheet and returns proper CSS definition.\n */\nfunction mapListStyleDefinition(value) {\n    if (value.startsWith('arabic-leading-zero')) {\n        return 'decimal-leading-zero';\n    }\n    switch (value) {\n        case 'alpha-upper':\n            return 'upper-alpha';\n        case 'alpha-lower':\n            return 'lower-alpha';\n        case 'roman-upper':\n            return 'upper-roman';\n        case 'roman-lower':\n            return 'lower-roman';\n        case 'circle':\n        case 'disc':\n        case 'square':\n            return value;\n        default:\n            return null;\n    }\n}\n/**\n * Creates an empty list of a given type and inserts it after a specified element.\n *\n * @param listStyle List style object which determines the type of newly created list.\n * Usually a result of `detectListStyle()` function.\n * @param element Element after which list is inserted.\n * @returns Newly created list element.\n */\nfunction insertNewEmptyList(listStyle, element, writer) {\n    const parent = element.parent;\n    const list = writer.createElement(listStyle.type);\n    const position = parent.getChildIndex(element) + 1;\n    writer.insertChild(position, list, parent);\n    // We do not support modifying the marker for a particular list item.\n    // Set the value for the `list-style-type` property directly to the list container.\n    if (listStyle.style) {\n        writer.setStyle('list-style-type', listStyle.style, list);\n    }\n    if (listStyle.startIndex && listStyle.startIndex > 1) {\n        writer.setAttribute('start', listStyle.startIndex, list);\n    }\n    return list;\n}\n/**\n * Transforms a given element into a semantic list item. As the function operates on a provided\n * {module:engine/src/view/element~Element element} it will modify the view structure to which this element belongs.\n *\n * @param element Element which will be transformed into a list item.\n * @returns New element to which the given one was transformed. It is\n * inserted in place of the old element (the reference to the old element is lost due to renaming).\n */\nfunction transformElementIntoListItem(element, writer) {\n    removeBulletElement(element, writer);\n    writer.removeStyle('text-indent', element); // #12361\n    return writer.rename('li', element);\n}\n/**\n * Extracts list item information from Word specific list-like element style:\n *\n * ```\n * `style=\"mso-list:l1 level1 lfo1\"`\n * ```\n *\n * where:\n *\n * ```\n * * `l1` is a list id (however it does not mean this is a continuous list - see #43),\n * * `level1` is a list item indentation level,\n * * `lfo1` is a list insertion order in a document.\n * ```\n *\n * @param element Element from which style data is extracted.\n */\nfunction getListItemData(element) {\n    const data = {};\n    const listStyle = element.getStyle('mso-list');\n    if (listStyle) {\n        const idMatch = listStyle.match(/(^|\\s{1,100})l(\\d+)/i);\n        const orderMatch = listStyle.match(/\\s{0,100}lfo(\\d+)/i);\n        const indentMatch = listStyle.match(/\\s{0,100}level(\\d+)/i);\n        if (idMatch && orderMatch && indentMatch) {\n            data.id = idMatch[2];\n            data.order = orderMatch[1];\n            data.indent = parseInt(indentMatch[1]);\n        }\n    }\n    return data;\n}\n/**\n * Removes span with a numbering/bullet from a given element.\n */\nfunction removeBulletElement(element, writer) {\n    // Matcher for finding `span` elements holding lists numbering/bullets.\n    const bulletMatcher = new Matcher({\n        name: 'span',\n        styles: {\n            'mso-list': 'Ignore'\n        }\n    });\n    const range = writer.createRangeIn(element);\n    for (const value of range) {\n        if (value.type === 'elementStart' && bulletMatcher.match(value.item)) {\n            writer.remove(value.item);\n        }\n    }\n}\n/**\n * Whether the previous and current items belong to the same list. It is determined based on `item.id`\n * (extracted from `mso-list` style, see #getListItemData) and a previous sibling of the current item.\n *\n * However, it's quite easy to change the `id` attribute for nested lists in Word. It will break the list feature while pasting.\n * Let's check also the `indent` attribute. If the difference between those two elements is equal to 1, we can assume that\n * the `currentItem` is a beginning of the nested list because lists in CKEditor 5 always start with the `indent=0` attribute.\n * See: https://github.com/ckeditor/ckeditor5/issues/7805.\n */\nfunction isNewListNeeded(previousItem, currentItem) {\n    if (!previousItem) {\n        return true;\n    }\n    if (previousItem.id !== currentItem.id) {\n        // See: https://github.com/ckeditor/ckeditor5/issues/7805.\n        //\n        // * List item 1.\n        //     - Nested list item 1.\n        if (currentItem.indent - previousItem.indent === 1) {\n            return false;\n        }\n        return true;\n    }\n    const previousSibling = currentItem.element.previousSibling;\n    if (!previousSibling) {\n        return true;\n    }\n    // Even with the same id the list does not have to be continuous (#43).\n    return !isList(previousSibling);\n}\nfunction isList(element) {\n    return element.is('element', 'ol') || element.is('element', 'ul');\n}\n/**\n * Calculates the indentation difference between two given list items (based on the indent attribute\n * extracted from the `mso-list` style, see #getListItemData).\n */\nfunction getIndentationDifference(previousItem, currentItem) {\n    return previousItem ? currentItem.indent - previousItem.indent : currentItem.indent - 1;\n}\n/**\n * Finds the parent list element (ul/ol) of a given list element with indentation level lower by a given value.\n *\n * @param listElement List element from which to start looking for a parent list.\n * @param indentationDifference Indentation difference between lists.\n * @returns Found list element with indentation level lower by a given value.\n */\nfunction findParentListAtLevel(listElement, indentationDifference) {\n    const ancestors = listElement.getAncestors({ parentFirst: true });\n    let parentList = null;\n    let levelChange = 0;\n    for (const ancestor of ancestors) {\n        if (ancestor.is('element', 'ul') || ancestor.is('element', 'ol')) {\n            levelChange++;\n        }\n        if (levelChange === indentationDifference) {\n            parentList = ancestor;\n            break;\n        }\n    }\n    return parentList;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/image\n */\n/* globals btoa */\nimport { Matcher, UpcastWriter } from 'ckeditor5/src/engine';\n/**\n * Replaces source attribute of all `<img>` elements representing regular\n * images (not the Word shapes) with inlined base64 image representation extracted from RTF or Blob data.\n *\n * @param documentFragment Document fragment on which transform images.\n * @param rtfData The RTF data from which images representation will be used.\n */\nexport function replaceImagesSourceWithBase64(documentFragment, rtfData) {\n    if (!documentFragment.childCount) {\n        return;\n    }\n    const upcastWriter = new UpcastWriter(documentFragment.document);\n    const shapesIds = findAllShapesIds(documentFragment, upcastWriter);\n    removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);\n    insertMissingImgs(shapesIds, documentFragment, upcastWriter);\n    removeAllShapeElements(documentFragment, upcastWriter);\n    const images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);\n    if (images.length) {\n        replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);\n    }\n}\n/**\n * Converts given HEX string to base64 representation.\n *\n * @internal\n * @param hexString The HEX string to be converted.\n * @returns Base64 representation of a given HEX string.\n */\nexport function _convertHexToBase64(hexString) {\n    return btoa(hexString.match(/\\w{2}/g).map(char => {\n        return String.fromCharCode(parseInt(char, 16));\n    }).join(''));\n}\n/**\n * Finds all shapes (`<v:*>...</v:*>`) ids. Shapes can represent images (canvas)\n * or Word shapes (which does not have RTF or Blob representation).\n *\n * @param documentFragment Document fragment from which to extract shape ids.\n * @returns Array of shape ids.\n */\nfunction findAllShapesIds(documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const shapeElementsMatcher = new Matcher({\n        name: /v:(.+)/\n    });\n    const shapesIds = [];\n    for (const value of range) {\n        if (value.type != 'elementStart') {\n            continue;\n        }\n        const el = value.item;\n        const previousSibling = el.previousSibling;\n        const prevSiblingName = previousSibling && previousSibling.is('element') ? previousSibling.name : null;\n        // If shape element have 'o:gfxdata' attribute and is not directly before `<v:shapetype>` element it means it represent Word shape.\n        if (shapeElementsMatcher.match(el) && el.getAttribute('o:gfxdata') && prevSiblingName !== 'v:shapetype') {\n            shapesIds.push(value.item.getAttribute('id'));\n        }\n    }\n    return shapesIds;\n}\n/**\n * Removes all `<img>` elements which represents Word shapes and not regular images.\n *\n * @param shapesIds Shape ids which will be checked against `<img>` elements.\n * @param documentFragment Document fragment from which to remove `<img>` elements.\n */\nfunction removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const imageElementsMatcher = new Matcher({\n        name: 'img'\n    });\n    const imgs = [];\n    for (const value of range) {\n        if (value.item.is('element') && imageElementsMatcher.match(value.item)) {\n            const el = value.item;\n            const shapes = el.getAttribute('v:shapes') ? el.getAttribute('v:shapes').split(' ') : [];\n            if (shapes.length && shapes.every(shape => shapesIds.indexOf(shape) > -1)) {\n                imgs.push(el);\n                // Shapes may also have empty source while content is paste in some browsers (Safari).\n            }\n            else if (!el.getAttribute('src')) {\n                imgs.push(el);\n            }\n        }\n    }\n    for (const img of imgs) {\n        writer.remove(img);\n    }\n}\n/**\n * Removes all shape elements (`<v:*>...</v:*>`) so they do not pollute the output structure.\n *\n * @param documentFragment Document fragment from which to remove shape elements.\n */\nfunction removeAllShapeElements(documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const shapeElementsMatcher = new Matcher({\n        name: /v:(.+)/\n    });\n    const shapes = [];\n    for (const value of range) {\n        if (value.type == 'elementStart' && shapeElementsMatcher.match(value.item)) {\n            shapes.push(value.item);\n        }\n    }\n    for (const shape of shapes) {\n        writer.remove(shape);\n    }\n}\n/**\n * Inserts `img` tags if there is none after a shape.\n */\nfunction insertMissingImgs(shapeIds, documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const shapes = [];\n    for (const value of range) {\n        if (value.type == 'elementStart' && value.item.is('element', 'v:shape')) {\n            const id = value.item.getAttribute('id');\n            if (shapeIds.includes(id)) {\n                continue;\n            }\n            if (!containsMatchingImg(value.item.parent.getChildren(), id)) {\n                shapes.push(value.item);\n            }\n        }\n    }\n    for (const shape of shapes) {\n        const attrs = {\n            src: findSrc(shape)\n        };\n        if (shape.hasAttribute('alt')) {\n            attrs.alt = shape.getAttribute('alt');\n        }\n        const img = writer.createElement('img', attrs);\n        writer.insertChild(shape.index + 1, img, shape.parent);\n    }\n    function containsMatchingImg(nodes, id) {\n        for (const node of nodes) {\n            /* istanbul ignore else -- @preserve */\n            if (node.is('element')) {\n                if (node.name == 'img' && node.getAttribute('v:shapes') == id) {\n                    return true;\n                }\n                if (containsMatchingImg(node.getChildren(), id)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    function findSrc(shape) {\n        for (const child of shape.getChildren()) {\n            /* istanbul ignore else -- @preserve */\n            if (child.is('element') && child.getAttribute('src')) {\n                return child.getAttribute('src');\n            }\n        }\n    }\n}\n/**\n * Finds all `<img>` elements in a given document fragment which have source pointing to local `file://` resource.\n *\n * @param documentFragment Document fragment in which to look for `<img>` elements.\n * @returns result All found images grouped by source type.\n */\nfunction findAllImageElementsWithLocalSource(documentFragment, writer) {\n    const range = writer.createRangeIn(documentFragment);\n    const imageElementsMatcher = new Matcher({\n        name: 'img'\n    });\n    const imgs = [];\n    for (const value of range) {\n        if (value.item.is('element') && imageElementsMatcher.match(value.item)) {\n            if (value.item.getAttribute('src').startsWith('file://')) {\n                imgs.push(value.item);\n            }\n        }\n    }\n    return imgs;\n}\n/**\n * Extracts all images HEX representations from a given RTF data.\n *\n * @param rtfData The RTF data from which to extract images HEX representation.\n * @returns Array of found HEX representations. Each array item is an object containing:\n *\n * * hex Image representation in HEX format.\n * * type Type of image, `image/png` or `image/jpeg`.\n */\nfunction extractImageDataFromRtf(rtfData) {\n    if (!rtfData) {\n        return [];\n    }\n    const regexPictureHeader = /{\\\\pict[\\s\\S]+?\\\\bliptag-?\\d+(\\\\blipupi-?\\d+)?({\\\\\\*\\\\blipuid\\s?[\\da-fA-F]+)?[\\s}]*?/;\n    const regexPicture = new RegExp('(?:(' + regexPictureHeader.source + '))([\\\\da-fA-F\\\\s]+)\\\\}', 'g');\n    const images = rtfData.match(regexPicture);\n    const result = [];\n    if (images) {\n        for (const image of images) {\n            let imageType = false;\n            if (image.includes('\\\\pngblip')) {\n                imageType = 'image/png';\n            }\n            else if (image.includes('\\\\jpegblip')) {\n                imageType = 'image/jpeg';\n            }\n            if (imageType) {\n                result.push({\n                    hex: image.replace(regexPictureHeader, '').replace(/[^\\da-fA-F]/g, ''),\n                    type: imageType\n                });\n            }\n        }\n    }\n    return result;\n}\n/**\n * Replaces `src` attribute value of all given images with the corresponding base64 image representation.\n *\n * @param imageElements Array of image elements which will have its source replaced.\n * @param imagesHexSources Array of images hex sources (usually the result of `extractImageDataFromRtf()` function).\n * The array should be the same length as `imageElements` parameter.\n */\nfunction replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {\n    // Assume there is an equal amount of image elements and images HEX sources so they can be matched accordingly based on existing order.\n    if (imageElements.length === imagesHexSources.length) {\n        for (let i = 0; i < imageElements.length; i++) {\n            const newSrc = `data:${imagesHexSources[i].type};base64,${_convertHexToBase64(imagesHexSources[i].hex)}`;\n            writer.setAttribute('src', newSrc, imageElements[i]);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/normalizers/mswordnormalizer\n */\nimport { transformListItemLikeElementsIntoLists } from '../filters/list';\nimport { replaceImagesSourceWithBase64 } from '../filters/image';\nconst msWordMatch1 = /<meta\\s*name=\"?generator\"?\\s*content=\"?microsoft\\s*word\\s*\\d+\"?\\/?>/i;\nconst msWordMatch2 = /xmlns:o=\"urn:schemas-microsoft-com/i;\n/**\n * Normalizer for the content pasted from Microsoft Word.\n */\nexport default class MSWordNormalizer {\n    /**\n     * Creates a new `MSWordNormalizer` instance.\n     *\n     * @param document View document.\n     */\n    constructor(document) {\n        this.document = document;\n    }\n    /**\n     * @inheritDoc\n     */\n    isActive(htmlString) {\n        return msWordMatch1.test(htmlString) || msWordMatch2.test(htmlString);\n    }\n    /**\n     * @inheritDoc\n     */\n    execute(data) {\n        const { body: documentFragment, stylesString } = data._parsedData;\n        transformListItemLikeElementsIntoLists(documentFragment, stylesString);\n        replaceImagesSourceWithBase64(documentFragment, data.dataTransfer.getData('text/rtf'));\n        data.content = documentFragment;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes the `<b>` tag wrapper added by Google Docs to a copied content.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeBoldWrapper(documentFragment, writer) {\n    for (const child of documentFragment.getChildren()) {\n        if (child.is('element', 'b') && child.getStyle('font-weight') === 'normal') {\n            const childIndex = documentFragment.getChildIndex(child);\n            writer.remove(child);\n            writer.insertChild(childIndex, child.getChildren(), documentFragment);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/br\n */\nimport { DomConverter, ViewDocument } from 'ckeditor5/src/engine';\n/**\n * Transforms `<br>` elements that are siblings to some block element into a paragraphs.\n *\n * @param documentFragment The view structure to be transformed.\n */\nexport default function transformBlockBrsToParagraphs(documentFragment, writer) {\n    const viewDocument = new ViewDocument(writer.document.stylesProcessor);\n    const domConverter = new DomConverter(viewDocument, { renderingMode: 'data' });\n    const blockElements = domConverter.blockElements;\n    const inlineObjectElements = domConverter.inlineObjectElements;\n    const elementsToReplace = [];\n    for (const value of writer.createRangeIn(documentFragment)) {\n        const element = value.item;\n        if (element.is('element', 'br')) {\n            const nextSibling = findSibling(element, 'forward', writer, { blockElements, inlineObjectElements });\n            const previousSibling = findSibling(element, 'backward', writer, { blockElements, inlineObjectElements });\n            const nextSiblingIsBlock = isBlockViewElement(nextSibling, blockElements);\n            const previousSiblingIsBlock = isBlockViewElement(previousSibling, blockElements);\n            // If the <br> is surrounded by blocks then convert it to a paragraph:\n            // * <p>foo</p>[<br>]<p>bar</p> -> <p>foo</p>[<p></p>]<p>bar</p>\n            // * <p>foo</p>[<br>] -> <p>foo</p>[<p></p>]\n            // * [<br>]<p>foo</p> -> [<p></p>]<p>foo</p>\n            if (previousSiblingIsBlock || nextSiblingIsBlock) {\n                elementsToReplace.push(element);\n            }\n        }\n    }\n    for (const element of elementsToReplace) {\n        if (element.hasClass('Apple-interchange-newline')) {\n            writer.remove(element);\n        }\n        else {\n            writer.replace(element, writer.createElement('p'));\n        }\n    }\n}\n/**\n * Returns sibling node, threats inline elements as transparent (but should stop on an inline objects).\n */\nfunction findSibling(viewElement, direction, writer, { blockElements, inlineObjectElements }) {\n    let position = writer.createPositionAt(viewElement, direction == 'forward' ? 'after' : 'before');\n    // Find first position that is just before a first:\n    // * text node,\n    // * block element,\n    // * inline object element.\n    // It's ignoring any inline (non-object) elements like span, strong, etc.\n    position = position.getLastMatchingPosition(({ item }) => (item.is('element') &&\n        !blockElements.includes(item.name) &&\n        !inlineObjectElements.includes(item.name)), { direction });\n    return direction == 'forward' ? position.nodeAfter : position.nodeBefore;\n}\n/**\n * Returns true for view elements that are listed as block view elements.\n */\nfunction isBlockViewElement(node, blockElements) {\n    return !!node && node.is('element') && blockElements.includes(node.name);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/normalizers/googledocsnormalizer\n */\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport removeBoldWrapper from '../filters/removeboldwrapper';\nimport transformBlockBrsToParagraphs from '../filters/br';\nimport { unwrapParagraphInListItem } from '../filters/list';\nconst googleDocsMatch = /id=(\"|')docs-internal-guid-[-0-9a-f]+(\"|')/i;\n/**\n * Normalizer for the content pasted from Google Docs.\n */\nexport default class GoogleDocsNormalizer {\n    /**\n     * Creates a new `GoogleDocsNormalizer` instance.\n     *\n     * @param document View document.\n     */\n    constructor(document) {\n        this.document = document;\n    }\n    /**\n     * @inheritDoc\n     */\n    isActive(htmlString) {\n        return googleDocsMatch.test(htmlString);\n    }\n    /**\n     * @inheritDoc\n     */\n    execute(data) {\n        const writer = new UpcastWriter(this.document);\n        const { body: documentFragment } = data._parsedData;\n        removeBoldWrapper(documentFragment, writer);\n        unwrapParagraphInListItem(documentFragment, writer);\n        transformBlockBrsToParagraphs(documentFragment, writer);\n        data.content = documentFragment;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes the `xmlns` attribute from table pasted from Google Sheets.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeXmlns(documentFragment, writer) {\n    for (const child of documentFragment.getChildren()) {\n        if (child.is('element', 'table') && child.hasAttribute('xmlns')) {\n            writer.removeAttribute('xmlns', child);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes the `<google-sheets-html-origin>` tag wrapper added by Google Sheets to a copied content.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeGoogleSheetsTag(documentFragment, writer) {\n    for (const child of documentFragment.getChildren()) {\n        if (child.is('element', 'google-sheets-html-origin')) {\n            const childIndex = documentFragment.getChildIndex(child);\n            writer.remove(child);\n            writer.insertChild(childIndex, child.getChildren(), documentFragment);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes the `width:0px` style from table pasted from Google Sheets.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeInvalidTableWidth(documentFragment, writer) {\n    for (const child of documentFragment.getChildren()) {\n        if (child.is('element', 'table') && child.getStyle('width') === '0px') {\n            writer.removeStyle('width', child);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Removes `<style>` block added by Google Sheets to a copied content.\n *\n * @param documentFragment element `data.content` obtained from clipboard\n */\nexport default function removeStyleBlock(documentFragment, writer) {\n    for (const child of Array.from(documentFragment.getChildren())) {\n        if (child.is('element', 'style')) {\n            writer.remove(child);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/normalizers/googlesheetsnormalizer\n */\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport removeXmlns from '../filters/removexmlns';\nimport removeGoogleSheetsTag from '../filters/removegooglesheetstag';\nimport removeInvalidTableWidth from '../filters/removeinvalidtablewidth';\nimport removeStyleBlock from '../filters/removestyleblock';\nconst googleSheetsMatch = /<google-sheets-html-origin/i;\n/**\n * Normalizer for the content pasted from Google Sheets.\n */\nexport default class GoogleSheetsNormalizer {\n    /**\n     * Creates a new `GoogleSheetsNormalizer` instance.\n     *\n     * @param document View document.\n     */\n    constructor(document) {\n        this.document = document;\n    }\n    /**\n     * @inheritDoc\n     */\n    isActive(htmlString) {\n        return googleSheetsMatch.test(htmlString);\n    }\n    /**\n     * @inheritDoc\n     */\n    execute(data) {\n        const writer = new UpcastWriter(this.document);\n        const { body: documentFragment } = data._parsedData;\n        removeGoogleSheetsTag(documentFragment, writer);\n        removeXmlns(documentFragment, writer);\n        removeInvalidTableWidth(documentFragment, writer);\n        removeStyleBlock(documentFragment, writer);\n        data.content = documentFragment;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/space\n */\n/**\n * Replaces last space preceding elements closing tag with `&nbsp;`. Such operation prevents spaces from being removed\n * during further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDomInlineNodes}).\n * This method also takes into account Word specific `<o:p></o:p>` empty tags.\n * Additionally multiline sequences of spaces and new lines between tags are removed (see #39 and #40).\n *\n * @param htmlString HTML string in which spacing should be normalized.\n * @returns Input HTML with spaces normalized.\n */\nexport function normalizeSpacing(htmlString) {\n    // Run normalizeSafariSpaceSpans() two times to cover nested spans.\n    return normalizeSafariSpaceSpans(normalizeSafariSpaceSpans(htmlString))\n        // Remove all \\r\\n from \"spacerun spans\" so the last replace line doesn't strip all whitespaces.\n        .replace(/(<span\\s+style=['\"]mso-spacerun:yes['\"]>[^\\S\\r\\n]*?)[\\r\\n]+([^\\S\\r\\n]*<\\/span>)/g, '$1$2')\n        .replace(/<span\\s+style=['\"]mso-spacerun:yes['\"]><\\/span>/g, '')\n        .replace(/(<span\\s+style=['\"]letter-spacing:[^'\"]+?['\"]>)[\\r\\n]+(<\\/span>)/g, '$1 $2')\n        .replace(/ <\\//g, '\\u00A0</')\n        .replace(/ <o:p><\\/o:p>/g, '\\u00A0<o:p></o:p>')\n        // Remove <o:p> block filler from empty paragraph. Safari uses \\u00A0 instead of &nbsp;.\n        .replace(/<o:p>(&nbsp;|\\u00A0)<\\/o:p>/g, '')\n        // Remove all whitespaces when they contain any \\r or \\n.\n        .replace(/>([^\\S\\r\\n]*[\\r\\n]\\s*)</g, '><');\n}\n/**\n * Normalizes spacing in special Word `spacerun spans` (`<span style='mso-spacerun:yes'>\\s+</span>`) by replacing\n * all spaces with `&nbsp; ` pairs. This prevents spaces from being removed during further DOM/View processing\n * (see especially {@link module:engine/view/domconverter~DomConverter#_processDomInlineNodes}).\n *\n * @param htmlDocument Native `Document` object in which spacing should be normalized.\n */\nexport function normalizeSpacerunSpans(htmlDocument) {\n    htmlDocument.querySelectorAll('span[style*=spacerun]').forEach(el => {\n        const htmlElement = el;\n        const innerTextLength = htmlElement.innerText.length || 0;\n        htmlElement.innerText = Array(innerTextLength + 1).join('\\u00A0 ').substr(0, innerTextLength);\n    });\n}\n/**\n * Normalizes specific spacing generated by Safari when content pasted from Word (`<span class=\"Apple-converted-space\"> </span>`)\n * by replacing all spaces sequences longer than 1 space with `&nbsp; ` pairs. This prevents spaces from being removed during\n * further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDataFromDomText}).\n *\n * This function is similar to {@link module:clipboard/utils/normalizeclipboarddata normalizeClipboardData util} but uses\n * regular spaces / &nbsp; sequence for replacement.\n *\n * @param htmlString HTML string in which spacing should be normalized\n * @returns Input HTML with spaces normalized.\n */\nfunction normalizeSafariSpaceSpans(htmlString) {\n    return htmlString.replace(/<span(?: class=\"Apple-converted-space\"|)>(\\s+)<\\/span>/g, (fullMatch, spaces) => {\n        return spaces.length === 1 ? ' ' : Array(spaces.length + 1).join('\\u00A0 ').substr(0, spaces.length);\n    });\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/filters/parse\n */\n/* globals DOMParser */\nimport { DomConverter, ViewDocument } from 'ckeditor5/src/engine';\nimport { normalizeSpacing, normalizeSpacerunSpans } from './space';\n/**\n * Parses the provided HTML extracting contents of `<body>` and `<style>` tags.\n *\n * @param htmlString HTML string to be parsed.\n */\nexport function parseHtml(htmlString, stylesProcessor) {\n    const domParser = new DOMParser();\n    // Remove Word specific \"if comments\" so content inside is not omitted by the parser.\n    htmlString = htmlString.replace(/<!--\\[if gte vml 1]>/g, '');\n    const normalizedHtml = normalizeSpacing(cleanContentAfterBody(htmlString));\n    // Parse htmlString as native Document object.\n    const htmlDocument = domParser.parseFromString(normalizedHtml, 'text/html');\n    normalizeSpacerunSpans(htmlDocument);\n    // Get `innerHTML` first as transforming to View modifies the source document.\n    const bodyString = htmlDocument.body.innerHTML;\n    // Transform document.body to View.\n    const bodyView = documentToView(htmlDocument, stylesProcessor);\n    // Extract stylesheets.\n    const stylesObject = extractStyles(htmlDocument);\n    return {\n        body: bodyView,\n        bodyString,\n        styles: stylesObject.styles,\n        stylesString: stylesObject.stylesString\n    };\n}\n/**\n * Transforms native `Document` object into {@link module:engine/view/documentfragment~DocumentFragment}. Comments are skipped.\n *\n * @param htmlDocument Native `Document` object to be transformed.\n */\nfunction documentToView(htmlDocument, stylesProcessor) {\n    const viewDocument = new ViewDocument(stylesProcessor);\n    const domConverter = new DomConverter(viewDocument, { renderingMode: 'data' });\n    const fragment = htmlDocument.createDocumentFragment();\n    const nodes = htmlDocument.body.childNodes;\n    while (nodes.length > 0) {\n        fragment.appendChild(nodes[0]);\n    }\n    return domConverter.domToView(fragment, { skipComments: true });\n}\n/**\n * Extracts both `CSSStyleSheet` and string representation from all `style` elements available in a provided `htmlDocument`.\n *\n * @param htmlDocument Native `Document` object from which styles will be extracted.\n */\nfunction extractStyles(htmlDocument) {\n    const styles = [];\n    const stylesString = [];\n    const styleTags = Array.from(htmlDocument.getElementsByTagName('style'));\n    for (const style of styleTags) {\n        if (style.sheet && style.sheet.cssRules && style.sheet.cssRules.length) {\n            styles.push(style.sheet);\n            stylesString.push(style.innerHTML);\n        }\n    }\n    return {\n        styles,\n        stylesString: stylesString.join(' ')\n    };\n}\n/**\n * Removes leftover content from between closing </body> and closing </html> tag:\n *\n * ```html\n * <html><body><p>Foo Bar</p></body><span>Fo</span></html> -> <html><body><p>Foo Bar</p></body></html>\n * ```\n *\n * This function is used as specific browsers (Edge) add some random content after `body` tag when pasting from Word.\n * @param htmlString The HTML string to be cleaned.\n * @returns The HTML string with leftover content removed.\n */\nfunction cleanContentAfterBody(htmlString) {\n    const bodyCloseTag = '</body>';\n    const htmlCloseTag = '</html>';\n    const bodyCloseIndex = htmlString.indexOf(bodyCloseTag);\n    if (bodyCloseIndex < 0) {\n        return htmlString;\n    }\n    const htmlCloseIndex = htmlString.indexOf(htmlCloseTag, bodyCloseIndex + bodyCloseTag.length);\n    return htmlString.substring(0, bodyCloseIndex + bodyCloseTag.length) +\n        (htmlCloseIndex >= 0 ? htmlString.substring(htmlCloseIndex) : '');\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module paste-from-office/pastefromoffice\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport MSWordNormalizer from './normalizers/mswordnormalizer';\nimport GoogleDocsNormalizer from './normalizers/googledocsnormalizer';\nimport GoogleSheetsNormalizer from './normalizers/googlesheetsnormalizer';\nimport { parseHtml } from './filters/parse';\n/**\n * The Paste from Office plugin.\n *\n * This plugin handles content pasted from Office apps and transforms it (if necessary)\n * to a valid structure which can then be understood by the editor features.\n *\n * Transformation is made by a set of predefined {@link module:paste-from-office/normalizer~Normalizer normalizers}.\n * This plugin includes following normalizers:\n * * {@link module:paste-from-office/normalizers/mswordnormalizer~MSWordNormalizer Microsoft Word normalizer}\n * * {@link module:paste-from-office/normalizers/googledocsnormalizer~GoogleDocsNormalizer Google Docs normalizer}\n *\n * For more information about this feature check the {@glink api/paste-from-office package page}.\n */\nexport default class PasteFromOffice extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'PasteFromOffice';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardPipeline];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const clipboardPipeline = editor.plugins.get('ClipboardPipeline');\n        const viewDocument = editor.editing.view.document;\n        const normalizers = [];\n        normalizers.push(new MSWordNormalizer(viewDocument));\n        normalizers.push(new GoogleDocsNormalizer(viewDocument));\n        normalizers.push(new GoogleSheetsNormalizer(viewDocument));\n        clipboardPipeline.on('inputTransformation', (evt, data) => {\n            if (data._isTransformedWithPasteFromOffice) {\n                return;\n            }\n            const codeBlock = editor.model.document.selection.getFirstPosition().parent;\n            if (codeBlock.is('element', 'codeBlock')) {\n                return;\n            }\n            const htmlString = data.dataTransfer.getData('text/html');\n            const activeNormalizer = normalizers.find(normalizer => normalizer.isActive(htmlString));\n            if (activeNormalizer) {\n                if (!data._parsedData) {\n                    data._parsedData = parseHtml(htmlString, viewDocument.stylesProcessor);\n                }\n                activeNormalizer.execute(data);\n                data._isTransformedWithPasteFromOffice = true;\n            }\n        }, { priority: 'high' });\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
