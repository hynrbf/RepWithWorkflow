import "./chunk-U2PNBOSA.js";
import {
  Paragraph
} from "./chunk-3ADQWQRG.js";
import "./chunk-DEIZSOIF.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  ButtonView,
  Model,
  addListToDropdown,
  createDropdown
} from "./chunk-SGTDNT4V.js";
import "./chunk-6LVMAMLV.js";
import {
  Collection,
  Command,
  DowncastWriter,
  Plugin,
  enablePlaceholder,
  first,
  hidePlaceholder,
  needsPlaceholder,
  priorities_default,
  showPlaceholder
} from "./chunk-JI2V5GJZ.js";
import "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-heading/src/headingcommand.js
var HeadingCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param editor Editor instance.
   * @param modelElements Names of the element which this command can apply in the model.
   */
  constructor(editor, modelElements) {
    super(editor);
    this.modelElements = modelElements;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const block = first(this.editor.model.document.selection.getSelectedBlocks());
    this.value = !!block && this.modelElements.includes(block.name) && block.name;
    this.isEnabled = !!block && this.modelElements.some((heading) => checkCanBecomeHeading(block, heading, this.editor.model.schema));
  }
  /**
   * Executes the command. Applies the heading to the selected blocks or, if the first selected
   * block is a heading already, turns selected headings (of this level only) to paragraphs.
   *
   * @param options.value Name of the element which this command will apply in the model.
   * @fires execute
   */
  execute(options) {
    const model = this.editor.model;
    const document = model.document;
    const modelElement = options.value;
    model.change((writer) => {
      const blocks = Array.from(document.selection.getSelectedBlocks()).filter((block) => {
        return checkCanBecomeHeading(block, modelElement, model.schema);
      });
      for (const block of blocks) {
        if (!block.is("element", modelElement)) {
          writer.rename(block, modelElement);
        }
      }
    });
  }
};
function checkCanBecomeHeading(block, heading, schema) {
  return schema.checkChild(block.parent, heading) && !schema.isObject(block);
}

// node_modules/@ckeditor/ckeditor5-heading/src/headingediting.js
var defaultModelElement = "paragraph";
var HeadingEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HeadingEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("heading", {
      options: [
        { model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" },
        { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" },
        { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" },
        { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Paragraph];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const options = editor.config.get("heading.options");
    const modelElements = [];
    for (const option of options) {
      if (option.model === "paragraph") {
        continue;
      }
      editor.model.schema.register(option.model, {
        inheritAllFrom: "$block"
      });
      editor.conversion.elementToElement(option);
      modelElements.push(option.model);
    }
    this._addDefaultH1Conversion(editor);
    editor.commands.add("heading", new HeadingCommand(editor, modelElements));
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const editor = this.editor;
    const enterCommand = editor.commands.get("enter");
    const options = editor.config.get("heading.options");
    if (enterCommand) {
      this.listenTo(enterCommand, "afterExecute", (evt, data) => {
        const positionParent = editor.model.document.selection.getFirstPosition().parent;
        const isHeading = options.some((option) => positionParent.is("element", option.model));
        if (isHeading && !positionParent.is("element", defaultModelElement) && positionParent.childCount === 0) {
          data.writer.rename(positionParent, defaultModelElement);
        }
      });
    }
  }
  /**
   * Adds default conversion for `h1` -> `heading1` with a low priority.
   *
   * @param editor Editor instance on which to add the `h1` conversion.
   */
  _addDefaultH1Conversion(editor) {
    editor.conversion.for("upcast").elementToElement({
      model: "heading1",
      view: "h1",
      // With a `low` priority, `paragraph` plugin autoparagraphing mechanism is executed. Make sure
      // this listener is called before it. If not, `h1` will be transformed into a paragraph.
      converterPriority: priorities_default.low + 1
    });
  }
};

// node_modules/@ckeditor/ckeditor5-heading/src/utils.js
function getLocalizedOptions(editor) {
  const t = editor.t;
  const localizedTitles = {
    "Paragraph": t("Paragraph"),
    "Heading 1": t("Heading 1"),
    "Heading 2": t("Heading 2"),
    "Heading 3": t("Heading 3"),
    "Heading 4": t("Heading 4"),
    "Heading 5": t("Heading 5"),
    "Heading 6": t("Heading 6")
  };
  return editor.config.get("heading.options").map((option) => {
    const title = localizedTitles[option.title];
    if (title && title != option.title) {
      option.title = title;
    }
    return option;
  });
}

// node_modules/@ckeditor/ckeditor5-heading/src/headingui.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-heading/theme/heading.css";
var HeadingUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "HeadingUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const options = getLocalizedOptions(editor);
    const defaultTitle = t("Choose heading");
    const accessibleLabel = t("Heading");
    editor.ui.componentFactory.add("heading", (locale) => {
      const titles = {};
      const itemDefinitions = new Collection();
      const headingCommand = editor.commands.get("heading");
      const paragraphCommand = editor.commands.get("paragraph");
      const commands = [headingCommand];
      for (const option of options) {
        const def = {
          type: "button",
          model: new Model({
            label: option.title,
            class: option.class,
            role: "menuitemradio",
            withText: true
          })
        };
        if (option.model === "paragraph") {
          def.model.bind("isOn").to(paragraphCommand, "value");
          def.model.set("commandName", "paragraph");
          commands.push(paragraphCommand);
        } else {
          def.model.bind("isOn").to(headingCommand, "value", (value) => value === option.model);
          def.model.set({
            commandName: "heading",
            commandValue: option.model
          });
        }
        itemDefinitions.add(def);
        titles[option.model] = option.title;
      }
      const dropdownView = createDropdown(locale);
      addListToDropdown(dropdownView, itemDefinitions, {
        ariaLabel: accessibleLabel,
        role: "menu"
      });
      dropdownView.buttonView.set({
        ariaLabel: accessibleLabel,
        ariaLabelledBy: void 0,
        isOn: false,
        withText: true,
        tooltip: accessibleLabel
      });
      dropdownView.extendTemplate({
        attributes: {
          class: [
            "ck-heading-dropdown"
          ]
        }
      });
      dropdownView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
        return areEnabled.some((isEnabled) => isEnabled);
      });
      dropdownView.buttonView.bind("label").to(headingCommand, "value", paragraphCommand, "value", (value, para) => {
        const whichModel = value || para && "paragraph";
        if (typeof whichModel === "boolean") {
          return defaultTitle;
        }
        if (!titles[whichModel]) {
          return defaultTitle;
        }
        return titles[whichModel];
      });
      this.listenTo(dropdownView, "execute", (evt) => {
        const { commandName, commandValue } = evt.source;
        editor.execute(commandName, commandValue ? { value: commandValue } : void 0);
        editor.editing.view.focus();
      });
      return dropdownView;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-heading/src/heading.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-heading/theme/heading.css";
var Heading = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [HeadingEditing, HeadingUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Heading";
  }
};

// node_modules/@ckeditor/ckeditor5-heading/src/headingbuttonsui.js
import iconHeading1 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-heading/theme/icons/heading1.svg";
import iconHeading2 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-heading/theme/icons/heading2.svg";
import iconHeading3 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-heading/theme/icons/heading3.svg";
import iconHeading4 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-heading/theme/icons/heading4.svg";
import iconHeading5 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-heading/theme/icons/heading5.svg";
import iconHeading6 from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-heading/theme/icons/heading6.svg";
var defaultIcons = {
  heading1: iconHeading1,
  heading2: iconHeading2,
  heading3: iconHeading3,
  heading4: iconHeading4,
  heading5: iconHeading5,
  heading6: iconHeading6
};
var HeadingButtonsUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  init() {
    const options = getLocalizedOptions(this.editor);
    options.filter((item) => item.model !== "paragraph").map((item) => this._createButton(item));
  }
  /**
   * Creates single button view from provided configuration option.
   */
  _createButton(option) {
    const editor = this.editor;
    editor.ui.componentFactory.add(option.model, (locale) => {
      const view = new ButtonView(locale);
      const command = editor.commands.get("heading");
      view.label = option.title;
      view.icon = option.icon || defaultIcons[option.model];
      view.tooltip = true;
      view.isToggleable = true;
      view.bind("isEnabled").to(command);
      view.bind("isOn").to(command, "value", (value) => value == option.model);
      view.on("execute", () => {
        editor.execute("heading", { value: option.model });
        editor.editing.view.focus();
      });
      return view;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-heading/src/title.js
var titleLikeElements = /* @__PURE__ */ new Set(["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"]);
var Title = class extends Plugin {
  constructor() {
    super(...arguments);
    this._bodyPlaceholder = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Title";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return ["Paragraph"];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    model.schema.register("title", { isBlock: true, allowIn: "$root" });
    model.schema.register("title-content", { isBlock: true, allowIn: "title", allowAttributes: ["alignment"] });
    model.schema.extend("$text", { allowIn: "title-content" });
    model.schema.addAttributeCheck((context) => {
      if (context.endsWith("title-content $text")) {
        return false;
      }
    });
    editor.editing.mapper.on("modelToViewPosition", mapModelPositionToView(editor.editing.view));
    editor.data.mapper.on("modelToViewPosition", mapModelPositionToView(editor.editing.view));
    editor.conversion.for("downcast").elementToElement({ model: "title-content", view: "h1" });
    editor.conversion.for("downcast").add((dispatcher) => dispatcher.on("insert:title", (evt, data, conversionApi) => {
      conversionApi.consumable.consume(data.item, evt.name);
    }));
    editor.data.upcastDispatcher.on("element:h1", dataViewModelH1Insertion, { priority: "high" });
    editor.data.upcastDispatcher.on("element:h2", dataViewModelH1Insertion, { priority: "high" });
    editor.data.upcastDispatcher.on("element:h3", dataViewModelH1Insertion, { priority: "high" });
    model.document.registerPostFixer((writer) => this._fixTitleContent(writer));
    model.document.registerPostFixer((writer) => this._fixTitleElement(writer));
    model.document.registerPostFixer((writer) => this._fixBodyElement(writer));
    model.document.registerPostFixer((writer) => this._fixExtraParagraph(writer));
    this._attachPlaceholders();
    this._attachTabPressHandling();
  }
  /**
   * Returns the title of the document. Note that because this plugin does not allow any formatting inside
   * the title element, the output of this method will be a plain text, with no HTML tags.
   *
   * It is not recommended to use this method together with features that insert markers to the
   * data output, like comments or track changes features. If such markers start in the title and end in the
   * body, the result of this method might be incorrect.
   *
   * @param options Additional configuration passed to the conversion process.
   * See {@link module:engine/controller/datacontroller~DataController#get `DataController#get`}.
   * @returns The title of the document.
   */
  getTitle(options = {}) {
    const rootName = options.rootName ? options.rootName : void 0;
    const titleElement = this._getTitleElement(rootName);
    const titleContentElement = titleElement.getChild(0);
    return this.editor.data.stringify(titleContentElement, options);
  }
  /**
   * Returns the body of the document.
   *
   * Note that it is not recommended to use this method together with features that insert markers to the
   * data output, like comments or track changes features. If such markers start in the title and end in the
   * body, the result of this method might be incorrect.
   *
   * @param options Additional configuration passed to the conversion process.
   * See {@link module:engine/controller/datacontroller~DataController#get `DataController#get`}.
   * @returns The body of the document.
   */
  getBody(options = {}) {
    const editor = this.editor;
    const data = editor.data;
    const model = editor.model;
    const rootName = options.rootName ? options.rootName : void 0;
    const root = editor.model.document.getRoot(rootName);
    const view = editor.editing.view;
    const viewWriter = new DowncastWriter(view.document);
    const rootRange = model.createRangeIn(root);
    const viewDocumentFragment = viewWriter.createDocumentFragment();
    const bodyStartPosition = model.createPositionAfter(root.getChild(0));
    const bodyRange = model.createRange(bodyStartPosition, model.createPositionAt(root, "end"));
    const markers = /* @__PURE__ */ new Map();
    for (const marker of model.markers) {
      const intersection = bodyRange.getIntersection(marker.getRange());
      if (intersection) {
        markers.set(marker.name, intersection);
      }
    }
    data.mapper.clearBindings();
    data.mapper.bindElements(root, viewDocumentFragment);
    data.downcastDispatcher.convert(rootRange, markers, viewWriter, options);
    viewWriter.remove(viewWriter.createRangeOn(viewDocumentFragment.getChild(0)));
    return editor.data.processor.toData(viewDocumentFragment);
  }
  /**
   * Returns the `title` element when it is in the document. Returns `undefined` otherwise.
   */
  _getTitleElement(rootName) {
    const root = this.editor.model.document.getRoot(rootName);
    for (const child of root.getChildren()) {
      if (isTitle(child)) {
        return child;
      }
    }
  }
  /**
   * Model post-fixer callback that ensures that `title` has only one `title-content` child.
   * All additional children should be moved after the `title` element and renamed to a paragraph.
   */
  _fixTitleContent(writer) {
    let changed = false;
    for (const rootName of this.editor.model.document.getRootNames()) {
      const title = this._getTitleElement(rootName);
      if (!title || title.maxOffset === 1) {
        continue;
      }
      const titleChildren = Array.from(title.getChildren());
      titleChildren.shift();
      for (const titleChild of titleChildren) {
        writer.move(writer.createRangeOn(titleChild), title, "after");
        writer.rename(titleChild, "paragraph");
      }
      changed = true;
    }
    return changed;
  }
  /**
   * Model post-fixer callback that creates a title element when it is missing,
   * takes care of the correct position of it and removes additional title elements.
   */
  _fixTitleElement(writer) {
    let changed = false;
    const model = this.editor.model;
    for (const modelRoot of this.editor.model.document.getRoots()) {
      const titleElements = Array.from(modelRoot.getChildren()).filter(isTitle);
      const firstTitleElement = titleElements[0];
      const firstRootChild = modelRoot.getChild(0);
      if (firstRootChild.is("element", "title")) {
        if (titleElements.length > 1) {
          fixAdditionalTitleElements(titleElements, writer, model);
          changed = true;
        }
        continue;
      }
      if (!firstTitleElement && !titleLikeElements.has(firstRootChild.name)) {
        const title = writer.createElement("title");
        writer.insert(title, modelRoot);
        writer.insertElement("title-content", title);
        changed = true;
        continue;
      }
      if (titleLikeElements.has(firstRootChild.name)) {
        changeElementToTitle(firstRootChild, writer, model);
      } else {
        writer.move(writer.createRangeOn(firstTitleElement), modelRoot, 0);
      }
      fixAdditionalTitleElements(titleElements, writer, model);
      changed = true;
    }
    return changed;
  }
  /**
   * Model post-fixer callback that adds an empty paragraph at the end of the document
   * when it is needed for the placeholder purposes.
   */
  _fixBodyElement(writer) {
    let changed = false;
    for (const rootName of this.editor.model.document.getRootNames()) {
      const modelRoot = this.editor.model.document.getRoot(rootName);
      if (modelRoot.childCount < 2) {
        const placeholder = writer.createElement("paragraph");
        writer.insert(placeholder, modelRoot, 1);
        this._bodyPlaceholder.set(rootName, placeholder);
        changed = true;
      }
    }
    return changed;
  }
  /**
   * Model post-fixer callback that removes a paragraph from the end of the document
   * if it was created for the placeholder purposes and is not needed anymore.
   */
  _fixExtraParagraph(writer) {
    let changed = false;
    for (const rootName of this.editor.model.document.getRootNames()) {
      const root = this.editor.model.document.getRoot(rootName);
      const placeholder = this._bodyPlaceholder.get(rootName);
      if (shouldRemoveLastParagraph(placeholder, root)) {
        this._bodyPlaceholder.delete(rootName);
        writer.remove(placeholder);
        changed = true;
      }
    }
    return changed;
  }
  /**
   * Attaches the `Title` and `Body` placeholders to the title and/or content.
   */
  _attachPlaceholders() {
    const editor = this.editor;
    const t = editor.t;
    const view = editor.editing.view;
    const sourceElement = editor.sourceElement;
    const titlePlaceholder = editor.config.get("title.placeholder") || t("Type your title");
    const bodyPlaceholder = editor.config.get("placeholder") || sourceElement && sourceElement.tagName.toLowerCase() === "textarea" && sourceElement.getAttribute("placeholder") || t("Type or paste your content here.");
    editor.editing.downcastDispatcher.on("insert:title-content", (evt, data, conversionApi) => {
      const element = conversionApi.mapper.toViewElement(data.item);
      element.placeholder = titlePlaceholder;
      enablePlaceholder({
        view,
        element,
        keepOnFocus: true
      });
    });
    const bodyViewElements = /* @__PURE__ */ new Map();
    view.document.registerPostFixer((writer) => {
      let hasChanged = false;
      for (const viewRoot of view.document.roots) {
        if (viewRoot.isEmpty) {
          continue;
        }
        const body = viewRoot.getChild(1);
        const oldBody = bodyViewElements.get(viewRoot.rootName);
        if (body !== oldBody) {
          if (oldBody) {
            hidePlaceholder(writer, oldBody);
            writer.removeAttribute("data-placeholder", oldBody);
          }
          writer.setAttribute("data-placeholder", bodyPlaceholder, body);
          bodyViewElements.set(viewRoot.rootName, body);
          hasChanged = true;
        }
        if (needsPlaceholder(body, true) && viewRoot.childCount === 2 && body.name === "p") {
          hasChanged = showPlaceholder(writer, body) ? true : hasChanged;
        } else {
          hasChanged = hidePlaceholder(writer, body) ? true : hasChanged;
        }
      }
      return hasChanged;
    });
  }
  /**
   * Creates navigation between the title and body sections using <kbd>Tab</kbd> and <kbd>Shift</kbd>+<kbd>Tab</kbd> keys.
   */
  _attachTabPressHandling() {
    const editor = this.editor;
    const model = editor.model;
    editor.keystrokes.set("TAB", (data, cancel) => {
      model.change((writer) => {
        const selection = model.document.selection;
        const selectedElements = Array.from(selection.getSelectedBlocks());
        if (selectedElements.length === 1 && selectedElements[0].is("element", "title-content")) {
          const root = selection.getFirstPosition().root;
          const firstBodyElement = root.getChild(1);
          writer.setSelection(firstBodyElement, 0);
          cancel();
        }
      });
    });
    editor.keystrokes.set("SHIFT + TAB", (data, cancel) => {
      model.change((writer) => {
        const selection = model.document.selection;
        if (!selection.isCollapsed) {
          return;
        }
        const selectedElement = first(selection.getSelectedBlocks());
        const selectionPosition = selection.getFirstPosition();
        const root = editor.model.document.getRoot(selectionPosition.root.rootName);
        const title = root.getChild(0);
        const body = root.getChild(1);
        if (selectedElement === body && selectionPosition.isAtStart) {
          writer.setSelection(title.getChild(0), 0);
          cancel();
        }
      });
    });
  }
};
function dataViewModelH1Insertion(evt, data, conversionApi) {
  const modelCursor = data.modelCursor;
  const viewItem = data.viewItem;
  if (!modelCursor.isAtStart || !modelCursor.parent.is("element", "$root")) {
    return;
  }
  if (!conversionApi.consumable.consume(viewItem, { name: true })) {
    return;
  }
  const modelWriter = conversionApi.writer;
  const title = modelWriter.createElement("title");
  const titleContent = modelWriter.createElement("title-content");
  modelWriter.append(titleContent, title);
  modelWriter.insert(title, modelCursor);
  conversionApi.convertChildren(viewItem, titleContent);
  conversionApi.updateConversionResult(title, data);
}
function mapModelPositionToView(editingView) {
  return (evt, data) => {
    const positionParent = data.modelPosition.parent;
    if (!positionParent.is("element", "title")) {
      return;
    }
    const modelTitleElement = positionParent.parent;
    const viewElement = data.mapper.toViewElement(modelTitleElement);
    data.viewPosition = editingView.createPositionAt(viewElement, 0);
    evt.stop();
  };
}
function isTitle(element) {
  return element.is("element", "title");
}
function changeElementToTitle(element, writer, model) {
  const title = writer.createElement("title");
  writer.insert(title, element, "before");
  writer.insert(element, title, 0);
  writer.rename(element, "title-content");
  model.schema.removeDisallowedAttributes([element], writer);
}
function fixAdditionalTitleElements(titleElements, writer, model) {
  let hasChanged = false;
  for (const title of titleElements) {
    if (title.index !== 0) {
      fixTitleElement(title, writer, model);
      hasChanged = true;
    }
  }
  return hasChanged;
}
function fixTitleElement(title, writer, model) {
  const child = title.getChild(0);
  if (child.isEmpty) {
    writer.remove(title);
    return;
  }
  writer.move(writer.createRangeOn(child), title, "before");
  writer.rename(child, "paragraph");
  writer.remove(title);
  model.schema.removeDisallowedAttributes([child], writer);
}
function shouldRemoveLastParagraph(placeholder, root) {
  if (!placeholder || !placeholder.is("element", "paragraph") || placeholder.childCount) {
    return false;
  }
  if (root.childCount <= 2 || root.getChild(root.childCount - 1) !== placeholder) {
    return false;
  }
  return true;
}
export {
  Heading,
  HeadingButtonsUI,
  HeadingEditing,
  HeadingUI,
  Title
};
/*! Bundled license information:

@ckeditor/ckeditor5-heading/src/headingcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-heading/src/headingediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-heading/src/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-heading/src/headingui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-heading/src/heading.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-heading/src/headingbuttonsui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-heading/src/title.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-heading/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-heading/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-heading.js.map
