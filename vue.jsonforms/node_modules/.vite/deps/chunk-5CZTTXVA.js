import {
  ButtonView
} from "./chunk-SGTDNT4V.js";
import {
  Command,
  NoOperation,
  Plugin,
  transformSets
} from "./chunk-JI2V5GJZ.js";

// node_modules/@ckeditor/ckeditor5-undo/src/basecommand.js
var BaseCommand = class extends Command {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._stack = [];
    this._createdBatches = /* @__PURE__ */ new WeakSet();
    this.refresh();
    this._isEnabledBasedOnSelection = false;
    this.listenTo(editor.data, "set", (evt, data) => {
      data[1] = { ...data[1] };
      const options = data[1];
      if (!options.batchType) {
        options.batchType = { isUndoable: false };
      }
    }, { priority: "high" });
    this.listenTo(editor.data, "set", (evt, data) => {
      const options = data[1];
      if (!options.batchType.isUndoable) {
        this.clearStack();
      }
    });
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._stack.length > 0;
  }
  /**
   * Returns all batches created by this command.
   */
  get createdBatches() {
    return this._createdBatches;
  }
  /**
   * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
   * created by the editor which this command is registered to.
   *
   * @param batch The batch to add.
   */
  addBatch(batch) {
    const docSelection = this.editor.model.document.selection;
    const selection = {
      ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],
      isBackward: docSelection.isBackward
    };
    this._stack.push({ batch, selection });
    this.refresh();
  }
  /**
   * Removes all items from the stack.
   */
  clearStack() {
    this._stack = [];
    this.refresh();
  }
  /**
   * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
   *
   * @param ranges Ranges to be restored.
   * @param isBackward A flag describing whether the restored range was selected forward or backward.
   * @param operations Operations which has been applied since selection has been stored.
   */
  _restoreSelection(ranges, isBackward, operations) {
    const model = this.editor.model;
    const document = model.document;
    const selectionRanges = [];
    const transformedRangeGroups = ranges.map((range) => range.getTransformedByOperations(operations));
    const allRanges = transformedRangeGroups.flat();
    for (const rangeGroup of transformedRangeGroups) {
      const transformed = rangeGroup.filter((range) => range.root != document.graveyard).filter((range) => !isRangeContainedByAnyOtherRange(range, allRanges));
      if (!transformed.length) {
        continue;
      }
      normalizeRanges(transformed);
      selectionRanges.push(transformed[0]);
    }
    if (selectionRanges.length) {
      model.change((writer) => {
        writer.setSelection(selectionRanges, { backward: isBackward });
      });
    }
  }
  /**
   * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
   * This is a helper method for {@link #execute}.
   *
   * @param batchToUndo The batch to be undone.
   * @param undoingBatch The batch that will contain undoing changes.
   */
  _undo(batchToUndo, undoingBatch) {
    const model = this.editor.model;
    const document = model.document;
    this._createdBatches.add(undoingBatch);
    const operationsToUndo = batchToUndo.operations.slice().filter((operation) => operation.isDocumentOperation);
    operationsToUndo.reverse();
    for (const operationToUndo of operationsToUndo) {
      const nextBaseVersion = operationToUndo.baseVersion + 1;
      const historyOperations = Array.from(document.history.getOperations(nextBaseVersion));
      const transformedSets = transformSets([operationToUndo.getReversed()], historyOperations, {
        useRelations: true,
        document: this.editor.model.document,
        padWithNoOps: false,
        forceWeakRemove: true
      });
      const reversedOperations = transformedSets.operationsA;
      for (let operation of reversedOperations) {
        const affectedSelectable = operation.affectedSelectable;
        if (affectedSelectable && !model.canEditAt(affectedSelectable)) {
          operation = new NoOperation(operation.baseVersion);
        }
        undoingBatch.addOperation(operation);
        model.applyOperation(operation);
        document.history.setOperationAsUndone(operationToUndo, operation);
      }
    }
  }
};
function normalizeRanges(ranges) {
  ranges.sort((a, b) => a.start.isBefore(b.start) ? -1 : 1);
  for (let i = 1; i < ranges.length; i++) {
    const previousRange = ranges[i - 1];
    const joinedRange = previousRange.getJoined(ranges[i], true);
    if (joinedRange) {
      i--;
      ranges.splice(i, 2, joinedRange);
    }
  }
}
function isRangeContainedByAnyOtherRange(range, ranges) {
  return ranges.some((otherRange) => otherRange !== range && otherRange.containsRange(range, true));
}

// node_modules/@ckeditor/ckeditor5-undo/src/undocommand.js
var UndoCommand = class extends BaseCommand {
  /**
   * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
   * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
   * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
   *
   * @fires execute
   * @fires revert
   * @param batch A batch that should be undone. If not set, the last added batch will be undone.
   */
  execute(batch = null) {
    const batchIndex = batch ? this._stack.findIndex((a) => a.batch == batch) : this._stack.length - 1;
    const item = this._stack.splice(batchIndex, 1)[0];
    const undoingBatch = this.editor.model.createBatch({ isUndo: true });
    this.editor.model.enqueueChange(undoingBatch, () => {
      this._undo(item.batch, undoingBatch);
      const operations = this.editor.model.document.history.getOperations(item.batch.baseVersion);
      this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);
    });
    this.fire("revert", item.batch, undoingBatch);
    this.refresh();
  }
};

// node_modules/@ckeditor/ckeditor5-undo/src/redocommand.js
var RedoCommand = class extends BaseCommand {
  /**
   * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
   * the command's stack, applies the reverted and transformed version on the
   * {@link module:engine/model/document~Document document} and removes the batch from the stack.
   * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
   *
   * @fires execute
   */
  execute() {
    const item = this._stack.pop();
    const redoingBatch = this.editor.model.createBatch({ isUndo: true });
    this.editor.model.enqueueChange(redoingBatch, () => {
      const lastOperation = item.batch.operations[item.batch.operations.length - 1];
      const nextBaseVersion = lastOperation.baseVersion + 1;
      const operations = this.editor.model.document.history.getOperations(nextBaseVersion);
      this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);
      this._undo(item.batch, redoingBatch);
    });
    this.refresh();
  }
};

// node_modules/@ckeditor/ckeditor5-undo/src/undoediting.js
var UndoEditing = class extends Plugin {
  constructor() {
    super(...arguments);
    this._batchRegistry = /* @__PURE__ */ new WeakSet();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UndoEditing";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    this._undoCommand = new UndoCommand(editor);
    this._redoCommand = new RedoCommand(editor);
    editor.commands.add("undo", this._undoCommand);
    editor.commands.add("redo", this._redoCommand);
    this.listenTo(editor.model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (!operation.isDocumentOperation) {
        return;
      }
      const batch = operation.batch;
      const isRedoBatch = this._redoCommand.createdBatches.has(batch);
      const isUndoBatch = this._undoCommand.createdBatches.has(batch);
      const wasProcessed = this._batchRegistry.has(batch);
      if (wasProcessed) {
        return;
      }
      this._batchRegistry.add(batch);
      if (!batch.isUndoable) {
        return;
      }
      if (isRedoBatch) {
        this._undoCommand.addBatch(batch);
      } else if (!isUndoBatch) {
        this._undoCommand.addBatch(batch);
        this._redoCommand.clearStack();
      }
    }, { priority: "highest" });
    this.listenTo(this._undoCommand, "revert", (evt, undoneBatch, undoingBatch) => {
      this._redoCommand.addBatch(undoingBatch);
    });
    editor.keystrokes.set("CTRL+Z", "undo");
    editor.keystrokes.set("CTRL+Y", "redo");
    editor.keystrokes.set("CTRL+SHIFT+Z", "redo");
  }
};

// node_modules/@ckeditor/ckeditor5-undo/src/undoui.js
import undoIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-undo/theme/icons/undo.svg";
import redoIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-undo/theme/icons/redo.svg";
var UndoUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UndoUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const locale = editor.locale;
    const t = editor.t;
    const localizedUndoIcon = locale.uiLanguageDirection == "ltr" ? undoIcon : redoIcon;
    const localizedRedoIcon = locale.uiLanguageDirection == "ltr" ? redoIcon : undoIcon;
    this._addButton("undo", t("Undo"), "CTRL+Z", localizedUndoIcon);
    this._addButton("redo", t("Redo"), "CTRL+Y", localizedRedoIcon);
  }
  /**
   * Creates a button for the specified command.
   *
   * @param name Command name.
   * @param label Button label.
   * @param keystroke Command keystroke.
   * @param Icon Source of the icon.
   */
  _addButton(name, label, keystroke, Icon) {
    const editor = this.editor;
    editor.ui.componentFactory.add(name, (locale) => {
      const command = editor.commands.get(name);
      const view = new ButtonView(locale);
      view.set({
        label,
        icon: Icon,
        keystroke,
        tooltip: true
      });
      view.bind("isEnabled").to(command, "isEnabled");
      this.listenTo(view, "execute", () => {
        editor.execute(name);
        editor.editing.view.focus();
      });
      return view;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-undo/src/undo.js
var Undo = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [UndoEditing, UndoUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Undo";
  }
};

export {
  Undo
};
/*! Bundled license information:

@ckeditor/ckeditor5-undo/src/basecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/undocommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/redocommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/undoediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/undoui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/undo.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/undo.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-5CZTTXVA.js.map
