{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-list/src/documentlist/utils/listwalker.js", "../../@ckeditor/ckeditor5-list/src/documentlist/utils/model.js", "../../@ckeditor/ckeditor5-list/src/documentlist/documentlistindentcommand.js", "../../@ckeditor/ckeditor5-list/src/documentlist/documentlistcommand.js", "../../@ckeditor/ckeditor5-list/src/documentlist/documentlistmergecommand.js", "../../@ckeditor/ckeditor5-list/src/documentlist/documentlistsplitcommand.js", "../../@ckeditor/ckeditor5-list/src/documentlist/documentlistutils.js", "../../@ckeditor/ckeditor5-list/src/documentlist/utils/view.js", "../../@ckeditor/ckeditor5-list/src/documentlist/utils/postfixers.js", "../../@ckeditor/ckeditor5-list/src/documentlist/converters.js", "../../@ckeditor/ckeditor5-list/src/documentlist/documentlistediting.js", "../../@ckeditor/ckeditor5-list/src/list/utils.js", "../../@ckeditor/ckeditor5-list/src/list/listui.js", "../../@ckeditor/ckeditor5-list/src/documentlist.js", "../../@ckeditor/ckeditor5-list/src/documentlist/adjacentlistssupport.js", "../../@ckeditor/ckeditor5-list/src/documentlistproperties/documentliststartcommand.js", "../../@ckeditor/ckeditor5-list/src/documentlistproperties/utils/style.js", "../../@ckeditor/ckeditor5-list/src/documentlistproperties/documentliststylecommand.js", "../../@ckeditor/ckeditor5-list/src/documentlistproperties/documentlistreversedcommand.js", "../../@ckeditor/ckeditor5-list/src/documentlistproperties/converters.js", "../../@ckeditor/ckeditor5-list/src/documentlistproperties/documentlistpropertiesutils.js", "../../@ckeditor/ckeditor5-list/src/documentlistproperties/documentlistpropertiesediting.js", "../../@ckeditor/ckeditor5-list/src/listproperties/ui/collapsibleview.js", "../../@ckeditor/ckeditor5-list/src/listproperties/ui/listpropertiesview.js", "../../@ckeditor/ckeditor5-list/src/listproperties/listpropertiesui.js", "../../@ckeditor/ckeditor5-list/src/documentlistproperties.js", "../../@ckeditor/ckeditor5-list/src/list/indentcommand.js", "../../@ckeditor/ckeditor5-list/src/list/listcommand.js", "../../@ckeditor/ckeditor5-list/src/list/listutils.js", "../../@ckeditor/ckeditor5-list/src/list/converters.js", "../../@ckeditor/ckeditor5-list/src/list/listediting.js", "../../@ckeditor/ckeditor5-list/src/list.js", "../../@ckeditor/ckeditor5-list/src/listproperties/liststylecommand.js", "../../@ckeditor/ckeditor5-list/src/listproperties/listreversedcommand.js", "../../@ckeditor/ckeditor5-list/src/listproperties/liststartcommand.js", "../../@ckeditor/ckeditor5-list/src/listproperties/listpropertiesediting.js", "../../@ckeditor/ckeditor5-list/src/listproperties.js", "../../@ckeditor/ckeditor5-list/src/todolist/checktodolistcommand.js", "../../@ckeditor/ckeditor5-list/src/todolist/todolistconverters.js", "../../@ckeditor/ckeditor5-list/src/todolist/todolistediting.js", "../../@ckeditor/ckeditor5-list/src/todolist/todolistui.js", "../../@ckeditor/ckeditor5-list/src/todolist.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlist/utils/listwalker\n */\nimport { first, toArray } from 'ckeditor5/src/utils';\nimport { isListItemBlock } from './model';\n/**\n * Document list blocks iterator.\n */\nexport default class ListWalker {\n    /**\n     * Creates a document list iterator.\n     *\n     * @param startElement The start list item block element.\n     * @param options.direction The iterating direction.\n     * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).\n     * @param options.sameAttributes Additional attributes that must be the same for each block.\n     * @param options.sameIndent Whether blocks with the same indent level as the start block should be included\n     * in the result.\n     * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included\n     * in the result.\n     * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included\n     * in the result.\n     */\n    constructor(startElement, options) {\n        this._startElement = startElement;\n        this._referenceIndent = startElement.getAttribute('listIndent');\n        this._isForward = options.direction == 'forward';\n        this._includeSelf = !!options.includeSelf;\n        this._sameAttributes = toArray(options.sameAttributes || []);\n        this._sameIndent = !!options.sameIndent;\n        this._lowerIndent = !!options.lowerIndent;\n        this._higherIndent = !!options.higherIndent;\n    }\n    /**\n     * Performs only first step of iteration and returns the result.\n     *\n     * @param startElement The start list item block element.\n     * @param options.direction The iterating direction.\n     * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).\n     * @param options.sameAttributes Additional attributes that must be the same for each block.\n     * @param options.sameIndent Whether blocks with the same indent level as the start block should be included\n     * in the result.\n     * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included\n     * in the result.\n     * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included\n     * in the result.\n     */\n    static first(startElement, options) {\n        const walker = new this(startElement, options);\n        const iterator = walker[Symbol.iterator]();\n        return first(iterator);\n    }\n    /**\n     * Iterable interface.\n     */\n    *[Symbol.iterator]() {\n        const nestedItems = [];\n        for (const { node } of iterateSiblingListBlocks(this._getStartNode(), this._isForward ? 'forward' : 'backward')) {\n            const indent = node.getAttribute('listIndent');\n            // Leaving a nested list.\n            if (indent < this._referenceIndent) {\n                // Abort searching blocks.\n                if (!this._lowerIndent) {\n                    break;\n                }\n                // While searching for lower indents, update the reference indent to find another parent in the next step.\n                this._referenceIndent = indent;\n            }\n            // Entering a nested list.\n            else if (indent > this._referenceIndent) {\n                // Ignore nested blocks.\n                if (!this._higherIndent) {\n                    continue;\n                }\n                // Collect nested blocks to verify if they are really nested, or it's a different item.\n                if (!this._isForward) {\n                    nestedItems.push(node);\n                    continue;\n                }\n            }\n            // Same indent level block.\n            else {\n                // Ignore same indent block.\n                if (!this._sameIndent) {\n                    // While looking for nested blocks, stop iterating while encountering first same indent block.\n                    if (this._higherIndent) {\n                        // No more nested blocks so yield nested items.\n                        if (nestedItems.length) {\n                            yield* nestedItems;\n                            nestedItems.length = 0;\n                        }\n                        break;\n                    }\n                    continue;\n                }\n                // Abort if item has any additionally specified attribute different.\n                if (this._sameAttributes.some(attr => node.getAttribute(attr) !== this._startElement.getAttribute(attr))) {\n                    break;\n                }\n            }\n            // There is another block for the same list item so the nested items were in the same list item.\n            if (nestedItems.length) {\n                yield* nestedItems;\n                nestedItems.length = 0;\n            }\n            yield node;\n        }\n    }\n    /**\n     * Returns the model element to start iterating.\n     */\n    _getStartNode() {\n        if (this._includeSelf) {\n            return this._startElement;\n        }\n        return this._isForward ?\n            this._startElement.nextSibling :\n            this._startElement.previousSibling;\n    }\n}\n/**\n * Iterates sibling list blocks starting from the given node.\n *\n * @internal\n * @param node The model node.\n * @param direction Iteration direction.\n * @returns The object with `node` and `previous` {@link module:engine/model/element~Element blocks}.\n */\nexport function* iterateSiblingListBlocks(node, direction = 'forward') {\n    const isForward = direction == 'forward';\n    let previous = null;\n    while (isListItemBlock(node)) {\n        yield { node, previous };\n        previous = node;\n        node = isForward ? node.nextSibling : node.previousSibling;\n    }\n}\n/**\n * The iterable protocol over the list elements.\n *\n * @internal\n */\nexport class ListBlocksIterable {\n    /**\n     * @param listHead The head element of a list.\n     */\n    constructor(listHead) {\n        this._listHead = listHead;\n    }\n    /**\n     * List blocks iterator.\n     *\n     * Iterates over all blocks of a list.\n     */\n    [Symbol.iterator]() {\n        return iterateSiblingListBlocks(this._listHead, 'forward');\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { uid, toArray } from 'ckeditor5/src/utils';\nimport ListWalker, { iterateSiblingListBlocks } from './listwalker';\n/**\n * The list item ID generator.\n *\n * @internal\n */\nexport class ListItemUid {\n    /**\n     * Returns the next ID.\n     *\n     * @internal\n     */\n    /* istanbul ignore next: static function definition -- @preserve */\n    static next() {\n        return uid();\n    }\n}\n/**\n * Returns true if the given model node is a list item block.\n *\n * @internal\n */\nexport function isListItemBlock(node) {\n    return !!node && node.is('element') && node.hasAttribute('listItemId');\n}\n/**\n * Returns an array with all elements that represents the same list item.\n *\n * It means that values for `listIndent`, and `listItemId` for all items are equal.\n *\n * @internal\n * @param listItem Starting list item element.\n * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included\n * in the result.\n */\nexport function getAllListItemBlocks(listItem, options = {}) {\n    return [\n        ...getListItemBlocks(listItem, { ...options, direction: 'backward' }),\n        ...getListItemBlocks(listItem, { ...options, direction: 'forward' })\n    ];\n}\n/**\n * Returns an array with elements that represents the same list item in the specified direction.\n *\n * It means that values for `listIndent` and `listItemId` for all items are equal.\n *\n * **Note**: For backward search the provided item is not included, but for forward search it is included in the result.\n *\n * @internal\n * @param listItem Starting list item element.\n * @param options.direction Walking direction.\n * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included in the result.\n */\nexport function getListItemBlocks(listItem, options = {}) {\n    const isForward = options.direction == 'forward';\n    const items = Array.from(new ListWalker(listItem, {\n        ...options,\n        includeSelf: isForward,\n        sameIndent: true,\n        sameAttributes: 'listItemId'\n    }));\n    return isForward ? items : items.reverse();\n}\n/**\n * Returns a list items nested inside the given list item.\n *\n * @internal\n */\nexport function getNestedListBlocks(listItem) {\n    return Array.from(new ListWalker(listItem, {\n        direction: 'forward',\n        higherIndent: true\n    }));\n}\n/**\n * Returns array of all blocks/items of the same list as given block (same indent, same type and properties).\n *\n * @internal\n * @param listItem Starting list item element.\n */\nexport function getListItems(listItem) {\n    const backwardBlocks = new ListWalker(listItem, {\n        sameIndent: true,\n        sameAttributes: 'listType'\n    });\n    const forwardBlocks = new ListWalker(listItem, {\n        sameIndent: true,\n        sameAttributes: 'listType',\n        includeSelf: true,\n        direction: 'forward'\n    });\n    return [\n        ...Array.from(backwardBlocks).reverse(),\n        ...forwardBlocks\n    ];\n}\n/**\n * Check if the given block is the first in the list item.\n *\n * @internal\n * @param listBlock The list block element.\n */\nexport function isFirstBlockOfListItem(listBlock) {\n    const previousSibling = ListWalker.first(listBlock, {\n        sameIndent: true,\n        sameAttributes: 'listItemId'\n    });\n    if (!previousSibling) {\n        return true;\n    }\n    return false;\n}\n/**\n * Check if the given block is the last in the list item.\n *\n * @internal\n */\nexport function isLastBlockOfListItem(listBlock) {\n    const nextSibling = ListWalker.first(listBlock, {\n        direction: 'forward',\n        sameIndent: true,\n        sameAttributes: 'listItemId'\n    });\n    if (!nextSibling) {\n        return true;\n    }\n    return false;\n}\n/**\n * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.\n *\n * @internal\n * @param blocks The list of selected blocks.\n * @param options.withNested Whether should include nested list items.\n */\nexport function expandListBlocksToCompleteItems(blocks, options = {}) {\n    blocks = toArray(blocks);\n    const higherIndent = options.withNested !== false;\n    const allBlocks = new Set();\n    for (const block of blocks) {\n        for (const itemBlock of getAllListItemBlocks(block, { higherIndent })) {\n            allBlocks.add(itemBlock);\n        }\n    }\n    return sortBlocks(allBlocks);\n}\n/**\n * Expands the given list of selected blocks to include all the items of the lists they're in.\n *\n * @internal\n * @param blocks The list of selected blocks.\n */\nexport function expandListBlocksToCompleteList(blocks) {\n    blocks = toArray(blocks);\n    const allBlocks = new Set();\n    for (const block of blocks) {\n        for (const itemBlock of getListItems(block)) {\n            allBlocks.add(itemBlock);\n        }\n    }\n    return sortBlocks(allBlocks);\n}\n/**\n * Splits the list item just before the provided list block.\n *\n * @internal\n * @param listBlock The list block element.\n * @param writer The model writer.\n * @returns The array of updated blocks.\n */\nexport function splitListItemBefore(listBlock, writer) {\n    const blocks = getListItemBlocks(listBlock, { direction: 'forward' });\n    const id = ListItemUid.next();\n    for (const block of blocks) {\n        writer.setAttribute('listItemId', id, block);\n    }\n    return blocks;\n}\n/**\n * Merges the list item with the parent list item.\n *\n * @internal\n * @param listBlock The list block element.\n * @param parentBlock The list block element to merge with.\n * @param writer The model writer.\n * @returns The array of updated blocks.\n */\nexport function mergeListItemBefore(listBlock, parentBlock, writer) {\n    const attributes = {};\n    for (const [key, value] of parentBlock.getAttributes()) {\n        if (key.startsWith('list')) {\n            attributes[key] = value;\n        }\n    }\n    const blocks = getListItemBlocks(listBlock, { direction: 'forward' });\n    for (const block of blocks) {\n        writer.setAttributes(attributes, block);\n    }\n    return blocks;\n}\n/**\n * Increases indentation of given list blocks.\n *\n * @internal\n * @param blocks The block or iterable of blocks.\n * @param writer The model writer.\n * @param options.expand Whether should expand the list of blocks to include complete list items.\n * @param options.indentBy The number of levels the indentation should change (could be negative).\n */\nexport function indentBlocks(blocks, writer, { expand, indentBy = 1 } = {}) {\n    blocks = toArray(blocks);\n    // Expand the selected blocks to contain the whole list items.\n    const allBlocks = expand ? expandListBlocksToCompleteItems(blocks) : blocks;\n    for (const block of allBlocks) {\n        const blockIndent = block.getAttribute('listIndent') + indentBy;\n        if (blockIndent < 0) {\n            removeListAttributes(block, writer);\n        }\n        else {\n            writer.setAttribute('listIndent', blockIndent, block);\n        }\n    }\n    return allBlocks;\n}\n/**\n * Decreases indentation of given list of blocks. If the indentation of some blocks matches the indentation\n * of surrounding blocks, they get merged together.\n *\n * @internal\n * @param blocks The block or iterable of blocks.\n * @param writer The model writer.\n */\nexport function outdentBlocksWithMerge(blocks, writer) {\n    blocks = toArray(blocks);\n    // Expand the selected blocks to contain the whole list items.\n    const allBlocks = expandListBlocksToCompleteItems(blocks);\n    const visited = new Set();\n    const referenceIndent = Math.min(...allBlocks.map(block => block.getAttribute('listIndent')));\n    const parentBlocks = new Map();\n    // Collect parent blocks before the list structure gets altered.\n    for (const block of allBlocks) {\n        parentBlocks.set(block, ListWalker.first(block, { lowerIndent: true }));\n    }\n    for (const block of allBlocks) {\n        if (visited.has(block)) {\n            continue;\n        }\n        visited.add(block);\n        const blockIndent = block.getAttribute('listIndent') - 1;\n        if (blockIndent < 0) {\n            removeListAttributes(block, writer);\n            continue;\n        }\n        // Merge with parent list item while outdenting and indent matches reference indent.\n        if (block.getAttribute('listIndent') == referenceIndent) {\n            const mergedBlocks = mergeListItemIfNotLast(block, parentBlocks.get(block), writer);\n            // All list item blocks are updated while merging so add those to visited set.\n            for (const mergedBlock of mergedBlocks) {\n                visited.add(mergedBlock);\n            }\n            // The indent level was updated while merging so continue to next block.\n            if (mergedBlocks.length) {\n                continue;\n            }\n        }\n        writer.setAttribute('listIndent', blockIndent, block);\n    }\n    return sortBlocks(visited);\n}\n/**\n * Removes all list attributes from the given blocks.\n *\n * @internal\n * @param blocks The block or iterable of blocks.\n * @param writer The model writer.\n * @returns Array of altered blocks.\n */\nexport function removeListAttributes(blocks, writer) {\n    blocks = toArray(blocks);\n    for (const block of blocks) {\n        for (const attributeKey of block.getAttributeKeys()) {\n            if (attributeKey.startsWith('list')) {\n                writer.removeAttribute(attributeKey, block);\n            }\n        }\n    }\n    return blocks;\n}\n/**\n * Checks whether the given blocks are related to a single list item.\n *\n * @internal\n * @param blocks The list block elements.\n */\nexport function isSingleListItem(blocks) {\n    if (!blocks.length) {\n        return false;\n    }\n    const firstItemId = blocks[0].getAttribute('listItemId');\n    if (!firstItemId) {\n        return false;\n    }\n    return !blocks.some(item => item.getAttribute('listItemId') != firstItemId);\n}\n/**\n * Modifies the indents of list blocks following the given list block so the indentation is valid after\n * the given block is no longer a list item.\n *\n * @internal\n * @param lastBlock The last list block that has become a non-list element.\n * @param writer The model writer.\n * @returns Array of altered blocks.\n */\nexport function outdentFollowingItems(lastBlock, writer) {\n    const changedBlocks = [];\n    // Start from the model item that is just after the last turned-off item.\n    let currentIndent = Number.POSITIVE_INFINITY;\n    // Correct indent of all items after the last turned off item.\n    // Rules that should be followed:\n    // 1. All direct sub-items of turned-off item should become indent 0, because the first item after it\n    //    will be the first item of a new list. Other items are at the same level, so should have same 0 index.\n    // 2. All items with indent lower than indent of turned-off item should become indent 0, because they\n    //    should not end up as a child of any of list items that they were not children of before.\n    // 3. All other items should have their indent changed relatively to it's parent.\n    //\n    // For example:\n    // 1  * --------\n    // 2     * --------\n    // 3        * --------\t\t\t<-- this is turned off.\n    // 4           * --------\t\t<-- this has to become indent = 0, because it will be first item on a new list.\n    // 5              * --------\t<-- this should be still be a child of item above, so indent = 1.\n    // 6        * --------\t\t\t<-- this has to become indent = 0, because it should not be a child of any of items above.\n    // 7           * --------\t\t<-- this should be still be a child of item above, so indent = 1.\n    // 8     * --------\t\t\t\t<-- this has to become indent = 0.\n    // 9        * --------\t\t\t<-- this should still be a child of item above, so indent = 1.\n    // 10          * --------\t\t<-- this should still be a child of item above, so indent = 2.\n    // 11          * --------\t\t<-- this should still be at the same level as item above, so indent = 2.\n    // 12 * --------\t\t\t\t<-- this and all below are left unchanged.\n    // 13    * --------\n    // 14       * --------\n    //\n    // After turning off 3 the list becomes:\n    //\n    // 1  * --------\n    // 2     * --------\n    //\n    // 3  --------\n    //\n    // 4  * --------\n    // 5     * --------\n    // 6  * --------\n    // 7     * --------\n    // 8  * --------\n    // 9     * --------\n    // 10       * --------\n    // 11       * --------\n    // 12 * --------\n    // 13    * --------\n    // 14       * --------\n    //\n    // Thanks to this algorithm no lists are mismatched and no items get unexpected children/parent, while\n    // those parent-child connection which are possible to maintain are still maintained. It's worth noting\n    // that this is the same effect that we would be get by multiple use of outdent command. However doing\n    // it like this is much more efficient because it's less operation (less memory usage, easier OT) and\n    // less conversion (faster).\n    for (const { node } of iterateSiblingListBlocks(lastBlock.nextSibling, 'forward')) {\n        // Check each next list item, as long as its indent is higher than 0.\n        const indent = node.getAttribute('listIndent');\n        // If the indent is 0 we are not going to change anything anyway.\n        if (indent == 0) {\n            break;\n        }\n        // We check if that's item indent is lower than current relative indent.\n        if (indent < currentIndent) {\n            // If it is, current relative indent becomes that indent.\n            currentIndent = indent;\n        }\n        // Fix indent relatively to current relative indent.\n        // Note, that if we just changed the current relative indent, the newIndent will be equal to 0.\n        const newIndent = indent - currentIndent;\n        writer.setAttribute('listIndent', newIndent, node);\n        changedBlocks.push(node);\n    }\n    return changedBlocks;\n}\n/**\n * Returns the array of given blocks sorted by model indexes (document order).\n *\n * @internal\n */\nexport function sortBlocks(blocks) {\n    return Array.from(blocks)\n        .filter(block => block.root.rootName !== '$graveyard')\n        .sort((a, b) => a.index - b.index);\n}\n/**\n * Returns a selected block object. If a selected object is inline or when there is no selected\n * object, `null` is returned.\n *\n * @internal\n * @param model The instance of editor model.\n * @returns Selected block object or `null`.\n */\nexport function getSelectedBlockObject(model) {\n    const selectedElement = model.document.selection.getSelectedElement();\n    if (!selectedElement) {\n        return null;\n    }\n    if (model.schema.isObject(selectedElement) && model.schema.isBlock(selectedElement)) {\n        return selectedElement;\n    }\n    return null;\n}\n// Merges a given block to the given parent block if parent is a list item and there is no more blocks in the same item.\nfunction mergeListItemIfNotLast(block, parentBlock, writer) {\n    const parentItemBlocks = getListItemBlocks(parentBlock, { direction: 'forward' });\n    // Merge with parent only if outdented item wasn't the last one in its parent.\n    // Merge:\n    // * a\t\t\t->\t\t* a\n    //   * [b]\t\t->\t\t  b\n    //   c\t\t\t->\t\t  c\n    // Don't merge:\n    // * a\t\t\t->\t\t* a\n    //   * [b]\t\t-> \t\t* b\n    // * c\t\t\t->\t\t* c\n    if (parentItemBlocks.pop().index > block.index) {\n        return mergeListItemBefore(block, parentBlock, writer);\n    }\n    return [];\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlist/documentlistindentcommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { expandListBlocksToCompleteItems, indentBlocks, isFirstBlockOfListItem, isListItemBlock, isSingleListItem, outdentBlocksWithMerge, sortBlocks, splitListItemBefore } from './utils/model';\nimport ListWalker from './utils/listwalker';\n/**\n * The document list indent command. It is used by the {@link module:list/documentlist~DocumentList list feature}.\n */\nexport default class DocumentListIndentCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param editor The editor instance.\n     * @param indentDirection The direction of indent. If it is equal to `backward`, the command\n     * will outdent a list item.\n     */\n    constructor(editor, indentDirection) {\n        super(editor);\n        this._direction = indentDirection;\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.\n     *\n     * @fires execute\n     * @fires afterExecute\n     */\n    execute() {\n        const model = this.editor.model;\n        const blocks = getSelectedListBlocks(model.document.selection);\n        model.change(writer => {\n            const changedBlocks = [];\n            // Handle selection contained in the single list item and starting in the following blocks.\n            if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {\n                // Allow increasing indent of following list item blocks.\n                if (this._direction == 'forward') {\n                    changedBlocks.push(...indentBlocks(blocks, writer));\n                }\n                // For indent make sure that indented blocks have a new ID.\n                // For outdent just split blocks from the list item (give them a new IDs).\n                changedBlocks.push(...splitListItemBefore(blocks[0], writer));\n            }\n            // More than a single list item is selected, or the first block of list item is selected.\n            else {\n                // Now just update the attributes of blocks.\n                if (this._direction == 'forward') {\n                    changedBlocks.push(...indentBlocks(blocks, writer, { expand: true }));\n                }\n                else {\n                    changedBlocks.push(...outdentBlocksWithMerge(blocks, writer));\n                }\n            }\n            // Align the list item type to match the previous list item (from the same list).\n            for (const block of changedBlocks) {\n                // This block become a plain block (for example a paragraph).\n                if (!block.hasAttribute('listType')) {\n                    continue;\n                }\n                const previousItemBlock = ListWalker.first(block, { sameIndent: true });\n                if (previousItemBlock) {\n                    writer.setAttribute('listType', previousItemBlock.getAttribute('listType'), block);\n                }\n            }\n            this._fireAfterExecute(changedBlocks);\n        });\n    }\n    /**\n     * Fires the `afterExecute` event.\n     *\n     * @param changedBlocks The changed list elements.\n     */\n    _fireAfterExecute(changedBlocks) {\n        this.fire('afterExecute', sortBlocks(new Set(changedBlocks)));\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @returns Whether the command should be enabled.\n     */\n    _checkEnabled() {\n        // Check whether any of position's ancestor is a list item.\n        let blocks = getSelectedListBlocks(this.editor.model.document.selection);\n        let firstBlock = blocks[0];\n        // If selection is not in a list item, the command is disabled.\n        if (!firstBlock) {\n            return false;\n        }\n        // If we are outdenting it is enough to be in list item. Every list item can always be outdented.\n        if (this._direction == 'backward') {\n            return true;\n        }\n        // A single block of a list item is selected, so it could be indented as a sublist.\n        if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {\n            return true;\n        }\n        blocks = expandListBlocksToCompleteItems(blocks);\n        firstBlock = blocks[0];\n        // Check if there is any list item before selected items that could become a parent of selected items.\n        const siblingItem = ListWalker.first(firstBlock, { sameIndent: true });\n        if (!siblingItem) {\n            return false;\n        }\n        if (siblingItem.getAttribute('listType') == firstBlock.getAttribute('listType')) {\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * Returns an array of selected blocks truncated to the first non list block element.\n */\nfunction getSelectedListBlocks(selection) {\n    const blocks = Array.from(selection.getSelectedBlocks());\n    const firstNonListBlockIndex = blocks.findIndex(block => !isListItemBlock(block));\n    if (firstNonListBlockIndex != -1) {\n        blocks.length = firstNonListBlockIndex;\n    }\n    return blocks;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { splitListItemBefore, expandListBlocksToCompleteItems, getListItemBlocks, getListItems, removeListAttributes, outdentFollowingItems, ListItemUid, sortBlocks, getSelectedBlockObject, isListItemBlock } from './utils/model';\n/**\n * The list command. It is used by the {@link module:list/documentlist~DocumentList document list feature}.\n */\nexport default class DocumentListCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param editor The editor instance.\n     * @param type List type that will be handled by this command.\n     */\n    constructor(editor, type) {\n        super(editor);\n        this.type = type;\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        this.value = this._getValue();\n        this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Executes the list command.\n     *\n     * @fires execute\n     * @fires afterExecute\n     * @param options Command options.\n     * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the\n     * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements\n     * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const document = model.document;\n        const selectedBlockObject = getSelectedBlockObject(model);\n        const blocks = Array.from(document.selection.getSelectedBlocks())\n            .filter(block => model.schema.checkAttribute(block, 'listType'));\n        // Whether we are turning off some items.\n        const turnOff = options.forceValue !== undefined ? !options.forceValue : this.value;\n        model.change(writer => {\n            if (turnOff) {\n                const lastBlock = blocks[blocks.length - 1];\n                // Split the first block from the list item.\n                const itemBlocks = getListItemBlocks(lastBlock, { direction: 'forward' });\n                const changedBlocks = [];\n                if (itemBlocks.length > 1) {\n                    changedBlocks.push(...splitListItemBefore(itemBlocks[1], writer));\n                }\n                // Convert list blocks to plain blocks.\n                changedBlocks.push(...removeListAttributes(blocks, writer));\n                // Outdent items following the selected list item.\n                changedBlocks.push(...outdentFollowingItems(lastBlock, writer));\n                this._fireAfterExecute(changedBlocks);\n            }\n            // Turning on the list items for a collapsed selection inside a list item.\n            else if ((selectedBlockObject || document.selection.isCollapsed) && isListItemBlock(blocks[0])) {\n                const changedBlocks = getListItems(selectedBlockObject || blocks[0]);\n                for (const block of changedBlocks) {\n                    writer.setAttribute('listType', this.type, block);\n                }\n                this._fireAfterExecute(changedBlocks);\n            }\n            // Turning on the list items for a non-collapsed selection.\n            else {\n                const changedBlocks = [];\n                for (const block of blocks) {\n                    // Promote the given block to the list item.\n                    if (!block.hasAttribute('listType')) {\n                        writer.setAttributes({\n                            listIndent: 0,\n                            listItemId: ListItemUid.next(),\n                            listType: this.type\n                        }, block);\n                        changedBlocks.push(block);\n                    }\n                    // Change the type of list item.\n                    else {\n                        for (const node of expandListBlocksToCompleteItems(block, { withNested: false })) {\n                            if (node.getAttribute('listType') != this.type) {\n                                writer.setAttribute('listType', this.type, node);\n                                changedBlocks.push(node);\n                            }\n                        }\n                    }\n                }\n                this._fireAfterExecute(changedBlocks);\n            }\n        });\n    }\n    /**\n     * Fires the `afterExecute` event.\n     *\n     * @param changedBlocks The changed list elements.\n     */\n    _fireAfterExecute(changedBlocks) {\n        this.fire('afterExecute', sortBlocks(new Set(changedBlocks)));\n    }\n    /**\n     * Checks the command's {@link #value}.\n     *\n     * @returns The current value.\n     */\n    _getValue() {\n        const selection = this.editor.model.document.selection;\n        const blocks = Array.from(selection.getSelectedBlocks());\n        if (!blocks.length) {\n            return false;\n        }\n        for (const block of blocks) {\n            if (block.getAttribute('listType') != this.type) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @returns Whether the command should be enabled.\n     */\n    _checkEnabled() {\n        const selection = this.editor.model.document.selection;\n        const schema = this.editor.model.schema;\n        const blocks = Array.from(selection.getSelectedBlocks());\n        if (!blocks.length) {\n            return false;\n        }\n        // If command value is true it means that we are in list item, so the command should be enabled.\n        if (this.value) {\n            return true;\n        }\n        for (const block of blocks) {\n            if (schema.checkAttribute(block, 'listType')) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlist/documentlistmergecommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { getNestedListBlocks, indentBlocks, sortBlocks, isFirstBlockOfListItem, mergeListItemBefore, isSingleListItem, getSelectedBlockObject, isListItemBlock } from './utils/model';\nimport ListWalker from './utils/listwalker';\n/**\n * The document list merge command. It is used by the {@link module:list/documentlist~DocumentList list feature}.\n */\nexport default class DocumentListMergeCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param editor The editor instance.\n     * @param direction Whether list item should be merged before or after the selected block.\n     */\n    constructor(editor, direction) {\n        super(editor);\n        this._direction = direction;\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Merges list blocks together (depending on the {@link #constructor}'s `direction` parameter).\n     *\n     * @fires execute\n     * @fires afterExecute\n     * @param options Command options.\n     * @param options.shouldMergeOnBlocksContentLevel When set `true`, merging will be performed together\n     * with {@link module:engine/model/model~Model#deleteContent} to get rid of the inline content in the selection or take advantage\n     * of the heuristics in `deleteContent()` that helps convert lists into paragraphs in certain cases.\n     */\n    execute({ shouldMergeOnBlocksContentLevel = false } = {}) {\n        const model = this.editor.model;\n        const selection = model.document.selection;\n        const changedBlocks = [];\n        model.change(writer => {\n            const { firstElement, lastElement } = this._getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel);\n            const firstIndent = firstElement.getAttribute('listIndent') || 0;\n            const lastIndent = lastElement.getAttribute('listIndent');\n            const lastElementId = lastElement.getAttribute('listItemId');\n            if (firstIndent != lastIndent) {\n                const nestedLastElementBlocks = getNestedListBlocks(lastElement);\n                changedBlocks.push(...indentBlocks([lastElement, ...nestedLastElementBlocks], writer, {\n                    indentBy: firstIndent - lastIndent,\n                    // If outdenting, the entire sub-tree that follows must be included.\n                    expand: firstIndent < lastIndent\n                }));\n            }\n            if (shouldMergeOnBlocksContentLevel) {\n                let sel = selection;\n                if (selection.isCollapsed) {\n                    sel = writer.createSelection(writer.createRange(writer.createPositionAt(firstElement, 'end'), writer.createPositionAt(lastElement, 0)));\n                }\n                // Delete selected content. Replace entire content only for non-collapsed selection.\n                model.deleteContent(sel, { doNotResetEntireContent: selection.isCollapsed });\n                // Get the last \"touched\" element after deleteContent call (can't use the lastElement because\n                // it could get merged into the firstElement while deleting content).\n                const lastElementAfterDelete = sel.getLastPosition().parent;\n                // Check if the element after it was in the same list item and adjust it if needed.\n                const nextSibling = lastElementAfterDelete.nextSibling;\n                changedBlocks.push(lastElementAfterDelete);\n                if (nextSibling && nextSibling !== lastElement && nextSibling.getAttribute('listItemId') == lastElementId) {\n                    changedBlocks.push(...mergeListItemBefore(nextSibling, lastElementAfterDelete, writer));\n                }\n            }\n            else {\n                changedBlocks.push(...mergeListItemBefore(lastElement, firstElement, writer));\n            }\n            this._fireAfterExecute(changedBlocks);\n        });\n    }\n    /**\n     * Fires the `afterExecute` event.\n     *\n     * @param changedBlocks The changed list elements.\n     */\n    _fireAfterExecute(changedBlocks) {\n        this.fire('afterExecute', sortBlocks(new Set(changedBlocks)));\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @returns Whether the command should be enabled.\n     */\n    _checkEnabled() {\n        const model = this.editor.model;\n        const selection = model.document.selection;\n        const selectedBlockObject = getSelectedBlockObject(model);\n        if (selection.isCollapsed || selectedBlockObject) {\n            const positionParent = selectedBlockObject || selection.getFirstPosition().parent;\n            if (!isListItemBlock(positionParent)) {\n                return false;\n            }\n            const siblingNode = this._direction == 'backward' ?\n                positionParent.previousSibling :\n                positionParent.nextSibling;\n            if (!siblingNode) {\n                return false;\n            }\n            if (isSingleListItem([positionParent, siblingNode])) {\n                return false;\n            }\n        }\n        else {\n            const lastPosition = selection.getLastPosition();\n            const firstPosition = selection.getFirstPosition();\n            // If deleting within a single block of a list item, there's no need to merge anything.\n            // The default delete should be executed instead.\n            if (lastPosition.parent === firstPosition.parent) {\n                return false;\n            }\n            if (!isListItemBlock(lastPosition.parent)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns the boundary elements the merge should be executed for. These are not necessarily selection's first\n     * and last position parents but sometimes sibling or even further blocks depending on the context.\n     *\n     * @param selection The selection the merge is executed for.\n     * @param shouldMergeOnBlocksContentLevel When `true`, merge is performed together with\n     * {@link module:engine/model/model~Model#deleteContent} to remove the inline content within the selection.\n     */\n    _getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel) {\n        const model = this.editor.model;\n        const selectedBlockObject = getSelectedBlockObject(model);\n        let firstElement, lastElement;\n        if (selection.isCollapsed || selectedBlockObject) {\n            const positionParent = selectedBlockObject || selection.getFirstPosition().parent;\n            const isFirstBlock = isFirstBlockOfListItem(positionParent);\n            if (this._direction == 'backward') {\n                lastElement = positionParent;\n                if (isFirstBlock && !shouldMergeOnBlocksContentLevel) {\n                    // For the \"c\" as an anchorElement:\n                    //  * a\n                    //    * b\n                    //  * [c]  <-- this block should be merged with \"a\"\n                    // It should find \"a\" element to merge with:\n                    //  * a\n                    //    * b\n                    //    c\n                    firstElement = ListWalker.first(positionParent, { sameIndent: true, lowerIndent: true });\n                }\n                else {\n                    firstElement = positionParent.previousSibling;\n                }\n            }\n            else {\n                // In case of the forward merge there is no case as above, just merge with next sibling.\n                firstElement = positionParent;\n                lastElement = positionParent.nextSibling;\n            }\n        }\n        else {\n            firstElement = selection.getFirstPosition().parent;\n            lastElement = selection.getLastPosition().parent;\n        }\n        return {\n            firstElement: firstElement,\n            lastElement: lastElement\n        };\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { isFirstBlockOfListItem, isListItemBlock, sortBlocks, splitListItemBefore } from './utils/model';\n/**\n * The document list split command that splits the list item at the selection.\n *\n * It is used by the {@link module:list/documentlist~DocumentList document list feature}.\n */\nexport default class DocumentListSplitCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param editor The editor instance.\n     * @param direction Whether list item should be split before or after the selected block.\n     */\n    constructor(editor, direction) {\n        super(editor);\n        this._direction = direction;\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Splits the list item at the selection.\n     *\n     * @fires execute\n     * @fires afterExecute\n     */\n    execute() {\n        const editor = this.editor;\n        editor.model.change(writer => {\n            const changedBlocks = splitListItemBefore(this._getStartBlock(), writer);\n            this._fireAfterExecute(changedBlocks);\n        });\n    }\n    /**\n     * Fires the `afterExecute` event.\n     *\n     * @param changedBlocks The changed list elements.\n     */\n    _fireAfterExecute(changedBlocks) {\n        this.fire('afterExecute', sortBlocks(new Set(changedBlocks)));\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @returns Whether the command should be enabled.\n     */\n    _checkEnabled() {\n        const selection = this.editor.model.document.selection;\n        const block = this._getStartBlock();\n        return selection.isCollapsed &&\n            isListItemBlock(block) &&\n            !isFirstBlockOfListItem(block);\n    }\n    /**\n     * Returns the model element that is the main focus of the command (according to the current selection and command direction).\n     */\n    _getStartBlock() {\n        const doc = this.editor.model.document;\n        const positionParent = doc.selection.getFirstPosition().parent;\n        return (this._direction == 'before' ? positionParent : positionParent.nextSibling);\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { expandListBlocksToCompleteItems, expandListBlocksToCompleteList, isFirstBlockOfListItem, isListItemBlock } from './utils/model';\n/**\n * A set of helpers related to document lists.\n */\nexport default class DocumentListUtils extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DocumentListUtils';\n    }\n    /**\n     * Expands the given list of selected blocks to include all the items of the lists they're in.\n     *\n     * @param blocks The list of selected blocks.\n     */\n    expandListBlocksToCompleteList(blocks) {\n        return expandListBlocksToCompleteList(blocks);\n    }\n    /**\n     * Check if the given block is the first in the list item.\n     *\n     * @param listBlock The list block element.\n     */\n    isFirstBlockOfListItem(listBlock) {\n        return isFirstBlockOfListItem(listBlock);\n    }\n    /**\n     * Returns true if the given model node is a list item block.\n     *\n     * @param node A model node.\n     */\n    isListItemBlock(node) {\n        return isListItemBlock(node);\n    }\n    /**\n     * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.\n     *\n     * @param blocks The list of selected blocks.\n     * @param options.withNested Whether should include nested list items.\n     */\n    expandListBlocksToCompleteItems(blocks, options = {}) {\n        return expandListBlocksToCompleteItems(blocks, options);\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Checks if view element is a list type (ul or ol).\n *\n * @internal\n */\nexport function isListView(viewElement) {\n    return viewElement.is('element', 'ol') || viewElement.is('element', 'ul');\n}\n/**\n * Checks if view element is a list item (li).\n *\n * @internal\n */\nexport function isListItemView(viewElement) {\n    return viewElement.is('element', 'li');\n}\n/**\n * Calculates the indent value for a list item. Handles HTML compliant and non-compliant lists.\n *\n * Also, fixes non HTML compliant lists indents:\n *\n * ```\n * before:                                     fixed list:\n * OL                                          OL\n * |-> LI (parent LIs: 0)                      |-> LI     (indent: 0)\n *     |-> OL                                  |-> OL\n *         |-> OL                                  |\n *         |   |-> OL                              |\n *         |       |-> OL                          |\n *         |           |-> LI (parent LIs: 1)      |-> LI (indent: 1)\n *         |-> LI (parent LIs: 1)                  |-> LI (indent: 1)\n *\n * before:                                     fixed list:\n * OL                                          OL\n * |-> OL                                      |\n *     |-> OL                                  |\n *          |-> OL                             |\n *              |-> LI (parent LIs: 0)         |-> LI        (indent: 0)\n *\n * before:                                     fixed list:\n * OL                                          OL\n * |-> LI (parent LIs: 0)                      |-> LI         (indent: 0)\n * |-> OL                                          |-> OL\n *     |-> LI (parent LIs: 0)                          |-> LI (indent: 1)\n * ```\n *\n * @internal\n */\nexport function getIndent(listItem) {\n    let indent = 0;\n    let parent = listItem.parent;\n    while (parent) {\n        // Each LI in the tree will result in an increased indent for HTML compliant lists.\n        if (isListItemView(parent)) {\n            indent++;\n        }\n        else {\n            // If however the list is nested in other list we should check previous sibling of any of the list elements...\n            const previousSibling = parent.previousSibling;\n            // ...because the we might need increase its indent:\n            //\t\tbefore:                           fixed list:\n            //\t\tOL                                OL\n            //\t\t|-> LI (parent LIs: 0)            |-> LI         (indent: 0)\n            //\t\t|-> OL                                |-> OL\n            //\t\t    |-> LI (parent LIs: 0)                |-> LI (indent: 1)\n            if (previousSibling && isListItemView(previousSibling)) {\n                indent++;\n            }\n        }\n        parent = parent.parent;\n    }\n    return indent;\n}\n/**\n * Creates a list attribute element (ol or ul).\n *\n * @internal\n */\nexport function createListElement(writer, indent, type, id = getViewElementIdForListType(type, indent)) {\n    // Negative priorities so that restricted editing attribute won't wrap lists.\n    return writer.createAttributeElement(getViewElementNameForListType(type), null, {\n        priority: 2 * indent / 100 - 100,\n        id\n    });\n}\n/**\n * Creates a list item attribute element (li).\n *\n * @internal\n */\nexport function createListItemElement(writer, indent, id) {\n    // Negative priorities so that restricted editing attribute won't wrap list items.\n    return writer.createAttributeElement('li', null, {\n        priority: (2 * indent + 1) / 100 - 100,\n        id\n    });\n}\n/**\n * Returns a view element name for the given list type.\n *\n * @internal\n */\nexport function getViewElementNameForListType(type) {\n    return type == 'numbered' ? 'ol' : 'ul';\n}\n/**\n * Returns a view element ID for the given list type and indent.\n *\n * @internal\n */\nexport function getViewElementIdForListType(type, indent) {\n    return `list-${type}-${indent}`;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { iterateSiblingListBlocks } from './listwalker';\nimport { getListItemBlocks, isListItemBlock, ListItemUid } from './model';\n/**\n * Based on the provided positions looks for the list head and stores it in the provided map.\n *\n * @internal\n * @param position The search starting position.\n * @param itemToListHead The map from list item element to the list head element.\n */\nexport function findAndAddListHeadToMap(position, itemToListHead) {\n    const previousNode = position.nodeBefore;\n    if (!isListItemBlock(previousNode)) {\n        const item = position.nodeAfter;\n        if (isListItemBlock(item)) {\n            itemToListHead.set(item, item);\n        }\n    }\n    else {\n        let listHead = previousNode;\n        // Previously, the loop below was defined like this:\n        //\n        // \t\tfor ( { node: listHead } of iterateSiblingListBlocks( listHead, 'backward' ) )\n        //\n        // Unfortunately, such a destructuring is incorrectly transpiled by Babel and the loop never ends.\n        // See: https://github.com/ckeditor/ckeditor5-react/issues/345.\n        for (const { node } of iterateSiblingListBlocks(listHead, 'backward')) {\n            listHead = node;\n            if (itemToListHead.has(listHead)) {\n                return;\n            }\n        }\n        itemToListHead.set(previousNode, listHead);\n    }\n}\n/**\n * Scans the list starting from the given list head element and fixes items' indentation.\n *\n * @internal\n * @param listNodes The iterable of list nodes.\n * @param writer The model writer.\n * @returns Whether the model was modified.\n */\nexport function fixListIndents(listNodes, writer) {\n    let maxIndent = 0; // Guards local sublist max indents that need fixing.\n    let prevIndent = -1; // Previous item indent.\n    let fixBy = null;\n    let applied = false;\n    for (const { node } of listNodes) {\n        const itemIndent = node.getAttribute('listIndent');\n        if (itemIndent > maxIndent) {\n            let newIndent;\n            if (fixBy === null) {\n                fixBy = itemIndent - maxIndent;\n                newIndent = maxIndent;\n            }\n            else {\n                if (fixBy > itemIndent) {\n                    fixBy = itemIndent;\n                }\n                newIndent = itemIndent - fixBy;\n            }\n            if (newIndent > prevIndent + 1) {\n                newIndent = prevIndent + 1;\n            }\n            writer.setAttribute('listIndent', newIndent, node);\n            applied = true;\n            prevIndent = newIndent;\n        }\n        else {\n            fixBy = null;\n            maxIndent = itemIndent + 1;\n            prevIndent = itemIndent;\n        }\n    }\n    return applied;\n}\n/**\n * Scans the list starting from the given list head element and fixes items' types.\n *\n * @internal\n * @param listNodes The iterable of list nodes.\n * @param seenIds The set of already known IDs.\n * @param writer The model writer.\n * @returns Whether the model was modified.\n */\nexport function fixListItemIds(listNodes, seenIds, writer) {\n    const visited = new Set();\n    let applied = false;\n    for (const { node } of listNodes) {\n        if (visited.has(node)) {\n            continue;\n        }\n        let listType = node.getAttribute('listType');\n        let listItemId = node.getAttribute('listItemId');\n        // Use a new ID if this one was spot earlier (even in other list).\n        if (seenIds.has(listItemId)) {\n            listItemId = ListItemUid.next();\n        }\n        seenIds.add(listItemId);\n        for (const block of getListItemBlocks(node, { direction: 'forward' })) {\n            visited.add(block);\n            // Use a new ID if a block of a bigger list item has different type.\n            if (block.getAttribute('listType') != listType) {\n                listItemId = ListItemUid.next();\n                listType = block.getAttribute('listType');\n            }\n            if (block.getAttribute('listItemId') != listItemId) {\n                writer.setAttribute('listItemId', listItemId, block);\n                applied = true;\n            }\n        }\n    }\n    return applied;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlist/converters\n */\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport { getAllListItemBlocks, getListItemBlocks, isListItemBlock, ListItemUid } from './utils/model';\nimport { createListElement, createListItemElement, getIndent, isListView, isListItemView } from './utils/view';\nimport ListWalker, { iterateSiblingListBlocks } from './utils/listwalker';\nimport { findAndAddListHeadToMap } from './utils/postfixers';\n/**\n * Returns the upcast converter for list items. It's supposed to work after the block converters (content inside list items) are converted.\n *\n * @internal\n */\nexport function listItemUpcastConverter() {\n    return (evt, data, conversionApi) => {\n        const { writer, schema } = conversionApi;\n        if (!data.modelRange) {\n            return;\n        }\n        const items = Array.from(data.modelRange.getItems({ shallow: true }))\n            .filter((item) => schema.checkAttribute(item, 'listItemId'));\n        if (!items.length) {\n            return;\n        }\n        const attributes = {\n            listItemId: ListItemUid.next(),\n            listIndent: getIndent(data.viewItem),\n            listType: data.viewItem.parent && data.viewItem.parent.is('element', 'ol') ? 'numbered' : 'bulleted'\n        };\n        for (const item of items) {\n            // Set list attributes only on same level items, those nested deeper are already handled by the recursive conversion.\n            if (!isListItemBlock(item)) {\n                writer.setAttributes(attributes, item);\n            }\n        }\n        if (items.length > 1) {\n            // Make sure that list item that contain only nested list will preserve paragraph for itself:\n            //\t<ul>\n            //\t\t<li>\n            //\t\t\t<p></p>  <-- this one must be kept\n            //\t\t\t<ul>\n            //\t\t\t\t<li></li>\n            //\t\t\t</ul>\n            //\t\t</li>\n            //\t</ul>\n            if (items[1].getAttribute('listItemId') != attributes.listItemId) {\n                conversionApi.keepEmptyElement(items[0]);\n            }\n        }\n    };\n}\n/**\n * Returns the upcast converter for the `<ul>` and `<ol>` view elements that cleans the input view of garbage.\n * This is mostly to clean whitespaces from between the `<li>` view elements inside the view list element. However,\n * incorrect data can also be cleared if the view was incorrect.\n *\n * @internal\n */\nexport function listUpcastCleanList() {\n    return (evt, data, conversionApi) => {\n        if (!conversionApi.consumable.test(data.viewItem, { name: true })) {\n            return;\n        }\n        const viewWriter = new UpcastWriter(data.viewItem.document);\n        for (const child of Array.from(data.viewItem.getChildren())) {\n            if (!isListItemView(child) && !isListView(child)) {\n                viewWriter.remove(child);\n            }\n        }\n    };\n}\n/**\n * Returns a model document change:data event listener that triggers conversion of related items if needed.\n *\n * @internal\n * @param model The editor model.\n * @param editing The editing controller.\n * @param attributeNames The list of all model list attributes (including registered strategies).\n * @param documentListEditing The document list editing plugin.\n */\nexport function reconvertItemsOnDataChange(model, editing, attributeNames, documentListEditing) {\n    return () => {\n        const changes = model.document.differ.getChanges();\n        const itemsToRefresh = [];\n        const itemToListHead = new Map();\n        const changedItems = new Set();\n        for (const entry of changes) {\n            if (entry.type == 'insert' && entry.name != '$text') {\n                findAndAddListHeadToMap(entry.position, itemToListHead);\n                // Insert of a non-list item.\n                if (!entry.attributes.has('listItemId')) {\n                    findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);\n                }\n                else {\n                    changedItems.add(entry.position.nodeAfter);\n                }\n            }\n            // Removed list item.\n            else if (entry.type == 'remove' && entry.attributes.has('listItemId')) {\n                findAndAddListHeadToMap(entry.position, itemToListHead);\n            }\n            // Changed list attribute.\n            else if (entry.type == 'attribute') {\n                const item = entry.range.start.nodeAfter;\n                if (attributeNames.includes(entry.attributeKey)) {\n                    findAndAddListHeadToMap(entry.range.start, itemToListHead);\n                    if (entry.attributeNewValue === null) {\n                        findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);\n                        // Check if paragraph should be converted from bogus to plain paragraph.\n                        if (doesItemParagraphRequiresRefresh(item)) {\n                            itemsToRefresh.push(item);\n                        }\n                    }\n                    else {\n                        changedItems.add(item);\n                    }\n                }\n                else if (isListItemBlock(item)) {\n                    // Some other attribute was changed on the list item,\n                    // check if paragraph does not need to be converted to bogus or back.\n                    if (doesItemParagraphRequiresRefresh(item)) {\n                        itemsToRefresh.push(item);\n                    }\n                }\n            }\n        }\n        for (const listHead of itemToListHead.values()) {\n            itemsToRefresh.push(...collectListItemsToRefresh(listHead, changedItems));\n        }\n        for (const item of new Set(itemsToRefresh)) {\n            editing.reconvertItem(item);\n        }\n    };\n    function collectListItemsToRefresh(listHead, changedItems) {\n        const itemsToRefresh = [];\n        const visited = new Set();\n        const stack = [];\n        for (const { node, previous } of iterateSiblingListBlocks(listHead, 'forward')) {\n            if (visited.has(node)) {\n                continue;\n            }\n            const itemIndent = node.getAttribute('listIndent');\n            // Current node is at the lower indent so trim the stack.\n            if (previous && itemIndent < previous.getAttribute('listIndent')) {\n                stack.length = itemIndent + 1;\n            }\n            // Update the stack for the current indent level.\n            stack[itemIndent] = Object.fromEntries(Array.from(node.getAttributes())\n                .filter(([key]) => attributeNames.includes(key)));\n            // Find all blocks of the current node.\n            const blocks = getListItemBlocks(node, { direction: 'forward' });\n            for (const block of blocks) {\n                visited.add(block);\n                // Check if bogus vs plain paragraph needs refresh.\n                if (doesItemParagraphRequiresRefresh(block, blocks)) {\n                    itemsToRefresh.push(block);\n                }\n                // Check if wrapping with UL, OL, LIs needs refresh.\n                else if (doesItemWrappingRequiresRefresh(block, stack, changedItems)) {\n                    itemsToRefresh.push(block);\n                }\n            }\n        }\n        return itemsToRefresh;\n    }\n    function doesItemParagraphRequiresRefresh(item, blocks) {\n        if (!item.is('element', 'paragraph')) {\n            return false;\n        }\n        const viewElement = editing.mapper.toViewElement(item);\n        if (!viewElement) {\n            return false;\n        }\n        const useBogus = shouldUseBogusParagraph(item, attributeNames, blocks);\n        if (useBogus && viewElement.is('element', 'p')) {\n            return true;\n        }\n        else if (!useBogus && viewElement.is('element', 'span')) {\n            return true;\n        }\n        return false;\n    }\n    function doesItemWrappingRequiresRefresh(item, stack, changedItems) {\n        // Items directly affected by some \"change\" don't need a refresh, they will be converted by their own changes.\n        if (changedItems.has(item)) {\n            return false;\n        }\n        const viewElement = editing.mapper.toViewElement(item);\n        let indent = stack.length - 1;\n        // Traverse down the stack to the root to verify if all ULs, OLs, and LIs are as expected.\n        for (let element = viewElement.parent; !element.is('editableElement'); element = element.parent) {\n            const isListItemElement = isListItemView(element);\n            const isListElement = isListView(element);\n            if (!isListElement && !isListItemElement) {\n                continue;\n            }\n            const eventName = `checkAttributes:${isListItemElement ? 'item' : 'list'}`;\n            const needsRefresh = documentListEditing.fire(eventName, {\n                viewElement: element,\n                modelAttributes: stack[indent]\n            });\n            if (needsRefresh) {\n                break;\n            }\n            if (isListElement) {\n                indent--;\n                // Don't need to iterate further if we already know that the item is wrapped appropriately.\n                if (indent < 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n/**\n * Returns the list item downcast converter.\n *\n * @internal\n * @param attributeNames A list of attribute names that should be converted if they are set.\n * @param strategies The strategies.\n * @param model The model.\n */\nexport function listItemDowncastConverter(attributeNames, strategies, model) {\n    const consumer = createAttributesConsumer(attributeNames);\n    return (evt, data, conversionApi) => {\n        const { writer, mapper, consumable } = conversionApi;\n        const listItem = data.item;\n        if (!attributeNames.includes(data.attributeKey)) {\n            return;\n        }\n        // Test if attributes on the converted items are not consumed.\n        if (!consumer(listItem, consumable)) {\n            return;\n        }\n        // Use positions mapping instead of mapper.toViewElement( listItem ) to find outermost view element.\n        // This is for cases when mapping is using inner view element like in the code blocks (pre > code).\n        const viewElement = findMappedViewElement(listItem, mapper, model);\n        // Unwrap element from current list wrappers.\n        unwrapListItemBlock(viewElement, writer);\n        // Then wrap them with the new list wrappers.\n        wrapListItemBlock(listItem, writer.createRangeOn(viewElement), strategies, writer);\n    };\n}\n/**\n * Returns the bogus paragraph view element creator. A bogus paragraph is used if a list item contains only a single block or nested list.\n *\n * @internal\n * @param attributeNames The list of all model list attributes (including registered strategies).\n */\nexport function bogusParagraphCreator(attributeNames, { dataPipeline } = {}) {\n    return (modelElement, { writer }) => {\n        // Convert only if a bogus paragraph should be used.\n        if (!shouldUseBogusParagraph(modelElement, attributeNames)) {\n            return null;\n        }\n        if (!dataPipeline) {\n            return writer.createContainerElement('span', { class: 'ck-list-bogus-paragraph' });\n        }\n        // Using `<p>` in case there are some markers on it and transparentRendering will render it anyway.\n        const viewElement = writer.createContainerElement('p');\n        writer.setCustomProperty('dataPipeline:transparentRendering', true, viewElement);\n        return viewElement;\n    };\n}\n/**\n * Helper for mapping mode to view elements. It's using positions mapping instead of mapper.toViewElement( element )\n * to find outermost view element. This is for cases when mapping is using inner view element like in the code blocks (pre > code).\n *\n * @internal\n * @param element The model element.\n * @param mapper The mapper instance.\n * @param model The model.\n */\nexport function findMappedViewElement(element, mapper, model) {\n    const modelRange = model.createRangeOn(element);\n    const viewRange = mapper.toViewRange(modelRange).getTrimmed();\n    return viewRange.getContainedElement();\n}\n// Unwraps all ol, ul, and li attribute elements that are wrapping the provided view element.\nfunction unwrapListItemBlock(viewElement, viewWriter) {\n    let attributeElement = viewElement.parent;\n    while (attributeElement.is('attributeElement') && ['ul', 'ol', 'li'].includes(attributeElement.name)) {\n        const parentElement = attributeElement.parent;\n        viewWriter.unwrap(viewWriter.createRangeOn(viewElement), attributeElement);\n        attributeElement = parentElement;\n    }\n}\n// Wraps the given list item with appropriate attribute elements for ul, ol, and li.\nfunction wrapListItemBlock(listItem, viewRange, strategies, writer) {\n    if (!listItem.hasAttribute('listIndent')) {\n        return;\n    }\n    const listItemIndent = listItem.getAttribute('listIndent');\n    let currentListItem = listItem;\n    for (let indent = listItemIndent; indent >= 0; indent--) {\n        const listItemViewElement = createListItemElement(writer, indent, currentListItem.getAttribute('listItemId'));\n        const listViewElement = createListElement(writer, indent, currentListItem.getAttribute('listType'));\n        for (const strategy of strategies) {\n            if (currentListItem.hasAttribute(strategy.attributeName)) {\n                strategy.setAttributeOnDowncast(writer, currentListItem.getAttribute(strategy.attributeName), strategy.scope == 'list' ? listViewElement : listItemViewElement);\n            }\n        }\n        viewRange = writer.wrap(viewRange, listItemViewElement);\n        viewRange = writer.wrap(viewRange, listViewElement);\n        if (indent == 0) {\n            break;\n        }\n        currentListItem = ListWalker.first(currentListItem, { lowerIndent: true });\n        // There is no list item with lower indent, this means this is a document fragment containing\n        // only a part of nested list (like copy to clipboard) so we don't need to try to wrap it further.\n        if (!currentListItem) {\n            break;\n        }\n    }\n}\n// Returns the function that is responsible for consuming attributes that are set on the model node.\nfunction createAttributesConsumer(attributeNames) {\n    return (node, consumable) => {\n        const events = [];\n        // Collect all set attributes that are triggering conversion.\n        for (const attributeName of attributeNames) {\n            if (node.hasAttribute(attributeName)) {\n                events.push(`attribute:${attributeName}`);\n            }\n        }\n        if (!events.every(event => consumable.test(node, event) !== false)) {\n            return false;\n        }\n        events.forEach(event => consumable.consume(node, event));\n        return true;\n    };\n}\n// Whether the given item should be rendered as a bogus paragraph.\nfunction shouldUseBogusParagraph(item, attributeNames, blocks = getAllListItemBlocks(item)) {\n    if (!isListItemBlock(item)) {\n        return false;\n    }\n    for (const attributeKey of item.getAttributeKeys()) {\n        // Ignore selection attributes stored on block elements.\n        if (attributeKey.startsWith('selection:')) {\n            continue;\n        }\n        // Don't use bogus paragraph if there are attributes from other features.\n        if (!attributeNames.includes(attributeKey)) {\n            return false;\n        }\n    }\n    return blocks.length < 2;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlist/documentlistediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { Delete } from 'ckeditor5/src/typing';\nimport { Enter } from 'ckeditor5/src/enter';\nimport { CKEditorError } from 'ckeditor5/src/utils';\nimport DocumentListIndentCommand from './documentlistindentcommand';\nimport DocumentListCommand from './documentlistcommand';\nimport DocumentListMergeCommand from './documentlistmergecommand';\nimport DocumentListSplitCommand from './documentlistsplitcommand';\nimport DocumentListUtils from './documentlistutils';\nimport { bogusParagraphCreator, listItemDowncastConverter, listItemUpcastConverter, listUpcastCleanList, reconvertItemsOnDataChange } from './converters';\nimport { findAndAddListHeadToMap, fixListIndents, fixListItemIds } from './utils/postfixers';\nimport { getAllListItemBlocks, isFirstBlockOfListItem, isLastBlockOfListItem, isSingleListItem, getSelectedBlockObject, isListItemBlock, removeListAttributes } from './utils/model';\nimport { getViewElementIdForListType, getViewElementNameForListType } from './utils/view';\nimport ListWalker, { iterateSiblingListBlocks, ListBlocksIterable } from './utils/listwalker';\nimport '../../theme/documentlist.css';\nimport '../../theme/list.css';\n/**\n * A list of base list model attributes.\n */\nconst LIST_BASE_ATTRIBUTES = ['listType', 'listIndent', 'listItemId'];\n/**\n * The editing part of the document-list feature. It handles creating, editing and removing lists and list items.\n */\nexport default class DocumentListEditing extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * The list of registered downcast strategies.\n         */\n        this._downcastStrategies = [];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DocumentListEditing';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [Enter, Delete, DocumentListUtils];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const model = editor.model;\n        if (editor.plugins.has('ListEditing')) {\n            /**\n             * The `DocumentList` feature can not be loaded together with the `List` plugin.\n             *\n             * @error document-list-feature-conflict\n             * @param conflictPlugin Name of the plugin.\n             */\n            throw new CKEditorError('document-list-feature-conflict', this, { conflictPlugin: 'ListEditing' });\n        }\n        model.schema.extend('$container', { allowAttributes: LIST_BASE_ATTRIBUTES });\n        model.schema.extend('$block', { allowAttributes: LIST_BASE_ATTRIBUTES });\n        model.schema.extend('$blockObject', { allowAttributes: LIST_BASE_ATTRIBUTES });\n        for (const attribute of LIST_BASE_ATTRIBUTES) {\n            model.schema.setAttributeProperties(attribute, {\n                copyOnReplace: true\n            });\n        }\n        // Register commands.\n        editor.commands.add('numberedList', new DocumentListCommand(editor, 'numbered'));\n        editor.commands.add('bulletedList', new DocumentListCommand(editor, 'bulleted'));\n        editor.commands.add('indentList', new DocumentListIndentCommand(editor, 'forward'));\n        editor.commands.add('outdentList', new DocumentListIndentCommand(editor, 'backward'));\n        editor.commands.add('mergeListItemBackward', new DocumentListMergeCommand(editor, 'backward'));\n        editor.commands.add('mergeListItemForward', new DocumentListMergeCommand(editor, 'forward'));\n        editor.commands.add('splitListItemBefore', new DocumentListSplitCommand(editor, 'before'));\n        editor.commands.add('splitListItemAfter', new DocumentListSplitCommand(editor, 'after'));\n        this._setupDeleteIntegration();\n        this._setupEnterIntegration();\n        this._setupTabIntegration();\n        this._setupClipboardIntegration();\n    }\n    /**\n     * @inheritDoc\n     */\n    afterInit() {\n        const editor = this.editor;\n        const commands = editor.commands;\n        const indent = commands.get('indent');\n        const outdent = commands.get('outdent');\n        if (indent) {\n            // Priority is high due to integration with `IndentBlock` plugin. We want to indent list first and if it's not possible\n            // user can indent content with `IndentBlock` plugin.\n            indent.registerChildCommand(commands.get('indentList'), { priority: 'high' });\n        }\n        if (outdent) {\n            // Priority is lowest due to integration with `IndentBlock` and `IndentCode` plugins.\n            // First we want to allow user to outdent all indendations from other features then he can oudent list item.\n            outdent.registerChildCommand(commands.get('outdentList'), { priority: 'lowest' });\n        }\n        // Register conversion and model post-fixer after other plugins had a chance to register their attribute strategies.\n        this._setupModelPostFixing();\n        this._setupConversion();\n    }\n    /**\n     * Registers a downcast strategy.\n     *\n     * **Note**: Strategies must be registered in the `Plugin#init()` phase so that it can be applied\n     * in the `DocumentListEditing#afterInit()`.\n     *\n     * @param strategy The downcast strategy to register.\n     */\n    registerDowncastStrategy(strategy) {\n        this._downcastStrategies.push(strategy);\n    }\n    /**\n     * Returns list of model attribute names that should affect downcast conversion.\n     */\n    _getListAttributeNames() {\n        return [\n            ...LIST_BASE_ATTRIBUTES,\n            ...this._downcastStrategies.map(strategy => strategy.attributeName)\n        ];\n    }\n    /**\n     * Attaches the listener to the {@link module:engine/view/document~Document#event:delete} event and handles backspace/delete\n     * keys in and around document lists.\n     */\n    _setupDeleteIntegration() {\n        const editor = this.editor;\n        const mergeBackwardCommand = editor.commands.get('mergeListItemBackward');\n        const mergeForwardCommand = editor.commands.get('mergeListItemForward');\n        this.listenTo(editor.editing.view.document, 'delete', (evt, data) => {\n            const selection = editor.model.document.selection;\n            // Let the Widget plugin take care of block widgets while deleting (https://github.com/ckeditor/ckeditor5/issues/11346).\n            if (getSelectedBlockObject(editor.model)) {\n                return;\n            }\n            editor.model.change(() => {\n                const firstPosition = selection.getFirstPosition();\n                if (selection.isCollapsed && data.direction == 'backward') {\n                    if (!firstPosition.isAtStart) {\n                        return;\n                    }\n                    const positionParent = firstPosition.parent;\n                    if (!isListItemBlock(positionParent)) {\n                        return;\n                    }\n                    const previousBlock = ListWalker.first(positionParent, {\n                        sameAttributes: 'listType',\n                        sameIndent: true\n                    });\n                    // Outdent the first block of a first list item.\n                    if (!previousBlock && positionParent.getAttribute('listIndent') === 0) {\n                        if (!isLastBlockOfListItem(positionParent)) {\n                            editor.execute('splitListItemAfter');\n                        }\n                        editor.execute('outdentList');\n                    }\n                    // Merge block with previous one (on the block level or on the content level).\n                    else {\n                        if (!mergeBackwardCommand.isEnabled) {\n                            return;\n                        }\n                        mergeBackwardCommand.execute({\n                            shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, 'backward')\n                        });\n                    }\n                    data.preventDefault();\n                    evt.stop();\n                }\n                // Non-collapsed selection or forward delete.\n                else {\n                    // Collapsed selection should trigger forward merging only if at the end of a block.\n                    if (selection.isCollapsed && !selection.getLastPosition().isAtEnd) {\n                        return;\n                    }\n                    if (!mergeForwardCommand.isEnabled) {\n                        return;\n                    }\n                    mergeForwardCommand.execute({\n                        shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, 'forward')\n                    });\n                    data.preventDefault();\n                    evt.stop();\n                }\n            });\n        }, { context: 'li' });\n    }\n    /**\n     * Attaches a listener to the {@link module:engine/view/document~Document#event:enter} event and handles enter key press\n     * in document lists.\n     */\n    _setupEnterIntegration() {\n        const editor = this.editor;\n        const model = editor.model;\n        const commands = editor.commands;\n        const enterCommand = commands.get('enter');\n        // Overwrite the default Enter key behavior: outdent or split the list in certain cases.\n        this.listenTo(editor.editing.view.document, 'enter', (evt, data) => {\n            const doc = model.document;\n            const positionParent = doc.selection.getFirstPosition().parent;\n            if (doc.selection.isCollapsed &&\n                isListItemBlock(positionParent) &&\n                positionParent.isEmpty &&\n                !data.isSoft) {\n                const isFirstBlock = isFirstBlockOfListItem(positionParent);\n                const isLastBlock = isLastBlockOfListItem(positionParent);\n                // * a      →      * a\n                // * []     →      []\n                if (isFirstBlock && isLastBlock) {\n                    editor.execute('outdentList');\n                    data.preventDefault();\n                    evt.stop();\n                }\n                // * []     →      * []\n                //   a      →      * a\n                else if (isFirstBlock && !isLastBlock) {\n                    editor.execute('splitListItemAfter');\n                    data.preventDefault();\n                    evt.stop();\n                }\n                // * a      →      * a\n                //   []     →      * []\n                else if (isLastBlock) {\n                    editor.execute('splitListItemBefore');\n                    data.preventDefault();\n                    evt.stop();\n                }\n            }\n        }, { context: 'li' });\n        // In some cases, after the default block splitting, we want to modify the new block to become a new list item\n        // instead of an additional block in the same list item.\n        this.listenTo(enterCommand, 'afterExecute', () => {\n            const splitCommand = commands.get('splitListItemBefore');\n            // The command has not refreshed because the change block related to EnterCommand#execute() is not over yet.\n            // Let's keep it up to date and take advantage of DocumentListSplitCommand#isEnabled.\n            splitCommand.refresh();\n            if (!splitCommand.isEnabled) {\n                return;\n            }\n            const doc = editor.model.document;\n            const positionParent = doc.selection.getLastPosition().parent;\n            const listItemBlocks = getAllListItemBlocks(positionParent);\n            // Keep in mind this split happens after the default enter handler was executed. For instance:\n            //\n            // │       Initial state       │    After default enter    │   Here in #afterExecute   │\n            // ├───────────────────────────┼───────────────────────────┼───────────────────────────┤\n            // │          * a[]            │           * a             │           * a             │\n            // │                           │             []            │           * []            │\n            if (listItemBlocks.length === 2) {\n                splitCommand.execute();\n            }\n        });\n    }\n    /**\n     * Attaches a listener to the {@link module:engine/view/document~Document#event:tab} event and handles tab key and tab+shift keys\n     * presses in document lists.\n     */\n    _setupTabIntegration() {\n        const editor = this.editor;\n        this.listenTo(editor.editing.view.document, 'tab', (evt, data) => {\n            const commandName = data.shiftKey ? 'outdentList' : 'indentList';\n            const command = this.editor.commands.get(commandName);\n            if (command.isEnabled) {\n                editor.execute(commandName);\n                data.stopPropagation();\n                data.preventDefault();\n                evt.stop();\n            }\n        }, { context: 'li' });\n    }\n    /**\n     * Registers the conversion helpers for the document-list feature.\n     */\n    _setupConversion() {\n        const editor = this.editor;\n        const model = editor.model;\n        const attributeNames = this._getListAttributeNames();\n        editor.conversion.for('upcast')\n            .elementToElement({ view: 'li', model: 'paragraph' })\n            .add(dispatcher => {\n            dispatcher.on('element:li', listItemUpcastConverter());\n            dispatcher.on('element:ul', listUpcastCleanList(), { priority: 'high' });\n            dispatcher.on('element:ol', listUpcastCleanList(), { priority: 'high' });\n        });\n        editor.conversion.for('editingDowncast')\n            .elementToElement({\n            model: 'paragraph',\n            view: bogusParagraphCreator(attributeNames),\n            converterPriority: 'high'\n        });\n        editor.conversion.for('dataDowncast')\n            .elementToElement({\n            model: 'paragraph',\n            view: bogusParagraphCreator(attributeNames, { dataPipeline: true }),\n            converterPriority: 'high'\n        });\n        editor.conversion.for('downcast')\n            .add(dispatcher => {\n            dispatcher.on('attribute', listItemDowncastConverter(attributeNames, this._downcastStrategies, model));\n        });\n        this.listenTo(model.document, 'change:data', reconvertItemsOnDataChange(model, editor.editing, attributeNames, this), { priority: 'high' });\n        // For LI verify if an ID of the attribute element is correct.\n        this.on('checkAttributes:item', (evt, { viewElement, modelAttributes }) => {\n            if (viewElement.id != modelAttributes.listItemId) {\n                evt.return = true;\n                evt.stop();\n            }\n        });\n        // For UL and OL check if the name and ID of element is correct.\n        this.on('checkAttributes:list', (evt, { viewElement, modelAttributes }) => {\n            if (viewElement.name != getViewElementNameForListType(modelAttributes.listType) ||\n                viewElement.id != getViewElementIdForListType(modelAttributes.listType, modelAttributes.listIndent)) {\n                evt.return = true;\n                evt.stop();\n            }\n        });\n    }\n    /**\n     * Registers model post-fixers.\n     */\n    _setupModelPostFixing() {\n        const model = this.editor.model;\n        const attributeNames = this._getListAttributeNames();\n        // Register list fixing.\n        // First the low level handler.\n        model.document.registerPostFixer(writer => modelChangePostFixer(model, writer, attributeNames, this));\n        // Then the callbacks for the specific lists.\n        // The indentation fixing must be the first one...\n        this.on('postFixer', (evt, { listNodes, writer }) => {\n            evt.return = fixListIndents(listNodes, writer) || evt.return;\n        }, { priority: 'high' });\n        // ...then the item ids... and after that other fixers that rely on the correct indentation and ids.\n        this.on('postFixer', (evt, { listNodes, writer, seenIds }) => {\n            evt.return = fixListItemIds(listNodes, seenIds, writer) || evt.return;\n        }, { priority: 'high' });\n    }\n    /**\n     * Integrates the feature with the clipboard via {@link module:engine/model/model~Model#insertContent} and\n     * {@link module:engine/model/model~Model#getSelectedContent}.\n     */\n    _setupClipboardIntegration() {\n        const model = this.editor.model;\n        this.listenTo(model, 'insertContent', createModelIndentPasteFixer(model), { priority: 'high' });\n        // To enhance the UX, the editor should not copy list attributes to the clipboard if the selection\n        // started and ended in the same list item.\n        //\n        // If the selection was enclosed in a single list item, there is a good chance the user did not want it\n        // copied as a list item but plain blocks.\n        //\n        // This avoids pasting orphaned list items instead of paragraphs, for instance, straight into the root.\n        //\n        //\t                       ┌─────────────────────┬───────────────────┐\n        //\t                       │ Selection           │ Clipboard content │\n        //\t                       ├─────────────────────┼───────────────────┤\n        //\t                       │ [* <Widget />]      │ <Widget />        │\n        //\t                       ├─────────────────────┼───────────────────┤\n        //\t                       │ [* Foo]             │ Foo               │\n        //\t                       ├─────────────────────┼───────────────────┤\n        //\t                       │ * Foo [bar] baz     │ bar               │\n        //\t                       ├─────────────────────┼───────────────────┤\n        //\t                       │ * Fo[o              │ o                 │\n        //\t                       │   ba]r              │ ba                │\n        //\t                       ├─────────────────────┼───────────────────┤\n        //\t                       │ * Fo[o              │ * o               │\n        //\t                       │ * ba]r              │ * ba              │\n        //\t                       ├─────────────────────┼───────────────────┤\n        //\t                       │ [* Foo              │ * Foo             │\n        //\t                       │  * bar]             │ * bar             │\n        //\t                       └─────────────────────┴───────────────────┘\n        //\n        // See https://github.com/ckeditor/ckeditor5/issues/11608.\n        this.listenTo(model, 'getSelectedContent', (evt, [selection]) => {\n            const isSingleListItemSelected = isSingleListItem(Array.from(selection.getSelectedBlocks()));\n            if (isSingleListItemSelected) {\n                model.change(writer => removeListAttributes(Array.from(evt.return.getChildren()), writer));\n            }\n        });\n    }\n}\n/**\n * Post-fixer that reacts to changes on document and fixes incorrect model states (invalid `listItemId` and `listIndent` values).\n *\n * In the example below, there is a correct list structure.\n * Then the middle element is removed so the list structure will become incorrect:\n *\n * ```xml\n * <paragraph listType=\"bulleted\" listItemId=\"a\" listIndent=0>Item 1</paragraph>\n * <paragraph listType=\"bulleted\" listItemId=\"b\" listIndent=1>Item 2</paragraph>   <--- this is removed.\n * <paragraph listType=\"bulleted\" listItemId=\"c\" listIndent=2>Item 3</paragraph>\n * ```\n *\n * The list structure after the middle element is removed:\n *\n * ```xml\n * <paragraph listType=\"bulleted\" listItemId=\"a\" listIndent=0>Item 1</paragraph>\n * <paragraph listType=\"bulleted\" listItemId=\"c\" listIndent=2>Item 3</paragraph>\n * ```\n *\n * Should become:\n *\n * ```xml\n * <paragraph listType=\"bulleted\" listItemId=\"a\" listIndent=0>Item 1</paragraph>\n * <paragraph listType=\"bulleted\" listItemId=\"c\" listIndent=1>Item 3</paragraph>   <--- note that indent got post-fixed.\n * ```\n *\n * @param model The data model.\n * @param writer The writer to do changes with.\n * @param attributeNames The list of all model list attributes (including registered strategies).\n * @param documentListEditing The document list editing plugin.\n * @returns `true` if any change has been applied, `false` otherwise.\n */\nfunction modelChangePostFixer(model, writer, attributeNames, documentListEditing) {\n    const changes = model.document.differ.getChanges();\n    const itemToListHead = new Map();\n    let applied = false;\n    for (const entry of changes) {\n        if (entry.type == 'insert' && entry.name != '$text') {\n            const item = entry.position.nodeAfter;\n            // Remove attributes in case of renamed element.\n            if (!model.schema.checkAttribute(item, 'listItemId')) {\n                for (const attributeName of Array.from(item.getAttributeKeys())) {\n                    if (attributeNames.includes(attributeName)) {\n                        writer.removeAttribute(attributeName, item);\n                        applied = true;\n                    }\n                }\n            }\n            findAndAddListHeadToMap(entry.position, itemToListHead);\n            // Insert of a non-list item - check if there is a list after it.\n            if (!entry.attributes.has('listItemId')) {\n                findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);\n            }\n            // Check if there is no nested list.\n            for (const { item: innerItem, previousPosition } of model.createRangeIn(item)) {\n                if (isListItemBlock(innerItem)) {\n                    findAndAddListHeadToMap(previousPosition, itemToListHead);\n                }\n            }\n        }\n        // Removed list item or block adjacent to a list.\n        else if (entry.type == 'remove') {\n            findAndAddListHeadToMap(entry.position, itemToListHead);\n        }\n        // Changed list item indent or type.\n        else if (entry.type == 'attribute' && attributeNames.includes(entry.attributeKey)) {\n            findAndAddListHeadToMap(entry.range.start, itemToListHead);\n            if (entry.attributeNewValue === null) {\n                findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);\n            }\n        }\n    }\n    // Make sure that IDs are not shared by split list.\n    const seenIds = new Set();\n    for (const listHead of itemToListHead.values()) {\n        applied = documentListEditing.fire('postFixer', {\n            listNodes: new ListBlocksIterable(listHead),\n            listHead,\n            writer,\n            seenIds\n        }) || applied;\n    }\n    return applied;\n}\n/**\n * A fixer for pasted content that includes list items.\n *\n * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.\n *\n * Example:\n *\n * ```xml\n * <paragraph listType=\"bulleted\" listItemId=\"a\" listIndent=0>A</paragraph>\n * <paragraph listType=\"bulleted\" listItemId=\"b\" listIndent=1>B^</paragraph>\n * // At ^ paste:  <paragraph listType=\"bulleted\" listItemId=\"x\" listIndent=4>X</paragraph>\n * //              <paragraph listType=\"bulleted\" listItemId=\"y\" listIndent=5>Y</paragraph>\n * <paragraph listType=\"bulleted\" listItemId=\"c\" listIndent=2>C</paragraph>\n * ```\n *\n * Should become:\n *\n * ```xml\n * <paragraph listType=\"bulleted\" listItemId=\"a\" listIndent=0>A</paragraph>\n * <paragraph listType=\"bulleted\" listItemId=\"b\" listIndent=1>BX</paragraph>\n * <paragraph listType=\"bulleted\" listItemId=\"y\" listIndent=2>Y/paragraph>\n * <paragraph listType=\"bulleted\" listItemId=\"c\" listIndent=2>C</paragraph>\n * ```\n */\nfunction createModelIndentPasteFixer(model) {\n    return (evt, [content, selectable]) => {\n        // Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other\n        // elements before it and there is no need to fix indents, because even if we insert that content into a list,\n        // that list will be broken.\n        // Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2\n        // would create incorrect model.\n        const item = content.is('documentFragment') ? content.getChild(0) : content;\n        if (!isListItemBlock(item)) {\n            return;\n        }\n        let selection;\n        if (!selectable) {\n            selection = model.document.selection;\n        }\n        else {\n            selection = model.createSelection(selectable);\n        }\n        // Get a reference list item. Inserted list items will be fixed according to that item.\n        const pos = selection.getFirstPosition();\n        let refItem = null;\n        if (isListItemBlock(pos.parent)) {\n            refItem = pos.parent;\n        }\n        else if (isListItemBlock(pos.nodeBefore)) {\n            refItem = pos.nodeBefore;\n        }\n        // If there is `refItem` it means that we do insert list items into an existing list.\n        if (!refItem) {\n            return;\n        }\n        // First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal\n        // to the indent of reference item. We have to fix the first item and all of it's children and following siblings.\n        // Indent of all those items has to be adjusted to reference item.\n        const indentChange = refItem.getAttribute('listIndent') - item.getAttribute('listIndent');\n        // Fix only if there is anything to fix.\n        if (indentChange <= 0) {\n            return;\n        }\n        model.change(writer => {\n            // Adjust indent of all \"first\" list items in inserted data.\n            for (const { node } of iterateSiblingListBlocks(item, 'forward')) {\n                writer.setAttribute('listIndent', node.getAttribute('listIndent') + indentChange, node);\n            }\n        });\n    };\n}\n/**\n * Decides whether the merge should be accompanied by the model's `deleteContent()`, for instance, to get rid of the inline\n * content in the selection or take advantage of the heuristics in `deleteContent()` that helps convert lists into paragraphs\n * in certain cases.\n */\nfunction shouldMergeOnBlocksContentLevel(model, direction) {\n    const selection = model.document.selection;\n    if (!selection.isCollapsed) {\n        return !getSelectedBlockObject(model);\n    }\n    if (direction === 'forward') {\n        return true;\n    }\n    const firstPosition = selection.getFirstPosition();\n    const positionParent = firstPosition.parent;\n    const previousSibling = positionParent.previousSibling;\n    if (model.schema.isObject(previousSibling)) {\n        return false;\n    }\n    if (previousSibling.isEmpty) {\n        return true;\n    }\n    return isSingleListItem([positionParent, previousSibling]);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { TreeWalker, getFillerOffset } from 'ckeditor5/src/engine';\nimport { ButtonView } from 'ckeditor5/src/ui';\n/**\n * Creates a list item {@link module:engine/view/containerelement~ContainerElement}.\n *\n * @param writer The writer instance.\n */\nexport function createViewListItemElement(writer) {\n    const viewItem = writer.createContainerElement('li');\n    viewItem.getFillerOffset = getListItemFillerOffset;\n    return viewItem;\n}\n/**\n * Helper function that creates a `<ul><li></li></ul>` or (`<ol>`) structure out of the given `modelItem` model `listItem` element.\n * Then, it binds the created view list item (`<li>`) with the model `listItem` element.\n * The function then returns the created view list item (`<li>`).\n *\n * @param modelItem Model list item.\n * @param conversionApi Conversion interface.\n * @returns View list element.\n */\nexport function generateLiInUl(modelItem, conversionApi) {\n    const mapper = conversionApi.mapper;\n    const viewWriter = conversionApi.writer;\n    const listType = modelItem.getAttribute('listType') == 'numbered' ? 'ol' : 'ul';\n    const viewItem = createViewListItemElement(viewWriter);\n    const viewList = viewWriter.createContainerElement(listType, null);\n    viewWriter.insert(viewWriter.createPositionAt(viewList, 0), viewItem);\n    mapper.bindElements(modelItem, viewItem);\n    return viewItem;\n}\n/**\n * Helper function that inserts a view list at a correct place and merges it with its siblings.\n * It takes a model list item element (`modelItem`) and a corresponding view list item element (`injectedItem`). The view list item\n * should be in a view list element (`<ul>` or `<ol>`) and should be its only child.\n * See comments below to better understand the algorithm.\n *\n * @param modelItem Model list item.\n * @param injectedItem\n * @param conversionApi Conversion interface.\n * @param model The model instance.\n */\nexport function injectViewList(modelItem, injectedItem, conversionApi, model) {\n    const injectedList = injectedItem.parent;\n    const mapper = conversionApi.mapper;\n    const viewWriter = conversionApi.writer;\n    // The position where the view list will be inserted.\n    let insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem));\n    // 1. Find the previous list item that has the same or smaller indent. Basically we are looking for the first model item\n    // that is a \"parent\" or \"sibling\" of the injected model item.\n    // If there is no such list item, it means that the injected list item is the first item in \"its list\".\n    const refItem = getSiblingListItem(modelItem.previousSibling, {\n        sameIndent: true,\n        smallerIndent: true,\n        listIndent: modelItem.getAttribute('listIndent')\n    });\n    const prevItem = modelItem.previousSibling;\n    if (refItem && refItem.getAttribute('listIndent') == modelItem.getAttribute('listIndent')) {\n        // There is a list item with the same indent - we found the same-level sibling.\n        // Break the list after it. The inserted view item will be added in the broken space.\n        const viewItem = mapper.toViewElement(refItem);\n        insertPosition = viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));\n    }\n    else {\n        // There is no list item with the same indent. Check the previous model item.\n        if (prevItem && prevItem.name == 'listItem') {\n            // If it is a list item, it has to have a lower indent.\n            // It means that the inserted item should be added to it as its nested item.\n            insertPosition = mapper.toViewPosition(model.createPositionAt(prevItem, 'end'));\n            // There could be some not mapped elements (eg. span in to-do list) but we need to insert\n            // a nested list directly inside the li element.\n            const mappedViewAncestor = mapper.findMappedViewAncestor(insertPosition);\n            const nestedList = findNestedList(mappedViewAncestor);\n            // If there already is some nested list, then use it's position.\n            if (nestedList) {\n                insertPosition = viewWriter.createPositionBefore(nestedList);\n            }\n            else {\n                // Else just put new list on the end of list item content.\n                insertPosition = viewWriter.createPositionAt(mappedViewAncestor, 'end');\n            }\n        }\n        else {\n            // The previous item is not a list item (or does not exist at all).\n            // Just map the position and insert the view item at the mapped position.\n            insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem));\n        }\n    }\n    insertPosition = positionAfterUiElements(insertPosition);\n    // Insert the view item.\n    viewWriter.insert(insertPosition, injectedList);\n    // 2. Handle possible children of the injected model item.\n    if (prevItem && prevItem.name == 'listItem') {\n        const prevView = mapper.toViewElement(prevItem);\n        const walkerBoundaries = viewWriter.createRange(viewWriter.createPositionAt(prevView, 0), insertPosition);\n        const walker = walkerBoundaries.getWalker({ ignoreElementEnd: true });\n        for (const value of walker) {\n            if (value.item.is('element', 'li')) {\n                const breakPosition = viewWriter.breakContainer(viewWriter.createPositionBefore(value.item));\n                const viewList = value.item.parent;\n                const targetPosition = viewWriter.createPositionAt(injectedItem, 'end');\n                mergeViewLists(viewWriter, targetPosition.nodeBefore, targetPosition.nodeAfter);\n                viewWriter.move(viewWriter.createRangeOn(viewList), targetPosition);\n                // This is bad, but those lists will be removed soon anyway.\n                walker._position = breakPosition;\n            }\n        }\n    }\n    else {\n        const nextViewList = injectedList.nextSibling;\n        if (nextViewList && (nextViewList.is('element', 'ul') || nextViewList.is('element', 'ol'))) {\n            let lastSubChild = null;\n            for (const child of nextViewList.getChildren()) {\n                const modelChild = mapper.toModelElement(child);\n                if (modelChild &&\n                    modelChild.getAttribute('listIndent') > modelItem.getAttribute('listIndent')) {\n                    lastSubChild = child;\n                }\n                else {\n                    break;\n                }\n            }\n            if (lastSubChild) {\n                viewWriter.breakContainer(viewWriter.createPositionAfter(lastSubChild));\n                viewWriter.move(viewWriter.createRangeOn(lastSubChild.parent), viewWriter.createPositionAt(injectedItem, 'end'));\n            }\n        }\n    }\n    // Merge the inserted view list with its possible neighbor lists.\n    mergeViewLists(viewWriter, injectedList, injectedList.nextSibling);\n    mergeViewLists(viewWriter, injectedList.previousSibling, injectedList);\n}\nexport function mergeViewLists(viewWriter, firstList, secondList) {\n    // Check if two lists are going to be merged.\n    if (!firstList || !secondList || (firstList.name != 'ul' && firstList.name != 'ol')) {\n        return null;\n    }\n    // Both parameters are list elements, so compare types now.\n    if (firstList.name != secondList.name || firstList.getAttribute('class') !== secondList.getAttribute('class')) {\n        return null;\n    }\n    return viewWriter.mergeContainers(viewWriter.createPositionAfter(firstList));\n}\n/**\n * Helper function that for a given `view.Position`, returns a `view.Position` that is after all `view.UIElement`s that\n * are after the given position.\n *\n * For example:\n * `<container:p>foo^<ui:span></ui:span><ui:span></ui:span>bar</container:p>`\n * For position ^, the position before \"bar\" will be returned.\n *\n */\nexport function positionAfterUiElements(viewPosition) {\n    return viewPosition.getLastMatchingPosition(value => value.item.is('uiElement'));\n}\n/**\n * Helper function that searches for a previous list item sibling of a given model item that meets the given criteria\n * passed by the options object.\n *\n * @param options Search criteria.\n * @param options.sameIndent Whether the sought sibling should have the same indentation.\n * @param options.smallerIndent Whether the sought sibling should have a smaller indentation.\n * @param options.listIndent The reference indentation.\n * @param options.direction Walking direction.\n */\nexport function getSiblingListItem(modelItem, options) {\n    const sameIndent = !!options.sameIndent;\n    const smallerIndent = !!options.smallerIndent;\n    const indent = options.listIndent;\n    let item = modelItem;\n    while (item && item.name == 'listItem') {\n        const itemIndent = item.getAttribute('listIndent');\n        if ((sameIndent && indent == itemIndent) || (smallerIndent && indent > itemIndent)) {\n            return item;\n        }\n        if (options.direction === 'forward') {\n            item = item.nextSibling;\n        }\n        else {\n            item = item.previousSibling;\n        }\n    }\n    return null;\n}\n/**\n * Helper method for creating a UI button and linking it with an appropriate command.\n *\n * @internal\n * @param editor The editor instance to which the UI component will be added.\n * @param commandName The name of the command.\n * @param label The button label.\n * @param icon The source of the icon.\n */\nexport function createUIComponent(editor, commandName, label, icon) {\n    editor.ui.componentFactory.add(commandName, locale => {\n        const command = editor.commands.get(commandName);\n        const buttonView = new ButtonView(locale);\n        buttonView.set({\n            label,\n            icon,\n            tooltip: true,\n            isToggleable: true\n        });\n        // Bind button model to command.\n        buttonView.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled');\n        // Execute command.\n        buttonView.on('execute', () => {\n            editor.execute(commandName);\n            editor.editing.view.focus();\n        });\n        return buttonView;\n    });\n}\n/**\n * Returns a first list view element that is direct child of the given view element.\n */\nexport function findNestedList(viewElement) {\n    for (const node of viewElement.getChildren()) {\n        if (node.name == 'ul' || node.name == 'ol') {\n            return node;\n        }\n    }\n    return null;\n}\n/**\n * Returns an array with all `listItem` elements that represent the same list.\n *\n * It means that values of `listIndent`, `listType`, `listStyle`, `listReversed` and `listStart` for all items are equal.\n *\n * Additionally, if the `position` is inside a list item, that list item will be returned as well.\n *\n * @param position Starting position.\n * @param direction Walking direction.\n */\nexport function getSiblingNodes(position, direction) {\n    const items = [];\n    const listItem = position.parent;\n    const walkerOptions = {\n        ignoreElementEnd: false,\n        startPosition: position,\n        shallow: true,\n        direction\n    };\n    const limitIndent = listItem.getAttribute('listIndent');\n    const nodes = [...new TreeWalker(walkerOptions)]\n        .filter(value => value.item.is('element'))\n        .map(value => value.item);\n    for (const element of nodes) {\n        // If found something else than `listItem`, we're out of the list scope.\n        if (!element.is('element', 'listItem')) {\n            break;\n        }\n        // If current parsed item has lower indent that element that the element that was a starting point,\n        // it means we left a nested list. Abort searching items.\n        //\n        // ■ List item 1.       [listIndent=0]\n        //     ○ List item 2.[] [listIndent=1], limitIndent = 1,\n        //     ○ List item 3.   [listIndent=1]\n        // ■ List item 4.       [listIndent=0]\n        //\n        // Abort searching when leave nested list.\n        if (element.getAttribute('listIndent') < limitIndent) {\n            break;\n        }\n        // ■ List item 1.[]     [listIndent=0] limitIndent = 0,\n        //     ○ List item 2.   [listIndent=1]\n        //     ○ List item 3.   [listIndent=1]\n        // ■ List item 4.       [listIndent=0]\n        //\n        // Ignore nested lists.\n        if (element.getAttribute('listIndent') > limitIndent) {\n            continue;\n        }\n        // ■ List item 1.[]  [listType=bulleted]\n        // 1. List item 2.   [listType=numbered]\n        // 2.List item 3.    [listType=numbered]\n        //\n        // Abort searching when found a different kind of a list.\n        if (element.getAttribute('listType') !== listItem.getAttribute('listType')) {\n            break;\n        }\n        // ■ List item 1.[]  [listType=bulleted]\n        // ■ List item 2.    [listType=bulleted]\n        // ○ List item 3.    [listType=bulleted]\n        // ○ List item 4.    [listType=bulleted]\n        //\n        // Abort searching when found a different list style,\n        if (element.getAttribute('listStyle') !== listItem.getAttribute('listStyle')) {\n            break;\n        }\n        // ... different direction\n        if (element.getAttribute('listReversed') !== listItem.getAttribute('listReversed')) {\n            break;\n        }\n        // ... and different start index\n        if (element.getAttribute('listStart') !== listItem.getAttribute('listStart')) {\n            break;\n        }\n        if (direction === 'backward') {\n            items.unshift(element);\n        }\n        else {\n            items.push(element);\n        }\n    }\n    return items;\n}\n/**\n * Returns an array with all `listItem` elements in the model selection.\n *\n * It returns all the items even if only a part of the list is selected, including items that belong to nested lists.\n * If no list is selected, it returns an empty array.\n * The order of the elements is not specified.\n *\n * @internal\n */\nexport function getSelectedListItems(model) {\n    const document = model.document;\n    // For all selected blocks find all list items that are being selected\n    // and update the `listStyle` attribute in those lists.\n    let listItems = [...document.selection.getSelectedBlocks()]\n        .filter(element => element.is('element', 'listItem'))\n        .map(element => {\n        const position = model.change(writer => writer.createPositionAt(element, 0));\n        return [\n            ...getSiblingNodes(position, 'backward'),\n            ...getSiblingNodes(position, 'forward')\n        ];\n    })\n        .flat();\n    // Since `getSelectedBlocks()` can return items that belong to the same list, and\n    // `getSiblingNodes()` returns the entire list, we need to remove duplicated items.\n    listItems = [...new Set(listItems)];\n    return listItems;\n}\nconst BULLETED_LIST_STYLE_TYPES = ['disc', 'circle', 'square'];\n// There's a lot of them (https://www.w3.org/TR/css-counter-styles-3/#typedef-counter-style).\n// Let's support only those that can be selected by ListPropertiesUI.\nconst NUMBERED_LIST_STYLE_TYPES = [\n    'decimal',\n    'decimal-leading-zero',\n    'lower-roman',\n    'upper-roman',\n    'lower-latin',\n    'upper-latin'\n];\n/**\n * Checks whether the given list-style-type is supported by numbered or bulleted list.\n */\nexport function getListTypeFromListStyleType(listStyleType) {\n    if (BULLETED_LIST_STYLE_TYPES.includes(listStyleType)) {\n        return 'bulleted';\n    }\n    if (NUMBERED_LIST_STYLE_TYPES.includes(listStyleType)) {\n        return 'numbered';\n    }\n    return null;\n}\n/**\n * Implementation of getFillerOffset for view list item element.\n *\n * @returns Block filler offset or `null` if block filler is not needed.\n */\nfunction getListItemFillerOffset() {\n    const hasOnlyLists = !this.isEmpty && (this.getChild(0).name == 'ul' || this.getChild(0).name == 'ol');\n    if (this.isEmpty || hasOnlyLists) {\n        return 0;\n    }\n    return getFillerOffset.call(this);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/list/listui\n */\nimport { createUIComponent } from './utils';\nimport numberedListIcon from '../../theme/icons/numberedlist.svg';\nimport bulletedListIcon from '../../theme/icons/bulletedlist.svg';\nimport { Plugin } from 'ckeditor5/src/core';\n/**\n * The list UI feature. It introduces the `'numberedList'` and `'bulletedList'` buttons that\n * allow to convert paragraphs to and from list items and indent or outdent them.\n */\nexport default class ListUI extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ListUI';\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const t = this.editor.t;\n        // Create two buttons and link them with numberedList and bulletedList commands.\n        createUIComponent(this.editor, 'numberedList', t('Numbered List'), numberedListIcon);\n        createUIComponent(this.editor, 'bulletedList', t('Bulleted List'), bulletedListIcon);\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlist\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport DocumentListEditing from './documentlist/documentlistediting';\nimport ListUI from './list/listui';\n/**\n * The document list feature.\n *\n * This is a \"glue\" plugin that loads the {@link module:list/documentlist/documentlistediting~DocumentListEditing document list\n * editing feature} and {@link module:list/list/listui~ListUI list UI feature}.\n */\nexport default class DocumentList extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [DocumentListEditing, ListUI];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DocumentList';\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { Plugin } from 'ckeditor5/src/core';\nexport default class AdjacentListsSupport extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'AdjacentListsSupport';\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const model = editor.model;\n        model.schema.register('listSeparator', {\n            allowWhere: '$block',\n            isBlock: true\n        });\n        editor.conversion.for('upcast')\n            // Add `listSeparator` element between similar list elements on upcast.\n            .add(dispatcher => {\n            dispatcher.on('element:ol', listSeparatorUpcastConverter());\n            dispatcher.on('element:ul', listSeparatorUpcastConverter());\n        })\n            // View to model transformation.\n            .elementToElement({\n            model: 'listSeparator',\n            view: 'ck-list-separator'\n        });\n        // The `listSeparator` element should exist in the view, but should be invisible (hidden).\n        editor.conversion.for('editingDowncast').elementToElement({\n            model: 'listSeparator',\n            view: {\n                name: 'div',\n                classes: ['ck-list-separator', 'ck-hidden']\n            }\n        });\n        // The `listSeparator` element should not exist in output data.\n        editor.conversion.for('dataDowncast').elementToElement({\n            model: 'listSeparator',\n            view: (modelElement, conversionApi) => {\n                const viewElement = conversionApi.writer.createContainerElement('ck-list-separator');\n                conversionApi.writer.setCustomProperty('dataPipeline:transparentRendering', true, viewElement);\n                viewElement.getFillerOffset = () => null;\n                return viewElement;\n            }\n        });\n    }\n}\n/**\n * Inserts a `listSeparator` element between two lists of the same type (`ol` + `ol` or `ul` + `ul`).\n */\nfunction listSeparatorUpcastConverter() {\n    return (evt, data, conversionApi) => {\n        const element = data.viewItem;\n        const nextSibling = element.nextSibling;\n        if (!nextSibling) {\n            return;\n        }\n        if (element.name !== nextSibling.name) {\n            return;\n        }\n        if (!data.modelRange) {\n            Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));\n        }\n        const writer = conversionApi.writer;\n        const modelElement = writer.createElement('listSeparator');\n        // Try to insert `listSeparator` element on the current model cursor position.\n        if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {\n            return;\n        }\n        const parts = conversionApi.getSplitParts(modelElement);\n        // Extend model range with the range of the created listSeparator element.\n        data.modelRange = writer.createRange(data.modelRange.start, writer.createPositionAfter(parts[parts.length - 1]));\n        conversionApi.updateConversionResult(modelElement, data);\n    };\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlistproperties/documentliststartcommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { first } from 'ckeditor5/src/utils';\nimport { expandListBlocksToCompleteList, isListItemBlock } from '../documentlist/utils/model';\n/**\n * The list start index command. It changes the `listStart` attribute of the selected list items,\n * letting the user to choose the starting point of an ordered list.\n * It is used by the {@link module:list/documentlistproperties~DocumentListProperties list properties feature}.\n */\nexport default class DocumentListStartCommand extends Command {\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        const value = this._getValue();\n        this.value = value;\n        this.isEnabled = value != null;\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param options.startIndex The list start index.\n     */\n    execute({ startIndex = 1 } = {}) {\n        const model = this.editor.model;\n        const document = model.document;\n        let blocks = Array.from(document.selection.getSelectedBlocks())\n            .filter(block => isListItemBlock(block) && block.getAttribute('listType') == 'numbered');\n        blocks = expandListBlocksToCompleteList(blocks);\n        model.change(writer => {\n            for (const block of blocks) {\n                writer.setAttribute('listStart', startIndex >= 0 ? startIndex : 1, block);\n            }\n        });\n    }\n    /**\n     * Checks the command's {@link #value}.\n     *\n     * @returns The current value.\n     */\n    _getValue() {\n        const model = this.editor.model;\n        const document = model.document;\n        const block = first(document.selection.getSelectedBlocks());\n        if (block && isListItemBlock(block) && block.getAttribute('listType') == 'numbered') {\n            return block.getAttribute('listStart');\n        }\n        return null;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n* @module list/documentlistproperties/utils/style\n*/\nconst LIST_STYLE_TO_LIST_TYPE = {};\nconst LIST_STYLE_TO_TYPE_ATTRIBUTE = {};\nconst TYPE_ATTRIBUTE_TO_LIST_STYLE = {};\nconst LIST_STYLE_TYPES = [\n    { listStyle: 'disc', typeAttribute: 'disc', listType: 'bulleted' },\n    { listStyle: 'circle', typeAttribute: 'circle', listType: 'bulleted' },\n    { listStyle: 'square', typeAttribute: 'square', listType: 'bulleted' },\n    { listStyle: 'decimal', typeAttribute: '1', listType: 'numbered' },\n    { listStyle: 'decimal-leading-zero', typeAttribute: null, listType: 'numbered' },\n    { listStyle: 'lower-roman', typeAttribute: 'i', listType: 'numbered' },\n    { listStyle: 'upper-roman', typeAttribute: 'I', listType: 'numbered' },\n    { listStyle: 'lower-alpha', typeAttribute: 'a', listType: 'numbered' },\n    { listStyle: 'upper-alpha', typeAttribute: 'A', listType: 'numbered' },\n    { listStyle: 'lower-latin', typeAttribute: 'a', listType: 'numbered' },\n    { listStyle: 'upper-latin', typeAttribute: 'A', listType: 'numbered' }\n];\nfor (const { listStyle, typeAttribute, listType } of LIST_STYLE_TYPES) {\n    LIST_STYLE_TO_LIST_TYPE[listStyle] = listType;\n    LIST_STYLE_TO_TYPE_ATTRIBUTE[listStyle] = typeAttribute;\n    if (typeAttribute) {\n        TYPE_ATTRIBUTE_TO_LIST_STYLE[typeAttribute] = listStyle;\n    }\n}\n/**\n * Gets all the style types supported by given list type.\n */\nexport function getAllSupportedStyleTypes() {\n    return LIST_STYLE_TYPES.map(x => x.listStyle);\n}\n/**\n * Checks whether the given list-style-type is supported by numbered or bulleted list.\n */\nexport function getListTypeFromListStyleType(listStyleType) {\n    return LIST_STYLE_TO_LIST_TYPE[listStyleType] || null;\n}\n/**\n * Converts `type` attribute of `<ul>` or `<ol>` elements to `list-style-type` equivalent.\n */\nexport function getListStyleTypeFromTypeAttribute(value) {\n    return TYPE_ATTRIBUTE_TO_LIST_STYLE[value] || null;\n}\n/**\n * Converts `list-style-type` style to `type` attribute of `<ul>` or `<ol>` elements.\n */\nexport function getTypeAttributeFromListStyleType(value) {\n    return LIST_STYLE_TO_TYPE_ATTRIBUTE[value] || null;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlistproperties/documentliststylecommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { first } from 'ckeditor5/src/utils';\nimport { expandListBlocksToCompleteList, isListItemBlock } from '../documentlist/utils/model';\nimport { getListTypeFromListStyleType } from './utils/style';\n/**\n * The list style command. It changes `listStyle` attribute of the selected list items,\n * letting the user choose styles for the list item markers.\n * It is used by the {@link module:list/documentlistproperties~DocumentListProperties list properties feature}.\n */\nexport default class DocumentListStyleCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param editor The editor instance.\n     * @param defaultType The list type that will be used by default if the value was not specified during\n     * the command execution.\n     * @param supportedTypes The list of supported style types by this command.\n     */\n    constructor(editor, defaultType, supportedTypes) {\n        super(editor);\n        this.defaultType = defaultType;\n        this._supportedTypes = supportedTypes;\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        this.value = this._getValue();\n        this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param options.type The type of the list style, e.g. `'disc'` or `'square'`. If `null` is specified, the default\n     * style will be applied.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const document = model.document;\n        model.change(writer => {\n            this._tryToConvertItemsToList(options);\n            let blocks = Array.from(document.selection.getSelectedBlocks())\n                .filter(block => block.hasAttribute('listType'));\n            if (!blocks.length) {\n                return;\n            }\n            blocks = expandListBlocksToCompleteList(blocks);\n            for (const block of blocks) {\n                writer.setAttribute('listStyle', options.type || this.defaultType, block);\n            }\n        });\n    }\n    /**\n     * Checks if the given style type is supported by this plugin.\n     */\n    isStyleTypeSupported(value) {\n        if (!this._supportedTypes) {\n            return true;\n        }\n        return this._supportedTypes.includes(value);\n    }\n    /**\n     * Checks the command's {@link #value}.\n     *\n     * @returns The current value.\n     */\n    _getValue() {\n        const listItem = first(this.editor.model.document.selection.getSelectedBlocks());\n        if (isListItemBlock(listItem)) {\n            return listItem.getAttribute('listStyle');\n        }\n        return null;\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @returns Whether the command should be enabled.\n     */\n    _checkEnabled() {\n        const editor = this.editor;\n        const numberedList = editor.commands.get('numberedList');\n        const bulletedList = editor.commands.get('bulletedList');\n        return numberedList.isEnabled || bulletedList.isEnabled;\n    }\n    /**\n     * Check if the provided list style is valid. Also change the selection to a list if it's not set yet.\n     *\n     * @param options.type The type of the list style. If `null` is specified, the function does nothing.\n    */\n    _tryToConvertItemsToList(options) {\n        if (!options.type) {\n            return;\n        }\n        const listType = getListTypeFromListStyleType(options.type);\n        if (!listType) {\n            return;\n        }\n        const editor = this.editor;\n        const commandName = `${listType}List`;\n        const command = editor.commands.get(commandName);\n        if (!command.value) {\n            editor.execute(commandName);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlistproperties/documentlistreversedcommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { first } from 'ckeditor5/src/utils';\nimport { expandListBlocksToCompleteList, isListItemBlock } from '../documentlist/utils/model';\n/**\n * The list reversed command. It changes the `listReversed` attribute of the selected list items,\n * letting the user to choose the order of an ordered list.\n * It is used by the {@link module:list/documentlistproperties~DocumentListProperties list properties feature}.\n */\nexport default class DocumentListReversedCommand extends Command {\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        const value = this._getValue();\n        this.value = value;\n        this.isEnabled = value != null;\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param options.reversed Whether the list should be reversed.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const document = model.document;\n        let blocks = Array.from(document.selection.getSelectedBlocks())\n            .filter(block => isListItemBlock(block) && block.getAttribute('listType') == 'numbered');\n        blocks = expandListBlocksToCompleteList(blocks);\n        model.change(writer => {\n            for (const block of blocks) {\n                writer.setAttribute('listReversed', !!options.reversed, block);\n            }\n        });\n    }\n    /**\n     * Checks the command's {@link #value}.\n     */\n    _getValue() {\n        const model = this.editor.model;\n        const document = model.document;\n        const block = first(document.selection.getSelectedBlocks());\n        if (isListItemBlock(block) && block.getAttribute('listType') == 'numbered') {\n            return block.getAttribute('listReversed');\n        }\n        return null;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Returns a converter that consumes the `style`, `reversed`, and `start` attributes.\n * In `style`, it searches for the `list-style-type` definition.\n * If not found, the `\"default\"` value will be used.\n *\n * @internal\n * @param strategy\n */\nexport function listPropertiesUpcastConverter(strategy) {\n    return (evt, data, conversionApi) => {\n        const { writer, schema, consumable } = conversionApi;\n        // If there is no view consumable to consume, set the default attribute value to be able to reconvert nested lists on parent change.\n        // So abort converting if attribute was directly consumed.\n        if (consumable.test(data.viewItem, strategy.viewConsumables) === false) {\n            return;\n        }\n        if (!data.modelRange) {\n            Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));\n        }\n        let applied = false;\n        for (const item of data.modelRange.getItems({ shallow: true })) {\n            if (!schema.checkAttribute(item, strategy.attributeName)) {\n                continue;\n            }\n            if (!strategy.appliesToListItem(item)) {\n                continue;\n            }\n            // Set list attributes only on same level items, those nested deeper are already handled by the recursive conversion.\n            if (item.hasAttribute(strategy.attributeName)) {\n                continue;\n            }\n            writer.setAttribute(strategy.attributeName, strategy.getAttributeOnUpcast(data.viewItem), item);\n            applied = true;\n        }\n        if (applied) {\n            consumable.consume(data.viewItem, strategy.viewConsumables);\n        }\n    };\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlistproperties/documentlistpropertiesutils\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { getAllSupportedStyleTypes, getListStyleTypeFromTypeAttribute, getListTypeFromListStyleType, getTypeAttributeFromListStyleType } from './utils/style';\n/**\n * A set of helpers related to document lists.\n */\nexport default class DocumentListPropertiesUtils extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DocumentListPropertiesUtils';\n    }\n    /**\n     * Gets all the style types supported by given list type.\n     */\n    getAllSupportedStyleTypes() {\n        return getAllSupportedStyleTypes();\n    }\n    /**\n     * Checks whether the given list-style-type is supported by numbered or bulleted list.\n     */\n    getListTypeFromListStyleType(listStyleType) {\n        return getListTypeFromListStyleType(listStyleType);\n    }\n    /**\n     * Converts `type` attribute of `<ul>` or `<ol>` elements to `list-style-type` equivalent.\n     */\n    getListStyleTypeFromTypeAttribute(value) {\n        return getListStyleTypeFromTypeAttribute(value);\n    }\n    /**\n     * Converts `list-style-type` style to `type` attribute of `<ul>` or `<ol>` elements.\n     */\n    getTypeAttributeFromListStyleType(value) {\n        return getTypeAttributeFromListStyleType(value);\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlistproperties/documentlistpropertiesediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport DocumentListEditing from '../documentlist/documentlistediting';\nimport DocumentListStartCommand from './documentliststartcommand';\nimport DocumentListStyleCommand from './documentliststylecommand';\nimport DocumentListReversedCommand from './documentlistreversedcommand';\nimport { listPropertiesUpcastConverter } from './converters';\nimport { getAllSupportedStyleTypes, getListTypeFromListStyleType, getListStyleTypeFromTypeAttribute, getTypeAttributeFromListStyleType } from './utils/style';\nimport DocumentListPropertiesUtils from './documentlistpropertiesutils';\nconst DEFAULT_LIST_TYPE = 'default';\n/**\n * The document list properties engine feature.\n *\n * It registers the `'listStyle'`, `'listReversed'` and `'listStart'` commands if they are enabled in the configuration.\n * Read more in {@link module:list/listconfig~ListPropertiesConfig}.\n */\nexport default class DocumentListPropertiesEditing extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [DocumentListEditing, DocumentListPropertiesUtils];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DocumentListPropertiesEditing';\n    }\n    /**\n     * @inheritDoc\n     */\n    constructor(editor) {\n        super(editor);\n        editor.config.define('list', {\n            properties: {\n                styles: true,\n                startIndex: false,\n                reversed: false\n            }\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const model = editor.model;\n        const documentListEditing = editor.plugins.get(DocumentListEditing);\n        const enabledProperties = editor.config.get('list.properties');\n        const strategies = createAttributeStrategies(enabledProperties);\n        for (const strategy of strategies) {\n            strategy.addCommand(editor);\n            model.schema.extend('$container', { allowAttributes: strategy.attributeName });\n            model.schema.extend('$block', { allowAttributes: strategy.attributeName });\n            model.schema.extend('$blockObject', { allowAttributes: strategy.attributeName });\n            // Register downcast strategy.\n            documentListEditing.registerDowncastStrategy({\n                scope: 'list',\n                attributeName: strategy.attributeName,\n                setAttributeOnDowncast(writer, attributeValue, viewElement) {\n                    strategy.setAttributeOnDowncast(writer, attributeValue, viewElement);\n                }\n            });\n        }\n        // Set up conversion.\n        editor.conversion.for('upcast').add(dispatcher => {\n            for (const strategy of strategies) {\n                dispatcher.on('element:ol', listPropertiesUpcastConverter(strategy));\n                dispatcher.on('element:ul', listPropertiesUpcastConverter(strategy));\n            }\n        });\n        // Verify if the list view element (ul or ol) requires refreshing.\n        documentListEditing.on('checkAttributes:list', (evt, { viewElement, modelAttributes }) => {\n            for (const strategy of strategies) {\n                if (strategy.getAttributeOnUpcast(viewElement) != modelAttributes[strategy.attributeName]) {\n                    evt.return = true;\n                    evt.stop();\n                }\n            }\n        });\n        // Reset list properties after indenting list items.\n        this.listenTo(editor.commands.get('indentList'), 'afterExecute', (evt, changedBlocks) => {\n            model.change(writer => {\n                for (const node of changedBlocks) {\n                    for (const strategy of strategies) {\n                        if (strategy.appliesToListItem(node)) {\n                            // Just reset the attribute.\n                            // If there is a previous indented list that this node should be merged into,\n                            // the postfixer will unify all the attributes of both sub-lists.\n                            writer.setAttribute(strategy.attributeName, strategy.defaultValue, node);\n                        }\n                    }\n                }\n            });\n        });\n        // Add or remove list properties attributes depending on the list type.\n        documentListEditing.on('postFixer', (evt, { listNodes, writer }) => {\n            for (const { node } of listNodes) {\n                for (const strategy of strategies) {\n                    // Check if attribute is valid.\n                    if (strategy.hasValidAttribute(node)) {\n                        continue;\n                    }\n                    // Add missing default property attributes...\n                    if (strategy.appliesToListItem(node)) {\n                        writer.setAttribute(strategy.attributeName, strategy.defaultValue, node);\n                    }\n                    // ...or remove invalid property attributes.\n                    else {\n                        writer.removeAttribute(strategy.attributeName, node);\n                    }\n                    evt.return = true;\n                }\n            }\n        });\n        // Make sure that all items in a single list (items at the same level & listType) have the same properties.\n        documentListEditing.on('postFixer', (evt, { listNodes, writer }) => {\n            const previousNodesByIndent = []; // Last seen nodes of lower indented lists.\n            for (const { node, previous } of listNodes) {\n                // For the first list block there is nothing to compare with.\n                if (!previous) {\n                    continue;\n                }\n                const nodeIndent = node.getAttribute('listIndent');\n                const previousNodeIndent = previous.getAttribute('listIndent');\n                let previousNodeInList = null; // It's like `previous` but has the same indent as current node.\n                // Let's find previous node for the same indent.\n                // We're going to need that when we get back to previous indent.\n                if (nodeIndent > previousNodeIndent) {\n                    previousNodesByIndent[previousNodeIndent] = previous;\n                }\n                // Restore the one for given indent.\n                else if (nodeIndent < previousNodeIndent) {\n                    previousNodeInList = previousNodesByIndent[nodeIndent];\n                    previousNodesByIndent.length = nodeIndent;\n                }\n                // Same indent.\n                else {\n                    previousNodeInList = previous;\n                }\n                // This is a first item of a nested list.\n                if (!previousNodeInList) {\n                    continue;\n                }\n                // This is a first block of a list of a different type.\n                if (previousNodeInList.getAttribute('listType') != node.getAttribute('listType')) {\n                    continue;\n                }\n                // Copy properties from the previous one.\n                for (const strategy of strategies) {\n                    const { attributeName } = strategy;\n                    if (!strategy.appliesToListItem(node)) {\n                        continue;\n                    }\n                    const value = previousNodeInList.getAttribute(attributeName);\n                    if (node.getAttribute(attributeName) != value) {\n                        writer.setAttribute(attributeName, value, node);\n                        evt.return = true;\n                    }\n                }\n            }\n        });\n    }\n}\n/**\n * Creates an array of strategies for dealing with enabled listItem attributes.\n */\nfunction createAttributeStrategies(enabledProperties) {\n    const strategies = [];\n    if (enabledProperties.styles) {\n        const useAttribute = typeof enabledProperties.styles == 'object' && enabledProperties.styles.useAttribute;\n        strategies.push({\n            attributeName: 'listStyle',\n            defaultValue: DEFAULT_LIST_TYPE,\n            viewConsumables: { styles: 'list-style-type' },\n            addCommand(editor) {\n                let supportedTypes = getAllSupportedStyleTypes();\n                if (useAttribute) {\n                    supportedTypes = supportedTypes.filter(styleType => !!getTypeAttributeFromListStyleType(styleType));\n                }\n                editor.commands.add('listStyle', new DocumentListStyleCommand(editor, DEFAULT_LIST_TYPE, supportedTypes));\n            },\n            appliesToListItem() {\n                return true;\n            },\n            hasValidAttribute(item) {\n                if (!item.hasAttribute('listStyle')) {\n                    return false;\n                }\n                const value = item.getAttribute('listStyle');\n                if (value == DEFAULT_LIST_TYPE) {\n                    return true;\n                }\n                return getListTypeFromListStyleType(value) == item.getAttribute('listType');\n            },\n            setAttributeOnDowncast(writer, listStyle, element) {\n                if (listStyle && listStyle !== DEFAULT_LIST_TYPE) {\n                    if (useAttribute) {\n                        const value = getTypeAttributeFromListStyleType(listStyle);\n                        if (value) {\n                            writer.setAttribute('type', value, element);\n                            return;\n                        }\n                    }\n                    else {\n                        writer.setStyle('list-style-type', listStyle, element);\n                        return;\n                    }\n                }\n                writer.removeStyle('list-style-type', element);\n                writer.removeAttribute('type', element);\n            },\n            getAttributeOnUpcast(listParent) {\n                const style = listParent.getStyle('list-style-type');\n                if (style) {\n                    return style;\n                }\n                const attribute = listParent.getAttribute('type');\n                if (attribute) {\n                    return getListStyleTypeFromTypeAttribute(attribute);\n                }\n                return DEFAULT_LIST_TYPE;\n            }\n        });\n    }\n    if (enabledProperties.reversed) {\n        strategies.push({\n            attributeName: 'listReversed',\n            defaultValue: false,\n            viewConsumables: { attributes: 'reversed' },\n            addCommand(editor) {\n                editor.commands.add('listReversed', new DocumentListReversedCommand(editor));\n            },\n            appliesToListItem(item) {\n                return item.getAttribute('listType') == 'numbered';\n            },\n            hasValidAttribute(item) {\n                return this.appliesToListItem(item) == item.hasAttribute('listReversed');\n            },\n            setAttributeOnDowncast(writer, listReversed, element) {\n                if (listReversed) {\n                    writer.setAttribute('reversed', 'reversed', element);\n                }\n                else {\n                    writer.removeAttribute('reversed', element);\n                }\n            },\n            getAttributeOnUpcast(listParent) {\n                return listParent.hasAttribute('reversed');\n            }\n        });\n    }\n    if (enabledProperties.startIndex) {\n        strategies.push({\n            attributeName: 'listStart',\n            defaultValue: 1,\n            viewConsumables: { attributes: 'start' },\n            addCommand(editor) {\n                editor.commands.add('listStart', new DocumentListStartCommand(editor));\n            },\n            appliesToListItem(item) {\n                return item.getAttribute('listType') == 'numbered';\n            },\n            hasValidAttribute(item) {\n                return this.appliesToListItem(item) == item.hasAttribute('listStart');\n            },\n            setAttributeOnDowncast(writer, listStart, element) {\n                if (listStart == 0 || listStart > 1) {\n                    writer.setAttribute('start', listStart, element);\n                }\n                else {\n                    writer.removeAttribute('start', element);\n                }\n            },\n            getAttributeOnUpcast(listParent) {\n                const startAttributeValue = listParent.getAttribute('start');\n                return startAttributeValue >= 0 ? startAttributeValue : 1;\n            }\n        });\n    }\n    return strategies;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { View, ButtonView } from 'ckeditor5/src/ui';\n// eslint-disable-next-line ckeditor5-rules/ckeditor-imports\nimport dropdownArrowIcon from '@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg';\nimport '../../../theme/collapsible.css';\n/**\n * A collapsible UI component. Consists of a labeled button and a container which can be collapsed\n * by clicking the button. The collapsible container can be a host to other UI views.\n *\n * @internal\n */\nexport default class CollapsibleView extends View {\n    /**\n     * Creates an instance of the collapsible view.\n     *\n     * @param locale The {@link module:core/editor/editor~Editor#locale} instance.\n     * @param childViews An optional array of initial child views to be inserted into the collapsible.\n     */\n    constructor(locale, childViews) {\n        super(locale);\n        const bind = this.bindTemplate;\n        this.set('isCollapsed', false);\n        this.set('label', '');\n        this.buttonView = this._createButtonView();\n        this.children = this.createCollection();\n        this.set('_collapsibleAriaLabelUid', undefined);\n        if (childViews) {\n            this.children.addMany(childViews);\n        }\n        this.setTemplate({\n            tag: 'div',\n            attributes: {\n                class: [\n                    'ck',\n                    'ck-collapsible',\n                    bind.if('isCollapsed', 'ck-collapsible_collapsed')\n                ]\n            },\n            children: [\n                this.buttonView,\n                {\n                    tag: 'div',\n                    attributes: {\n                        class: [\n                            'ck',\n                            'ck-collapsible__children'\n                        ],\n                        role: 'region',\n                        hidden: bind.if('isCollapsed', 'hidden'),\n                        'aria-labelledby': bind.to('_collapsibleAriaLabelUid')\n                    },\n                    children: this.children\n                }\n            ]\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    render() {\n        super.render();\n        this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id;\n    }\n    /**\n     * Creates the main {@link #buttonView} of the collapsible.\n     */\n    _createButtonView() {\n        const buttonView = new ButtonView(this.locale);\n        const bind = buttonView.bindTemplate;\n        buttonView.set({\n            withText: true,\n            icon: dropdownArrowIcon\n        });\n        buttonView.extendTemplate({\n            attributes: {\n                'aria-expanded': bind.to('isOn', value => String(value))\n            }\n        });\n        buttonView.bind('label').to(this);\n        buttonView.bind('isOn').to(this, 'isCollapsed', isCollapsed => !isCollapsed);\n        buttonView.on('execute', () => {\n            this.isCollapsed = !this.isCollapsed;\n        });\n        return buttonView;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/listproperties/ui/listpropertiesview\n */\nimport { View, ViewCollection, FocusCycler, SwitchButtonView, LabeledFieldView, createLabeledInputNumber, addKeyboardHandlingForGrid } from 'ckeditor5/src/ui';\nimport { FocusTracker, KeystrokeHandler, global } from 'ckeditor5/src/utils';\nimport CollapsibleView from './collapsibleview';\nimport '../../../theme/listproperties.css';\n/**\n * The list properties view to be displayed in the list dropdown.\n *\n * Contains a grid of available list styles and, for numbered list, also the list start index and reversed fields.\n *\n * @internal\n */\nexport default class ListPropertiesView extends View {\n    /**\n     * Creates an instance of the list properties view.\n     *\n     * @param locale The {@link module:core/editor/editor~Editor#locale} instance.\n     * @param options Options of the view.\n     * @param options.enabledProperties An object containing the configuration of enabled list property names.\n     * Allows conditional rendering the sub-components of the properties view.\n     * @param options.styleButtonViews A list of style buttons to be rendered\n     * inside the styles grid. The grid will not be rendered when `enabledProperties` does not include the `'styles'` key.\n     * @param options.styleGridAriaLabel An assistive technologies label set on the grid of styles (if the grid is rendered).\n     */\n    constructor(locale, { enabledProperties, styleButtonViews, styleGridAriaLabel }) {\n        super(locale);\n        /**\n         * A view that renders the grid of list styles.\n         */\n        this.stylesView = null;\n        /**\n         * A collapsible view that hosts additional list property fields ({@link #startIndexFieldView} and\n         * {@link #reversedSwitchButtonView}) to visually separate them from the {@link #stylesView grid of styles}.\n         *\n         * **Note**: Only present when:\n         * * the view represents **numbered** list properties,\n         * * and the {@link #stylesView} is rendered,\n         * * and either {@link #startIndexFieldView} or {@link #reversedSwitchButtonView} is rendered.\n         *\n         * @readonly\n         */\n        this.additionalPropertiesCollapsibleView = null;\n        /**\n         * A labeled number field allowing the user to set the start index of the list.\n         *\n         * **Note**: Only present when the view represents **numbered** list properties.\n         *\n         * @readonly\n         */\n        this.startIndexFieldView = null;\n        /**\n         * A switch button allowing the user to make the edited list reversed.\n         *\n         * **Note**: Only present when the view represents **numbered** list properties.\n         *\n         * @readonly\n         */\n        this.reversedSwitchButtonView = null;\n        /**\n         * Tracks information about the DOM focus in the view.\n         */\n        this.focusTracker = new FocusTracker();\n        /**\n         * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.\n         */\n        this.keystrokes = new KeystrokeHandler();\n        /**\n         * A collection of views that can be focused in the properties view.\n         */\n        this.focusables = new ViewCollection();\n        const elementCssClasses = [\n            'ck',\n            'ck-list-properties'\n        ];\n        this.children = this.createCollection();\n        this.focusCycler = new FocusCycler({\n            focusables: this.focusables,\n            focusTracker: this.focusTracker,\n            keystrokeHandler: this.keystrokes,\n            actions: {\n                // Navigate #children backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.\n                focusPrevious: 'shift + tab',\n                // Navigate #children forwards using the <kbd>Tab</kbd> key.\n                focusNext: 'tab'\n            }\n        });\n        // The rendering of the styles grid is conditional. When there is no styles grid, the view will render without collapsible\n        // for numbered list properties, hence simplifying the layout.\n        if (enabledProperties.styles) {\n            this.stylesView = this._createStylesView(styleButtonViews, styleGridAriaLabel);\n            this.children.add(this.stylesView);\n        }\n        else {\n            elementCssClasses.push('ck-list-properties_without-styles');\n        }\n        // The rendering of the numbered list property views is also conditional. It only makes sense for the numbered list\n        // dropdown. The unordered list does not have such properties.\n        if (enabledProperties.startIndex || enabledProperties.reversed) {\n            this._addNumberedListPropertyViews(enabledProperties);\n            elementCssClasses.push('ck-list-properties_with-numbered-properties');\n        }\n        this.setTemplate({\n            tag: 'div',\n            attributes: {\n                class: elementCssClasses\n            },\n            children: this.children\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    render() {\n        super.render();\n        if (this.stylesView) {\n            this.focusables.add(this.stylesView);\n            this.focusTracker.add(this.stylesView.element);\n            // Register the collapsible toggle button to the focus system.\n            if (this.startIndexFieldView || this.reversedSwitchButtonView) {\n                this.focusables.add(this.children.last.buttonView);\n                this.focusTracker.add(this.children.last.buttonView.element);\n            }\n            for (const item of this.stylesView.children) {\n                this.stylesView.focusTracker.add(item.element);\n            }\n            addKeyboardHandlingForGrid({\n                keystrokeHandler: this.stylesView.keystrokes,\n                focusTracker: this.stylesView.focusTracker,\n                gridItems: this.stylesView.children,\n                // Note: The styles view has a different number of columns depending on whether the other properties\n                // are enabled in the dropdown or not (https://github.com/ckeditor/ckeditor5/issues/12340)\n                numberOfColumns: () => global.window\n                    .getComputedStyle(this.stylesView.element)\n                    .getPropertyValue('grid-template-columns')\n                    .split(' ')\n                    .length,\n                uiLanguageDirection: this.locale && this.locale.uiLanguageDirection\n            });\n        }\n        if (this.startIndexFieldView) {\n            this.focusables.add(this.startIndexFieldView);\n            this.focusTracker.add(this.startIndexFieldView.element);\n            const stopPropagation = (data) => data.stopPropagation();\n            // Since the form is in the dropdown panel which is a child of the toolbar, the toolbar's\n            // keystroke handler would take over the key management in the input. We need to prevent\n            // this ASAP. Otherwise, the basic caret movement using the arrow keys will be impossible.\n            this.keystrokes.set('arrowright', stopPropagation);\n            this.keystrokes.set('arrowleft', stopPropagation);\n            this.keystrokes.set('arrowup', stopPropagation);\n            this.keystrokes.set('arrowdown', stopPropagation);\n        }\n        if (this.reversedSwitchButtonView) {\n            this.focusables.add(this.reversedSwitchButtonView);\n            this.focusTracker.add(this.reversedSwitchButtonView.element);\n        }\n        // Start listening for the keystrokes coming from #element.\n        this.keystrokes.listenTo(this.element);\n    }\n    /**\n     * @inheritDoc\n     */\n    focus() {\n        this.focusCycler.focusFirst();\n    }\n    /**\n     * @inheritDoc\n     */\n    focusLast() {\n        this.focusCycler.focusLast();\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        this.focusTracker.destroy();\n        this.keystrokes.destroy();\n    }\n    /**\n     * Creates the list styles grid.\n     *\n     * @param styleButtons Buttons to be placed in the grid.\n     * @param styleGridAriaLabel The assistive technology label of the grid.\n     */\n    _createStylesView(styleButtons, styleGridAriaLabel) {\n        const stylesView = new View(this.locale);\n        stylesView.children = stylesView.createCollection();\n        stylesView.children.addMany(styleButtons);\n        stylesView.setTemplate({\n            tag: 'div',\n            attributes: {\n                'aria-label': styleGridAriaLabel,\n                class: [\n                    'ck',\n                    'ck-list-styles-list'\n                ]\n            },\n            children: stylesView.children\n        });\n        stylesView.children.delegate('execute').to(this);\n        stylesView.focus = function () {\n            this.children.first.focus();\n        };\n        stylesView.focusTracker = new FocusTracker();\n        stylesView.keystrokes = new KeystrokeHandler();\n        stylesView.render();\n        stylesView.keystrokes.listenTo(stylesView.element);\n        return stylesView;\n    }\n    /**\n     * Renders {@link #startIndexFieldView} and/or {@link #reversedSwitchButtonView} depending on the configuration of the properties view.\n     *\n     * @param enabledProperties An object containing the configuration of enabled list property names\n     * (see {@link #constructor}).\n     */\n    _addNumberedListPropertyViews(enabledProperties) {\n        const t = this.locale.t;\n        const numberedPropertyViews = [];\n        if (enabledProperties.startIndex) {\n            this.startIndexFieldView = this._createStartIndexField();\n            numberedPropertyViews.push(this.startIndexFieldView);\n        }\n        if (enabledProperties.reversed) {\n            this.reversedSwitchButtonView = this._createReversedSwitchButton();\n            numberedPropertyViews.push(this.reversedSwitchButtonView);\n        }\n        // When there are some style buttons, pack the numbered list properties into a collapsible to separate them.\n        if (enabledProperties.styles) {\n            this.additionalPropertiesCollapsibleView = new CollapsibleView(this.locale, numberedPropertyViews);\n            this.additionalPropertiesCollapsibleView.set({\n                label: t('List properties'),\n                isCollapsed: true\n            });\n            // Don't enable the collapsible view unless either start index or reversed field is enabled (e.g. when no list is selected).\n            this.additionalPropertiesCollapsibleView.buttonView.bind('isEnabled').toMany(numberedPropertyViews, 'isEnabled', (...areEnabled) => areEnabled.some(isEnabled => isEnabled));\n            // Automatically collapse the additional properties collapsible when either start index or reversed field gets disabled.\n            this.additionalPropertiesCollapsibleView.buttonView.on('change:isEnabled', (evt, data, isEnabled) => {\n                if (!isEnabled) {\n                    this.additionalPropertiesCollapsibleView.isCollapsed = true;\n                }\n            });\n            this.children.add(this.additionalPropertiesCollapsibleView);\n        }\n        else {\n            this.children.addMany(numberedPropertyViews);\n        }\n    }\n    /**\n     * Creates the list start index labeled field.\n     */\n    _createStartIndexField() {\n        const t = this.locale.t;\n        const startIndexFieldView = new LabeledFieldView(this.locale, createLabeledInputNumber);\n        startIndexFieldView.set({\n            label: t('Start at'),\n            class: 'ck-numbered-list-properties__start-index'\n        });\n        startIndexFieldView.fieldView.set({\n            min: 0,\n            step: 1,\n            value: 1,\n            inputMode: 'numeric'\n        });\n        startIndexFieldView.fieldView.on('input', () => {\n            const inputElement = startIndexFieldView.fieldView.element;\n            const startIndex = inputElement.valueAsNumber;\n            if (Number.isNaN(startIndex)) {\n                return;\n            }\n            if (!inputElement.checkValidity()) {\n                startIndexFieldView.errorText = t('Start index must be greater than 0.');\n            }\n            else {\n                this.fire('listStart', { startIndex });\n            }\n        });\n        return startIndexFieldView;\n    }\n    /**\n     * Creates the reversed list switch button.\n     */\n    _createReversedSwitchButton() {\n        const t = this.locale.t;\n        const reversedButtonView = new SwitchButtonView(this.locale);\n        reversedButtonView.set({\n            withText: true,\n            label: t('Reversed order'),\n            class: 'ck-numbered-list-properties__reversed-order'\n        });\n        reversedButtonView.delegate('execute').to(this, 'listReversed');\n        return reversedButtonView;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/listproperties/listpropertiesui\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ButtonView, SplitButtonView, createDropdown, focusChildOnDropdownOpen } from 'ckeditor5/src/ui';\nimport ListPropertiesView from './ui/listpropertiesview';\nimport bulletedListIcon from '../../theme/icons/bulletedlist.svg';\nimport numberedListIcon from '../../theme/icons/numberedlist.svg';\nimport listStyleDiscIcon from '../../theme/icons/liststyledisc.svg';\nimport listStyleCircleIcon from '../../theme/icons/liststylecircle.svg';\nimport listStyleSquareIcon from '../../theme/icons/liststylesquare.svg';\nimport listStyleDecimalIcon from '../../theme/icons/liststyledecimal.svg';\nimport listStyleDecimalWithLeadingZeroIcon from '../../theme/icons/liststyledecimalleadingzero.svg';\nimport listStyleLowerRomanIcon from '../../theme/icons/liststylelowerroman.svg';\nimport listStyleUpperRomanIcon from '../../theme/icons/liststyleupperroman.svg';\nimport listStyleLowerLatinIcon from '../../theme/icons/liststylelowerlatin.svg';\nimport listStyleUpperLatinIcon from '../../theme/icons/liststyleupperlatin.svg';\nimport '../../theme/liststyles.css';\n/**\n * The list properties UI plugin. It introduces the extended `'bulletedList'` and `'numberedList'` toolbar\n * buttons that allow users to control such aspects of list as the marker, start index or order.\n *\n * **Note**: Buttons introduced by this plugin override implementations from the {@link module:list/list/listui~ListUI}\n * (because they share the same names).\n */\nexport default class ListPropertiesUI extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ListPropertiesUI';\n    }\n    init() {\n        const editor = this.editor;\n        const t = editor.locale.t;\n        const enabledProperties = editor.config.get('list.properties');\n        // Note: When this plugin does not register the \"bulletedList\" dropdown due to properties configuration,\n        // a simple button will be still registered under the same name by ListUI as a fallback. This should happen\n        // in most editor configuration because the List plugin automatically requires ListUI.\n        if (enabledProperties.styles) {\n            editor.ui.componentFactory.add('bulletedList', getDropdownViewCreator({\n                editor,\n                parentCommandName: 'bulletedList',\n                buttonLabel: t('Bulleted List'),\n                buttonIcon: bulletedListIcon,\n                styleGridAriaLabel: t('Bulleted list styles toolbar'),\n                styleDefinitions: [\n                    {\n                        label: t('Toggle the disc list style'),\n                        tooltip: t('Disc'),\n                        type: 'disc',\n                        icon: listStyleDiscIcon\n                    },\n                    {\n                        label: t('Toggle the circle list style'),\n                        tooltip: t('Circle'),\n                        type: 'circle',\n                        icon: listStyleCircleIcon\n                    },\n                    {\n                        label: t('Toggle the square list style'),\n                        tooltip: t('Square'),\n                        type: 'square',\n                        icon: listStyleSquareIcon\n                    }\n                ]\n            }));\n        }\n        // Note: When this plugin does not register the \"numberedList\" dropdown due to properties configuration,\n        // a simple button will be still registered under the same name by ListUI as a fallback. This should happen\n        // in most editor configuration because the List plugin automatically requires ListUI.\n        if (enabledProperties.styles || enabledProperties.startIndex || enabledProperties.reversed) {\n            editor.ui.componentFactory.add('numberedList', getDropdownViewCreator({\n                editor,\n                parentCommandName: 'numberedList',\n                buttonLabel: t('Numbered List'),\n                buttonIcon: numberedListIcon,\n                styleGridAriaLabel: t('Numbered list styles toolbar'),\n                styleDefinitions: [\n                    {\n                        label: t('Toggle the decimal list style'),\n                        tooltip: t('Decimal'),\n                        type: 'decimal',\n                        icon: listStyleDecimalIcon\n                    },\n                    {\n                        label: t('Toggle the decimal with leading zero list style'),\n                        tooltip: t('Decimal with leading zero'),\n                        type: 'decimal-leading-zero',\n                        icon: listStyleDecimalWithLeadingZeroIcon\n                    },\n                    {\n                        label: t('Toggle the lower–roman list style'),\n                        tooltip: t('Lower–roman'),\n                        type: 'lower-roman',\n                        icon: listStyleLowerRomanIcon\n                    },\n                    {\n                        label: t('Toggle the upper–roman list style'),\n                        tooltip: t('Upper-roman'),\n                        type: 'upper-roman',\n                        icon: listStyleUpperRomanIcon\n                    },\n                    {\n                        label: t('Toggle the lower–latin list style'),\n                        tooltip: t('Lower-latin'),\n                        type: 'lower-latin',\n                        icon: listStyleLowerLatinIcon\n                    },\n                    {\n                        label: t('Toggle the upper–latin list style'),\n                        tooltip: t('Upper-latin'),\n                        type: 'upper-latin',\n                        icon: listStyleUpperLatinIcon\n                    }\n                ]\n            }));\n        }\n    }\n}\n/**\n * A helper that returns a function that creates a split button with a toolbar in the dropdown,\n * which in turn contains buttons allowing users to change list styles in the context of the current selection.\n *\n * @param options.editor\n * @param options.parentCommandName The name of the higher-order editor command associated with\n * the set of particular list styles (e.g. \"bulletedList\" for \"disc\", \"circle\", and \"square\" styles).\n * @param options.buttonLabel Label of the main part of the split button.\n * @param options.buttonIcon The SVG string of an icon for the main part of the split button.\n * @param options.styleGridAriaLabel The ARIA label for the styles grid in the split button dropdown.\n * @param options.styleDefinitions Definitions of the style buttons.\n * @returns A function that can be passed straight into {@link module:ui/componentfactory~ComponentFactory#add}.\n */\nfunction getDropdownViewCreator({ editor, parentCommandName, buttonLabel, buttonIcon, styleGridAriaLabel, styleDefinitions }) {\n    const parentCommand = editor.commands.get(parentCommandName);\n    return (locale) => {\n        const dropdownView = createDropdown(locale, SplitButtonView);\n        const mainButtonView = dropdownView.buttonView;\n        dropdownView.bind('isEnabled').to(parentCommand);\n        dropdownView.class = 'ck-list-styles-dropdown';\n        // Main button was clicked.\n        mainButtonView.on('execute', () => {\n            editor.execute(parentCommandName);\n            editor.editing.view.focus();\n        });\n        mainButtonView.set({\n            label: buttonLabel,\n            icon: buttonIcon,\n            tooltip: true,\n            isToggleable: true\n        });\n        mainButtonView.bind('isOn').to(parentCommand, 'value', value => !!value);\n        dropdownView.once('change:isOpen', () => {\n            const listPropertiesView = createListPropertiesView({\n                editor,\n                dropdownView,\n                parentCommandName,\n                styleGridAriaLabel,\n                styleDefinitions\n            });\n            dropdownView.panelView.children.add(listPropertiesView);\n        });\n        // Focus the editable after executing the command.\n        // Overrides a default behaviour where the focus is moved to the dropdown button (#12125).\n        dropdownView.on('execute', () => {\n            editor.editing.view.focus();\n        });\n        return dropdownView;\n    };\n}\n/**\n * A helper that returns a function (factory) that creates individual buttons used by users to change styles\n * of lists.\n *\n * @param options.editor\n * @param options.listStyleCommand The instance of the `ListStylesCommand` class.\n * @param options.parentCommandName The name of the higher-order command associated with a\n * particular list style (e.g. \"bulletedList\" is associated with \"square\" and \"numberedList\" is associated with \"roman\").\n * @returns A function that can be passed straight into {@link module:ui/componentfactory~ComponentFactory#add}.\n */\nfunction getStyleButtonCreator({ editor, listStyleCommand, parentCommandName }) {\n    const locale = editor.locale;\n    const parentCommand = editor.commands.get(parentCommandName);\n    return ({ label, type, icon, tooltip }) => {\n        const button = new ButtonView(locale);\n        button.set({ label, icon, tooltip });\n        listStyleCommand.on('change:value', () => {\n            button.isOn = listStyleCommand.value === type;\n        });\n        button.on('execute', () => {\n            // If the content the selection is anchored to is a list, let's change its style.\n            if (parentCommand.value) {\n                // If the current list style is not set in the model or the style is different than the\n                // one to be applied, simply apply the new style.\n                if (listStyleCommand.value !== type) {\n                    editor.execute('listStyle', { type });\n                }\n                // If the style was the same, remove it (the button works as an off toggle).\n                else {\n                    editor.execute('listStyle', { type: listStyleCommand.defaultType });\n                }\n            }\n            // Otherwise, leave the creation of the styled list to the `ListStyleCommand`.\n            else {\n                editor.model.change(() => {\n                    editor.execute('listStyle', { type });\n                });\n            }\n        });\n        return button;\n    };\n}\n/**\n * A helper that creates the properties view for the individual style dropdown.\n *\n * @param options.editor Editor instance.\n * @param options.dropdownView Styles dropdown view that hosts the properties view.\n * @param options.parentCommandName The name of the higher-order editor command associated with\n * the set of particular list styles (e.g. \"bulletedList\" for \"disc\", \"circle\", and \"square\" styles).\n * @param options.styleDefinitions Definitions of the style buttons.\n * @param options.styleGridAriaLabel An assistive technologies label set on the grid of styles (if the grid is rendered).\n */\nfunction createListPropertiesView({ editor, dropdownView, parentCommandName, styleDefinitions, styleGridAriaLabel }) {\n    const locale = editor.locale;\n    const enabledProperties = editor.config.get('list.properties');\n    let styleButtonViews = null;\n    if (parentCommandName != 'numberedList') {\n        enabledProperties.startIndex = false;\n        enabledProperties.reversed = false;\n    }\n    if (enabledProperties.styles) {\n        const listStyleCommand = editor.commands.get('listStyle');\n        const styleButtonCreator = getStyleButtonCreator({\n            editor,\n            parentCommandName,\n            listStyleCommand\n        });\n        // The command can be ListStyleCommand or DocumentListStyleCommand.\n        const isStyleTypeSupported = typeof listStyleCommand.isStyleTypeSupported == 'function' ?\n            (styleDefinition) => listStyleCommand.isStyleTypeSupported(styleDefinition.type) :\n            () => true;\n        styleButtonViews = styleDefinitions.filter(isStyleTypeSupported).map(styleButtonCreator);\n    }\n    const listPropertiesView = new ListPropertiesView(locale, {\n        styleGridAriaLabel,\n        enabledProperties,\n        styleButtonViews\n    });\n    if (enabledProperties.styles) {\n        // Accessibility: focus the first active style when opening the dropdown.\n        focusChildOnDropdownOpen(dropdownView, () => {\n            return listPropertiesView.stylesView.children.find((child) => child.isOn);\n        });\n    }\n    if (enabledProperties.startIndex) {\n        const listStartCommand = editor.commands.get('listStart');\n        listPropertiesView.startIndexFieldView.bind('isEnabled').to(listStartCommand);\n        listPropertiesView.startIndexFieldView.fieldView.bind('value').to(listStartCommand);\n        listPropertiesView.on('listStart', (evt, data) => editor.execute('listStart', data));\n    }\n    if (enabledProperties.reversed) {\n        const listReversedCommand = editor.commands.get('listReversed');\n        listPropertiesView.reversedSwitchButtonView.bind('isEnabled').to(listReversedCommand);\n        listPropertiesView.reversedSwitchButtonView.bind('isOn').to(listReversedCommand, 'value', value => !!value);\n        listPropertiesView.on('listReversed', () => {\n            const isReversed = listReversedCommand.value;\n            editor.execute('listReversed', { reversed: !isReversed });\n        });\n    }\n    // Make sure applying styles closes the dropdown.\n    listPropertiesView.delegate('execute').to(dropdownView);\n    return listPropertiesView;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/documentlistproperties\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport DocumentListPropertiesEditing from './documentlistproperties/documentlistpropertiesediting';\nimport ListPropertiesUI from './listproperties/listpropertiesui';\n/**\n * The document list properties feature.\n *\n * This is a \"glue\" plugin that loads the\n * {@link module:list/documentlistproperties/documentlistpropertiesediting~DocumentListPropertiesEditing document list properties\n * editing feature} and the {@link module:list/listproperties/listpropertiesui~ListPropertiesUI list properties UI feature}.\n */\nexport default class DocumentListProperties extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [DocumentListPropertiesEditing, ListPropertiesUI];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DocumentListProperties';\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { first } from 'ckeditor5/src/utils';\n/**\n * The list indent command. It is used by the {@link module:list/list~List list feature}.\n */\nexport default class IndentCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param editor The editor instance.\n     * @param indentDirection The direction of indent. If it is equal to `backward`, the command will outdent a list item.\n     */\n    constructor(editor, indentDirection) {\n        super(editor);\n        this._indentBy = indentDirection == 'forward' ? 1 : -1;\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.\n     *\n     * @fires execute\n     */\n    execute() {\n        const model = this.editor.model;\n        const doc = model.document;\n        let itemsToChange = Array.from(doc.selection.getSelectedBlocks());\n        model.change(writer => {\n            const lastItem = itemsToChange[itemsToChange.length - 1];\n            // Indenting a list item should also indent all the items that are already sub-items of indented item.\n            let next = lastItem.nextSibling;\n            // Check all items after last indented item, as long as their indent is bigger than indent of that item.\n            while (next && next.name == 'listItem' &&\n                next.getAttribute('listIndent') > lastItem.getAttribute('listIndent')) {\n                itemsToChange.push(next);\n                next = next.nextSibling;\n            }\n            // We need to be sure to keep model in correct state after each small change, because converters\n            // bases on that state and assumes that model is correct.\n            // Because of that, if the command outdents items, we will outdent them starting from the last item, as\n            // it is safer.\n            if (this._indentBy < 0) {\n                itemsToChange = itemsToChange.reverse();\n            }\n            for (const item of itemsToChange) {\n                const indent = item.getAttribute('listIndent') + this._indentBy;\n                // If indent is lower than 0, it means that the item got outdented when it was not indented.\n                // This means that we need to convert that list item to paragraph.\n                if (indent < 0) {\n                    // To keep the model as correct as possible, first rename listItem, then remove attributes,\n                    // as listItem without attributes is very incorrect and will cause problems in converters.\n                    // No need to remove attributes, will be removed by post fixer.\n                    writer.rename(item, 'paragraph');\n                }\n                // If indent is >= 0, change the attribute value.\n                else {\n                    writer.setAttribute('listIndent', indent, item);\n                }\n            }\n            // It allows to execute an action after executing the `~IndentCommand#execute` method, for example adjusting\n            // attributes of changed list items.\n            this.fire('_executeCleanup', itemsToChange);\n        });\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @returns Whether the command should be enabled.\n     */\n    _checkEnabled() {\n        // Check whether any of position's ancestor is a list item.\n        const listItem = first(this.editor.model.document.selection.getSelectedBlocks());\n        // If selection is not in a list item, the command is disabled.\n        if (!listItem || !listItem.is('element', 'listItem')) {\n            return false;\n        }\n        if (this._indentBy > 0) {\n            // Cannot indent first item in it's list. Check if before `listItem` is a list item that is in same list.\n            // To be in the same list, the item has to have same attributes and cannot be \"split\" by an item with lower indent.\n            const indent = listItem.getAttribute('listIndent');\n            const type = listItem.getAttribute('listType');\n            let prev = listItem.previousSibling;\n            while (prev && prev.is('element', 'listItem') && prev.getAttribute('listIndent') >= indent) {\n                if (prev.getAttribute('listIndent') == indent) {\n                    // The item is on the same level.\n                    // If it has same type, it means that we found a preceding sibling from the same list.\n                    // If it does not have same type, it means that `listItem` is on different list (this can happen only\n                    // on top level lists, though).\n                    return prev.getAttribute('listType') == type;\n                }\n                prev = prev.previousSibling;\n            }\n            // Could not find similar list item, this means that `listItem` is first in its list.\n            return false;\n        }\n        // If we are outdenting it is enough to be in list item. Every list item can always be outdented.\n        return true;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { first } from 'ckeditor5/src/utils';\n/**\n * The list command. It is used by the {@link module:list/list~List list feature}.\n */\nexport default class ListCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param editor The editor instance.\n     * @param type List type that will be handled by this command.\n     */\n    constructor(editor, type) {\n        super(editor);\n        this.type = type;\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        this.value = this._getValue();\n        this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Executes the list command.\n     *\n     * @fires execute\n     * @param options Command options.\n     * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the\n     * selected items and potentially the neighbor elements to the proper list items. If set to `false`, it will convert selected elements\n     * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const document = model.document;\n        const blocks = Array.from(document.selection.getSelectedBlocks())\n            .filter(block => checkCanBecomeListItem(block, model.schema));\n        // Whether we are turning off some items.\n        const turnOff = options.forceValue !== undefined ? !options.forceValue : this.value;\n        // If we are turning off items, we are going to rename them to paragraphs.\n        model.change(writer => {\n            // If part of a list got turned off, we need to handle (outdent) all of sub-items of the last turned-off item.\n            // To be sure that model is all the time in a good state, we first fix items below turned-off item.\n            if (turnOff) {\n                // Start from the model item that is just after the last turned-off item.\n                let next = blocks[blocks.length - 1].nextSibling;\n                let currentIndent = Number.POSITIVE_INFINITY;\n                let changes = [];\n                // Correct indent of all items after the last turned off item.\n                // Rules that should be followed:\n                // 1. All direct sub-items of turned-off item should become indent 0, because the first item after it\n                //    will be the first item of a new list. Other items are at the same level, so should have same 0 index.\n                // 2. All items with indent lower than indent of turned-off item should become indent 0, because they\n                //    should not end up as a child of any of list items that they were not children of before.\n                // 3. All other items should have their indent changed relatively to it's parent.\n                //\n                // For example:\n                // 1  * --------\n                // 2     * --------\n                // 3        * --------\t\t\t<-- this is turned off.\n                // 4           * --------\t\t<-- this has to become indent = 0, because it will be first item on a new list.\n                // 5              * --------\t<-- this should be still be a child of item above, so indent = 1.\n                // 6        * --------\t\t\t<-- this has to become indent = 0, because it should not be a child of any of items above.\n                // 7           * --------\t\t<-- this should be still be a child of item above, so indent = 1.\n                // 8     * --------\t\t\t\t<-- this has to become indent = 0.\n                // 9        * --------\t\t\t<-- this should still be a child of item above, so indent = 1.\n                // 10          * --------\t\t<-- this should still be a child of item above, so indent = 2.\n                // 11          * --------\t\t<-- this should still be at the same level as item above, so indent = 2.\n                // 12 * --------\t\t\t\t<-- this and all below are left unchanged.\n                // 13    * --------\n                // 14       * --------\n                //\n                // After turning off 3 the list becomes:\n                //\n                // 1  * --------\n                // 2     * --------\n                //\n                // 3  --------\n                //\n                // 4  * --------\n                // 5     * --------\n                // 6  * --------\n                // 7     * --------\n                // 8  * --------\n                // 9     * --------\n                // 10       * --------\n                // 11       * --------\n                // 12 * --------\n                // 13    * --------\n                // 14       * --------\n                //\n                // Thanks to this algorithm no lists are mismatched and no items get unexpected children/parent, while\n                // those parent-child connection which are possible to maintain are still maintained. It's worth noting\n                // that this is the same effect that we would be get by multiple use of outdent command. However doing\n                // it like this is much more efficient because it's less operation (less memory usage, easier OT) and\n                // less conversion (faster).\n                while (next && next.name == 'listItem' && next.getAttribute('listIndent') !== 0) {\n                    // Check each next list item, as long as its indent is bigger than 0.\n                    // If the indent is 0 we are not going to change anything anyway.\n                    const indent = next.getAttribute('listIndent');\n                    // We check if that's item indent is lower as current relative indent.\n                    if (indent < currentIndent) {\n                        // If it is, current relative indent becomes that indent.\n                        currentIndent = indent;\n                    }\n                    // Fix indent relatively to current relative indent.\n                    // Note, that if we just changed the current relative indent, the newIndent will be equal to 0.\n                    const newIndent = indent - currentIndent;\n                    // Save the entry in changes array. We do not apply it at the moment, because we will need to\n                    // reverse the changes so the last item is changed first.\n                    // This is to keep model in correct state all the time.\n                    changes.push({ element: next, listIndent: newIndent });\n                    // Find next item.\n                    next = next.nextSibling;\n                }\n                changes = changes.reverse();\n                for (const item of changes) {\n                    writer.setAttribute('listIndent', item.listIndent, item.element);\n                }\n            }\n            // If we are turning on, we might change some items that are already `listItem`s but with different type.\n            // Changing one nested list item to other type should also trigger changing all its siblings so the\n            // whole nested list is of the same type.\n            // Example (assume changing to numbered list):\n            // * ------\t\t\t\t<-- do not fix, top level item\n            //   * ------\t\t\t<-- fix, because latter list item of this item's list is changed\n            //      * ------\t\t<-- do not fix, item is not affected (different list)\n            //   * ------\t\t\t<-- fix, because latter list item of this item's list is changed\n            //      * ------\t\t<-- fix, because latter list item of this item's list is changed\n            //      * ---[--\t\t<-- already in selection\n            //   * ------\t\t\t<-- already in selection\n            //   * ------\t\t\t<-- already in selection\n            // * ------\t\t\t\t<-- already in selection, but does not cause other list items to change because is top-level\n            //   * ---]--\t\t\t<-- already in selection\n            //   * ------\t\t\t<-- fix, because preceding list item of this item's list is changed\n            //      * ------\t\t<-- do not fix, item is not affected (different list)\n            // * ------\t\t\t\t<-- do not fix, top level item\n            if (!turnOff) {\n                // Find lowest indent among selected items. This will be indicator what is the indent of\n                // top-most list affected by the command.\n                let lowestIndent = Number.POSITIVE_INFINITY;\n                for (const item of blocks) {\n                    if (item.is('element', 'listItem') && item.getAttribute('listIndent') < lowestIndent) {\n                        lowestIndent = item.getAttribute('listIndent');\n                    }\n                }\n                // Do not execute the fix for top-level lists.\n                lowestIndent = lowestIndent === 0 ? 1 : lowestIndent;\n                // Fix types of list items that are \"before\" the selected blocks.\n                _fixType(blocks, true, lowestIndent);\n                // Fix types of list items that are \"after\" the selected blocks.\n                _fixType(blocks, false, lowestIndent);\n            }\n            // Phew! Now it will be easier :).\n            // For each block element that was in the selection, we will either: turn it to list item,\n            // turn it to paragraph, or change it's type. Or leave it as it is.\n            // Do it in reverse as there might be multiple blocks (same as with changing indents).\n            for (const element of blocks.reverse()) {\n                if (turnOff && element.name == 'listItem') {\n                    // We are turning off and the element is a `listItem` - it should be converted to `paragraph`.\n                    // List item specific attributes are removed by post fixer.\n                    writer.rename(element, 'paragraph');\n                }\n                else if (!turnOff && element.name != 'listItem') {\n                    // We are turning on and the element is not a `listItem` - it should be converted to `listItem`.\n                    // The order of operations is important to keep model in correct state.\n                    writer.setAttributes({ listType: this.type, listIndent: 0 }, element);\n                    writer.rename(element, 'listItem');\n                }\n                else if (!turnOff && element.name == 'listItem' && element.getAttribute('listType') != this.type) {\n                    // We are turning on and the element is a `listItem` but has different type - change it's type and\n                    // type of it's all siblings that have same indent.\n                    writer.setAttribute('listType', this.type, element);\n                }\n            }\n            /**\n             * Event fired by the {@link #execute} method.\n             *\n             * It allows to execute an action after executing the {@link ~ListCommand#execute} method, for example adjusting\n             * attributes of changed blocks.\n             *\n             * @protected\n             * @event _executeCleanup\n             */\n            this.fire('_executeCleanup', blocks);\n        });\n    }\n    /**\n     * Checks the command's {@link #value}.\n     *\n     * @returns The current value.\n     */\n    _getValue() {\n        // Check whether closest `listItem` ancestor of the position has a correct type.\n        const listItem = first(this.editor.model.document.selection.getSelectedBlocks());\n        return !!listItem && listItem.is('element', 'listItem') && listItem.getAttribute('listType') == this.type;\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @returns Whether the command should be enabled.\n     */\n    _checkEnabled() {\n        // If command value is true it means that we are in list item, so the command should be enabled.\n        if (this.value) {\n            return true;\n        }\n        const selection = this.editor.model.document.selection;\n        const schema = this.editor.model.schema;\n        const firstBlock = first(selection.getSelectedBlocks());\n        if (!firstBlock) {\n            return false;\n        }\n        // Otherwise, check if list item can be inserted at the position start.\n        return checkCanBecomeListItem(firstBlock, schema);\n    }\n}\n/**\n * Helper function used when one or more list item have their type changed. Fixes type of other list items\n * that are affected by the change (are in same lists) but are not directly in selection. The function got extracted\n * not to duplicated code, as same fix has to be performed before and after selection.\n *\n * @param blocks Blocks that are in selection.\n * @param isBackward Specified whether fix will be applied for blocks before first selected block (`true`)\n * or blocks after last selected block (`false`).\n * @param lowestIndent Lowest indent among selected blocks.\n */\nfunction _fixType(blocks, isBackward, lowestIndent) {\n    // We need to check previous sibling of first changed item and next siblings of last changed item.\n    const startingItem = isBackward ? blocks[0] : blocks[blocks.length - 1];\n    if (startingItem.is('element', 'listItem')) {\n        let item = startingItem[isBackward ? 'previousSibling' : 'nextSibling'];\n        // During processing items, keeps the lowest indent of already processed items.\n        // This saves us from changing too many items.\n        // Following example is for going forward as it is easier to read, however same applies to going backward.\n        // * ------\n        //   * ------\n        //     * --[---\n        //   * ------\t\t<-- `lowestIndent` should be 1\n        //     * --]---\t\t<-- `startingItem`, `currentIndent` = 2, `lowestIndent` == 1\n        //     * ------\t\t<-- should be fixed, `indent` == 2 == `currentIndent`\n        //   * ------\t\t<-- should be fixed, set `currentIndent` to 1, `indent` == 1 == `currentIndent`\n        //     * ------\t\t<-- should not be fixed, item is in different list, `indent` = 2, `indent` != `currentIndent`\n        //   * ------\t\t<-- should be fixed, `indent` == 1 == `currentIndent`\n        // * ------\t\t\t<-- break loop (`indent` < `lowestIndent`)\n        let currentIndent = startingItem.getAttribute('listIndent');\n        // Look back until a list item with indent lower than reference `lowestIndent`.\n        // That would be the parent of nested sublist which contains item having `lowestIndent`.\n        while (item && item.is('element', 'listItem') && item.getAttribute('listIndent') >= lowestIndent) {\n            if (currentIndent > item.getAttribute('listIndent')) {\n                currentIndent = item.getAttribute('listIndent');\n            }\n            // Found an item that is in the same nested sublist.\n            if (item.getAttribute('listIndent') == currentIndent) {\n                // Just add the item to selected blocks like it was selected by the user.\n                blocks[isBackward ? 'unshift' : 'push'](item);\n            }\n            item = item[isBackward ? 'previousSibling' : 'nextSibling'];\n        }\n    }\n}\n/**\n * Checks whether the given block can be replaced by a listItem.\n *\n * @param block A block to be tested.\n * @param schema The schema of the document.\n */\nfunction checkCanBecomeListItem(block, schema) {\n    return schema.checkChild(block.parent, 'listItem') && !schema.isObject(block);\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { getListTypeFromListStyleType, getSelectedListItems, getSiblingNodes } from './utils';\n/**\n * A set of helpers related to document lists.\n */\nexport default class ListUtils extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ListUtils';\n    }\n    /**\n     * Checks whether the given list-style-type is supported by numbered or bulleted list.\n     */\n    getListTypeFromListStyleType(listStyleType) {\n        return getListTypeFromListStyleType(listStyleType);\n    }\n    /**\n     * Returns an array with all `listItem` elements in the model selection.\n     *\n     * It returns all the items even if only a part of the list is selected, including items that belong to nested lists.\n     * If no list is selected, it returns an empty array.\n     * The order of the elements is not specified.\n     */\n    getSelectedListItems(model) {\n        return getSelectedListItems(model);\n    }\n    /**\n     * Returns an array with all `listItem` elements that represent the same list.\n     *\n     * It means that values of `listIndent`, `listType`, `listStyle`, `listReversed` and `listStart` for all items are equal.\n     *\n     * Additionally, if the `position` is inside a list item, that list item will be returned as well.\n     *\n     * @param position Starting position.\n     * @param direction Walking direction.\n     */\n    getSiblingNodes(position, direction) {\n        return getSiblingNodes(position, direction);\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/list/converters\n */\nimport { TreeWalker } from 'ckeditor5/src/engine';\nimport { generateLiInUl, injectViewList, mergeViewLists, getSiblingListItem, positionAfterUiElements } from './utils';\n/**\n * A model-to-view converter for the `listItem` model element insertion.\n *\n * It creates a `<ul><li></li><ul>` (or `<ol>`) view structure out of a `listItem` model element, inserts it at the correct\n * position, and merges the list with surrounding lists (if available).\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param model Model instance.\n */\nexport function modelViewInsertion(model) {\n    return (evt, data, conversionApi) => {\n        const consumable = conversionApi.consumable;\n        if (!consumable.test(data.item, 'insert') ||\n            !consumable.test(data.item, 'attribute:listType') ||\n            !consumable.test(data.item, 'attribute:listIndent')) {\n            return;\n        }\n        consumable.consume(data.item, 'insert');\n        consumable.consume(data.item, 'attribute:listType');\n        consumable.consume(data.item, 'attribute:listIndent');\n        const modelItem = data.item;\n        const viewItem = generateLiInUl(modelItem, conversionApi);\n        injectViewList(modelItem, viewItem, conversionApi, model);\n    };\n}\n/**\n * A model-to-view converter for the `listItem` model element removal.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param model Model instance.\n * @returns Returns a conversion callback.\n */\nexport function modelViewRemove(model) {\n    return (evt, data, conversionApi) => {\n        const viewPosition = conversionApi.mapper.toViewPosition(data.position);\n        const viewStart = viewPosition.getLastMatchingPosition(value => !value.item.is('element', 'li'));\n        const viewItem = viewStart.nodeAfter;\n        const viewWriter = conversionApi.writer;\n        // 1. Break the container after and before the list item.\n        // This will create a view list with one view list item - the one to remove.\n        viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n        viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));\n        // 2. Remove the list with the item to remove.\n        const viewList = viewItem.parent;\n        const viewListPrev = viewList.previousSibling;\n        const removeRange = viewWriter.createRangeOn(viewList);\n        const removed = viewWriter.remove(removeRange);\n        // 3. Merge the whole created by breaking and removing the list.\n        if (viewListPrev && viewListPrev.nextSibling) {\n            mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);\n        }\n        // 4. Bring back nested list that was in the removed <li>.\n        const modelItem = conversionApi.mapper.toModelElement(viewItem);\n        hoistNestedLists(modelItem.getAttribute('listIndent') + 1, data.position, removeRange.start, viewItem, conversionApi, model);\n        // 5. Unbind removed view item and all children.\n        for (const child of viewWriter.createRangeIn(removed).getItems()) {\n            conversionApi.mapper.unbindViewElement(child);\n        }\n        evt.stop();\n    };\n}\n/**\n * A model-to-view converter for the `type` attribute change on the `listItem` model element.\n *\n * This change means that the `<li>` element parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished\n * by breaking view elements and changing their name. The next {@link module:list/list/converters~modelViewMergeAfterChangeType}\n * converter will attempt to merge split nodes.\n *\n * Splitting this conversion into 2 steps makes it possible to add an additional conversion in the middle.\n * Check {@link module:list/todolist/todolistconverters~modelViewChangeType} to see an example of it.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n */\nexport const modelViewChangeType = (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n        return;\n    }\n    const viewItem = conversionApi.mapper.toViewElement(data.item);\n    const viewWriter = conversionApi.writer;\n    // Break the container after and before the list item.\n    // This will create a view list with one view list item -- the one that changed type.\n    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));\n    // Change name of the view list that holds the changed view item.\n    // We cannot just change name property, because that would not render properly.\n    const viewList = viewItem.parent;\n    const listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';\n    viewWriter.rename(listName, viewList);\n};\n/**\n * A model-to-view converter that attempts to merge nodes split by {@link module:list/list/converters~modelViewChangeType}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n */\nexport const modelViewMergeAfterChangeType = (evt, data, conversionApi) => {\n    conversionApi.consumable.consume(data.item, evt.name);\n    const viewItem = conversionApi.mapper.toViewElement(data.item);\n    const viewList = viewItem.parent;\n    const viewWriter = conversionApi.writer;\n    // Merge the changed view list with other lists, if possible.\n    mergeViewLists(viewWriter, viewList, viewList.nextSibling);\n    mergeViewLists(viewWriter, viewList.previousSibling, viewList);\n};\n/**\n * A model-to-view converter for the `listIndent` attribute change on the `listItem` model element.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param model Model instance.\n * @returns Returns a conversion callback.\n */\nexport function modelViewChangeIndent(model) {\n    return (evt, data, conversionApi) => {\n        if (!conversionApi.consumable.consume(data.item, 'attribute:listIndent')) {\n            return;\n        }\n        const viewItem = conversionApi.mapper.toViewElement(data.item);\n        const viewWriter = conversionApi.writer;\n        // 1. Break the container after and before the list item.\n        // This will create a view list with one view list item -- the one that changed type.\n        viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n        viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));\n        // 2. Extract view list with changed view list item and merge \"hole\" possibly created by breaking and removing elements.\n        const viewList = viewItem.parent;\n        const viewListPrev = viewList.previousSibling;\n        const removeRange = viewWriter.createRangeOn(viewList);\n        viewWriter.remove(removeRange);\n        if (viewListPrev && viewListPrev.nextSibling) {\n            mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);\n        }\n        // 3. Bring back nested list that was in the removed <li>.\n        hoistNestedLists(data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model);\n        // 4. Inject view list like it is newly inserted.\n        injectViewList(data.item, viewItem, conversionApi, model);\n        // 5. Consume insertion of children inside the item. They are already handled by re-building the item in view.\n        for (const child of data.item.getChildren()) {\n            conversionApi.consumable.consume(child, 'insert');\n        }\n    };\n}\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter is fired for\n * insert change of every model item, and should be fired before the actual converter. The converter checks whether the inserted\n * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the\n * list so the model element is inserted to the view parent element corresponding to its model parent element.\n *\n * The converter prevents such situations:\n *\n * ```xml\n * // Model:                        // View:\n * <listItem>foo</listItem>         <ul>\n * <listItem>bar</listItem>             <li>foo</li>\n *                                      <li>bar</li>\n *                                  </ul>\n *\n * // After change:                 // Correct view guaranteed by this converter:\n * <listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>\n * <paragraph>xxx</paragraph>       // Instead of this wrong view state:\n * <listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>\n * ```\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n */\nexport const modelViewSplitOnInsert = (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n        return;\n    }\n    if (data.item.name != 'listItem') {\n        let viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n        const viewWriter = conversionApi.writer;\n        const lists = [];\n        // Break multiple ULs/OLs if there are.\n        //\n        // Imagine following list:\n        //\n        // 1 --------\n        //   1.1 --------\n        //     1.1.1 --------\n        //     1.1.2 --------\n        //     1.1.3 --------\n        //       1.1.3.1 --------\n        //   1.2 --------\n        //     1.2.1 --------\n        // 2 --------\n        //\n        // Insert paragraph after item 1.1.1:\n        //\n        // 1 --------\n        //   1.1 --------\n        //     1.1.1 --------\n        //\n        // Lorem ipsum.\n        //\n        //     1.1.2 --------\n        //     1.1.3 --------\n        //       1.1.3.1 --------\n        //   1.2 --------\n        //     1.2.1 --------\n        // 2 --------\n        //\n        // In this case 1.1.2 has to become beginning of a new list.\n        // We need to break list before 1.1.2 (obvious), then we need to break list also before 1.2.\n        // Then we need to move those broken pieces one after another and merge:\n        //\n        // 1 --------\n        //   1.1 --------\n        //     1.1.1 --------\n        //\n        // Lorem ipsum.\n        //\n        // 1.1.2 --------\n        //   1.1.3 --------\n        //     1.1.3.1 --------\n        // 1.2 --------\n        //   1.2.1 --------\n        // 2 --------\n        //\n        while (viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol') {\n            viewPosition = viewWriter.breakContainer(viewPosition);\n            if (viewPosition.parent.name != 'li') {\n                break;\n            }\n            // Remove lists that are after inserted element.\n            // They will be brought back later, below the inserted element.\n            const removeStart = viewPosition;\n            const removeEnd = viewWriter.createPositionAt(viewPosition.parent, 'end');\n            // Don't remove if there is nothing to remove.\n            if (!removeStart.isEqual(removeEnd)) {\n                const removed = viewWriter.remove(viewWriter.createRange(removeStart, removeEnd));\n                lists.push(removed);\n            }\n            viewPosition = viewWriter.createPositionAfter(viewPosition.parent);\n        }\n        // Bring back removed lists.\n        if (lists.length > 0) {\n            for (let i = 0; i < lists.length; i++) {\n                const previousList = viewPosition.nodeBefore;\n                const insertedRange = viewWriter.insert(viewPosition, lists[i]);\n                viewPosition = insertedRange.end;\n                // Don't merge first list! We want a split in that place (this is why this converter is introduced).\n                if (i > 0) {\n                    const mergePos = mergeViewLists(viewWriter, previousList, previousList.nextSibling);\n                    // If `mergePos` is in `previousList` it means that the lists got merged.\n                    // In this case, we need to fix insert position.\n                    if (mergePos && mergePos.parent == previousList) {\n                        viewPosition.offset--;\n                    }\n                }\n            }\n            // Merge last inserted list with element after it.\n            mergeViewLists(viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter);\n        }\n    }\n};\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter takes care of\n * merging view lists after something is removed or moved from near them.\n *\n * Example:\n *\n * ```xml\n * // Model:                        // View:\n * <listItem>foo</listItem>         <ul><li>foo</li></ul>\n * <paragraph>xxx</paragraph>       <p>xxx</p>\n * <listItem>bar</listItem>         <ul><li>bar</li></ul>\n *\n * // After change:                 // Correct view guaranteed by this converter:\n * <listItem>foo</listItem>         <ul>\n * <listItem>bar</listItem>             <li>foo</li>\n *                                      <li>bar</li>\n *                                  </ul>\n * ```\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n */\nexport const modelViewMergeAfter = (evt, data, conversionApi) => {\n    const viewPosition = conversionApi.mapper.toViewPosition(data.position);\n    const viewItemPrev = viewPosition.nodeBefore;\n    const viewItemNext = viewPosition.nodeAfter;\n    // Merge lists if something (remove, move) was done from inside of list.\n    // Merging will be done only if both items are view lists of the same type.\n    // The check is done inside the helper function.\n    mergeViewLists(conversionApi.writer, viewItemPrev, viewItemNext);\n};\n/**\n * A view-to-model converter that converts the `<li>` view elements into the `listItem` model elements.\n *\n * To set correct values of the `listType` and `listIndent` attributes the converter:\n * * checks `<li>`'s parent,\n * * stores and increases the `conversionApi.store.indent` value when `<li>`'s sub-items are converted.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n */\nexport const viewModelConverter = (evt, data, conversionApi) => {\n    if (conversionApi.consumable.consume(data.viewItem, { name: true })) {\n        const writer = conversionApi.writer;\n        // 1. Create `listItem` model element.\n        const listItem = writer.createElement('listItem');\n        // 2. Handle `listItem` model element attributes.\n        const indent = getIndent(data.viewItem);\n        writer.setAttribute('listIndent', indent, listItem);\n        // Set 'bulleted' as default. If this item is pasted into a context,\n        const type = data.viewItem.parent && data.viewItem.parent.name == 'ol' ? 'numbered' : 'bulleted';\n        writer.setAttribute('listType', type, listItem);\n        if (!conversionApi.safeInsert(listItem, data.modelCursor)) {\n            return;\n        }\n        const nextPosition = viewToModelListItemChildrenConverter(listItem, data.viewItem.getChildren(), conversionApi);\n        // Result range starts before the first item and ends after the last.\n        data.modelRange = writer.createRange(data.modelCursor, nextPosition);\n        conversionApi.updateConversionResult(listItem, data);\n    }\n};\n/**\n * A view-to-model converter for the `<ul>` and `<ol>` view elements that cleans the input view of garbage.\n * This is mostly to clean whitespaces from between the `<li>` view elements inside the view list element, however, also\n * incorrect data can be cleared if the view was incorrect.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n */\nexport const cleanList = (evt, data, conversionApi) => {\n    if (conversionApi.consumable.test(data.viewItem, { name: true })) {\n        // Caching children because when we start removing them iterating fails.\n        const children = Array.from(data.viewItem.getChildren());\n        for (const child of children) {\n            const isWrongElement = !(child.is('element', 'li') || isList(child));\n            if (isWrongElement) {\n                child._remove();\n            }\n        }\n    }\n};\n/**\n * A view-to-model converter for the `<li>` elements that cleans whitespace formatting from the input view.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n */\nexport const cleanListItem = (evt, data, conversionApi) => {\n    if (conversionApi.consumable.test(data.viewItem, { name: true })) {\n        if (data.viewItem.childCount === 0) {\n            return;\n        }\n        const children = [...data.viewItem.getChildren()];\n        let foundList = false;\n        for (const child of children) {\n            if (foundList && !isList(child)) {\n                child._remove();\n            }\n            if (isList(child)) {\n                // If this is a <ul> or <ol>, do not process it, just mark that we already visited list element.\n                foundList = true;\n            }\n        }\n    }\n};\n/**\n * Returns a callback for model position to view position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `listItem` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n */\nexport function modelToViewPosition(view) {\n    return (evt, data) => {\n        if (data.isPhantom) {\n            return;\n        }\n        const modelItem = data.modelPosition.nodeBefore;\n        if (modelItem && modelItem.is('element', 'listItem')) {\n            const viewItem = data.mapper.toViewElement(modelItem);\n            const topmostViewList = viewItem.getAncestors().find(isList);\n            const walker = view.createPositionAt(viewItem, 0).getWalker();\n            for (const value of walker) {\n                if (value.type == 'elementStart' && value.item.is('element', 'li')) {\n                    data.viewPosition = value.previousPosition;\n                    break;\n                }\n                else if (value.type == 'elementEnd' && value.item == topmostViewList) {\n                    data.viewPosition = value.nextPosition;\n                    break;\n                }\n            }\n        }\n    };\n}\n/**\n * The callback for view position to model position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `<li>` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:viewToModelPosition\n * @param model Model instance.\n * @returns Returns a conversion callback.\n */\nexport function viewToModelPosition(model) {\n    return (evt, data) => {\n        const viewPos = data.viewPosition;\n        const viewParent = viewPos.parent;\n        const mapper = data.mapper;\n        if (viewParent.name == 'ul' || viewParent.name == 'ol') {\n            // Position is directly in <ul> or <ol>.\n            if (!viewPos.isAtEnd) {\n                // If position is not at the end, it must be before <li>.\n                // Get that <li>, map it to `listItem` and set model position before that `listItem`.\n                const modelNode = mapper.toModelElement(viewPos.nodeAfter);\n                data.modelPosition = model.createPositionBefore(modelNode);\n            }\n            else {\n                // Position is at the end of <ul> or <ol>, so there is no <li> after it to be mapped.\n                // There is <li> before the position, but we cannot just map it to `listItem` and set model position after it,\n                // because that <li> may contain nested items.\n                // We will check \"model length\" of that <li>, in other words - how many `listItem`s are in that <li>.\n                const modelNode = mapper.toModelElement(viewPos.nodeBefore);\n                const modelLength = mapper.getModelLength(viewPos.nodeBefore);\n                // Then we get model position before mapped `listItem` and shift it accordingly.\n                data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);\n            }\n            evt.stop();\n        }\n        else if (viewParent.name == 'li' &&\n            viewPos.nodeBefore &&\n            (viewPos.nodeBefore.name == 'ul' || viewPos.nodeBefore.name == 'ol')) {\n            // In most cases when view position is in <li> it is in text and this is a correct position.\n            // However, if position is after <ul> or <ol> we have to fix it -- because in model <ul>/<ol> are not in the `listItem`.\n            const modelNode = mapper.toModelElement(viewParent);\n            // Check all <ul>s and <ol>s that are in the <li> but before mapped position.\n            // Get model length of those elements and then add it to the offset of `listItem` mapped to the original <li>.\n            let modelLength = 1; // Starts from 1 because the original <li> has to be counted in too.\n            let viewList = viewPos.nodeBefore;\n            while (viewList && isList(viewList)) {\n                modelLength += mapper.getModelLength(viewList);\n                viewList = viewList.previousSibling;\n            }\n            data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);\n            evt.stop();\n        }\n    };\n}\n/**\n * Post-fixer that reacts to changes on document and fixes incorrect model states.\n *\n * In the example below, there is a correct list structure.\n * Then the middle element is removed so the list structure will become incorrect:\n *\n * ```xml\n * <listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n * <listItem listType=\"bulleted\" listIndent=1>Item 2</listItem>   <--- this is removed.\n * <listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n * ```\n *\n * The list structure after the middle element is removed:\n *\n * ```xml\n * <listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n * <listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n * ```\n *\n * Should become:\n *\n * ```xml\n * <listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n * <listItem listType=\"bulleted\" listIndent=1>Item 3</listItem>   <--- note that indent got post-fixed.\n * ```\n *\n * @param model The data model.\n * @param writer The writer to do changes with.\n * @returns `true` if any change has been applied, `false` otherwise.\n */\nexport function modelChangePostFixer(model, writer) {\n    const changes = model.document.differ.getChanges();\n    const itemToListHead = new Map();\n    let applied = false;\n    for (const entry of changes) {\n        if (entry.type == 'insert' && entry.name == 'listItem') {\n            _addListToFix(entry.position);\n        }\n        else if (entry.type == 'insert' && entry.name != 'listItem') {\n            if (entry.name != '$text') {\n                // In case of renamed element.\n                const item = entry.position.nodeAfter;\n                if (item.hasAttribute('listIndent')) {\n                    writer.removeAttribute('listIndent', item);\n                    applied = true;\n                }\n                if (item.hasAttribute('listType')) {\n                    writer.removeAttribute('listType', item);\n                    applied = true;\n                }\n                if (item.hasAttribute('listStyle')) {\n                    writer.removeAttribute('listStyle', item);\n                    applied = true;\n                }\n                if (item.hasAttribute('listReversed')) {\n                    writer.removeAttribute('listReversed', item);\n                    applied = true;\n                }\n                if (item.hasAttribute('listStart')) {\n                    writer.removeAttribute('listStart', item);\n                    applied = true;\n                }\n                for (const innerItem of Array.from(model.createRangeIn(item)).filter(e => e.item.is('element', 'listItem'))) {\n                    _addListToFix(innerItem.previousPosition);\n                }\n            }\n            const posAfter = entry.position.getShiftedBy(entry.length);\n            _addListToFix(posAfter);\n        }\n        else if (entry.type == 'remove' && entry.name == 'listItem') {\n            _addListToFix(entry.position);\n        }\n        else if (entry.type == 'attribute' && entry.attributeKey == 'listIndent') {\n            _addListToFix(entry.range.start);\n        }\n        else if (entry.type == 'attribute' && entry.attributeKey == 'listType') {\n            _addListToFix(entry.range.start);\n        }\n    }\n    for (const listHead of itemToListHead.values()) {\n        _fixListIndents(listHead);\n        _fixListTypes(listHead);\n    }\n    return applied;\n    function _addListToFix(position) {\n        const previousNode = position.nodeBefore;\n        if (!previousNode || !previousNode.is('element', 'listItem')) {\n            const item = position.nodeAfter;\n            if (item && item.is('element', 'listItem')) {\n                itemToListHead.set(item, item);\n            }\n        }\n        else {\n            let listHead = previousNode;\n            if (itemToListHead.has(listHead)) {\n                return;\n            }\n            for (\n            // Cache previousSibling and reuse for performance reasons. See #6581.\n            let previousSibling = listHead.previousSibling; previousSibling && previousSibling.is('element', 'listItem'); previousSibling = listHead.previousSibling) {\n                listHead = previousSibling;\n                if (itemToListHead.has(listHead)) {\n                    return;\n                }\n            }\n            itemToListHead.set(previousNode, listHead);\n        }\n    }\n    function _fixListIndents(item) {\n        let maxIndent = 0;\n        let fixBy = null;\n        while (item && item.is('element', 'listItem')) {\n            const itemIndent = item.getAttribute('listIndent');\n            if (itemIndent > maxIndent) {\n                let newIndent;\n                if (fixBy === null) {\n                    fixBy = itemIndent - maxIndent;\n                    newIndent = maxIndent;\n                }\n                else {\n                    if (fixBy > itemIndent) {\n                        fixBy = itemIndent;\n                    }\n                    newIndent = itemIndent - fixBy;\n                }\n                writer.setAttribute('listIndent', newIndent, item);\n                applied = true;\n            }\n            else {\n                fixBy = null;\n                maxIndent = item.getAttribute('listIndent') + 1;\n            }\n            item = item.nextSibling;\n        }\n    }\n    function _fixListTypes(item) {\n        let typesStack = [];\n        let prev = null;\n        while (item && item.is('element', 'listItem')) {\n            const itemIndent = item.getAttribute('listIndent');\n            if (prev && prev.getAttribute('listIndent') > itemIndent) {\n                typesStack = typesStack.slice(0, itemIndent + 1);\n            }\n            if (itemIndent != 0) {\n                if (typesStack[itemIndent]) {\n                    const type = typesStack[itemIndent];\n                    if (item.getAttribute('listType') != type) {\n                        writer.setAttribute('listType', type, item);\n                        applied = true;\n                    }\n                }\n                else {\n                    typesStack[itemIndent] = item.getAttribute('listType');\n                }\n            }\n            prev = item;\n            item = item.nextSibling;\n        }\n    }\n}\n/**\n * A fixer for pasted content that includes list items.\n *\n * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.\n *\n * Example:\n *\n * ```xml\n * <listItem listType=\"bulleted\" listIndent=0>A</listItem>\n * <listItem listType=\"bulleted\" listIndent=1>B^</listItem>\n * // At ^ paste:  <listItem listType=\"bulleted\" listIndent=4>X</listItem>\n * //              <listItem listType=\"bulleted\" listIndent=5>Y</listItem>\n * <listItem listType=\"bulleted\" listIndent=2>C</listItem>\n * ```\n *\n * Should become:\n *\n * ```xml\n * <listItem listType=\"bulleted\" listIndent=0>A</listItem>\n * <listItem listType=\"bulleted\" listIndent=1>BX</listItem>\n * <listItem listType=\"bulleted\" listIndent=2>Y/listItem>\n * <listItem listType=\"bulleted\" listIndent=2>C</listItem>\n * ```\n */\nexport const modelIndentPasteFixer = function (evt, [content, selectable]) {\n    const model = this;\n    // Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other\n    // elements before it and there is no need to fix indents, because even if we insert that content into a list,\n    // that list will be broken.\n    // Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2\n    // would create incorrect model.\n    let item = content.is('documentFragment') ? content.getChild(0) : content;\n    let selection;\n    if (!selectable) {\n        selection = model.document.selection;\n    }\n    else {\n        selection = model.createSelection(selectable);\n    }\n    if (item && item.is('element', 'listItem')) {\n        // Get a reference list item. Inserted list items will be fixed according to that item.\n        const pos = selection.getFirstPosition();\n        let refItem = null;\n        if (pos.parent.is('element', 'listItem')) {\n            refItem = pos.parent;\n        }\n        else if (pos.nodeBefore && pos.nodeBefore.is('element', 'listItem')) {\n            refItem = pos.nodeBefore;\n        }\n        // If there is `refItem` it means that we do insert list items into an existing list.\n        if (refItem) {\n            // First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal\n            // to the indent of reference item. We have to fix the first item and all of it's children and following siblings.\n            // Indent of all those items has to be adjusted to reference item.\n            const indentChange = refItem.getAttribute('listIndent');\n            // Fix only if there is anything to fix.\n            if (indentChange > 0) {\n                // Adjust indent of all \"first\" list items in inserted data.\n                while (item && item.is('element', 'listItem')) {\n                    item._setAttribute('listIndent', item.getAttribute('listIndent') + indentChange);\n                    item = item.nextSibling;\n                }\n            }\n        }\n    }\n};\n/**\n * Helper function that converts children of a given `<li>` view element into corresponding model elements.\n * The function maintains proper order of elements if model `listItem` is split during the conversion\n * due to block children conversion.\n *\n * @param listItemModel List item model element to which converted children will be inserted.\n * @param viewChildren View elements which will be converted.\n * @param conversionApi Conversion interface to be used by the callback.\n * @returns Position on which next elements should be inserted after children conversion.\n */\nfunction viewToModelListItemChildrenConverter(listItemModel, viewChildren, conversionApi) {\n    const { writer, schema } = conversionApi;\n    // A position after the last inserted `listItem`.\n    let nextPosition = writer.createPositionAfter(listItemModel);\n    // Check all children of the converted `<li>`. At this point we assume there are no \"whitespace\" view text nodes\n    // in view list, between view list items. This should be handled by `<ul>` and `<ol>` converters.\n    for (const child of viewChildren) {\n        if (child.name == 'ul' || child.name == 'ol') {\n            // If the children is a list, we will insert its conversion result after currently handled `listItem`.\n            // Then, next insertion position will be set after all the new list items (and maybe other elements if\n            // something split list item).\n            //\n            // If this is a list, we expect that some `listItem`s and possibly other blocks will be inserted, however `.modelCursor`\n            // should be set after last `listItem` (or block). This is why it feels safe to use it as `nextPosition`\n            nextPosition = conversionApi.convertItem(child, nextPosition).modelCursor;\n        }\n        else {\n            // If this is not a list, try inserting content at the end of the currently handled `listItem`.\n            const result = conversionApi.convertItem(child, writer.createPositionAt(listItemModel, 'end'));\n            // It may end up that the current `listItem` becomes split (if that content cannot be inside `listItem`). For example:\n            //\n            // <li><p>Foo</p></li>\n            //\n            // will be converted to:\n            //\n            // <listItem></listItem><paragraph>Foo</paragraph><listItem></listItem>\n            //\n            const convertedChild = result.modelRange.start.nodeAfter;\n            const wasSplit = convertedChild && convertedChild.is('element') && !schema.checkChild(listItemModel, convertedChild.name);\n            if (wasSplit) {\n                // As `lastListItem` got split, we need to update it to the second part of the split `listItem` element.\n                //\n                // `modelCursor` should be set to a position where the conversion should continue. There are multiple possible scenarios\n                // that may happen. Usually, `modelCursor` (marked as `#` below) would point to the second list item after conversion:\n                //\n                //\t\t`<li><p>Foo</p></li>` -> `<listItem></listItem><paragraph>Foo</paragraph><listItem>#</listItem>`\n                //\n                // However, in some cases, like auto-paragraphing, the position is placed at the end of the block element:\n                //\n                //\t\t`<li><div>Foo</div></li>` -> `<listItem></listItem><paragraph>Foo#</paragraph><listItem></listItem>`\n                //\n                // or after an element if another element broken auto-paragraphed element:\n                //\n                //\t\t`<li><div><h2>Foo</h2></div></li>` -> `<listItem></listItem><heading1>Foo</heading1>#<listItem></listItem>`\n                //\n                // We need to check for such cases and use proper list item and position based on it.\n                //\n                if (result.modelCursor.parent.is('element', 'listItem')) {\n                    // (1).\n                    listItemModel = result.modelCursor.parent;\n                }\n                else {\n                    // (2), (3).\n                    listItemModel = findNextListItem(result.modelCursor);\n                }\n                nextPosition = writer.createPositionAfter(listItemModel);\n            }\n        }\n    }\n    return nextPosition;\n}\n/**\n * Helper function that seeks for a next list item starting from given `startPosition`.\n */\nfunction findNextListItem(startPosition) {\n    const treeWalker = new TreeWalker({ startPosition });\n    let value;\n    do {\n        value = treeWalker.next();\n    } while (!value.value.item.is('element', 'listItem'));\n    return value.value.item;\n}\n/**\n * Helper function that takes all children of given `viewRemovedItem` and moves them in a correct place, according\n * to other given parameters.\n */\nfunction hoistNestedLists(nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model) {\n    // Find correct previous model list item element.\n    // The element has to have either same or smaller indent than given reference indent.\n    // This will be the model element which will get nested items (if it has smaller indent) or sibling items (if it has same indent).\n    // Keep in mind that such element might not be found, if removed item was the first item.\n    const prevModelItem = getSiblingListItem(modelRemoveStartPosition.nodeBefore, {\n        sameIndent: true,\n        smallerIndent: true,\n        listIndent: nextIndent\n    });\n    const mapper = conversionApi.mapper;\n    const viewWriter = conversionApi.writer;\n    // Indent of found element or `null` if the element has not been found.\n    const prevIndent = prevModelItem ? prevModelItem.getAttribute('listIndent') : null;\n    let insertPosition;\n    if (!prevModelItem) {\n        // If element has not been found, simply insert lists at the position where the removed item was:\n        //\n        // Lorem ipsum.\n        // 1 --------           <--- this is removed, no previous list item, put nested items in place of removed item.\n        //   1.1 --------       <--- this is reference indent.\n        //     1.1.1 --------\n        //     1.1.2 --------\n        //   1.2 --------\n        //\n        // Becomes:\n        //\n        // Lorem ipsum.\n        // 1.1 --------\n        //   1.1.1 --------\n        //   1.1.2 --------\n        // 1.2 --------\n        insertPosition = viewRemoveStartPosition;\n    }\n    else if (prevIndent == nextIndent) {\n        // If element has been found and has same indent as reference indent it means that nested items should\n        // become siblings of found element:\n        //\n        // 1 --------\n        //   1.1 --------\n        //   1.2 --------       <--- this is `prevModelItem`.\n        // 2 --------           <--- this is removed, previous list item has indent same as reference indent.\n        //   2.1 --------       <--- this is reference indent, this and 2.2 should become siblings of 1.2.\n        //   2.2 --------\n        //\n        // Becomes:\n        //\n        // 1 --------\n        //   1.1 --------\n        //   1.2 --------\n        //   2.1 --------\n        //   2.2 --------\n        const prevViewList = mapper.toViewElement(prevModelItem).parent;\n        insertPosition = viewWriter.createPositionAfter(prevViewList);\n    }\n    else {\n        // If element has been found and has smaller indent as reference indent it means that nested items\n        // should become nested items of found item:\n        //\n        // 1 --------           <--- this is `prevModelItem`.\n        //   1.1 --------       <--- this is removed, previous list item has indent smaller than reference indent.\n        //     1.1.1 --------   <--- this is reference indent, this and 1.1.1 should become nested items of 1.\n        //     1.1.2 --------\n        //   1.2 --------\n        //\n        // Becomes:\n        //\n        // 1 --------\n        //   1.1.1 --------\n        //   1.1.2 --------\n        //   1.2 --------\n        //\n        // Note: in this case 1.1.1 have indent 2 while 1 have indent 0. In model that should not be possible,\n        // because following item may have indent bigger only by one. But this is fixed by postfixer.\n        const modelPosition = model.createPositionAt(prevModelItem, 'end');\n        insertPosition = mapper.toViewPosition(modelPosition);\n    }\n    insertPosition = positionAfterUiElements(insertPosition);\n    // Handle multiple lists. This happens if list item has nested numbered and bulleted lists. Following lists\n    // are inserted after the first list (no need to recalculate insertion position for them).\n    for (const child of [...viewRemovedItem.getChildren()]) {\n        if (isList(child)) {\n            insertPosition = viewWriter.move(viewWriter.createRangeOn(child), insertPosition).end;\n            mergeViewLists(viewWriter, child, child.nextSibling);\n            mergeViewLists(viewWriter, child.previousSibling, child);\n        }\n    }\n}\n/**\n * Checks if view element is a list type (ul or ol).\n */\nfunction isList(viewElement) {\n    return viewElement.is('element', 'ol') || viewElement.is('element', 'ul');\n}\n/**\n * Calculates the indent value for a list item. Handles HTML compliant and non-compliant lists.\n *\n * Also, fixes non HTML compliant lists indents:\n *\n * ```\n * before:                                     fixed list:\n * OL                                          OL\n * |-> LI (parent LIs: 0)                      |-> LI     (indent: 0)\n *     |-> OL                                  |-> OL\n *         |-> OL                                  |\n *         |   |-> OL                              |\n *         |       |-> OL                          |\n *         |           |-> LI (parent LIs: 1)      |-> LI (indent: 1)\n *         |-> LI (parent LIs: 1)                  |-> LI (indent: 1)\n *\n * before:                                     fixed list:\n * OL                                          OL\n * |-> OL                                      |\n *     |-> OL                                  |\n *          |-> OL                             |\n *              |-> LI (parent LIs: 0)         |-> LI        (indent: 0)\n *\n * before:                                     fixed list:\n * OL                                          OL\n * |-> LI (parent LIs: 0)                      |-> LI         (indent: 0)\n * |-> OL                                          |-> OL\n *     |-> LI (parent LIs: 0)                          |-> LI (indent: 1)\n * ```\n */\nfunction getIndent(listItem) {\n    let indent = 0;\n    let parent = listItem.parent;\n    while (parent) {\n        // Each LI in the tree will result in an increased indent for HTML compliant lists.\n        if (parent.is('element', 'li')) {\n            indent++;\n        }\n        else {\n            // If however the list is nested in other list we should check previous sibling of any of the list elements...\n            const previousSibling = parent.previousSibling;\n            // ...because the we might need increase its indent:\n            //\t\tbefore:                           fixed list:\n            //\t\tOL                                OL\n            //\t\t|-> LI (parent LIs: 0)            |-> LI         (indent: 0)\n            //\t\t|-> OL                                |-> OL\n            //\t\t    |-> LI (parent LIs: 0)                |-> LI (indent: 1)\n            if (previousSibling && previousSibling.is('element', 'li')) {\n                indent++;\n            }\n        }\n        parent = parent.parent;\n    }\n    return indent;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/list/listediting\n */\nimport ListCommand from './listcommand';\nimport IndentCommand from './indentcommand';\nimport ListUtils from './listutils';\nimport { Plugin } from 'ckeditor5/src/core';\nimport { Enter } from 'ckeditor5/src/enter';\nimport { Delete } from 'ckeditor5/src/typing';\nimport { cleanList, cleanListItem, modelViewInsertion, modelViewChangeType, modelViewMergeAfterChangeType, modelViewMergeAfter, modelViewRemove, modelViewSplitOnInsert, modelViewChangeIndent, modelChangePostFixer, modelIndentPasteFixer, viewModelConverter, modelToViewPosition, viewToModelPosition } from './converters';\nimport '../../theme/list.css';\n/**\n * The engine of the list feature. It handles creating, editing and removing lists and list items.\n *\n * It registers the `'numberedList'`, `'bulletedList'`, `'indentList'` and `'outdentList'` commands.\n */\nexport default class ListEditing extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ListEditing';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [Enter, Delete, ListUtils];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        // Schema.\n        // Note: in case `$block` will ever be allowed in `listItem`, keep in mind that this feature\n        // uses `Selection#getSelectedBlocks()` without any additional processing to obtain all selected list items.\n        // If there are blocks allowed inside list item, algorithms using `getSelectedBlocks()` will have to be modified.\n        editor.model.schema.register('listItem', {\n            inheritAllFrom: '$block',\n            allowAttributes: ['listType', 'listIndent']\n        });\n        // Converters.\n        const data = editor.data;\n        const editing = editor.editing;\n        editor.model.document.registerPostFixer(writer => modelChangePostFixer(editor.model, writer));\n        editing.mapper.registerViewToModelLength('li', getViewListItemLength);\n        data.mapper.registerViewToModelLength('li', getViewListItemLength);\n        editing.mapper.on('modelToViewPosition', modelToViewPosition(editing.view));\n        editing.mapper.on('viewToModelPosition', viewToModelPosition(editor.model));\n        data.mapper.on('modelToViewPosition', modelToViewPosition(editing.view));\n        editor.conversion.for('editingDowncast')\n            .add(dispatcher => {\n            dispatcher.on('insert', modelViewSplitOnInsert, { priority: 'high' });\n            dispatcher.on('insert:listItem', modelViewInsertion(editor.model));\n            dispatcher.on('attribute:listType:listItem', modelViewChangeType, { priority: 'high' });\n            dispatcher.on('attribute:listType:listItem', modelViewMergeAfterChangeType, { priority: 'low' });\n            dispatcher.on('attribute:listIndent:listItem', modelViewChangeIndent(editor.model));\n            dispatcher.on('remove:listItem', modelViewRemove(editor.model));\n            dispatcher.on('remove', modelViewMergeAfter, { priority: 'low' });\n        });\n        editor.conversion.for('dataDowncast')\n            .add(dispatcher => {\n            dispatcher.on('insert', modelViewSplitOnInsert, { priority: 'high' });\n            dispatcher.on('insert:listItem', modelViewInsertion(editor.model));\n        });\n        editor.conversion.for('upcast')\n            .add(dispatcher => {\n            dispatcher.on('element:ul', cleanList, { priority: 'high' });\n            dispatcher.on('element:ol', cleanList, { priority: 'high' });\n            dispatcher.on('element:li', cleanListItem, { priority: 'high' });\n            dispatcher.on('element:li', viewModelConverter);\n        });\n        // Fix indentation of pasted items.\n        editor.model.on('insertContent', modelIndentPasteFixer, { priority: 'high' });\n        // Register commands for numbered and bulleted list.\n        editor.commands.add('numberedList', new ListCommand(editor, 'numbered'));\n        editor.commands.add('bulletedList', new ListCommand(editor, 'bulleted'));\n        // Register commands for indenting.\n        editor.commands.add('indentList', new IndentCommand(editor, 'forward'));\n        editor.commands.add('outdentList', new IndentCommand(editor, 'backward'));\n        const viewDocument = editing.view.document;\n        // Overwrite default Enter key behavior.\n        // If Enter key is pressed with selection collapsed in empty list item, outdent it instead of breaking it.\n        this.listenTo(viewDocument, 'enter', (evt, data) => {\n            const doc = this.editor.model.document;\n            const positionParent = doc.selection.getLastPosition().parent;\n            if (doc.selection.isCollapsed && positionParent.name == 'listItem' && positionParent.isEmpty) {\n                this.editor.execute('outdentList');\n                data.preventDefault();\n                evt.stop();\n            }\n        }, { context: 'li' });\n        // Overwrite default Backspace key behavior.\n        // If Backspace key is pressed with selection collapsed on first position in first list item, outdent it. #83\n        this.listenTo(viewDocument, 'delete', (evt, data) => {\n            // Check conditions from those that require less computations like those immediately available.\n            if (data.direction !== 'backward') {\n                return;\n            }\n            const selection = this.editor.model.document.selection;\n            if (!selection.isCollapsed) {\n                return;\n            }\n            const firstPosition = selection.getFirstPosition();\n            if (!firstPosition.isAtStart) {\n                return;\n            }\n            const positionParent = firstPosition.parent;\n            if (positionParent.name !== 'listItem') {\n                return;\n            }\n            const previousIsAListItem = positionParent.previousSibling && positionParent.previousSibling.name === 'listItem';\n            if (previousIsAListItem) {\n                return;\n            }\n            this.editor.execute('outdentList');\n            data.preventDefault();\n            evt.stop();\n        }, { context: 'li' });\n        this.listenTo(editor.editing.view.document, 'tab', (evt, data) => {\n            const commandName = data.shiftKey ? 'outdentList' : 'indentList';\n            const command = this.editor.commands.get(commandName);\n            if (command.isEnabled) {\n                editor.execute(commandName);\n                data.stopPropagation();\n                data.preventDefault();\n                evt.stop();\n            }\n        }, { context: 'li' });\n    }\n    /**\n     * @inheritDoc\n     */\n    afterInit() {\n        const commands = this.editor.commands;\n        const indent = commands.get('indent');\n        const outdent = commands.get('outdent');\n        if (indent) {\n            indent.registerChildCommand(commands.get('indentList'));\n        }\n        if (outdent) {\n            outdent.registerChildCommand(commands.get('outdentList'));\n        }\n    }\n}\nfunction getViewListItemLength(element) {\n    let length = 1;\n    for (const child of element.getChildren()) {\n        if (child.name == 'ul' || child.name == 'ol') {\n            for (const item of child.getChildren()) {\n                length += getViewListItemLength(item);\n            }\n        }\n    }\n    return length;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/list\n */\nimport ListEditing from './list/listediting';\nimport ListUI from './list/listui';\nimport { Plugin } from 'ckeditor5/src/core';\n/**\n * The list feature.\n *\n * This is a \"glue\" plugin that loads the {@link module:list/list/listediting~ListEditing list editing feature}\n * and {@link module:list/list/listui~ListUI list UI feature}.\n */\nexport default class List extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ListEditing, ListUI];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'List';\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/listproperties/liststylecommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { getListTypeFromListStyleType, getSelectedListItems } from '../list/utils';\n/**\n * The list style command. It changes the `listStyle` attribute of the selected list items.\n *\n * If the list type (numbered or bulleted) can be inferred from the passed style type,\n * the command tries to convert selected items to a list of that type.\n * It is used by the {@link module:list/listproperties~ListProperties list properties feature}.\n */\nexport default class ListStyleCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param editor The editor instance.\n     * @param defaultType The list type that will be used by default if the value was not specified during\n     * the command execution.\n     */\n    constructor(editor, defaultType) {\n        super(editor);\n        this.defaultType = defaultType;\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        this.value = this._getValue();\n        this.isEnabled = this._checkEnabled();\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param options.type The type of the list style, e.g. `'disc'` or `'square'`. If `null` is specified, the default\n     * style will be applied.\n     */\n    execute(options = {}) {\n        this._tryToConvertItemsToList(options);\n        const model = this.editor.model;\n        const listItems = getSelectedListItems(model);\n        if (!listItems.length) {\n            return;\n        }\n        model.change(writer => {\n            for (const item of listItems) {\n                writer.setAttribute('listStyle', options.type || this.defaultType, item);\n            }\n        });\n    }\n    /**\n     * Checks the command's {@link #value}.\n     *\n     * @returns The current value.\n     */\n    _getValue() {\n        const listItem = this.editor.model.document.selection.getFirstPosition().parent;\n        if (listItem && listItem.is('element', 'listItem')) {\n            return listItem.getAttribute('listStyle');\n        }\n        return null;\n    }\n    /**\n     * Checks whether the command can be enabled in the current context.\n     *\n     * @returns Whether the command should be enabled.\n     */\n    _checkEnabled() {\n        const editor = this.editor;\n        const numberedList = editor.commands.get('numberedList');\n        const bulletedList = editor.commands.get('bulletedList');\n        return numberedList.isEnabled || bulletedList.isEnabled;\n    }\n    /**\n     * Checks if the provided list style is valid. Also changes the selection to a list if it's not set yet.\n     *\n     * @param The type of the list style. If `null` is specified, the function does nothing.\n    */\n    _tryToConvertItemsToList(options) {\n        if (!options.type) {\n            return;\n        }\n        const listType = getListTypeFromListStyleType(options.type);\n        if (!listType) {\n            return;\n        }\n        const editor = this.editor;\n        const commandName = `${listType}List`;\n        const command = editor.commands.get(commandName);\n        if (!command.value) {\n            editor.execute(commandName);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/listproperties/listreversedcommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { getSelectedListItems } from '../list/utils';\n/**\n * The reversed list command. It changes the `listReversed` attribute of the selected list items. As a result, the list order will be\n * reversed.\n * It is used by the {@link module:list/listproperties~ListProperties list properties feature}.\n */\nexport default class ListReversedCommand extends Command {\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        const value = this._getValue();\n        this.value = value;\n        this.isEnabled = value != null;\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param options.reversed Whether the list should be reversed.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const listItems = getSelectedListItems(model)\n            .filter(item => item.getAttribute('listType') == 'numbered');\n        model.change(writer => {\n            for (const item of listItems) {\n                writer.setAttribute('listReversed', !!options.reversed, item);\n            }\n        });\n    }\n    /**\n     * Checks the command's {@link #value}.\n     *\n     * @returns The current value.\n     */\n    _getValue() {\n        const listItem = this.editor.model.document.selection.getFirstPosition().parent;\n        if (listItem && listItem.is('element', 'listItem') && listItem.getAttribute('listType') == 'numbered') {\n            return listItem.getAttribute('listReversed');\n        }\n        return null;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/listproperties/liststartcommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport { getSelectedListItems } from '../list/utils';\n/**\n * The list start index command. It changes the `listStart` attribute of the selected list items.\n * It is used by the {@link module:list/listproperties~ListProperties list properties feature}.\n */\nexport default class ListStartCommand extends Command {\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        const value = this._getValue();\n        this.value = value;\n        this.isEnabled = value != null;\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param options.startIndex The list start index.\n     */\n    execute({ startIndex = 1 } = {}) {\n        const model = this.editor.model;\n        const listItems = getSelectedListItems(model)\n            .filter(item => item.getAttribute('listType') == 'numbered');\n        model.change(writer => {\n            for (const item of listItems) {\n                writer.setAttribute('listStart', startIndex >= 0 ? startIndex : 1, item);\n            }\n        });\n    }\n    /**\n     * Checks the command's {@link #value}.\n     *\n     * @returns The current value.\n     */\n    _getValue() {\n        const listItem = this.editor.model.document.selection.getFirstPosition().parent;\n        if (listItem && listItem.is('element', 'listItem') && listItem.getAttribute('listType') == 'numbered') {\n            return listItem.getAttribute('listStart');\n        }\n        return null;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/listproperties/listpropertiesediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport ListEditing from '../list/listediting';\nimport ListStyleCommand from './liststylecommand';\nimport ListReversedCommand from './listreversedcommand';\nimport ListStartCommand from './liststartcommand';\nimport { getSiblingListItem, getSiblingNodes } from '../list/utils';\nconst DEFAULT_LIST_TYPE = 'default';\n/**\n * The engine of the list properties feature.\n *\n * It sets the value for the `listItem` attribute of the {@link module:list/list~List `<listItem>`} element that\n * allows modifying the list style type.\n *\n * It registers the `'listStyle'`, `'listReversed'` and `'listStart'` commands if they are enabled in the configuration.\n * Read more in {@link module:list/listconfig~ListPropertiesConfig}.\n */\nexport default class ListPropertiesEditing extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ListEditing];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ListPropertiesEditing';\n    }\n    /**\n     * @inheritDoc\n     */\n    constructor(editor) {\n        super(editor);\n        editor.config.define('list', {\n            properties: {\n                styles: true,\n                startIndex: false,\n                reversed: false\n            }\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const model = editor.model;\n        const enabledProperties = editor.config.get('list.properties');\n        const strategies = createAttributeStrategies(enabledProperties);\n        // Extend schema.\n        model.schema.extend('listItem', {\n            allowAttributes: strategies.map(s => s.attributeName)\n        });\n        for (const strategy of strategies) {\n            strategy.addCommand(editor);\n        }\n        // Fix list attributes when modifying their nesting levels (the `listIndent` attribute).\n        this.listenTo(editor.commands.get('indentList'), '_executeCleanup', fixListAfterIndentListCommand(editor, strategies));\n        this.listenTo(editor.commands.get('outdentList'), '_executeCleanup', fixListAfterOutdentListCommand(editor, strategies));\n        this.listenTo(editor.commands.get('bulletedList'), '_executeCleanup', restoreDefaultListStyle(editor));\n        this.listenTo(editor.commands.get('numberedList'), '_executeCleanup', restoreDefaultListStyle(editor));\n        // Register a post-fixer that ensures that the attributes is specified in each `listItem` element.\n        model.document.registerPostFixer(fixListAttributesOnListItemElements(editor, strategies));\n        // Set up conversion.\n        editor.conversion.for('upcast').add(upcastListItemAttributes(strategies));\n        editor.conversion.for('downcast').add(downcastListItemAttributes(strategies));\n        // Handle merging two separated lists into the single one.\n        this._mergeListAttributesWhileMergingLists(strategies);\n    }\n    /**\n     * @inheritDoc\n     */\n    afterInit() {\n        const editor = this.editor;\n        // Enable post-fixer that removes the attributes from to-do list items only if the \"TodoList\" plugin is on.\n        // We need to registry the hook here since the `TodoList` plugin can be added after the `ListPropertiesEditing`.\n        if (editor.commands.get('todoList')) {\n            editor.model.document.registerPostFixer(removeListItemAttributesFromTodoList(editor));\n        }\n    }\n    /**\n     * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether two lists will be merged into a single\n     * one after deleting the content.\n     *\n     * The purpose of this action is to adjust the `listStyle`, `listReversed` and `listStart` values\n     * for the list that was merged.\n     *\n     * Consider the following model's content:\n     *\n     * ```xml\n     * <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n     * <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n     * <paragraph>[A paragraph.]</paragraph>\n     * <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">UL List item 1</listItem>\n     * <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">UL List item 2</listItem>\n     * ```\n     *\n     * After removing the paragraph element, the second list will be merged into the first one.\n     * We want to inherit the `listStyle` attribute for the second list from the first one.\n     *\n     * ```xml\n     * <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n     * <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n     * <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n     * <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n     * ```\n     *\n     * See https://github.com/ckeditor/ckeditor5/issues/7879.\n     *\n     * @param attributeStrategies Strategies for the enabled attributes.\n     */\n    _mergeListAttributesWhileMergingLists(attributeStrategies) {\n        const editor = this.editor;\n        const model = editor.model;\n        // First the outer-most`listItem` in the first list reference.\n        // If found, the lists should be merged and this `listItem` provides the attributes\n        // and it is also a starting point when searching for items in the second list.\n        let firstMostOuterItem;\n        // Check whether the removed content is between two lists.\n        this.listenTo(model, 'deleteContent', (evt, [selection]) => {\n            const firstPosition = selection.getFirstPosition();\n            const lastPosition = selection.getLastPosition();\n            // Typing or removing content in a single item. Aborting.\n            if (firstPosition.parent === lastPosition.parent) {\n                return;\n            }\n            // An element before the content that will be removed is not a list.\n            if (!firstPosition.parent.is('element', 'listItem')) {\n                return;\n            }\n            const nextSibling = lastPosition.parent.nextSibling;\n            // An element after the content that will be removed is not a list.\n            if (!nextSibling || !nextSibling.is('element', 'listItem')) {\n                return;\n            }\n            // Find the outermost list item based on the `listIndent` attribute. We can't assume that `listIndent=0`\n            // because the selection can be hooked in nested lists.\n            //\n            // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n            // <listItem listIndent=\"1\" listType=\"bulleted\" listStyle=\"square\">UL List [item 1.1</listItem>\n            // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">[]UL List item 1.</listItem>\n            // <listItem listIndent=\"1\" listType=\"bulleted\" listStyle=\"circle\">UL List ]item 1.1</listItem>\n            //\n            // After deleting the content, we would like to inherit the \"square\" attribute for the last element:\n            //\n            // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n            // <listItem listIndent=\"1\" listType=\"bulleted\" listStyle=\"square\">UL List []item 1.1</listItem>\n            const mostOuterItemList = getSiblingListItem(firstPosition.parent, {\n                sameIndent: true,\n                listIndent: nextSibling.getAttribute('listIndent')\n            });\n            // The outermost list item may not exist while removing elements between lists with different value\n            // of the `listIndent` attribute. In such a case we don't want to update anything. See: #8073.\n            if (!mostOuterItemList) {\n                return;\n            }\n            if (mostOuterItemList.getAttribute('listType') === nextSibling.getAttribute('listType')) {\n                firstMostOuterItem = mostOuterItemList;\n            }\n        }, { priority: 'high' });\n        // If so, update the `listStyle` attribute for the second list.\n        this.listenTo(model, 'deleteContent', () => {\n            if (!firstMostOuterItem) {\n                return;\n            }\n            model.change(writer => {\n                // Find the first most-outer item list in the merged list.\n                // A case when the first list item in the second list was merged into the last item in the first list.\n                //\n                // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n                // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n                // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">[]UL List item 1</listItem>\n                // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">UL List item 2</listItem>\n                const secondListMostOuterItem = getSiblingListItem(firstMostOuterItem.nextSibling, {\n                    sameIndent: true,\n                    listIndent: firstMostOuterItem.getAttribute('listIndent'),\n                    direction: 'forward'\n                });\n                // If the selection ends in a non-list element, there are no <listItem>s that would require adjustments.\n                // See: #8642.\n                if (!secondListMostOuterItem) {\n                    firstMostOuterItem = null;\n                    return;\n                }\n                const items = [\n                    secondListMostOuterItem,\n                    ...getSiblingNodes(writer.createPositionAt(secondListMostOuterItem, 0), 'forward')\n                ];\n                for (const listItem of items) {\n                    for (const strategy of attributeStrategies) {\n                        if (strategy.appliesToListItem(listItem)) {\n                            const attributeName = strategy.attributeName;\n                            const value = firstMostOuterItem.getAttribute(attributeName);\n                            writer.setAttribute(attributeName, value, listItem);\n                        }\n                    }\n                }\n            });\n            firstMostOuterItem = null;\n        }, { priority: 'low' });\n    }\n}\n/**\n * Creates an array of strategies for dealing with enabled listItem attributes.\n */\nfunction createAttributeStrategies(enabledProperties) {\n    const strategies = [];\n    if (enabledProperties.styles) {\n        strategies.push({\n            attributeName: 'listStyle',\n            defaultValue: DEFAULT_LIST_TYPE,\n            addCommand(editor) {\n                editor.commands.add('listStyle', new ListStyleCommand(editor, DEFAULT_LIST_TYPE));\n            },\n            appliesToListItem() {\n                return true;\n            },\n            setAttributeOnDowncast(writer, listStyle, element) {\n                if (listStyle && listStyle !== DEFAULT_LIST_TYPE) {\n                    writer.setStyle('list-style-type', listStyle, element);\n                }\n                else {\n                    writer.removeStyle('list-style-type', element);\n                }\n            },\n            getAttributeOnUpcast(listParent) {\n                return listParent.getStyle('list-style-type') || DEFAULT_LIST_TYPE;\n            }\n        });\n    }\n    if (enabledProperties.reversed) {\n        strategies.push({\n            attributeName: 'listReversed',\n            defaultValue: false,\n            addCommand(editor) {\n                editor.commands.add('listReversed', new ListReversedCommand(editor));\n            },\n            appliesToListItem(item) {\n                return item.getAttribute('listType') == 'numbered';\n            },\n            setAttributeOnDowncast(writer, listReversed, element) {\n                if (listReversed) {\n                    writer.setAttribute('reversed', 'reversed', element);\n                }\n                else {\n                    writer.removeAttribute('reversed', element);\n                }\n            },\n            getAttributeOnUpcast(listParent) {\n                return listParent.hasAttribute('reversed');\n            }\n        });\n    }\n    if (enabledProperties.startIndex) {\n        strategies.push({\n            attributeName: 'listStart',\n            defaultValue: 1,\n            addCommand(editor) {\n                editor.commands.add('listStart', new ListStartCommand(editor));\n            },\n            appliesToListItem(item) {\n                return item.getAttribute('listType') == 'numbered';\n            },\n            setAttributeOnDowncast(writer, listStart, element) {\n                if (listStart == 0 || listStart > 1) {\n                    writer.setAttribute('start', listStart, element);\n                }\n                else {\n                    writer.removeAttribute('start', element);\n                }\n            },\n            getAttributeOnUpcast(listParent) {\n                const startAttributeValue = listParent.getAttribute('start');\n                return startAttributeValue >= 0 ? startAttributeValue : 1;\n            }\n        });\n    }\n    return strategies;\n}\n/**\n * Returns a converter consumes the `style`, `reversed` and `start` attribute.\n * In `style` it searches for the `list-style-type` definition.\n * If not found, the `\"default\"` value will be used.\n */\nfunction upcastListItemAttributes(attributeStrategies) {\n    return (dispatcher) => {\n        dispatcher.on('element:li', (evt, data, conversionApi) => {\n            // https://github.com/ckeditor/ckeditor5/issues/13858\n            if (!data.modelRange) {\n                return;\n            }\n            const listParent = data.viewItem.parent;\n            const listItem = data.modelRange.start.nodeAfter || data.modelRange.end.nodeBefore;\n            for (const strategy of attributeStrategies) {\n                if (strategy.appliesToListItem(listItem)) {\n                    const listStyle = strategy.getAttributeOnUpcast(listParent);\n                    conversionApi.writer.setAttribute(strategy.attributeName, listStyle, listItem);\n                }\n            }\n        }, { priority: 'low' });\n    };\n}\n/**\n * Returns a converter that adds `reversed`, `start` attributes and adds `list-style-type` definition as a value for the `style` attribute.\n * The `\"default\"` values are removed and not present in the view/data.\n */\nfunction downcastListItemAttributes(attributeStrategies) {\n    return (dispatcher) => {\n        for (const strategy of attributeStrategies) {\n            dispatcher.on(`attribute:${strategy.attributeName}:listItem`, (evt, data, conversionApi) => {\n                const viewWriter = conversionApi.writer;\n                const currentElement = data.item;\n                const previousElement = getSiblingListItem(currentElement.previousSibling, {\n                    sameIndent: true,\n                    listIndent: currentElement.getAttribute('listIndent'),\n                    direction: 'backward'\n                });\n                const viewItem = conversionApi.mapper.toViewElement(currentElement);\n                // A case when elements represent different lists. We need to separate their container.\n                if (!areRepresentingSameList(currentElement, previousElement)) {\n                    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n                }\n                strategy.setAttributeOnDowncast(viewWriter, data.attributeNewValue, viewItem.parent);\n            }, { priority: 'low' });\n        }\n    };\n    /**\n     * Checks whether specified list items belong to the same list.\n     */\n    function areRepresentingSameList(listItem1, listItem2) {\n        return listItem2 &&\n            listItem1.getAttribute('listType') === listItem2.getAttribute('listType') &&\n            listItem1.getAttribute('listIndent') === listItem2.getAttribute('listIndent') &&\n            listItem1.getAttribute('listStyle') === listItem2.getAttribute('listStyle') &&\n            listItem1.getAttribute('listReversed') === listItem2.getAttribute('listReversed') &&\n            listItem1.getAttribute('listStart') === listItem2.getAttribute('listStart');\n    }\n}\n/**\n * When indenting list, nested list should clear its value for the attributes or inherit from nested lists.\n *\n * ■ List item 1.\n * ■ List item 2.[]\n * ■ List item 3.\n * editor.execute( 'indentList' );\n *\n * ■ List item 1.\n *     ○ List item 2.[]\n * ■ List item 3.\n */\nfunction fixListAfterIndentListCommand(editor, attributeStrategies) {\n    return (evt, changedItems) => {\n        const root = changedItems[0];\n        const rootIndent = root.getAttribute('listIndent');\n        const itemsToUpdate = changedItems.filter(item => item.getAttribute('listIndent') === rootIndent);\n        // A case where a few list items are indented must be checked separately\n        // since `getSiblingListItem()` returns the first changed element.\n        // ■ List item 1.\n        //     ○ [List item 2.\n        //     ○ List item 3.]\n        // ■ List item 4.\n        //\n        // List items: `2` and `3` should be adjusted.\n        let previousSibling = null;\n        if (root.previousSibling.getAttribute('listIndent') + 1 !== rootIndent) {\n            previousSibling = getSiblingListItem(root.previousSibling, {\n                sameIndent: true, direction: 'backward', listIndent: rootIndent\n            });\n        }\n        editor.model.change(writer => {\n            for (const item of itemsToUpdate) {\n                for (const strategy of attributeStrategies) {\n                    if (strategy.appliesToListItem(item)) {\n                        const valueToSet = previousSibling == null ?\n                            strategy.defaultValue :\n                            previousSibling.getAttribute(strategy.attributeName);\n                        writer.setAttribute(strategy.attributeName, valueToSet, item);\n                    }\n                }\n            }\n        });\n    };\n}\n/**\n * When outdenting a list, a nested list should copy attribute values\n * from the previous sibling list item including the same value for the `listIndent` value.\n *\n * ■ List item 1.\n *     ○ List item 2.[]\n * ■ List item 3.\n *\n * editor.execute( 'outdentList' );\n *\n * ■ List item 1.\n * ■ List item 2.[]\n * ■ List item 3.\n */\nfunction fixListAfterOutdentListCommand(editor, attributeStrategies) {\n    return (evt, changedItems) => {\n        changedItems = changedItems.reverse().filter(item => item.is('element', 'listItem'));\n        if (!changedItems.length) {\n            return;\n        }\n        const indent = changedItems[0].getAttribute('listIndent');\n        const listType = changedItems[0].getAttribute('listType');\n        let listItem = changedItems[0].previousSibling;\n        // ■ List item 1.\n        //     ○ List item 2.\n        //     ○ List item 3.[]\n        // ■ List item 4.\n        //\n        // After outdenting a list, `List item 3` should inherit the `listStyle` attribute from `List item 1`.\n        //\n        // ■ List item 1.\n        //     ○ List item 2.\n        // ■ List item 3.[]\n        // ■ List item 4.\n        if (listItem.is('element', 'listItem')) {\n            while (listItem.getAttribute('listIndent') !== indent) {\n                listItem = listItem.previousSibling;\n            }\n        }\n        else {\n            listItem = null;\n        }\n        // Outdenting such a list should restore values based on `List item 4`.\n        // ■ List item 1.[]\n        //     ○ List item 2.\n        //     ○ List item 3.\n        // ■ List item 4.\n        if (!listItem) {\n            listItem = changedItems[changedItems.length - 1].nextSibling;\n        }\n        // And such a list should not modify anything.\n        // However, `listItem` can indicate a node below the list. Be sure that we have the `listItem` element.\n        // ■ List item 1.[]\n        //     ○ List item 2.\n        //     ○ List item 3.\n        // <paragraph>The later if check.</paragraph>\n        if (!listItem || !listItem.is('element', 'listItem')) {\n            return;\n        }\n        // Do not modify the list if found `listItem` represents other type of list than outdented list items.\n        if (listItem.getAttribute('listType') !== listType) {\n            return;\n        }\n        editor.model.change(writer => {\n            const itemsToUpdate = changedItems.filter(item => item.getAttribute('listIndent') === indent);\n            for (const item of itemsToUpdate) {\n                for (const strategy of attributeStrategies) {\n                    if (strategy.appliesToListItem(item)) {\n                        const attributeName = strategy.attributeName;\n                        const valueToSet = listItem.getAttribute(attributeName);\n                        writer.setAttribute(attributeName, valueToSet, item);\n                    }\n                }\n            }\n        });\n    };\n}\n/**\n * Each `listItem` element must have specified the `listStyle`, `listReversed` and `listStart` attributes\n * if they are enabled and supported by its `listType`.\n * This post-fixer checks whether inserted elements `listItem` elements should inherit the attribute values from\n * their sibling nodes or should use the default values.\n *\n * Paragraph[]\n * ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n * ■ List item 2. // ...\n * ■ List item 3. // ...\n *\n * editor.execute( 'bulletedList' )\n *\n * ■ Paragraph[]  // [listStyle=\"square\", listType=\"bulleted\"]\n * ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n * ■ List item 2.\n * ■ List item 3.\n *\n * It also covers a such change:\n *\n * [Paragraph 1\n * Paragraph 2]\n * ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n * ■ List item 2. // ...\n * ■ List item 3. // ...\n *\n * editor.execute( 'numberedList' )\n *\n * 1. [Paragraph 1 // [listStyle=\"default\", listType=\"numbered\"]\n * 2. Paragraph 2] // [listStyle=\"default\", listType=\"numbered\"]\n * ■ List item 1.  // [listStyle=\"square\", listType=\"bulleted\"]\n * ■ List item 2.  // ...\n * ■ List item 3.  // ...\n */\nfunction fixListAttributesOnListItemElements(editor, attributeStrategies) {\n    return (writer) => {\n        let wasFixed = false;\n        const insertedListItems = getChangedListItems(editor.model.document.differ.getChanges())\n            .filter(item => {\n            // Don't touch todo lists. They are handled in another post-fixer.\n            return item.getAttribute('listType') !== 'todo';\n        });\n        if (!insertedListItems.length) {\n            return wasFixed;\n        }\n        // Check whether the last inserted element is next to the `listItem` element.\n        //\n        // ■ Paragraph[]  // <-- The inserted item.\n        // ■ List item 1.\n        let existingListItem = insertedListItems[insertedListItems.length - 1].nextSibling;\n        // If it doesn't, maybe the `listItem` was inserted at the end of the list.\n        //\n        // ■ List item 1.\n        // ■ Paragraph[]  // <-- The inserted item.\n        if (!existingListItem || !existingListItem.is('element', 'listItem')) {\n            existingListItem = insertedListItems[0].previousSibling;\n            if (existingListItem) {\n                const indent = insertedListItems[0].getAttribute('listIndent');\n                // But we need to find a `listItem` with the `listIndent=0` attribute.\n                // If doesn't, maybe the `listItem` was inserted at the end of the list.\n                //\n                // ■ List item 1.\n                //     ○ List item 2.\n                // ■ Paragraph[]  // <-- The inserted item.\n                while (existingListItem.is('element', 'listItem') && existingListItem.getAttribute('listIndent') !== indent) {\n                    existingListItem = existingListItem.previousSibling;\n                    // If the item does not exist, most probably there is no other content in the editor. See: #8072.\n                    if (!existingListItem) {\n                        break;\n                    }\n                }\n            }\n        }\n        for (const strategy of attributeStrategies) {\n            const attributeName = strategy.attributeName;\n            for (const item of insertedListItems) {\n                if (!strategy.appliesToListItem(item)) {\n                    writer.removeAttribute(attributeName, item);\n                    continue;\n                }\n                if (!item.hasAttribute(attributeName)) {\n                    if (shouldInheritListType(existingListItem, item, strategy)) {\n                        writer.setAttribute(attributeName, existingListItem.getAttribute(attributeName), item);\n                    }\n                    else {\n                        writer.setAttribute(attributeName, strategy.defaultValue, item);\n                    }\n                    wasFixed = true;\n                }\n                else {\n                    // Adjust the `listStyle`, `listReversed` and `listStart`\n                    // attributes for inserted (pasted) items. See #8160.\n                    //\n                    // ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n                    //     ○ List item 1.1. // [listStyle=\"circle\", listType=\"bulleted\"]\n                    //     ○ [] (selection is here)\n                    //\n                    // Then, pasting a list with different attributes (listStyle, listType):\n                    //\n                    // 1. First. // [listStyle=\"decimal\", listType=\"numbered\"]\n                    // 2. Second // [listStyle=\"decimal\", listType=\"numbered\"]\n                    //\n                    // The `listType` attribute will be corrected by the `ListEditing` converters.\n                    // We need to adjust the `listStyle` attribute. Expected structure:\n                    //\n                    // ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n                    //     ○ List item 1.1. // [listStyle=\"circle\", listType=\"bulleted\"]\n                    //     ○ First. // [listStyle=\"circle\", listType=\"bulleted\"]\n                    //     ○ Second // [listStyle=\"circle\", listType=\"bulleted\"]\n                    const previousSibling = item.previousSibling;\n                    if (shouldInheritListTypeFromPreviousItem(previousSibling, item, strategy.attributeName)) {\n                        writer.setAttribute(attributeName, previousSibling.getAttribute(attributeName), item);\n                        wasFixed = true;\n                    }\n                }\n            }\n        }\n        return wasFixed;\n    };\n}\n/**\n * Checks whether the `listStyle`, `listReversed` and `listStart` attributes\n * should be copied from the `baseItem` element.\n *\n * The attribute should be copied if the inserted element does not have defined it and\n * the value for the element is other than default in the base element.\n */\nfunction shouldInheritListType(baseItem, itemToChange, attributeStrategy) {\n    if (!baseItem) {\n        return false;\n    }\n    const baseListAttribute = baseItem.getAttribute(attributeStrategy.attributeName);\n    if (!baseListAttribute) {\n        return false;\n    }\n    if (baseListAttribute == attributeStrategy.defaultValue) {\n        return false;\n    }\n    if (baseItem.getAttribute('listType') !== itemToChange.getAttribute('listType')) {\n        return false;\n    }\n    return true;\n}\n/**\n * Checks whether the `listStyle`, `listReversed` and `listStart` attributes\n * should be copied from previous list item.\n *\n * The attribute should be copied if there's a mismatch of styles of the pasted list into a nested list.\n * Top-level lists are not normalized as we allow side-by-side list of different types.\n */\nfunction shouldInheritListTypeFromPreviousItem(previousItem, itemToChange, attributeName) {\n    if (!previousItem || !previousItem.is('element', 'listItem')) {\n        return false;\n    }\n    if (itemToChange.getAttribute('listType') !== previousItem.getAttribute('listType')) {\n        return false;\n    }\n    const previousItemIndent = previousItem.getAttribute('listIndent');\n    if (previousItemIndent < 1 || previousItemIndent !== itemToChange.getAttribute('listIndent')) {\n        return false;\n    }\n    const previousItemListAttribute = previousItem.getAttribute(attributeName);\n    if (!previousItemListAttribute || previousItemListAttribute === itemToChange.getAttribute(attributeName)) {\n        return false;\n    }\n    return true;\n}\n/**\n * Removes the `listStyle`, `listReversed` and `listStart` attributes from \"todo\" list items.\n */\nfunction removeListItemAttributesFromTodoList(editor) {\n    return (writer) => {\n        const todoListItems = getChangedListItems(editor.model.document.differ.getChanges())\n            .filter(item => {\n            // Handle the todo lists only. The rest is handled in another post-fixer.\n            return item.getAttribute('listType') === 'todo' && (item.hasAttribute('listStyle') ||\n                item.hasAttribute('listReversed') ||\n                item.hasAttribute('listStart'));\n        });\n        if (!todoListItems.length) {\n            return false;\n        }\n        for (const item of todoListItems) {\n            writer.removeAttribute('listStyle', item);\n            writer.removeAttribute('listReversed', item);\n            writer.removeAttribute('listStart', item);\n        }\n        return true;\n    };\n}\n/**\n * Restores the `listStyle` attribute after changing the list type.\n */\nfunction restoreDefaultListStyle(editor) {\n    return (evt, changedItems) => {\n        changedItems = changedItems.filter(item => item.is('element', 'listItem'));\n        editor.model.change(writer => {\n            for (const item of changedItems) {\n                // Remove the attribute. Post-fixer will restore the proper value.\n                writer.removeAttribute('listStyle', item);\n            }\n        });\n    };\n}\n/**\n * Returns the `listItem` that was inserted or changed.\n *\n * @param changes The changes list returned by the differ.\n */\nfunction getChangedListItems(changes) {\n    const items = [];\n    for (const change of changes) {\n        const item = getItemFromChange(change);\n        if (item && item.is('element', 'listItem')) {\n            items.push(item);\n        }\n    }\n    return items;\n}\nfunction getItemFromChange(change) {\n    if (change.type === 'attribute') {\n        return change.range.start.nodeAfter;\n    }\n    if (change.type === 'insert') {\n        return change.position.nodeAfter;\n    }\n    return null;\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/listproperties\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport ListPropertiesEditing from './listproperties/listpropertiesediting';\nimport ListPropertiesUI from './listproperties/listpropertiesui';\n/**\n * The list properties feature.\n *\n * This is a \"glue\" plugin that loads the {@link module:list/listproperties/listpropertiesediting~ListPropertiesEditing list properties\n * editing feature} and the {@link module:list/listproperties/listpropertiesui~ListPropertiesUI list properties UI feature}.\n */\nexport default class ListProperties extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ListPropertiesEditing, ListPropertiesUI];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ListProperties';\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/todolist/checktodolistcommand\n */\nimport { Command } from 'ckeditor5/src/core';\nconst attributeKey = 'todoListChecked';\n/**\n * The check to-do command.\n *\n * The command is registered by the {@link module:list/todolist/todolistediting~TodoListEditing} as\n * the `checkTodoList` editor command and it is also available via aliased `todoListCheck` name.\n */\nexport default class CheckTodoListCommand extends Command {\n    /**\n     * @inheritDoc\n     */\n    constructor(editor) {\n        super(editor);\n        this._selectedElements = [];\n        // Refresh command before executing to be sure all values are up to date.\n        // It is needed when selection has changed before command execution, in the same change block.\n        this.on('execute', () => {\n            this.refresh();\n        }, { priority: 'highest' });\n    }\n    /**\n     * Updates the command's {@link #value} and {@link #isEnabled} properties based on the current selection.\n     */\n    refresh() {\n        this._selectedElements = this._getSelectedItems();\n        this.value = this._selectedElements.every(element => !!element.getAttribute(attributeKey));\n        this.isEnabled = !!this._selectedElements.length;\n    }\n    /**\n     * Gets all to-do list items selected by the {@link module:engine/model/selection~Selection}.\n     */\n    _getSelectedItems() {\n        const model = this.editor.model;\n        const schema = model.schema;\n        const selectionRange = model.document.selection.getFirstRange();\n        const startElement = selectionRange.start.parent;\n        const elements = [];\n        if (schema.checkAttribute(startElement, attributeKey)) {\n            elements.push(startElement);\n        }\n        for (const item of selectionRange.getItems()) {\n            if (schema.checkAttribute(item, attributeKey) && !elements.includes(item)) {\n                elements.push(item);\n            }\n        }\n        return elements;\n    }\n    /**\n     * Executes the command.\n     *\n     * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply\n     * the attribute. Otherwise, the command will remove the attribute. If not set, the command will look for its current\n     * value to decide what it should do.\n     */\n    execute(options = {}) {\n        this.editor.model.change(writer => {\n            for (const element of this._selectedElements) {\n                const value = (options.forceValue === undefined) ? !this.value : options.forceValue;\n                if (value) {\n                    writer.setAttribute(attributeKey, true, element);\n                }\n                else {\n                    writer.removeAttribute(attributeKey, element);\n                }\n            }\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { createElement } from 'ckeditor5/src/utils';\nimport { generateLiInUl, injectViewList, positionAfterUiElements, findNestedList } from '../list/utils';\n/**\n * A model-to-view converter for the `listItem` model element insertion.\n *\n * It converts the `listItem` model element to an unordered list with a {@link module:engine/view/uielement~UIElement checkbox element}\n * at the beginning of each list item. It also merges the list with surrounding lists (if available).\n *\n * It is used by {@link module:engine/controller/editingcontroller~EditingController}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param model Model instance.\n * @param onCheckboxChecked Callback function.\n * @returns Returns a conversion callback.\n */\nexport function modelViewInsertion(model, onCheckboxChecked) {\n    return (evt, data, conversionApi) => {\n        const consumable = conversionApi.consumable;\n        if (!consumable.test(data.item, 'insert') ||\n            !consumable.test(data.item, 'attribute:listType') ||\n            !consumable.test(data.item, 'attribute:listIndent')) {\n            return;\n        }\n        if (data.item.getAttribute('listType') != 'todo') {\n            return;\n        }\n        const modelItem = data.item;\n        consumable.consume(modelItem, 'insert');\n        consumable.consume(modelItem, 'attribute:listType');\n        consumable.consume(modelItem, 'attribute:listIndent');\n        consumable.consume(modelItem, 'attribute:todoListChecked');\n        const viewWriter = conversionApi.writer;\n        const viewItem = generateLiInUl(modelItem, conversionApi);\n        const isChecked = !!modelItem.getAttribute('todoListChecked');\n        const checkmarkElement = createCheckmarkElement(modelItem, viewWriter, isChecked, onCheckboxChecked);\n        const span = viewWriter.createContainerElement('span', {\n            class: 'todo-list__label__description'\n        });\n        viewWriter.addClass('todo-list', viewItem.parent);\n        viewWriter.insert(viewWriter.createPositionAt(viewItem, 0), checkmarkElement);\n        viewWriter.insert(viewWriter.createPositionAfter(checkmarkElement), span);\n        injectViewList(modelItem, viewItem, conversionApi, model);\n    };\n}\n/**\n * A model-to-view converter for the `listItem` model element insertion.\n *\n * It is used by {@link module:engine/controller/datacontroller~DataController}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param model Model instance.\n * @returns Returns a conversion callback.\n */\nexport function dataModelViewInsertion(model) {\n    return (evt, data, conversionApi) => {\n        const consumable = conversionApi.consumable;\n        if (!consumable.test(data.item, 'insert') ||\n            !consumable.test(data.item, 'attribute:listType') ||\n            !consumable.test(data.item, 'attribute:listIndent')) {\n            return;\n        }\n        if (data.item.getAttribute('listType') != 'todo') {\n            return;\n        }\n        const modelItem = data.item;\n        consumable.consume(modelItem, 'insert');\n        consumable.consume(modelItem, 'attribute:listType');\n        consumable.consume(modelItem, 'attribute:listIndent');\n        consumable.consume(modelItem, 'attribute:todoListChecked');\n        const viewWriter = conversionApi.writer;\n        const viewItem = generateLiInUl(modelItem, conversionApi);\n        viewWriter.addClass('todo-list', viewItem.parent);\n        const label = viewWriter.createContainerElement('label', {\n            class: 'todo-list__label'\n        });\n        const checkbox = viewWriter.createEmptyElement('input', {\n            type: 'checkbox',\n            disabled: 'disabled'\n        });\n        const span = viewWriter.createContainerElement('span', {\n            class: 'todo-list__label__description'\n        });\n        if (modelItem.getAttribute('todoListChecked')) {\n            viewWriter.setAttribute('checked', 'checked', checkbox);\n        }\n        viewWriter.insert(viewWriter.createPositionAt(viewItem, 0), label);\n        viewWriter.insert(viewWriter.createPositionAt(label, 0), checkbox);\n        viewWriter.insert(viewWriter.createPositionAfter(checkbox), span);\n        injectViewList(modelItem, viewItem, conversionApi, model);\n    };\n}\n/**\n * A view-to-model converter for the checkbox element inside a view list item.\n *\n * It changes the `listType` of the model `listItem` to a `todo` value.\n * When a view checkbox element is marked as checked, an additional `todoListChecked=\"true\"` attribute is added to the model item.\n *\n * It is used by {@link module:engine/controller/datacontroller~DataController}.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n */\nexport const dataViewModelCheckmarkInsertion = (evt, data, conversionApi) => {\n    const modelCursor = data.modelCursor;\n    const modelItem = modelCursor.parent;\n    const viewItem = data.viewItem;\n    if (viewItem.getAttribute('type') != 'checkbox' || modelItem.name != 'listItem' || !modelCursor.isAtStart) {\n        return;\n    }\n    if (!conversionApi.consumable.consume(viewItem, { name: true })) {\n        return;\n    }\n    const writer = conversionApi.writer;\n    writer.setAttribute('listType', 'todo', modelItem);\n    if (data.viewItem.hasAttribute('checked')) {\n        writer.setAttribute('todoListChecked', true, modelItem);\n    }\n    data.modelRange = writer.createRange(modelCursor);\n};\n/**\n * A model-to-view converter for the `listType` attribute change on the `listItem` model element.\n *\n * This change means that the `<li>` element parent changes to `<ul class=\"todo-list\">` and a\n * {@link module:engine/view/uielement~UIElement checkbox UI element} is added at the beginning\n * of the list item element (or vice versa).\n *\n * This converter is preceded by {@link module:list/list/converters~modelViewChangeType} and followed by\n * {@link module:list/list/converters~modelViewMergeAfterChangeType} to handle splitting and merging surrounding lists of the same type.\n *\n * It is used by {@link module:engine/controller/editingcontroller~EditingController}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param onCheckedChange Callback fired after clicking the checkbox UI element.\n * @param view Editing view controller.\n * @returns Returns a conversion callback.\n */\nexport function modelViewChangeType(onCheckedChange, view) {\n    return (evt, data, conversionApi) => {\n        if (!conversionApi.consumable.consume(data.item, evt.name)) {\n            return;\n        }\n        const viewItem = conversionApi.mapper.toViewElement(data.item);\n        const viewWriter = conversionApi.writer;\n        const labelElement = findLabel(viewItem, view);\n        if (data.attributeNewValue == 'todo') {\n            const isChecked = !!data.item.getAttribute('todoListChecked');\n            const checkmarkElement = createCheckmarkElement(data.item, viewWriter, isChecked, onCheckedChange);\n            const span = viewWriter.createContainerElement('span', {\n                class: 'todo-list__label__description'\n            });\n            const itemRange = viewWriter.createRangeIn(viewItem);\n            const nestedList = findNestedList(viewItem);\n            const descriptionStart = positionAfterUiElements(itemRange.start);\n            const descriptionEnd = nestedList ? viewWriter.createPositionBefore(nestedList) : itemRange.end;\n            const descriptionRange = viewWriter.createRange(descriptionStart, descriptionEnd);\n            viewWriter.addClass('todo-list', viewItem.parent);\n            viewWriter.move(descriptionRange, viewWriter.createPositionAt(span, 0));\n            viewWriter.insert(viewWriter.createPositionAt(viewItem, 0), checkmarkElement);\n            viewWriter.insert(viewWriter.createPositionAfter(checkmarkElement), span);\n        }\n        else if (data.attributeOldValue == 'todo') {\n            const descriptionSpan = findDescription(viewItem, view);\n            viewWriter.removeClass('todo-list', viewItem.parent);\n            viewWriter.remove(labelElement);\n            viewWriter.move(viewWriter.createRangeIn(descriptionSpan), viewWriter.createPositionBefore(descriptionSpan));\n            viewWriter.remove(descriptionSpan);\n        }\n    };\n}\n/**\n * A model-to-view converter for the `todoListChecked` attribute change on the `listItem` model element.\n *\n * It marks the {@link module:engine/view/uielement~UIElement checkbox UI element} as checked.\n *\n * It is used by {@link module:engine/controller/editingcontroller~EditingController}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param onCheckedChange Callback fired after clicking the checkbox UI element.\n * @returns Returns a conversion callback.\n */\nexport function modelViewChangeChecked(onCheckedChange) {\n    return (evt, data, conversionApi) => {\n        // Do not convert `todoListChecked` attribute when to-do list item has changed to other list item.\n        // This attribute will be removed by the model post fixer.\n        if (data.item.getAttribute('listType') != 'todo') {\n            return;\n        }\n        if (!conversionApi.consumable.consume(data.item, 'attribute:todoListChecked')) {\n            return;\n        }\n        const { mapper, writer: viewWriter } = conversionApi;\n        const isChecked = !!data.item.getAttribute('todoListChecked');\n        const viewItem = mapper.toViewElement(data.item);\n        // Because of m -> v position mapper we can be sure checkbox is always at the beginning.\n        const oldCheckmarkElement = viewItem.getChild(0);\n        const newCheckmarkElement = createCheckmarkElement(data.item, viewWriter, isChecked, onCheckedChange);\n        viewWriter.insert(viewWriter.createPositionAfter(oldCheckmarkElement), newCheckmarkElement);\n        viewWriter.remove(oldCheckmarkElement);\n    };\n}\n/**\n * A model-to-view position at zero offset mapper.\n *\n * This helper ensures that position inside todo-list in the view is mapped after the checkbox.\n *\n * It only handles the position at the beginning of a list item as other positions are properly mapped be the default mapper.\n */\nexport function mapModelToViewPosition(view) {\n    return (evt, data) => {\n        const modelPosition = data.modelPosition;\n        const parent = modelPosition.parent;\n        if (!parent.is('element', 'listItem') || parent.getAttribute('listType') != 'todo') {\n            return;\n        }\n        const viewLi = data.mapper.toViewElement(parent);\n        const descSpan = findDescription(viewLi, view);\n        if (descSpan) {\n            data.viewPosition = data.mapper.findPositionIn(descSpan, modelPosition.offset);\n        }\n    };\n}\n/**\n * Creates a checkbox UI element.\n */\nfunction createCheckmarkElement(modelItem, viewWriter, isChecked, onChange) {\n    const uiElement = viewWriter.createUIElement('label', {\n        class: 'todo-list__label',\n        contenteditable: false\n    }, function (domDocument) {\n        const checkbox = createElement(document, 'input', { type: 'checkbox', tabindex: '-1' });\n        if (isChecked) {\n            checkbox.setAttribute('checked', 'checked');\n        }\n        checkbox.addEventListener('change', () => onChange(modelItem));\n        const domElement = this.toDomElement(domDocument);\n        domElement.appendChild(checkbox);\n        return domElement;\n    });\n    return uiElement;\n}\n// Helper method to find label element inside li.\nfunction findLabel(viewItem, view) {\n    const range = view.createRangeIn(viewItem);\n    for (const value of range) {\n        if (value.item.is('uiElement', 'label')) {\n            return value.item;\n        }\n    }\n}\nfunction findDescription(viewItem, view) {\n    const range = view.createRangeIn(viewItem);\n    for (const value of range) {\n        if (value.item.is('containerElement', 'span') && value.item.hasClass('todo-list__label__description')) {\n            return value.item;\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { getCode, parseKeystroke, getLocalizedArrowKeyCodeDirection } from 'ckeditor5/src/utils';\nimport ListCommand from '../list/listcommand';\nimport ListEditing from '../list/listediting';\nimport CheckTodoListCommand from './checktodolistcommand';\nimport { dataModelViewInsertion, dataViewModelCheckmarkInsertion, mapModelToViewPosition, modelViewChangeChecked, modelViewChangeType, modelViewInsertion } from './todolistconverters';\nconst ITEM_TOGGLE_KEYSTROKE = parseKeystroke('Ctrl+Enter');\n/**\n * The engine of the to-do list feature. It handles creating, editing and removing to-do lists and their items.\n *\n * It registers the entire functionality of the {@link module:list/list/listediting~ListEditing list editing plugin} and extends\n * it with the commands:\n *\n * - `'todoList'`,\n * - `'checkTodoList'`,\n * - `'todoListCheck'` as an alias for `checkTodoList` command.\n */\nexport default class TodoListEditing extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'TodoListEditing';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ListEditing];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const { editing, data, model } = editor;\n        // Extend schema.\n        model.schema.extend('listItem', {\n            allowAttributes: ['todoListChecked']\n        });\n        // Disallow todoListChecked attribute on other nodes than listItem with to-do listType.\n        model.schema.addAttributeCheck((context, attributeName) => {\n            const item = context.last;\n            if (attributeName == 'todoListChecked' && item.name == 'listItem' && item.getAttribute('listType') != 'todo') {\n                return false;\n            }\n        });\n        // Register `todoList` command.\n        editor.commands.add('todoList', new ListCommand(editor, 'todo'));\n        const checkTodoListCommand = new CheckTodoListCommand(editor);\n        // Register `checkTodoList` command and add `todoListCheck` command as an alias for backward compatibility.\n        editor.commands.add('checkTodoList', checkTodoListCommand);\n        editor.commands.add('todoListCheck', checkTodoListCommand);\n        // Define converters.\n        data.downcastDispatcher.on('insert:listItem', dataModelViewInsertion(model), { priority: 'high' });\n        data.upcastDispatcher.on('element:input', dataViewModelCheckmarkInsertion, { priority: 'high' });\n        editing.downcastDispatcher.on('insert:listItem', modelViewInsertion(model, listItem => this._handleCheckmarkChange(listItem)), { priority: 'high' });\n        editing.downcastDispatcher.on('attribute:listType:listItem', modelViewChangeType(listItem => this._handleCheckmarkChange(listItem), editing.view));\n        editing.downcastDispatcher.on('attribute:todoListChecked:listItem', modelViewChangeChecked(listItem => this._handleCheckmarkChange(listItem)));\n        editing.mapper.on('modelToViewPosition', mapModelToViewPosition(editing.view));\n        data.mapper.on('modelToViewPosition', mapModelToViewPosition(editing.view));\n        // Jump at the end of the previous node on left arrow key press, when selection is after the checkbox.\n        //\n        // <blockquote><p>Foo</p></blockquote>\n        // <ul><li><checkbox/>{}Bar</li></ul>\n        //\n        // press: `<-`\n        //\n        // <blockquote><p>Foo{}</p></blockquote>\n        // <ul><li><checkbox/>Bar</li></ul>\n        //\n        this.listenTo(editing.view.document, 'arrowKey', jumpOverCheckmarkOnSideArrowKeyPress(model, editor.locale), { context: 'li' });\n        // Toggle check state of selected to-do list items on keystroke.\n        this.listenTo(editing.view.document, 'keydown', (evt, data) => {\n            if (getCode(data) === ITEM_TOGGLE_KEYSTROKE) {\n                editor.execute('checkTodoList');\n                evt.stop();\n            }\n        }, { priority: 'high' });\n        // Remove `todoListChecked` attribute when a host element is no longer a to-do list item.\n        const listItemsToFix = new Set();\n        this.listenTo(model, 'applyOperation', (evt, args) => {\n            const operation = args[0];\n            if (operation.type == 'rename' && operation.oldName == 'listItem') {\n                const item = operation.position.nodeAfter;\n                if (item.hasAttribute('todoListChecked')) {\n                    listItemsToFix.add(item);\n                }\n            }\n            else if (operation.type == 'changeAttribute' && operation.key == 'listType' && operation.oldValue === 'todo') {\n                for (const item of operation.range.getItems()) {\n                    if (item.hasAttribute('todoListChecked') && item.getAttribute('listType') !== 'todo') {\n                        listItemsToFix.add(item);\n                    }\n                }\n            }\n        });\n        model.document.registerPostFixer(writer => {\n            let hasChanged = false;\n            for (const listItem of listItemsToFix) {\n                writer.removeAttribute('todoListChecked', listItem);\n                hasChanged = true;\n            }\n            listItemsToFix.clear();\n            return hasChanged;\n        });\n    }\n    /**\n     * Handles the checkbox element change, moves the selection to the corresponding model item to make it possible\n     * to toggle the `todoListChecked` attribute using the command, and restores the selection position.\n     *\n     * Some say it's a hack :) Moving the selection only for executing the command on a certain node and restoring it after,\n     * is not a clear solution. We need to design an API for using commands beyond the selection range.\n     * See https://github.com/ckeditor/ckeditor5/issues/1954.\n     */\n    _handleCheckmarkChange(listItem) {\n        const editor = this.editor;\n        const model = editor.model;\n        const previousSelectionRanges = Array.from(model.document.selection.getRanges());\n        model.change(writer => {\n            writer.setSelection(listItem, 'end');\n            editor.execute('checkTodoList');\n            writer.setSelection(previousSelectionRanges);\n        });\n    }\n}\n/**\n * Handles the left/right (LTR/RTL content) arrow key and moves the selection at the end of the previous block element\n * if the selection is just after the checkbox element. In other words, it jumps over the checkbox element when\n * moving the selection to the left/right (LTR/RTL).\n *\n * @returns Callback for 'keydown' events.\n */\nfunction jumpOverCheckmarkOnSideArrowKeyPress(model, locale) {\n    return (eventInfo, domEventData) => {\n        const direction = getLocalizedArrowKeyCodeDirection(domEventData.keyCode, locale.contentLanguageDirection);\n        if (direction != 'left') {\n            return;\n        }\n        const schema = model.schema;\n        const selection = model.document.selection;\n        if (!selection.isCollapsed) {\n            return;\n        }\n        const position = selection.getFirstPosition();\n        const parent = position.parent;\n        if (parent.name === 'listItem' && parent.getAttribute('listType') == 'todo' && position.isAtStart) {\n            const newRange = schema.getNearestSelectionRange(model.createPositionBefore(parent), 'backward');\n            if (newRange) {\n                model.change(writer => writer.setSelection(newRange));\n            }\n            domEventData.preventDefault();\n            domEventData.stopPropagation();\n            eventInfo.stop();\n        }\n    };\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/todolist/todolistui\n */\nimport { createUIComponent } from '../list/utils';\nimport todoListIcon from '../../theme/icons/todolist.svg';\nimport { Plugin } from 'ckeditor5/src/core';\n/**\n * The to-do list UI feature. It introduces the `'todoList'` button that\n * allows to convert elements to and from to-do list items and to indent or outdent them.\n */\nexport default class TodoListUI extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'TodoListUI';\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const t = this.editor.t;\n        createUIComponent(this.editor, 'todoList', t('To-do List'), todoListIcon);\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module list/todolist\n */\nimport TodoListEditing from './todolist/todolistediting';\nimport TodoListUI from './todolist/todolistui';\nimport { Plugin } from 'ckeditor5/src/core';\nimport '../theme/todolist.css';\n/**\n * The to-do list feature.\n *\n * This is a \"glue\" plugin that loads the {@link module:list/todolist/todolistediting~TodoListEditing to-do list editing feature}\n * and the {@link module:list/todolist/todolistui~TodoListUI to-do list UI feature}.\n */\nexport default class TodoList extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [TodoListEditing, TodoListUI];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'TodoList';\n    }\n}\n"],
  "mappings": "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",
  "names": ["attributeKey", "document", "shouldMergeOnBlocksContentLevel", "attributeKey", "document", "document", "getListTypeFromListStyleType", "document", "getListTypeFromListStyleType", "document", "getListTypeFromListStyleType", "getListTypeFromListStyleType", "bulletedListIcon", "numberedListIcon", "document", "getIndent", "modelChangePostFixer", "modelChangePostFixer", "data", "DEFAULT_LIST_TYPE", "createAttributeStrategies", "modelViewInsertion", "modelViewChangeType", "modelViewInsertion", "modelViewChangeType", "data"]
}
