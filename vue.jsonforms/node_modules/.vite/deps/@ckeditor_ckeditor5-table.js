import "./chunk-SX3YCKSJ.js";
import {
  Widget,
  WidgetToolbarRepository,
  isWidget,
  toWidget,
  toWidgetEditable
} from "./chunk-NMGSIING.js";
import "./chunk-DEIZSOIF.js";
import "./chunk-GGCPNJOL.js";
import "./chunk-LTAT4F5Y.js";
import "./chunk-VQXVBVB4.js";
import {
  BalloonPanelView,
  ButtonView,
  ColorSelectorView,
  ContextualBalloon,
  FocusCycler,
  FormHeaderView,
  InputTextView,
  LabelView,
  LabeledFieldView,
  Model,
  SplitButtonView,
  SwitchButtonView,
  ToolbarView,
  View,
  ViewCollection,
  addKeyboardHandlingForGrid,
  addListToDropdown,
  clickOutsideHandler,
  createDropdown,
  createLabeledDropdown,
  createLabeledInputText,
  getLocalizedColorOptions,
  normalizeColorOptions,
  submitHandler
} from "./chunk-SGTDNT4V.js";
import "./chunk-4MFML76R.js";
import "./chunk-6LVMAMLV.js";
import {
  CKEditorError,
  Collection,
  Command,
  DomEmitterMixin,
  DomEventObserver,
  Element,
  FocusTracker,
  KeystrokeHandler,
  Plugin,
  Rect,
  addBackgroundRules,
  addBorderRules,
  addPaddingRules,
  enablePlaceholder,
  first,
  getLocalizedArrowKeyCodeDirection,
  global_default,
  icons,
  isColor,
  isLength,
  isPercentage
} from "./chunk-JI2V5GJZ.js";
import {
  debounce_default,
  isEqual_default,
  isObject_default,
  throttle_default
} from "./chunk-6DXDGCMU.js";
import "./chunk-HM4MQYWN.js";

// node_modules/@ckeditor/ckeditor5-table/src/converters/tableproperties.js
function upcastStyleToAttribute(conversion, options) {
  const { modelAttribute, styleName, viewElement, defaultValue, reduceBoxSides = false, shouldUpcast = () => true } = options;
  conversion.for("upcast").attributeToAttribute({
    view: {
      name: viewElement,
      styles: {
        [styleName]: /[\s\S]+/
      }
    },
    model: {
      key: modelAttribute,
      value: (viewElement2) => {
        if (!shouldUpcast(viewElement2)) {
          return;
        }
        const normalized = viewElement2.getNormalizedStyle(styleName);
        const value = reduceBoxSides ? reduceBoxSidesValue(normalized) : normalized;
        if (defaultValue !== value) {
          return value;
        }
      }
    }
  });
}
function upcastBorderStyles(conversion, viewElementName, modelAttributes, defaultBorder) {
  conversion.for("upcast").add((dispatcher) => dispatcher.on("element:" + viewElementName, (evt, data, conversionApi) => {
    if (!data.modelRange) {
      return;
    }
    const stylesToConsume = [
      "border-top-width",
      "border-top-color",
      "border-top-style",
      "border-bottom-width",
      "border-bottom-color",
      "border-bottom-style",
      "border-right-width",
      "border-right-color",
      "border-right-style",
      "border-left-width",
      "border-left-color",
      "border-left-style"
    ].filter((styleName) => data.viewItem.hasStyle(styleName));
    if (!stylesToConsume.length) {
      return;
    }
    const matcherPattern = {
      styles: stylesToConsume
    };
    if (!conversionApi.consumable.test(data.viewItem, matcherPattern)) {
      return;
    }
    const modelElement = [...data.modelRange.getItems({ shallow: true })].pop();
    conversionApi.consumable.consume(data.viewItem, matcherPattern);
    const normalizedBorder = {
      style: data.viewItem.getNormalizedStyle("border-style"),
      color: data.viewItem.getNormalizedStyle("border-color"),
      width: data.viewItem.getNormalizedStyle("border-width")
    };
    const reducedBorder = {
      style: reduceBoxSidesValue(normalizedBorder.style),
      color: reduceBoxSidesValue(normalizedBorder.color),
      width: reduceBoxSidesValue(normalizedBorder.width)
    };
    if (reducedBorder.style !== defaultBorder.style) {
      conversionApi.writer.setAttribute(modelAttributes.style, reducedBorder.style, modelElement);
    }
    if (reducedBorder.color !== defaultBorder.color) {
      conversionApi.writer.setAttribute(modelAttributes.color, reducedBorder.color, modelElement);
    }
    if (reducedBorder.width !== defaultBorder.width) {
      conversionApi.writer.setAttribute(modelAttributes.width, reducedBorder.width, modelElement);
    }
  }));
}
function downcastAttributeToStyle(conversion, options) {
  const { modelElement, modelAttribute, styleName } = options;
  conversion.for("downcast").attributeToAttribute({
    model: {
      name: modelElement,
      key: modelAttribute
    },
    view: (modelAttributeValue) => ({
      key: "style",
      value: {
        [styleName]: modelAttributeValue
      }
    })
  });
}
function downcastTableAttribute(conversion, options) {
  const { modelAttribute, styleName } = options;
  conversion.for("downcast").add((dispatcher) => dispatcher.on(`attribute:${modelAttribute}:table`, (evt, data, conversionApi) => {
    const { item, attributeNewValue } = data;
    const { mapper, writer } = conversionApi;
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const table = [...mapper.toViewElement(item).getChildren()].find((child) => child.is("element", "table"));
    if (attributeNewValue) {
      writer.setStyle(styleName, attributeNewValue, table);
    } else {
      writer.removeStyle(styleName, table);
    }
  }));
}
function reduceBoxSidesValue(style) {
  if (!style) {
    return;
  }
  const sides = ["top", "right", "bottom", "left"];
  const allSidesDefined = sides.every((side) => style[side]);
  if (!allSidesDefined) {
    return style;
  }
  const topSideStyle = style.top;
  const allSidesEqual = sides.every((side) => style[side] === topSideStyle);
  if (!allSidesEqual) {
    return style;
  }
  return topSideStyle;
}

// node_modules/@ckeditor/ckeditor5-table/src/utils/common.js
function updateNumericAttribute(key, value, item, writer, defaultValue = 1) {
  if (value !== void 0 && value !== null && defaultValue !== void 0 && defaultValue !== null && value > defaultValue) {
    writer.setAttribute(key, value, item);
  } else {
    writer.removeAttribute(key, item);
  }
}
function createEmptyTableCell(writer, insertPosition, attributes = {}) {
  const tableCell = writer.createElement("tableCell", attributes);
  writer.insertElement("paragraph", tableCell);
  writer.insert(tableCell, insertPosition);
  return tableCell;
}
function isHeadingColumnCell(tableUtils, tableCell) {
  const table = tableCell.parent.parent;
  const headingColumns = parseInt(table.getAttribute("headingColumns") || "0");
  const { column } = tableUtils.getCellLocation(tableCell);
  return !!headingColumns && column < headingColumns;
}
function enableProperty(schema, conversion, options) {
  const { modelAttribute } = options;
  schema.extend("tableCell", {
    allowAttributes: [modelAttribute]
  });
  upcastStyleToAttribute(conversion, { viewElement: /^(td|th)$/, ...options });
  downcastAttributeToStyle(conversion, { modelElement: "tableCell", ...options });
}

// node_modules/@ckeditor/ckeditor5-table/src/converters/upcasttable.js
function upcastTableFigure() {
  return (dispatcher) => {
    dispatcher.on("element:figure", (evt, data, conversionApi) => {
      if (!conversionApi.consumable.test(data.viewItem, { name: true, classes: "table" })) {
        return;
      }
      const viewTable = getViewTableFromFigure(data.viewItem);
      if (!viewTable || !conversionApi.consumable.test(viewTable, { name: true })) {
        return;
      }
      conversionApi.consumable.consume(data.viewItem, { name: true, classes: "table" });
      const conversionResult = conversionApi.convertItem(viewTable, data.modelCursor);
      const modelTable = first(conversionResult.modelRange.getItems());
      if (!modelTable) {
        conversionApi.consumable.revert(data.viewItem, { name: true, classes: "table" });
        return;
      }
      conversionApi.convertChildren(data.viewItem, conversionApi.writer.createPositionAt(modelTable, "end"));
      conversionApi.updateConversionResult(modelTable, data);
    });
  };
}
function upcastTable() {
  return (dispatcher) => {
    dispatcher.on("element:table", (evt, data, conversionApi) => {
      const viewTable = data.viewItem;
      if (!conversionApi.consumable.test(viewTable, { name: true })) {
        return;
      }
      const { rows, headingRows, headingColumns } = scanTable(viewTable);
      const attributes = {};
      if (headingColumns) {
        attributes.headingColumns = headingColumns;
      }
      if (headingRows) {
        attributes.headingRows = headingRows;
      }
      const table = conversionApi.writer.createElement("table", attributes);
      if (!conversionApi.safeInsert(table, data.modelCursor)) {
        return;
      }
      conversionApi.consumable.consume(viewTable, { name: true });
      rows.forEach((row) => conversionApi.convertItem(row, conversionApi.writer.createPositionAt(table, "end")));
      conversionApi.convertChildren(viewTable, conversionApi.writer.createPositionAt(table, "end"));
      if (table.isEmpty) {
        const row = conversionApi.writer.createElement("tableRow");
        conversionApi.writer.insert(row, conversionApi.writer.createPositionAt(table, "end"));
        createEmptyTableCell(conversionApi.writer, conversionApi.writer.createPositionAt(row, "end"));
      }
      conversionApi.updateConversionResult(table, data);
    });
  };
}
function skipEmptyTableRow() {
  return (dispatcher) => {
    dispatcher.on("element:tr", (evt, data) => {
      if (data.viewItem.isEmpty && data.modelCursor.index == 0) {
        evt.stop();
      }
    }, { priority: "high" });
  };
}
function ensureParagraphInTableCell(elementName) {
  return (dispatcher) => {
    dispatcher.on(`element:${elementName}`, (evt, data, { writer }) => {
      if (!data.modelRange) {
        return;
      }
      const tableCell = data.modelRange.start.nodeAfter;
      const modelCursor = writer.createPositionAt(tableCell, 0);
      if (data.viewItem.isEmpty) {
        writer.insertElement("paragraph", modelCursor);
        return;
      }
      const childNodes = Array.from(tableCell.getChildren());
      if (childNodes.every((node) => node.is("element", "$marker"))) {
        const paragraph = writer.createElement("paragraph");
        writer.insert(paragraph, writer.createPositionAt(tableCell, 0));
        for (const node of childNodes) {
          writer.move(writer.createRangeOn(node), writer.createPositionAt(paragraph, "end"));
        }
      }
    }, { priority: "low" });
  };
}
function getViewTableFromFigure(figureView) {
  for (const figureChild of figureView.getChildren()) {
    if (figureChild.is("element", "table")) {
      return figureChild;
    }
  }
}
function scanTable(viewTable) {
  let headingRows = 0;
  let headingColumns = void 0;
  const headRows = [];
  const bodyRows = [];
  let firstTheadElement;
  for (const tableChild of Array.from(viewTable.getChildren())) {
    if (tableChild.name !== "tbody" && tableChild.name !== "thead" && tableChild.name !== "tfoot") {
      continue;
    }
    if (tableChild.name === "thead" && !firstTheadElement) {
      firstTheadElement = tableChild;
    }
    const trs = Array.from(tableChild.getChildren()).filter((el) => el.is("element", "tr"));
    for (const tr of trs) {
      if (firstTheadElement && tableChild === firstTheadElement || tableChild.name === "tbody" && Array.from(tr.getChildren()).length && Array.from(tr.getChildren()).every((e) => e.is("element", "th"))) {
        headingRows++;
        headRows.push(tr);
      } else {
        bodyRows.push(tr);
        const headingCols = scanRowForHeadingColumns(tr);
        if (!headingColumns || headingCols < headingColumns) {
          headingColumns = headingCols;
        }
      }
    }
  }
  return {
    headingRows,
    headingColumns: headingColumns || 0,
    rows: [...headRows, ...bodyRows]
  };
}
function scanRowForHeadingColumns(tr) {
  let headingColumns = 0;
  let index = 0;
  const children = Array.from(tr.getChildren()).filter((child) => child.name === "th" || child.name === "td");
  while (index < children.length && children[index].name === "th") {
    const th = children[index];
    const colspan = parseInt(th.getAttribute("colspan") || "1");
    headingColumns = headingColumns + colspan;
    index++;
  }
  return headingColumns;
}

// node_modules/@ckeditor/ckeditor5-table/src/tablewalker.js
var TableWalker = class {
  /**
   * Creates an instance of the table walker.
   *
   * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
   * It walks row by row and column by column in order to output values defined in the constructor.
   * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
   * pass the `includeAllSlots` option to the constructor.
   *
   * The most important values of the iterator are column and row indexes of a cell.
   *
   * See {@link module:table/tablewalker~TableSlot} what values are returned by the table walker.
   *
   * To iterate over a given row:
   *
   * ```ts
   * const tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );
   *
   * for ( const tableSlot of tableWalker ) {
   *   console.log( 'A cell at row', tableSlot.row, 'and column', tableSlot.column );
   * }
   * ```
   *
   * For instance the code above for the following table:
   *
   *  +----+----+----+----+----+----+
   *  | 00      | 02 | 03 | 04 | 05 |
   *  |         +----+----+----+----+
   *  |         | 12      | 14 | 15 |
   *  |         +----+----+----+    +
   *  |         | 22           |    |
   *  |----+----+----+----+----+    +
   *  | 30 | 31 | 32 | 33 | 34 |    |
   *  +----+----+----+----+----+----+
   *
   * will log in the console:
   *
   *  'A cell at row 1 and column 2'
   *  'A cell at row 1 and column 4'
   *  'A cell at row 1 and column 5'
   *  'A cell at row 2 and column 2'
   *
   * To also iterate over spanned cells:
   *
   * ```ts
   * const tableWalker = new TableWalker( table, { row: 1, includeAllSlots: true } );
   *
   * for ( const tableSlot of tableWalker ) {
   *   console.log( 'Slot at', tableSlot.row, 'x', tableSlot.column, ':', tableSlot.isAnchor ? 'is anchored' : 'is spanned' );
   * }
   * ```
   *
   * will log in the console for the table from the previous example:
   *
   *  'Cell at 1 x 0 : is spanned'
   *  'Cell at 1 x 1 : is spanned'
   *  'Cell at 1 x 2 : is anchored'
   *  'Cell at 1 x 3 : is spanned'
   *  'Cell at 1 x 4 : is anchored'
   *  'Cell at 1 x 5 : is anchored'
   *
   * **Note**: Option `row` is a shortcut that sets both `startRow` and `endRow` to the same row.
   * (Use either `row` or `startRow` and `endRow` but never together). Similarly the `column` option sets both `startColumn`
   * and `endColumn` to the same column (Use either `column` or `startColumn` and `endColumn` but never together).
   *
   * @param table A table over which the walker iterates.
   * @param options An object with configuration.
   * @param options.row A row index for which this iterator will output cells. Can't be used together with `startRow` and `endRow`.
   * @param options.startRow A row index from which this iterator should start. Can't be used together with `row`. Default value is 0.
   * @param options.endRow A row index at which this iterator should end. Can't be used together with `row`.
   * @param options.column A column index for which this iterator will output cells.
   * Can't be used together with `startColumn` and `endColumn`.
   * @param options.startColumn A column index from which this iterator should start.
   * Can't be used together with `column`. Default value is 0.
   * @param options.endColumn A column index at which this iterator should end. Can't be used together with `column`.
   * @param options.includeAllSlots Also return values for spanned cells. Default value is "false".
   */
  constructor(table, options = {}) {
    this._jumpedToStartRow = false;
    this._table = table;
    this._startRow = options.row !== void 0 ? options.row : options.startRow || 0;
    this._endRow = options.row !== void 0 ? options.row : options.endRow;
    this._startColumn = options.column !== void 0 ? options.column : options.startColumn || 0;
    this._endColumn = options.column !== void 0 ? options.column : options.endColumn;
    this._includeAllSlots = !!options.includeAllSlots;
    this._skipRows = /* @__PURE__ */ new Set();
    this._row = 0;
    this._rowIndex = 0;
    this._column = 0;
    this._cellIndex = 0;
    this._spannedCells = /* @__PURE__ */ new Map();
    this._nextCellAtColumn = -1;
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Gets the next table walker's value.
   *
   * @returns The next table walker's value.
   */
  next() {
    if (this._canJumpToStartRow()) {
      this._jumpToNonSpannedRowClosestToStartRow();
    }
    const row = this._table.getChild(this._rowIndex);
    if (!row || this._isOverEndRow()) {
      return { done: true, value: void 0 };
    }
    if (!row.is("element", "tableRow")) {
      this._rowIndex++;
      return this.next();
    }
    if (this._isOverEndColumn()) {
      return this._advanceToNextRow();
    }
    let outValue = null;
    const spanData = this._getSpanned();
    if (spanData) {
      if (this._includeAllSlots && !this._shouldSkipSlot()) {
        outValue = this._formatOutValue(spanData.cell, spanData.row, spanData.column);
      }
    } else {
      const cell = row.getChild(this._cellIndex);
      if (!cell) {
        return this._advanceToNextRow();
      }
      const colspan = parseInt(cell.getAttribute("colspan") || "1");
      const rowspan = parseInt(cell.getAttribute("rowspan") || "1");
      if (colspan > 1 || rowspan > 1) {
        this._recordSpans(cell, rowspan, colspan);
      }
      if (!this._shouldSkipSlot()) {
        outValue = this._formatOutValue(cell);
      }
      this._nextCellAtColumn = this._column + colspan;
    }
    this._column++;
    if (this._column == this._nextCellAtColumn) {
      this._cellIndex++;
    }
    return outValue || this.next();
  }
  /**
   * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row
   * to output.
   *
   * @param row The row index to skip.
   */
  skipRow(row) {
    this._skipRows.add(row);
  }
  /**
   * Advances internal cursor to the next row.
   */
  _advanceToNextRow() {
    this._row++;
    this._rowIndex++;
    this._column = 0;
    this._cellIndex = 0;
    this._nextCellAtColumn = -1;
    return this.next();
  }
  /**
   * Checks if the current row is over {@link #_endRow}.
   */
  _isOverEndRow() {
    return this._endRow !== void 0 && this._row > this._endRow;
  }
  /**
   * Checks if the current cell is over {@link #_endColumn}
   */
  _isOverEndColumn() {
    return this._endColumn !== void 0 && this._column > this._endColumn;
  }
  /**
   * A common method for formatting the iterator's output value.
   *
   * @param cell The table cell to output.
   * @param anchorRow The row index of a cell anchor slot.
   * @param anchorColumn The column index of a cell anchor slot.
   */
  _formatOutValue(cell, anchorRow = this._row, anchorColumn = this._column) {
    return {
      done: false,
      value: new TableSlot(this, cell, anchorRow, anchorColumn)
    };
  }
  /**
   * Checks if the current slot should be skipped.
   */
  _shouldSkipSlot() {
    const rowIsMarkedAsSkipped = this._skipRows.has(this._row);
    const rowIsBeforeStartRow = this._row < this._startRow;
    const columnIsBeforeStartColumn = this._column < this._startColumn;
    const columnIsAfterEndColumn = this._endColumn !== void 0 && this._column > this._endColumn;
    return rowIsMarkedAsSkipped || rowIsBeforeStartRow || columnIsBeforeStartColumn || columnIsAfterEndColumn;
  }
  /**
   * Returns the cell element that is spanned over the current cell location.
   */
  _getSpanned() {
    const rowMap = this._spannedCells.get(this._row);
    if (!rowMap) {
      return null;
    }
    return rowMap.get(this._column) || null;
  }
  /**
   * Updates spanned cells map relative to the current cell location and its span dimensions.
   *
   * @param cell A cell that is spanned.
   * @param rowspan Cell height.
   * @param colspan Cell width.
   */
  _recordSpans(cell, rowspan, colspan) {
    const data = {
      cell,
      row: this._row,
      column: this._column
    };
    for (let rowToUpdate = this._row; rowToUpdate < this._row + rowspan; rowToUpdate++) {
      for (let columnToUpdate = this._column; columnToUpdate < this._column + colspan; columnToUpdate++) {
        if (rowToUpdate != this._row || columnToUpdate != this._column) {
          this._markSpannedCell(rowToUpdate, columnToUpdate, data);
        }
      }
    }
  }
  /**
   * Marks the cell location as spanned by another cell.
   *
   * @param row The row index of the cell location.
   * @param column The column index of the cell location.
   * @param data A spanned cell details (cell element, anchor row and column).
   */
  _markSpannedCell(row, column, data) {
    if (!this._spannedCells.has(row)) {
      this._spannedCells.set(row, /* @__PURE__ */ new Map());
    }
    const rowSpans = this._spannedCells.get(row);
    rowSpans.set(column, data);
  }
  /**
   * Checks if part of the table can be skipped.
   */
  _canJumpToStartRow() {
    return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow;
  }
  /**
   * Sets the current row to `this._startRow` or the first row before it that has the number of cells
   * equal to the number of columns in the table.
   *
   * Example:
   * 	+----+----+----+
   *  | 00 | 01 | 02 |
   *  |----+----+----+
   *  | 10      | 12 |
   *  |         +----+
   *  |         | 22 |
   *  |         +----+
   *  |         | 32 | <--- Start row
   *  +----+----+----+
   *  | 40 | 41 | 42 |
   *  +----+----+----+
   *
   * If the 4th row is a `this._startRow`, this method will:
   * 1.) Count the number of columns this table has based on the first row (3 columns in this case).
   * 2.) Check if the 4th row contains 3 cells. It doesn't, so go to the row before it.
   * 3.) Check if the 3rd row contains 3 cells. It doesn't, so go to the row before it.
   * 4.) Check if the 2nd row contains 3 cells. It does, so set the current row to that row.
   *
   * Setting the current row this way is necessary to let the `next()`  method loop over the cells
   * spanning multiple rows or columns and update the `this._spannedCells` property.
   */
  _jumpToNonSpannedRowClosestToStartRow() {
    const firstRowLength = this._getRowLength(0);
    for (let i = this._startRow; !this._jumpedToStartRow; i--) {
      if (firstRowLength === this._getRowLength(i)) {
        this._row = i;
        this._rowIndex = i;
        this._jumpedToStartRow = true;
      }
    }
  }
  /**
   * Returns a number of columns in a row taking `colspan` into consideration.
   */
  _getRowLength(rowIndex) {
    const row = this._table.getChild(rowIndex);
    return [...row.getChildren()].reduce((cols, row2) => {
      return cols + parseInt(row2.getAttribute("colspan") || "1");
    }, 0);
  }
};
var TableSlot = class {
  /**
   * Creates an instance of the table walker value.
   *
   * @param tableWalker The table walker instance.
   * @param cell The current table cell.
   * @param anchorRow The row index of a cell anchor slot.
   * @param anchorColumn The column index of a cell anchor slot.
   */
  constructor(tableWalker, cell, anchorRow, anchorColumn) {
    this.cell = cell;
    this.row = tableWalker._row;
    this.column = tableWalker._column;
    this.cellAnchorRow = anchorRow;
    this.cellAnchorColumn = anchorColumn;
    this._cellIndex = tableWalker._cellIndex;
    this._rowIndex = tableWalker._rowIndex;
    this._table = tableWalker._table;
  }
  // @if CK_DEBUG // public get isSpanned(): unknown { return throwMissingGetterError( 'isSpanned' ); }
  // @if CK_DEBUG // public get colspan(): unknown { return throwMissingGetterError( 'colspan' ); }
  // @if CK_DEBUG // public get rowspan(): unknown { return throwMissingGetterError( 'rowspan' ); }
  // @if CK_DEBUG // public get cellIndex(): unknown { return throwMissingGetterError( 'cellIndex' ); }
  /**
   * Whether the cell is anchored in the current slot.
   */
  get isAnchor() {
    return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
  }
  /**
   * The width of a cell defined by a `colspan` attribute. If the model attribute is not present, it is set to `1`.
   */
  get cellWidth() {
    return parseInt(this.cell.getAttribute("colspan") || "1");
  }
  /**
   * The height of a cell defined by a `rowspan` attribute. If the model attribute is not present, it is set to `1`.
   */
  get cellHeight() {
    return parseInt(this.cell.getAttribute("rowspan") || "1");
  }
  /**
   * The index of the current row element in the table.
   */
  get rowIndex() {
    return this._rowIndex;
  }
  /**
   * Returns the {@link module:engine/model/position~Position} before the table slot.
   */
  getPositionBefore() {
    const model = this._table.root.document.model;
    return model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/converters/downcast.js
function downcastTable(tableUtils, options) {
  return (table, { writer }) => {
    const headingRows = table.getAttribute("headingRows") || 0;
    const tableElement = writer.createContainerElement("table", null, []);
    const figureElement = writer.createContainerElement("figure", { class: "table" }, tableElement);
    if (headingRows > 0) {
      writer.insert(writer.createPositionAt(tableElement, "end"), writer.createContainerElement("thead", null, writer.createSlot((element) => element.is("element", "tableRow") && element.index < headingRows)));
    }
    if (headingRows < tableUtils.getRows(table)) {
      writer.insert(writer.createPositionAt(tableElement, "end"), writer.createContainerElement("tbody", null, writer.createSlot((element) => element.is("element", "tableRow") && element.index >= headingRows)));
    }
    for (const { positionOffset, filter } of options.additionalSlots) {
      writer.insert(writer.createPositionAt(tableElement, positionOffset), writer.createSlot(filter));
    }
    writer.insert(writer.createPositionAt(tableElement, "after"), writer.createSlot((element) => {
      if (element.is("element", "tableRow")) {
        return false;
      }
      return !options.additionalSlots.some(({ filter }) => filter(element));
    }));
    return options.asWidget ? toTableWidget(figureElement, writer) : figureElement;
  };
}
function downcastRow() {
  return (tableRow, { writer }) => {
    return tableRow.isEmpty ? writer.createEmptyElement("tr") : writer.createContainerElement("tr");
  };
}
function downcastCell(options = {}) {
  return (tableCell, { writer }) => {
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const rowIndex = table.getChildIndex(tableRow);
    const tableWalker = new TableWalker(table, { row: rowIndex });
    const headingRows = table.getAttribute("headingRows") || 0;
    const headingColumns = table.getAttribute("headingColumns") || 0;
    let result = null;
    for (const tableSlot of tableWalker) {
      if (tableSlot.cell == tableCell) {
        const isHeading = tableSlot.row < headingRows || tableSlot.column < headingColumns;
        const cellElementName = isHeading ? "th" : "td";
        result = options.asWidget ? toWidgetEditable(writer.createEditableElement(cellElementName), writer) : writer.createContainerElement(cellElementName);
        break;
      }
    }
    return result;
  };
}
function convertParagraphInTableCell(options = {}) {
  return (modelElement, { writer }) => {
    if (!modelElement.parent.is("element", "tableCell")) {
      return null;
    }
    if (!isSingleParagraphWithoutAttributes(modelElement)) {
      return null;
    }
    if (options.asWidget) {
      return writer.createContainerElement("span", { class: "ck-table-bogus-paragraph" });
    } else {
      const viewElement = writer.createContainerElement("p");
      writer.setCustomProperty("dataPipeline:transparentRendering", true, viewElement);
      return viewElement;
    }
  };
}
function isSingleParagraphWithoutAttributes(modelElement) {
  const tableCell = modelElement.parent;
  const isSingleParagraph = tableCell.childCount == 1;
  return isSingleParagraph && !hasAnyAttribute(modelElement);
}
function toTableWidget(viewElement, writer) {
  writer.setCustomProperty("table", true, viewElement);
  return toWidget(viewElement, writer, { hasSelectionHandle: true });
}
function hasAnyAttribute(element) {
  const iteratorItem = element.getAttributeKeys().next();
  return !iteratorItem.done;
}

// node_modules/@ckeditor/ckeditor5-table/src/commands/inserttablecommand.js
var InsertTableCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const selection = model.document.selection;
    const schema = model.schema;
    this.isEnabled = isAllowedInParent(selection, schema);
  }
  /**
   * Executes the command.
   *
   * Inserts a table with the given number of rows and columns into the editor.
   *
   * @param options.rows The number of rows to create in the inserted table. Default value is 2.
   * @param options.columns The number of columns to create in the inserted table. Default value is 2.
   * @param options.headingRows The number of heading rows. If not provided it will default to
   * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.rows`} table config.
   * @param options.headingColumns The number of heading columns. If not provided it will default to
   * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.columns`} table config.
   * @fires execute
   */
  execute(options = {}) {
    const editor = this.editor;
    const model = editor.model;
    const tableUtils = editor.plugins.get("TableUtils");
    const defaultRows = editor.config.get("table.defaultHeadings.rows");
    const defaultColumns = editor.config.get("table.defaultHeadings.columns");
    if (options.headingRows === void 0 && defaultRows) {
      options.headingRows = defaultRows;
    }
    if (options.headingColumns === void 0 && defaultColumns) {
      options.headingColumns = defaultColumns;
    }
    model.change((writer) => {
      const table = tableUtils.createTable(writer, options);
      model.insertObject(table, null, null, { findOptimalPosition: "auto" });
      writer.setSelection(writer.createPositionAt(table.getNodeByPath([0, 0, 0]), 0));
    });
  }
};
function isAllowedInParent(selection, schema) {
  const positionParent = selection.getFirstPosition().parent;
  const validParent = positionParent === positionParent.root ? positionParent : positionParent.parent;
  return schema.checkChild(validParent, "table");
}

// node_modules/@ckeditor/ckeditor5-table/src/commands/insertrowcommand.js
var InsertRowCommand = class extends Command {
  /**
   * Creates a new `InsertRowCommand` instance.
   *
   * @param editor The editor on which this command will be used.
   * @param options.order The order of insertion relative to the row in which the caret is located.
   * Possible values: `"above"` and `"below"`. Default value is "below"
   */
  constructor(editor, options = {}) {
    super(editor);
    this.order = options.order || "below";
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const selection = this.editor.model.document.selection;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const isAnyCellSelected = !!tableUtils.getSelectionAffectedTableCells(selection).length;
    this.isEnabled = isAnyCellSelected;
  }
  /**
   * Executes the command.
   *
   * Depending on the command's {@link #order} value, it inserts a row `'below'` or `'above'` the row in which selection is set.
   *
   * @fires execute
   */
  execute() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const tableUtils = editor.plugins.get("TableUtils");
    const insertAbove = this.order === "above";
    const affectedTableCells = tableUtils.getSelectionAffectedTableCells(selection);
    const rowIndexes = tableUtils.getRowIndexes(affectedTableCells);
    const row = insertAbove ? rowIndexes.first : rowIndexes.last;
    const table = affectedTableCells[0].findAncestor("table");
    tableUtils.insertRows(table, { at: insertAbove ? row : row + 1, copyStructureFromAbove: !insertAbove });
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/commands/insertcolumncommand.js
var InsertColumnCommand = class extends Command {
  /**
   * Creates a new `InsertColumnCommand` instance.
   *
   * @param editor An editor on which this command will be used.
   * @param options.order The order of insertion relative to the column in which the caret is located.
   * Possible values: `"left"` and `"right"`. Default value is "right".
   */
  constructor(editor, options = {}) {
    super(editor);
    this.order = options.order || "right";
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const selection = this.editor.model.document.selection;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const isAnyCellSelected = !!tableUtils.getSelectionAffectedTableCells(selection).length;
    this.isEnabled = isAnyCellSelected;
  }
  /**
   * Executes the command.
   *
   * Depending on the command's {@link #order} value, it inserts a column to the `'left'` or `'right'` of the column
   * in which the selection is set.
   *
   * @fires execute
   */
  execute() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const tableUtils = editor.plugins.get("TableUtils");
    const insertBefore = this.order === "left";
    const affectedTableCells = tableUtils.getSelectionAffectedTableCells(selection);
    const columnIndexes = tableUtils.getColumnIndexes(affectedTableCells);
    const column = insertBefore ? columnIndexes.first : columnIndexes.last;
    const table = affectedTableCells[0].findAncestor("table");
    tableUtils.insertColumns(table, { columns: 1, at: insertBefore ? column : column + 1 });
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/commands/splitcellcommand.js
var SplitCellCommand = class extends Command {
  /**
   * Creates a new `SplitCellCommand` instance.
   *
   * @param editor The editor on which this command will be used.
   * @param options.direction Indicates whether the command should split cells `'horizontally'` or `'vertically'`.
   */
  constructor(editor, options = {}) {
    super(editor);
    this.direction = options.direction || "horizontally";
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = selectedCells.length === 1;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const tableCell = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
    const isHorizontal = this.direction === "horizontally";
    if (isHorizontal) {
      tableUtils.splitCellHorizontally(tableCell, 2);
    } else {
      tableUtils.splitCellVertically(tableCell, 2);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/utils/structure.js
function cropTableToDimensions(sourceTable, cropDimensions, writer) {
  const { startRow, startColumn, endRow, endColumn } = cropDimensions;
  const croppedTable = writer.createElement("table");
  const cropHeight = endRow - startRow + 1;
  for (let i = 0; i < cropHeight; i++) {
    writer.insertElement("tableRow", croppedTable, "end");
  }
  const tableMap = [...new TableWalker(sourceTable, { startRow, endRow, startColumn, endColumn, includeAllSlots: true })];
  for (const { row: sourceRow, column: sourceColumn, cell: tableCell, isAnchor, cellAnchorRow, cellAnchorColumn } of tableMap) {
    const rowInCroppedTable = sourceRow - startRow;
    const row = croppedTable.getChild(rowInCroppedTable);
    if (!isAnchor) {
      if (cellAnchorRow < startRow || cellAnchorColumn < startColumn) {
        createEmptyTableCell(writer, writer.createPositionAt(row, "end"));
      }
    } else {
      const tableCellCopy = writer.cloneElement(tableCell);
      writer.append(tableCellCopy, row);
      trimTableCellIfNeeded(tableCellCopy, sourceRow, sourceColumn, endRow, endColumn, writer);
    }
  }
  addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer);
  return croppedTable;
}
function getVerticallyOverlappingCells(table, overlapRow, startRow = 0) {
  const cells = [];
  const tableWalker = new TableWalker(table, { startRow, endRow: overlapRow - 1 });
  for (const slotInfo of tableWalker) {
    const { row, cellHeight } = slotInfo;
    const cellEndRow = row + cellHeight - 1;
    if (row < overlapRow && overlapRow <= cellEndRow) {
      cells.push(slotInfo);
    }
  }
  return cells;
}
function splitHorizontally(tableCell, splitRow, writer) {
  const tableRow = tableCell.parent;
  const table = tableRow.parent;
  const rowIndex = tableRow.index;
  const rowspan = parseInt(tableCell.getAttribute("rowspan"));
  const newRowspan = splitRow - rowIndex;
  const newCellAttributes = {};
  const newCellRowSpan = rowspan - newRowspan;
  if (newCellRowSpan > 1) {
    newCellAttributes.rowspan = newCellRowSpan;
  }
  const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
  if (colspan > 1) {
    newCellAttributes.colspan = colspan;
  }
  const startRow = rowIndex;
  const endRow = startRow + newRowspan;
  const tableMap = [...new TableWalker(table, { startRow, endRow, includeAllSlots: true })];
  let newCell = null;
  let columnIndex;
  for (const tableSlot of tableMap) {
    const { row, column, cell } = tableSlot;
    if (cell === tableCell && columnIndex === void 0) {
      columnIndex = column;
    }
    if (columnIndex !== void 0 && columnIndex === column && row === endRow) {
      newCell = createEmptyTableCell(writer, tableSlot.getPositionBefore(), newCellAttributes);
    }
  }
  updateNumericAttribute("rowspan", newRowspan, tableCell, writer);
  return newCell;
}
function getHorizontallyOverlappingCells(table, overlapColumn) {
  const cellsToSplit = [];
  const tableWalker = new TableWalker(table);
  for (const slotInfo of tableWalker) {
    const { column, cellWidth } = slotInfo;
    const cellEndColumn = column + cellWidth - 1;
    if (column < overlapColumn && overlapColumn <= cellEndColumn) {
      cellsToSplit.push(slotInfo);
    }
  }
  return cellsToSplit;
}
function splitVertically(tableCell, columnIndex, splitColumn, writer) {
  const colspan = parseInt(tableCell.getAttribute("colspan"));
  const newColspan = splitColumn - columnIndex;
  const newCellAttributes = {};
  const newCellColSpan = colspan - newColspan;
  if (newCellColSpan > 1) {
    newCellAttributes.colspan = newCellColSpan;
  }
  const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
  if (rowspan > 1) {
    newCellAttributes.rowspan = rowspan;
  }
  const newCell = createEmptyTableCell(writer, writer.createPositionAfter(tableCell), newCellAttributes);
  updateNumericAttribute("colspan", newColspan, tableCell, writer);
  return newCell;
}
function trimTableCellIfNeeded(tableCell, cellRow, cellColumn, limitRow, limitColumn, writer) {
  const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
  const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
  const endColumn = cellColumn + colspan - 1;
  if (endColumn > limitColumn) {
    const trimmedSpan = limitColumn - cellColumn + 1;
    updateNumericAttribute("colspan", trimmedSpan, tableCell, writer, 1);
  }
  const endRow = cellRow + rowspan - 1;
  if (endRow > limitRow) {
    const trimmedSpan = limitRow - cellRow + 1;
    updateNumericAttribute("rowspan", trimmedSpan, tableCell, writer, 1);
  }
}
function addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer) {
  const headingRows = parseInt(sourceTable.getAttribute("headingRows") || "0");
  if (headingRows > 0) {
    const headingRowsInCrop = headingRows - startRow;
    updateNumericAttribute("headingRows", headingRowsInCrop, croppedTable, writer, 0);
  }
  const headingColumns = parseInt(sourceTable.getAttribute("headingColumns") || "0");
  if (headingColumns > 0) {
    const headingColumnsInCrop = headingColumns - startColumn;
    updateNumericAttribute("headingColumns", headingColumnsInCrop, croppedTable, writer, 0);
  }
}
function removeEmptyColumns(table, tableUtils) {
  const width = tableUtils.getColumns(table);
  const columnsMap = new Array(width).fill(0);
  for (const { column } of new TableWalker(table)) {
    columnsMap[column]++;
  }
  const emptyColumns = columnsMap.reduce((result, cellsCount, column) => {
    return cellsCount ? result : [...result, column];
  }, []);
  if (emptyColumns.length > 0) {
    const emptyColumn = emptyColumns[emptyColumns.length - 1];
    tableUtils.removeColumns(table, { at: emptyColumn });
    return true;
  }
  return false;
}
function removeEmptyRows(table, tableUtils) {
  const emptyRows = [];
  const tableRowCount = tableUtils.getRows(table);
  for (let rowIndex = 0; rowIndex < tableRowCount; rowIndex++) {
    const tableRow = table.getChild(rowIndex);
    if (tableRow.isEmpty) {
      emptyRows.push(rowIndex);
    }
  }
  if (emptyRows.length > 0) {
    const emptyRow = emptyRows[emptyRows.length - 1];
    tableUtils.removeRows(table, { at: emptyRow });
    return true;
  }
  return false;
}
function removeEmptyRowsColumns(table, tableUtils) {
  const removedColumns = removeEmptyColumns(table, tableUtils);
  if (!removedColumns) {
    removeEmptyRows(table, tableUtils);
  }
}
function adjustLastRowIndex(table, dimensions) {
  const lastRowMap = Array.from(new TableWalker(table, {
    startColumn: dimensions.firstColumn,
    endColumn: dimensions.lastColumn,
    row: dimensions.lastRow
  }));
  const everyCellHasSingleRowspan = lastRowMap.every(({ cellHeight }) => cellHeight === 1);
  if (everyCellHasSingleRowspan) {
    return dimensions.lastRow;
  }
  const rowspanAdjustment = lastRowMap[0].cellHeight - 1;
  return dimensions.lastRow + rowspanAdjustment;
}
function adjustLastColumnIndex(table, dimensions) {
  const lastColumnMap = Array.from(new TableWalker(table, {
    startRow: dimensions.firstRow,
    endRow: dimensions.lastRow,
    column: dimensions.lastColumn
  }));
  const everyCellHasSingleColspan = lastColumnMap.every(({ cellWidth }) => cellWidth === 1);
  if (everyCellHasSingleColspan) {
    return dimensions.lastColumn;
  }
  const colspanAdjustment = lastColumnMap[0].cellWidth - 1;
  return dimensions.lastColumn + colspanAdjustment;
}

// node_modules/@ckeditor/ckeditor5-table/src/commands/mergecellcommand.js
var MergeCellCommand = class extends Command {
  /**
   * Creates a new `MergeCellCommand` instance.
   *
   * @param editor The editor on which this command will be used.
   * @param options.direction Indicates which cell to merge with the currently selected one.
   * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.
   */
  constructor(editor, options) {
    super(editor);
    this.direction = options.direction;
    this.isHorizontal = this.direction == "right" || this.direction == "left";
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const cellToMerge = this._getMergeableCell();
    this.value = cellToMerge;
    this.isEnabled = !!cellToMerge;
  }
  /**
   * Executes the command.
   *
   * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.
   *
   * @fires execute
   */
  execute() {
    const model = this.editor.model;
    const doc = model.document;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const tableCell = tableUtils.getTableCellsContainingSelection(doc.selection)[0];
    const cellToMerge = this.value;
    const direction = this.direction;
    model.change((writer) => {
      const isMergeNext = direction == "right" || direction == "down";
      const cellToExpand = isMergeNext ? tableCell : cellToMerge;
      const cellToRemove = isMergeNext ? cellToMerge : tableCell;
      const removedTableCellRow = cellToRemove.parent;
      mergeTableCells(cellToRemove, cellToExpand, writer);
      const spanAttribute = this.isHorizontal ? "colspan" : "rowspan";
      const cellSpan = parseInt(tableCell.getAttribute(spanAttribute) || "1");
      const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || "1");
      writer.setAttribute(spanAttribute, cellSpan + cellToMergeSpan, cellToExpand);
      writer.setSelection(writer.createRangeIn(cellToExpand));
      const tableUtils2 = this.editor.plugins.get("TableUtils");
      const table = removedTableCellRow.findAncestor("table");
      removeEmptyRowsColumns(table, tableUtils2);
    });
  }
  /**
   * Returns a cell that can be merged with the current cell depending on the command's direction.
   */
  _getMergeableCell() {
    const model = this.editor.model;
    const doc = model.document;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const tableCell = tableUtils.getTableCellsContainingSelection(doc.selection)[0];
    if (!tableCell) {
      return;
    }
    const cellToMerge = this.isHorizontal ? getHorizontalCell(tableCell, this.direction, tableUtils) : getVerticalCell(tableCell, this.direction, tableUtils);
    if (!cellToMerge) {
      return;
    }
    const spanAttribute = this.isHorizontal ? "rowspan" : "colspan";
    const span = parseInt(tableCell.getAttribute(spanAttribute) || "1");
    const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || "1");
    if (cellToMergeSpan === span) {
      return cellToMerge;
    }
  }
};
function getHorizontalCell(tableCell, direction, tableUtils) {
  const tableRow = tableCell.parent;
  const table = tableRow.parent;
  const horizontalCell = direction == "right" ? tableCell.nextSibling : tableCell.previousSibling;
  const hasHeadingColumns = (table.getAttribute("headingColumns") || 0) > 0;
  if (!horizontalCell) {
    return;
  }
  const cellOnLeft = direction == "right" ? tableCell : horizontalCell;
  const cellOnRight = direction == "right" ? horizontalCell : tableCell;
  const { column: leftCellColumn } = tableUtils.getCellLocation(cellOnLeft);
  const { column: rightCellColumn } = tableUtils.getCellLocation(cellOnRight);
  const leftCellSpan = parseInt(cellOnLeft.getAttribute("colspan") || "1");
  const isCellOnLeftInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnLeft);
  const isCellOnRightInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnRight);
  if (hasHeadingColumns && isCellOnLeftInHeadingColumn != isCellOnRightInHeadingColumn) {
    return;
  }
  const cellsAreTouching = leftCellColumn + leftCellSpan === rightCellColumn;
  return cellsAreTouching ? horizontalCell : void 0;
}
function getVerticalCell(tableCell, direction, tableUtils) {
  const tableRow = tableCell.parent;
  const table = tableRow.parent;
  const rowIndex = table.getChildIndex(tableRow);
  if (direction == "down" && rowIndex === tableUtils.getRows(table) - 1 || direction == "up" && rowIndex === 0) {
    return null;
  }
  const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
  const headingRows = table.getAttribute("headingRows") || 0;
  const isMergeWithBodyCell = direction == "down" && rowIndex + rowspan === headingRows;
  const isMergeWithHeadCell = direction == "up" && rowIndex === headingRows;
  if (headingRows && (isMergeWithBodyCell || isMergeWithHeadCell)) {
    return null;
  }
  const currentCellRowSpan = parseInt(tableCell.getAttribute("rowspan") || "1");
  const rowOfCellToMerge = direction == "down" ? rowIndex + currentCellRowSpan : rowIndex;
  const tableMap = [...new TableWalker(table, { endRow: rowOfCellToMerge })];
  const currentCellData = tableMap.find((value) => value.cell === tableCell);
  const mergeColumn = currentCellData.column;
  const cellToMergeData = tableMap.find(({ row, cellHeight, column }) => {
    if (column !== mergeColumn) {
      return false;
    }
    if (direction == "down") {
      return row === rowOfCellToMerge;
    } else {
      return rowOfCellToMerge === row + cellHeight;
    }
  });
  return cellToMergeData && cellToMergeData.cell ? cellToMergeData.cell : null;
}
function mergeTableCells(cellToRemove, cellToExpand, writer) {
  if (!isEmpty(cellToRemove)) {
    if (isEmpty(cellToExpand)) {
      writer.remove(writer.createRangeIn(cellToExpand));
    }
    writer.move(writer.createRangeIn(cellToRemove), writer.createPositionAt(cellToExpand, "end"));
  }
  writer.remove(cellToRemove);
}
function isEmpty(tableCell) {
  const firstTableChild = tableCell.getChild(0);
  return tableCell.childCount == 1 && firstTableChild.is("element", "paragraph") && firstTableChild.isEmpty;
}

// node_modules/@ckeditor/ckeditor5-table/src/commands/removerowcommand.js
var RemoveRowCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    const firstCell = selectedCells[0];
    if (firstCell) {
      const table = firstCell.findAncestor("table");
      const tableRowCount = tableUtils.getRows(table);
      const lastRowIndex = tableRowCount - 1;
      const selectedRowIndexes = tableUtils.getRowIndexes(selectedCells);
      const areAllRowsSelected = selectedRowIndexes.first === 0 && selectedRowIndexes.last === lastRowIndex;
      this.isEnabled = !areAllRowsSelected;
    } else {
      this.isEnabled = false;
    }
  }
  /**
   * @inheritDoc
   */
  execute() {
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const referenceCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const removedRowIndexes = tableUtils.getRowIndexes(referenceCells);
    const firstCell = referenceCells[0];
    const table = firstCell.findAncestor("table");
    const columnIndexToFocus = tableUtils.getCellLocation(firstCell).column;
    model.change((writer) => {
      const rowsToRemove = removedRowIndexes.last - removedRowIndexes.first + 1;
      tableUtils.removeRows(table, {
        at: removedRowIndexes.first,
        rows: rowsToRemove
      });
      const cellToFocus = getCellToFocus(table, removedRowIndexes.first, columnIndexToFocus, tableUtils.getRows(table));
      writer.setSelection(writer.createPositionAt(cellToFocus, 0));
    });
  }
};
function getCellToFocus(table, removedRowIndex, columnToFocus, tableRowCount) {
  const row = table.getChild(Math.min(removedRowIndex, tableRowCount - 1));
  let cellToFocus = row.getChild(0);
  let column = 0;
  for (const tableCell of row.getChildren()) {
    if (column > columnToFocus) {
      return cellToFocus;
    }
    cellToFocus = tableCell;
    column += parseInt(tableCell.getAttribute("colspan") || "1");
  }
  return cellToFocus;
}

// node_modules/@ckeditor/ckeditor5-table/src/commands/removecolumncommand.js
var RemoveColumnCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    const firstCell = selectedCells[0];
    if (firstCell) {
      const table = firstCell.findAncestor("table");
      const tableColumnCount = tableUtils.getColumns(table);
      const { first: first2, last } = tableUtils.getColumnIndexes(selectedCells);
      this.isEnabled = last - first2 < tableColumnCount - 1;
    } else {
      this.isEnabled = false;
    }
  }
  /**
   * @inheritDoc
   */
  execute() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const [firstCell, lastCell] = getBoundaryCells(this.editor.model.document.selection, tableUtils);
    const table = firstCell.parent.parent;
    const tableMap = [...new TableWalker(table)];
    const removedColumnIndexes = {
      first: tableMap.find((value) => value.cell === firstCell).column,
      last: tableMap.find((value) => value.cell === lastCell).column
    };
    const cellToFocus = getCellToFocus2(tableMap, firstCell, lastCell, removedColumnIndexes);
    this.editor.model.change((writer) => {
      const columnsToRemove = removedColumnIndexes.last - removedColumnIndexes.first + 1;
      tableUtils.removeColumns(table, {
        at: removedColumnIndexes.first,
        columns: columnsToRemove
      });
      writer.setSelection(writer.createPositionAt(cellToFocus, 0));
    });
  }
};
function getCellToFocus2(tableMap, firstCell, lastCell, removedColumnIndexes) {
  const colspan = parseInt(lastCell.getAttribute("colspan") || "1");
  if (colspan > 1) {
    return lastCell;
  } else if (firstCell.previousSibling || lastCell.nextSibling) {
    return lastCell.nextSibling || firstCell.previousSibling;
  } else {
    if (removedColumnIndexes.first) {
      return tableMap.reverse().find(({ column }) => {
        return column < removedColumnIndexes.first;
      }).cell;
    } else {
      return tableMap.reverse().find(({ column }) => {
        return column > removedColumnIndexes.last;
      }).cell;
    }
  }
}
function getBoundaryCells(selection, tableUtils) {
  const referenceCells = tableUtils.getSelectionAffectedTableCells(selection);
  const firstCell = referenceCells[0];
  const lastCell = referenceCells.pop();
  const returnValue = [firstCell, lastCell];
  return firstCell.isBefore(lastCell) ? returnValue : returnValue.reverse();
}

// node_modules/@ckeditor/ckeditor5-table/src/commands/setheaderrowcommand.js
var SetHeaderRowCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const model = this.editor.model;
    const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const isInTable = selectedCells.length > 0;
    this.isEnabled = isInTable;
    this.value = isInTable && selectedCells.every((cell) => this._isInHeading(cell, cell.parent.parent));
  }
  /**
   * Executes the command.
   *
   * When the selection is in a non-header row, the command will set the `headingRows` table attribute to cover that row.
   *
   * When the selection is already in a header row, it will set `headingRows` so the heading section will end before that row.
   *
   * @fires execute
   * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header rows according to
   * the `forceValue` parameter instead of the current model state.
   */
  execute(options = {}) {
    if (options.forceValue === this.value) {
      return;
    }
    const tableUtils = this.editor.plugins.get("TableUtils");
    const model = this.editor.model;
    const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const table = selectedCells[0].findAncestor("table");
    const { first: first2, last } = tableUtils.getRowIndexes(selectedCells);
    const headingRowsToSet = this.value ? first2 : last + 1;
    const currentHeadingRows = table.getAttribute("headingRows") || 0;
    model.change((writer) => {
      if (headingRowsToSet) {
        const startRow = headingRowsToSet > currentHeadingRows ? currentHeadingRows : 0;
        const overlappingCells = getVerticallyOverlappingCells(table, headingRowsToSet, startRow);
        for (const { cell } of overlappingCells) {
          splitHorizontally(cell, headingRowsToSet, writer);
        }
      }
      updateNumericAttribute("headingRows", headingRowsToSet, table, writer, 0);
    });
  }
  /**
   * Checks if a table cell is in the heading section.
   */
  _isInHeading(tableCell, table) {
    const headingRows = parseInt(table.getAttribute("headingRows") || "0");
    return !!headingRows && tableCell.parent.index < headingRows;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/commands/setheadercolumncommand.js
var SetHeaderColumnCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const isInTable = selectedCells.length > 0;
    this.isEnabled = isInTable;
    this.value = isInTable && selectedCells.every((cell) => isHeadingColumnCell(tableUtils, cell));
  }
  /**
   * Executes the command.
   *
   * When the selection is in a non-header column, the command will set the `headingColumns` table attribute to cover that column.
   *
   * When the selection is already in a header column, it will set `headingColumns` so the heading section will end before that column.
   *
   * @fires execute
   * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header columns according to
   * the `forceValue` parameter instead of the current model state.
   */
  execute(options = {}) {
    if (options.forceValue === this.value) {
      return;
    }
    const tableUtils = this.editor.plugins.get("TableUtils");
    const model = this.editor.model;
    const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const table = selectedCells[0].findAncestor("table");
    const { first: first2, last } = tableUtils.getColumnIndexes(selectedCells);
    const headingColumnsToSet = this.value ? first2 : last + 1;
    model.change((writer) => {
      if (headingColumnsToSet) {
        const overlappingCells = getHorizontallyOverlappingCells(table, headingColumnsToSet);
        for (const { cell, column } of overlappingCells) {
          splitVertically(cell, column, headingColumnsToSet, writer);
        }
      }
      updateNumericAttribute("headingColumns", headingColumnsToSet, table, writer, 0);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecolumnresize/constants.js
var COLUMN_MIN_WIDTH_AS_PERCENTAGE = 5;
var COLUMN_MIN_WIDTH_IN_PIXELS = 40;
var COLUMN_WIDTH_PRECISION = 2;

// node_modules/@ckeditor/ckeditor5-table/src/tablecolumnresize/utils.js
function getChangedResizedTables(model) {
  const affectedTables = /* @__PURE__ */ new Set();
  for (const change of model.document.differ.getChanges()) {
    let referencePosition = null;
    switch (change.type) {
      case "insert":
        referencePosition = ["table", "tableRow", "tableCell"].includes(change.name) ? change.position : null;
        break;
      case "remove":
        referencePosition = ["tableRow", "tableCell"].includes(change.name) ? change.position : null;
        break;
      case "attribute":
        if (change.range.start.nodeAfter) {
          referencePosition = ["table", "tableRow", "tableCell"].includes(change.range.start.nodeAfter.name) ? change.range.start : null;
        }
        break;
    }
    if (!referencePosition) {
      continue;
    }
    const tableNode = referencePosition.nodeAfter && referencePosition.nodeAfter.is("element", "table") ? referencePosition.nodeAfter : referencePosition.findAncestor("table");
    for (const node of model.createRangeOn(tableNode).getItems()) {
      if (!node.is("element", "table")) {
        continue;
      }
      if (!getColumnGroupElement(node)) {
        continue;
      }
      affectedTables.add(node);
    }
  }
  return affectedTables;
}
function getColumnMinWidthAsPercentage(modelTable, editor) {
  return COLUMN_MIN_WIDTH_IN_PIXELS * 100 / getTableWidthInPixels(modelTable, editor);
}
function getTableWidthInPixels(modelTable, editor) {
  const referenceElement = getChildrenViewElement(modelTable, "tbody", editor) || getChildrenViewElement(modelTable, "thead", editor);
  const domReferenceElement = editor.editing.view.domConverter.mapViewToDom(referenceElement);
  return getElementWidthInPixels(domReferenceElement);
}
function getChildrenViewElement(modelTable, elementName, editor) {
  const viewFigure = editor.editing.mapper.toViewElement(modelTable);
  const viewTable = [...viewFigure.getChildren()].find((node) => node.is("element", "table"));
  return [...viewTable.getChildren()].find((node) => node.is("element", elementName));
}
function getElementWidthInPixels(domElement) {
  const styles = global_default.window.getComputedStyle(domElement);
  if (styles.boxSizing === "border-box") {
    return parseFloat(styles.width) - parseFloat(styles.paddingLeft) - parseFloat(styles.paddingRight) - parseFloat(styles.borderLeftWidth) - parseFloat(styles.borderRightWidth);
  } else {
    return parseFloat(styles.width);
  }
}
function getColumnEdgesIndexes(cell, tableUtils) {
  const cellColumnIndex = tableUtils.getCellLocation(cell).column;
  const cellWidth = cell.getAttribute("colspan") || 1;
  return {
    leftEdge: cellColumnIndex,
    rightEdge: cellColumnIndex + cellWidth - 1
  };
}
function toPrecision(value) {
  const multiplier = Math.pow(10, COLUMN_WIDTH_PRECISION);
  const number = typeof value === "number" ? value : parseFloat(value);
  return Math.round(number * multiplier) / multiplier;
}
function clamp(number, min, max) {
  if (number <= min) {
    return toPrecision(min);
  }
  if (number >= max) {
    return toPrecision(max);
  }
  return toPrecision(number);
}
function createFilledArray(length, value) {
  return Array(length).fill(value);
}
function sumArray(array) {
  return array.map((value) => typeof value === "number" ? value : parseFloat(value)).filter((value) => !Number.isNaN(value)).reduce((result, item) => result + item, 0);
}
function normalizeColumnWidths(columnWidths) {
  const widths = columnWidths.map((width) => {
    if (width === "auto") {
      return width;
    }
    return parseFloat(width.replace("%", ""));
  });
  let normalizedWidths = calculateMissingColumnWidths(widths);
  const totalWidth = sumArray(normalizedWidths);
  if (totalWidth !== 100) {
    normalizedWidths = normalizedWidths.map((width) => toPrecision(width * 100 / totalWidth)).map((columnWidth, columnIndex, width) => {
      const isLastColumn = columnIndex === width.length - 1;
      if (!isLastColumn) {
        return columnWidth;
      }
      const totalWidth2 = sumArray(width);
      return toPrecision(columnWidth + 100 - totalWidth2);
    });
  }
  return normalizedWidths.map((width) => width + "%");
}
function calculateMissingColumnWidths(columnWidths) {
  const numberOfUninitializedColumns = columnWidths.filter((columnWidth) => columnWidth === "auto").length;
  if (numberOfUninitializedColumns === 0) {
    return columnWidths.map((columnWidth) => toPrecision(columnWidth));
  }
  const totalWidthOfInitializedColumns = sumArray(columnWidths);
  const widthForUninitializedColumn = Math.max((100 - totalWidthOfInitializedColumns) / numberOfUninitializedColumns, COLUMN_MIN_WIDTH_AS_PERCENTAGE);
  return columnWidths.map((columnWidth) => columnWidth === "auto" ? widthForUninitializedColumn : columnWidth).map((columnWidth) => toPrecision(columnWidth));
}
function getDomCellOuterWidth(domCell) {
  const styles = global_default.window.getComputedStyle(domCell);
  if (styles.boxSizing === "border-box") {
    return parseInt(styles.width);
  } else {
    return parseFloat(styles.width) + parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight) + parseFloat(styles.borderWidth);
  }
}
function updateColumnElements(columns, tableColumnGroup, normalizedWidths, writer) {
  for (let i = 0; i < Math.max(normalizedWidths.length, columns.length); i++) {
    const column = columns[i];
    const columnWidth = normalizedWidths[i];
    if (!columnWidth) {
      writer.remove(column);
    } else if (!column) {
      writer.appendElement("tableColumn", { columnWidth }, tableColumnGroup);
    } else {
      writer.setAttribute("columnWidth", columnWidth, column);
    }
  }
}
function getColumnGroupElement(element) {
  if (element.is("element", "tableColumnGroup")) {
    return element;
  }
  const children = element.getChildren();
  return Array.from(children).find((element2) => element2.is("element", "tableColumnGroup"));
}
function getTableColumnElements(element) {
  const columnGroupElement = getColumnGroupElement(element);
  if (!columnGroupElement) {
    return [];
  }
  return Array.from(columnGroupElement.getChildren());
}
function getTableColumnsWidths(element) {
  return getTableColumnElements(element).map((column) => column.getAttribute("columnWidth"));
}
function translateColSpanAttribute(element, writer) {
  const tableColumnElements = getTableColumnElements(element);
  return tableColumnElements.reduce((acc, element2) => {
    const columnWidth = element2.getAttribute("columnWidth");
    const colSpan = element2.getAttribute("colSpan");
    if (!colSpan) {
      acc.push(columnWidth);
      return acc;
    }
    for (let i = 0; i < colSpan; i++) {
      acc.push(columnWidth);
    }
    writer.removeAttribute("colSpan", element2);
    return acc;
  }, []);
}

// node_modules/@ckeditor/ckeditor5-table/src/tableutils.js
var TableUtils = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableUtils";
  }
  /**
   * @inheritDoc
   */
  init() {
    this.decorate("insertColumns");
    this.decorate("insertRows");
  }
  /**
   * Returns the table cell location as an object with table row and table column indexes.
   *
   * For instance, in the table below:
   *
   *      0   1   2   3
   *    +---+---+---+---+
   *  0 | a     | b | c |
   *    +       +   +---+
   *  1 |       |   | d |
   *    +---+---+   +---+
   *  2 | e     |   | f |
   *    +---+---+---+---+
   *
   * the method will return:
   *
   * ```ts
   * const cellA = table.getNodeByPath( [ 0, 0 ] );
   * editor.plugins.get( 'TableUtils' ).getCellLocation( cellA );
   * // will return { row: 0, column: 0 }
   *
   * const cellD = table.getNodeByPath( [ 1, 0 ] );
   * editor.plugins.get( 'TableUtils' ).getCellLocation( cellD );
   * // will return { row: 1, column: 3 }
   * ```
   *
   * @returns Returns a `{row, column}` object.
   */
  getCellLocation(tableCell) {
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const rowIndex = table.getChildIndex(tableRow);
    const tableWalker = new TableWalker(table, { row: rowIndex });
    for (const { cell, row, column } of tableWalker) {
      if (cell === tableCell) {
        return { row, column };
      }
    }
    return void 0;
  }
  /**
   * Creates an empty table with a proper structure. The table needs to be inserted into the model,
   * for example, by using the {@link module:engine/model/model~Model#insertContent} function.
   *
   * ```ts
   * model.change( ( writer ) => {
   *   // Create a table of 2 rows and 7 columns:
   *   const table = tableUtils.createTable( writer, { rows: 2, columns: 7 } );
   *
   *   // Insert a table to the model at the best position taking the current selection:
   *   model.insertContent( table );
   * }
   * ```
   *
   * @param writer The model writer.
   * @param options.rows The number of rows to create. Default value is 2.
   * @param options.columns The number of columns to create. Default value is 2.
   * @param options.headingRows The number of heading rows. Default value is 0.
   * @param options.headingColumns The number of heading columns. Default value is 0.
   * @returns The created table element.
   */
  createTable(writer, options) {
    const table = writer.createElement("table");
    const rows = options.rows || 2;
    const columns = options.columns || 2;
    createEmptyRows(writer, table, 0, rows, columns);
    if (options.headingRows) {
      updateNumericAttribute("headingRows", Math.min(options.headingRows, rows), table, writer, 0);
    }
    if (options.headingColumns) {
      updateNumericAttribute("headingColumns", Math.min(options.headingColumns, columns), table, writer, 0);
    }
    return table;
  }
  /**
   * Inserts rows into a table.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );
   * ```
   *
   * Assuming the table on the left, the above code will transform it to the table on the right:
   *
   *  row index
   *    0 +---+---+---+       `at` = 1,      +---+---+---+ 0
   *      | a | b | c |       `rows` = 2,    | a | b | c |
   *    1 +   +---+---+   <-- insert here    +   +---+---+ 1
   *      |   | d | e |                      |   |   |   |
   *    2 +   +---+---+       will give:     +   +---+---+ 2
   *      |   | f | g |                      |   |   |   |
   *    3 +---+---+---+                      +   +---+---+ 3
   *                                         |   | d | e |
   *                                         +   +---+---+ 4
   *                                         +   + f | g |
   *                                         +---+---+---+ 5
   *
   * @param table The table model element where the rows will be inserted.
   * @param options.at The row index at which the rows will be inserted.  Default value is 0.
   * @param options.rows The number of rows to insert.  Default value is 1.
   * @param options.copyStructureFromAbove The flag for copying row structure. Note that
   * the row structure will not be copied if this option is not provided.
   */
  insertRows(table, options = {}) {
    const model = this.editor.model;
    const insertAt = options.at || 0;
    const rowsToInsert = options.rows || 1;
    const isCopyStructure = options.copyStructureFromAbove !== void 0;
    const copyStructureFrom = options.copyStructureFromAbove ? insertAt - 1 : insertAt;
    const rows = this.getRows(table);
    const columns = this.getColumns(table);
    if (insertAt > rows) {
      throw new CKEditorError("tableutils-insertrows-insert-out-of-range", this, { options });
    }
    model.change((writer) => {
      const headingRows = table.getAttribute("headingRows") || 0;
      if (headingRows > insertAt) {
        updateNumericAttribute("headingRows", headingRows + rowsToInsert, table, writer, 0);
      }
      if (!isCopyStructure && (insertAt === 0 || insertAt === rows)) {
        createEmptyRows(writer, table, insertAt, rowsToInsert, columns);
        return;
      }
      const walkerEndRow = isCopyStructure ? Math.max(insertAt, copyStructureFrom) : insertAt;
      const tableIterator = new TableWalker(table, { endRow: walkerEndRow });
      const rowColSpansMap = new Array(columns).fill(1);
      for (const { row, column, cellHeight, cellWidth, cell } of tableIterator) {
        const lastCellRow = row + cellHeight - 1;
        const isOverlappingInsertedRow = row < insertAt && insertAt <= lastCellRow;
        const isReferenceRow = row <= copyStructureFrom && copyStructureFrom <= lastCellRow;
        if (isOverlappingInsertedRow) {
          writer.setAttribute("rowspan", cellHeight + rowsToInsert, cell);
          rowColSpansMap[column] = -cellWidth;
        } else if (isCopyStructure && isReferenceRow) {
          rowColSpansMap[column] = cellWidth;
        }
      }
      for (let rowIndex = 0; rowIndex < rowsToInsert; rowIndex++) {
        const tableRow = writer.createElement("tableRow");
        writer.insert(tableRow, table, insertAt);
        for (let cellIndex = 0; cellIndex < rowColSpansMap.length; cellIndex++) {
          const colspan = rowColSpansMap[cellIndex];
          const insertPosition = writer.createPositionAt(tableRow, "end");
          if (colspan > 0) {
            createEmptyTableCell(writer, insertPosition, colspan > 1 ? { colspan } : void 0);
          }
          cellIndex += Math.abs(colspan) - 1;
        }
      }
    });
  }
  /**
   * Inserts columns into a table.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );
   * ```
   *
   * Assuming the table on the left, the above code will transform it to the table on the right:
   *
   *  0   1   2   3                   0   1   2   3   4   5
   *  +---+---+---+                   +---+---+---+---+---+
   *  | a     | b |                   | a             | b |
   *  +       +---+                   +               +---+
   *  |       | c |                   |               | c |
   *  +---+---+---+     will give:    +---+---+---+---+---+
   *  | d | e | f |                   | d |   |   | e | f |
   *  +---+   +---+                   +---+---+---+   +---+
   *  | g |   | h |                   | g |   |   |   | h |
   *  +---+---+---+                   +---+---+---+---+---+
   *  | i         |                   | i                 |
   *  +---+---+---+                   +---+---+---+---+---+
   *      ^---- insert here, `at` = 1, `columns` = 2
   *
   * @param table The table model element where the columns will be inserted.
   * @param options.at The column index at which the columns will be inserted. Default value is 0.
   * @param options.columns The number of columns to insert. Default value is 1.
   */
  insertColumns(table, options = {}) {
    const model = this.editor.model;
    const insertAt = options.at || 0;
    const columnsToInsert = options.columns || 1;
    model.change((writer) => {
      const headingColumns = table.getAttribute("headingColumns");
      if (insertAt < headingColumns) {
        writer.setAttribute("headingColumns", headingColumns + columnsToInsert, table);
      }
      const tableColumns = this.getColumns(table);
      if (insertAt === 0 || tableColumns === insertAt) {
        for (const tableRow of table.getChildren()) {
          if (!tableRow.is("element", "tableRow")) {
            continue;
          }
          createCells(columnsToInsert, writer, writer.createPositionAt(tableRow, insertAt ? "end" : 0));
        }
        return;
      }
      const tableWalker = new TableWalker(table, { column: insertAt, includeAllSlots: true });
      for (const tableSlot of tableWalker) {
        const { row, cell, cellAnchorColumn, cellAnchorRow, cellWidth, cellHeight } = tableSlot;
        if (cellAnchorColumn < insertAt) {
          writer.setAttribute("colspan", cellWidth + columnsToInsert, cell);
          const lastCellRow = cellAnchorRow + cellHeight - 1;
          for (let i = row; i <= lastCellRow; i++) {
            tableWalker.skipRow(i);
          }
        } else {
          createCells(columnsToInsert, writer, tableSlot.getPositionBefore());
        }
      }
    });
  }
  /**
   * Removes rows from the given `table`.
   *
   * This method re-calculates the table geometry including `rowspan` attribute of table cells overlapping removed rows
   * and table headings values.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).removeRows( table, { at: 1, rows: 2 } );
   * ```
   *
   * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
   *
   *  row index
   *              `at` = 1        
   *    0  a  b  c         `rows` = 2       a  b  c  0
   *                                    
   *    1     d  e   <-- remove from here      d  g  1
   *                    will give:      
   *    2        f                          h  i  j  2
   *                                    
   *    3        g 
   *      
   *    4  h  i  j 
   *      
   *
   * @param options.at The row index at which the removing rows will start.
   * @param options.rows The number of rows to remove. Default value is 1.
   */
  removeRows(table, options) {
    const model = this.editor.model;
    const rowsToRemove = options.rows || 1;
    const rowCount = this.getRows(table);
    const first2 = options.at;
    const last = first2 + rowsToRemove - 1;
    if (last > rowCount - 1) {
      throw new CKEditorError("tableutils-removerows-row-index-out-of-range", this, { table, options });
    }
    model.change((writer) => {
      const indexesObject = { first: first2, last };
      const { cellsToMove, cellsToTrim } = getCellsToMoveAndTrimOnRemoveRow(table, indexesObject);
      if (cellsToMove.size) {
        const rowAfterRemovedSection = last + 1;
        moveCellsToRow(table, rowAfterRemovedSection, cellsToMove, writer);
      }
      for (let i = last; i >= first2; i--) {
        writer.remove(table.getChild(i));
      }
      for (const { rowspan, cell } of cellsToTrim) {
        updateNumericAttribute("rowspan", rowspan, cell, writer);
      }
      updateHeadingRows(table, indexesObject, writer);
      if (!removeEmptyColumns(table, this)) {
        removeEmptyRows(table, this);
      }
    });
  }
  /**
   * Removes columns from the given `table`.
   *
   * This method re-calculates the table geometry including the `colspan` attribute of table cells overlapping removed columns
   * and table headings values.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).removeColumns( table, { at: 1, columns: 2 } );
   * ```
   *
   * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
   *
   *    0   1   2   3   4                       0   1   2
   *                     
   *   a              b                     a      b 
   *                                           
   *                  c                            c 
   *       will give:    
   *   d  e  f  g  h                     d  g  h 
   *                           
   *   i  j  k     l                     i     l 
   *                     
   *   m                                     m         
   *                     
   *        ^---- remove from here, `at` = 1, `columns` = 2
   *
   * @param options.at The row index at which the removing columns will start.
   * @param options.columns The number of columns to remove.
   */
  removeColumns(table, options) {
    const model = this.editor.model;
    const first2 = options.at;
    const columnsToRemove = options.columns || 1;
    const last = options.at + columnsToRemove - 1;
    model.change((writer) => {
      adjustHeadingColumns(table, { first: first2, last }, writer);
      const tableColumns = getTableColumnElements(table);
      for (let removedColumnIndex = last; removedColumnIndex >= first2; removedColumnIndex--) {
        for (const { cell, column, cellWidth } of [...new TableWalker(table)]) {
          if (column <= removedColumnIndex && cellWidth > 1 && column + cellWidth > removedColumnIndex) {
            updateNumericAttribute("colspan", cellWidth - 1, cell, writer);
          } else if (column === removedColumnIndex) {
            writer.remove(cell);
          }
        }
        if (tableColumns[removedColumnIndex]) {
          const adjacentColumn = removedColumnIndex === 0 ? tableColumns[1] : tableColumns[removedColumnIndex - 1];
          const removedColumnWidth = parseFloat(tableColumns[removedColumnIndex].getAttribute("columnWidth"));
          const adjacentColumnWidth = parseFloat(adjacentColumn.getAttribute("columnWidth"));
          writer.remove(tableColumns[removedColumnIndex]);
          writer.setAttribute("columnWidth", removedColumnWidth + adjacentColumnWidth + "%", adjacentColumn);
        }
      }
      if (!removeEmptyRows(table, this)) {
        removeEmptyColumns(table, this);
      }
    });
  }
  /**
   * Divides a table cell vertically into several ones.
   *
   * The cell will be visually split into more cells by updating colspans of other cells in a column
   * and inserting cells (columns) after that cell.
   *
   * In the table below, if cell "a" is split into 3 cells:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +---+---+---+
   *  | d | e | f |
   *  +---+---+---+
   *
   * it will result in the table below:
   *
   *  +---+---+---+---+---+
   *  | a |   |   | b | c |
   *  +---+---+---+---+---+
   *  | d         | e | f |
   *  +---+---+---+---+---+
   *
   * So cell "d" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).
   *
   * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder
   * will be left to the original cell:
   *
   *  +---+---+---+
   *  | a         |
   *  +---+---+---+
   *  | b | c | d |
   *  +---+---+---+
   *
   * Splitting cell "a" with `colspan=3` into 2 cells will create 1 cell with a `colspan=a` and cell "a" that will have `colspan=2`:
   *
   *  +---+---+---+
   *  | a     |   |
   *  +---+---+---+
   *  | b | c | d |
   *  +---+---+---+
   */
  splitCellVertically(tableCell, numberOfCells = 2) {
    const model = this.editor.model;
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
    const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
    model.change((writer) => {
      if (colspan > 1) {
        const { newCellsSpan, updatedSpan } = breakSpanEvenly(colspan, numberOfCells);
        updateNumericAttribute("colspan", updatedSpan, tableCell, writer);
        const newCellsAttributes = {};
        if (newCellsSpan > 1) {
          newCellsAttributes.colspan = newCellsSpan;
        }
        if (rowspan > 1) {
          newCellsAttributes.rowspan = rowspan;
        }
        const cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;
        createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);
      }
      if (colspan < numberOfCells) {
        const cellsToInsert = numberOfCells - colspan;
        const tableMap = [...new TableWalker(table)];
        const { column: splitCellColumn } = tableMap.find(({ cell }) => cell === tableCell);
        const cellsToUpdate = tableMap.filter(({ cell, cellWidth, column }) => {
          const isOnSameColumn = cell !== tableCell && column === splitCellColumn;
          const spansOverColumn = column < splitCellColumn && column + cellWidth > splitCellColumn;
          return isOnSameColumn || spansOverColumn;
        });
        for (const { cell, cellWidth } of cellsToUpdate) {
          writer.setAttribute("colspan", cellWidth + cellsToInsert, cell);
        }
        const newCellsAttributes = {};
        if (rowspan > 1) {
          newCellsAttributes.rowspan = rowspan;
        }
        createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);
        const headingColumns = table.getAttribute("headingColumns") || 0;
        if (headingColumns > splitCellColumn) {
          updateNumericAttribute("headingColumns", headingColumns + cellsToInsert, table, writer);
        }
      }
    });
  }
  /**
   * Divides a table cell horizontally into several ones.
   *
   * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell
   * below.
   *
   * If in the table below cell "b" is split into 3 cells:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +---+---+---+
   *  | d | e | f |
   *  +---+---+---+
   *
   * It will result in the table below:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +   +---+   +
   *  |   |   |   |
   *  +   +---+   +
   *  |   |   |   |
   *  +---+---+---+
   *  | d | e | f |
   *  +---+---+---+
   *
   * So cells "a" and "b" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.
   *
   * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder
   * will be left to the original cell:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +   +---+---+
   *  |   | d | e |
   *  +   +---+---+
   *  |   | f | g |
   *  +   +---+---+
   *  |   | h | i |
   *  +---+---+---+
   *
   * Splitting cell "a" with `rowspan=4` into 3 cells will create 2 cells with a `rowspan=1` and cell "a" will have `rowspan=2`:
   *
   *  +---+---+---+
   *  | a | b | c |
   *  +   +---+---+
   *  |   | d | e |
   *  +---+---+---+
   *  |   | f | g |
   *  +---+---+---+
   *  |   | h | i |
   *  +---+---+---+
   */
  splitCellHorizontally(tableCell, numberOfCells = 2) {
    const model = this.editor.model;
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const splitCellRow = table.getChildIndex(tableRow);
    const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
    const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
    model.change((writer) => {
      if (rowspan > 1) {
        const tableMap = [...new TableWalker(table, {
          startRow: splitCellRow,
          endRow: splitCellRow + rowspan - 1,
          includeAllSlots: true
        })];
        const { newCellsSpan, updatedSpan } = breakSpanEvenly(rowspan, numberOfCells);
        updateNumericAttribute("rowspan", updatedSpan, tableCell, writer);
        const { column: cellColumn } = tableMap.find(({ cell }) => cell === tableCell);
        const newCellsAttributes = {};
        if (newCellsSpan > 1) {
          newCellsAttributes.rowspan = newCellsSpan;
        }
        if (colspan > 1) {
          newCellsAttributes.colspan = colspan;
        }
        for (const tableSlot of tableMap) {
          const { column, row } = tableSlot;
          const isAfterSplitCell = row >= splitCellRow + updatedSpan;
          const isOnSameColumn = column === cellColumn;
          const isInEvenlySplitRow = (row + splitCellRow + updatedSpan) % newCellsSpan === 0;
          if (isAfterSplitCell && isOnSameColumn && isInEvenlySplitRow) {
            createCells(1, writer, tableSlot.getPositionBefore(), newCellsAttributes);
          }
        }
      }
      if (rowspan < numberOfCells) {
        const cellsToInsert = numberOfCells - rowspan;
        const tableMap = [...new TableWalker(table, { startRow: 0, endRow: splitCellRow })];
        for (const { cell, cellHeight, row } of tableMap) {
          if (cell !== tableCell && row + cellHeight > splitCellRow) {
            const rowspanToSet = cellHeight + cellsToInsert;
            writer.setAttribute("rowspan", rowspanToSet, cell);
          }
        }
        const newCellsAttributes = {};
        if (colspan > 1) {
          newCellsAttributes.colspan = colspan;
        }
        createEmptyRows(writer, table, splitCellRow + 1, cellsToInsert, 1, newCellsAttributes);
        const headingRows = table.getAttribute("headingRows") || 0;
        if (headingRows > splitCellRow) {
          updateNumericAttribute("headingRows", headingRows + cellsToInsert, table, writer);
        }
      }
    });
  }
  /**
   * Returns the number of columns for a given table.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).getColumns( table );
   * ```
   *
   * @param table The table to analyze.
   */
  getColumns(table) {
    const row = table.getChild(0);
    return [...row.getChildren()].reduce((columns, row2) => {
      const columnWidth = parseInt(row2.getAttribute("colspan") || "1");
      return columns + columnWidth;
    }, 0);
  }
  /**
   * Returns the number of rows for a given table. Any other element present in the table model is omitted.
   *
   * ```ts
   * editor.plugins.get( 'TableUtils' ).getRows( table );
   * ```
   *
   * @param table The table to analyze.
   */
  getRows(table) {
    return Array.from(table.getChildren()).reduce((rowCount, child) => child.is("element", "tableRow") ? rowCount + 1 : rowCount, 0);
  }
  /**
   * Creates an instance of the table walker.
   *
   * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
   * It walks row by row and column by column in order to output values defined in the options.
   * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
   * pass the `includeAllSlots` option.
   *
   * @internal
   * @param table A table over which the walker iterates.
   * @param options An object with configuration.
   */
  createTableWalker(table, options = {}) {
    return new TableWalker(table, options);
  }
  /**
   * Returns all model table cells that are fully selected (from the outside)
   * within the provided model selection's ranges.
   *
   * To obtain the cells selected from the inside, use
   * {@link #getTableCellsContainingSelection}.
   */
  getSelectedTableCells(selection) {
    const cells = [];
    for (const range of this.sortRanges(selection.getRanges())) {
      const element = range.getContainedElement();
      if (element && element.is("element", "tableCell")) {
        cells.push(element);
      }
    }
    return cells;
  }
  /**
   * Returns all model table cells that the provided model selection's ranges
   * {@link module:engine/model/range~Range#start} inside.
   *
   * To obtain the cells selected from the outside, use
   * {@link #getSelectedTableCells}.
   */
  getTableCellsContainingSelection(selection) {
    const cells = [];
    for (const range of selection.getRanges()) {
      const cellWithSelection = range.start.findAncestor("tableCell");
      if (cellWithSelection) {
        cells.push(cellWithSelection);
      }
    }
    return cells;
  }
  /**
   * Returns all model table cells that are either completely selected
   * by selection ranges or host selection range
   * {@link module:engine/model/range~Range#start start positions} inside them.
   *
   * Combines {@link #getTableCellsContainingSelection} and
   * {@link #getSelectedTableCells}.
   */
  getSelectionAffectedTableCells(selection) {
    const selectedCells = this.getSelectedTableCells(selection);
    if (selectedCells.length) {
      return selectedCells;
    }
    return this.getTableCellsContainingSelection(selection);
  }
  /**
   * Returns an object with the `first` and `last` row index contained in the given `tableCells`.
   *
   * ```ts
   * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
   *
   * const { first, last } = getRowIndexes( selectedTableCells );
   *
   * console.log( `Selected rows: ${ first } to ${ last }` );
   * ```
   *
   * @returns Returns an object with the `first` and `last` table row indexes.
   */
  getRowIndexes(tableCells) {
    const indexes = tableCells.map((cell) => cell.parent.index);
    return this._getFirstLastIndexesObject(indexes);
  }
  /**
   * Returns an object with the `first` and `last` column index contained in the given `tableCells`.
   *
   * ```ts
   * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
   *
   * const { first, last } = getColumnIndexes( selectedTableCells );
   *
   * console.log( `Selected columns: ${ first } to ${ last }` );
   * ```
   *
   * @returns Returns an object with the `first` and `last` table column indexes.
   */
  getColumnIndexes(tableCells) {
    const table = tableCells[0].findAncestor("table");
    const tableMap = [...new TableWalker(table)];
    const indexes = tableMap.filter((entry) => tableCells.includes(entry.cell)).map((entry) => entry.column);
    return this._getFirstLastIndexesObject(indexes);
  }
  /**
   * Checks if the selection contains cells that do not exceed rectangular selection.
   *
   * In a table below:
   *
   *  
   *   a  b  c  d 
   *     
   *   e      f    
   *         
   *          g  h 
   *  
   *
   * Valid selections are these which create a solid rectangle (without gaps), such as:
   *   - a, b (two horizontal cells)
   *   - c, f (two vertical cells)
   *   - a, b, e (cell "e" spans over four cells)
   *   - c, d, f (cell d spans over a cell in the row below)
   *
   * While an invalid selection would be:
   *   - a, c (the unselected cell "b" creates a gap)
   *   - f, g, h (cell "d" spans over a cell from the row of "f" cell - thus creates a gap)
   */
  isSelectionRectangular(selectedTableCells) {
    if (selectedTableCells.length < 2 || !this._areCellInTheSameTableSection(selectedTableCells)) {
      return false;
    }
    const rows = /* @__PURE__ */ new Set();
    const columns = /* @__PURE__ */ new Set();
    let areaOfSelectedCells = 0;
    for (const tableCell of selectedTableCells) {
      const { row, column } = this.getCellLocation(tableCell);
      const rowspan = parseInt(tableCell.getAttribute("rowspan")) || 1;
      const colspan = parseInt(tableCell.getAttribute("colspan")) || 1;
      rows.add(row);
      columns.add(column);
      if (rowspan > 1) {
        rows.add(row + rowspan - 1);
      }
      if (colspan > 1) {
        columns.add(column + colspan - 1);
      }
      areaOfSelectedCells += rowspan * colspan;
    }
    const areaOfValidSelection = getBiggestRectangleArea(rows, columns);
    return areaOfValidSelection == areaOfSelectedCells;
  }
  /**
   * Returns array of sorted ranges.
   */
  sortRanges(ranges) {
    return Array.from(ranges).sort(compareRangeOrder);
  }
  /**
   * Helper method to get an object with `first` and `last` indexes from an unsorted array of indexes.
   */
  _getFirstLastIndexesObject(indexes) {
    const allIndexesSorted = indexes.sort((indexA, indexB) => indexA - indexB);
    const first2 = allIndexesSorted[0];
    const last = allIndexesSorted[allIndexesSorted.length - 1];
    return { first: first2, last };
  }
  /**
   * Checks if the selection does not mix a header (column or row) with other cells.
   *
   * For instance, in the table below valid selections consist of cells with the same letter only.
   * So, a-a (same heading row and column) or d-d (body cells) are valid while c-d or a-b are not.
   *
   * header columns
   *       
   *  
   *   a  a  b  b    header row
   *  
   *   c  c  d  d 
   *  
   *   c  c  d  d 
   *  
   */
  _areCellInTheSameTableSection(tableCells) {
    const table = tableCells[0].findAncestor("table");
    const rowIndexes = this.getRowIndexes(tableCells);
    const headingRows = parseInt(table.getAttribute("headingRows")) || 0;
    if (!this._areIndexesInSameSection(rowIndexes, headingRows)) {
      return false;
    }
    const columnIndexes = this.getColumnIndexes(tableCells);
    const headingColumns = parseInt(table.getAttribute("headingColumns")) || 0;
    return this._areIndexesInSameSection(columnIndexes, headingColumns);
  }
  /**
   * Unified check if table rows/columns indexes are in the same heading/body section.
   */
  _areIndexesInSameSection({ first: first2, last }, headingSectionSize) {
    const firstCellIsInHeading = first2 < headingSectionSize;
    const lastCellIsInHeading = last < headingSectionSize;
    return firstCellIsInHeading === lastCellIsInHeading;
  }
};
function createEmptyRows(writer, table, insertAt, rows, tableCellToInsert, attributes = {}) {
  for (let i = 0; i < rows; i++) {
    const tableRow = writer.createElement("tableRow");
    writer.insert(tableRow, table, insertAt);
    createCells(tableCellToInsert, writer, writer.createPositionAt(tableRow, "end"), attributes);
  }
}
function createCells(cells, writer, insertPosition, attributes = {}) {
  for (let i = 0; i < cells; i++) {
    createEmptyTableCell(writer, insertPosition, attributes);
  }
}
function breakSpanEvenly(span, numberOfCells) {
  if (span < numberOfCells) {
    return { newCellsSpan: 1, updatedSpan: 1 };
  }
  const newCellsSpan = Math.floor(span / numberOfCells);
  const updatedSpan = span - newCellsSpan * numberOfCells + newCellsSpan;
  return { newCellsSpan, updatedSpan };
}
function adjustHeadingColumns(table, removedColumnIndexes, writer) {
  const headingColumns = table.getAttribute("headingColumns") || 0;
  if (headingColumns && removedColumnIndexes.first < headingColumns) {
    const headingsRemoved = Math.min(headingColumns - 1, removedColumnIndexes.last) - removedColumnIndexes.first + 1;
    writer.setAttribute("headingColumns", headingColumns - headingsRemoved, table);
  }
}
function updateHeadingRows(table, { first: first2, last }, writer) {
  const headingRows = table.getAttribute("headingRows") || 0;
  if (first2 < headingRows) {
    const newRows = last < headingRows ? headingRows - (last - first2 + 1) : first2;
    updateNumericAttribute("headingRows", newRows, table, writer, 0);
  }
}
function getCellsToMoveAndTrimOnRemoveRow(table, { first: first2, last }) {
  const cellsToMove = /* @__PURE__ */ new Map();
  const cellsToTrim = [];
  for (const { row, column, cellHeight, cell } of new TableWalker(table, { endRow: last })) {
    const lastRowOfCell = row + cellHeight - 1;
    const isCellStickingOutFromRemovedRows = row >= first2 && row <= last && lastRowOfCell > last;
    if (isCellStickingOutFromRemovedRows) {
      const rowspanInRemovedSection = last - row + 1;
      const rowSpanToSet = cellHeight - rowspanInRemovedSection;
      cellsToMove.set(column, {
        cell,
        rowspan: rowSpanToSet
      });
    }
    const isCellOverlappingRemovedRows = row < first2 && lastRowOfCell >= first2;
    if (isCellOverlappingRemovedRows) {
      let rowspanAdjustment;
      if (lastRowOfCell >= last) {
        rowspanAdjustment = last - first2 + 1;
      } else {
        rowspanAdjustment = lastRowOfCell - first2 + 1;
      }
      cellsToTrim.push({
        cell,
        rowspan: cellHeight - rowspanAdjustment
      });
    }
  }
  return { cellsToMove, cellsToTrim };
}
function moveCellsToRow(table, targetRowIndex, cellsToMove, writer) {
  const tableWalker = new TableWalker(table, {
    includeAllSlots: true,
    row: targetRowIndex
  });
  const tableRowMap = [...tableWalker];
  const row = table.getChild(targetRowIndex);
  let previousCell;
  for (const { column, cell, isAnchor } of tableRowMap) {
    if (cellsToMove.has(column)) {
      const { cell: cellToMove, rowspan } = cellsToMove.get(column);
      const targetPosition = previousCell ? writer.createPositionAfter(previousCell) : writer.createPositionAt(row, 0);
      writer.move(writer.createRangeOn(cellToMove), targetPosition);
      updateNumericAttribute("rowspan", rowspan, cellToMove, writer);
      previousCell = cellToMove;
    } else if (isAnchor) {
      previousCell = cell;
    }
  }
}
function compareRangeOrder(rangeA, rangeB) {
  const posA = rangeA.start;
  const posB = rangeB.start;
  return posA.isBefore(posB) ? -1 : 1;
}
function getBiggestRectangleArea(rows, columns) {
  const rowsIndexes = Array.from(rows.values());
  const columnIndexes = Array.from(columns.values());
  const lastRow = Math.max(...rowsIndexes);
  const firstRow = Math.min(...rowsIndexes);
  const lastColumn = Math.max(...columnIndexes);
  const firstColumn = Math.min(...columnIndexes);
  return (lastRow - firstRow + 1) * (lastColumn - firstColumn + 1);
}

// node_modules/@ckeditor/ckeditor5-table/src/commands/mergecellscommand.js
var MergeCellsCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const selectedTableCells = tableUtils.getSelectedTableCells(this.editor.model.document.selection);
    this.isEnabled = tableUtils.isSelectionRectangular(selectedTableCells);
  }
  /**
   * Executes the command.
   *
   * @fires execute
   */
  execute() {
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get(TableUtils);
    model.change((writer) => {
      const selectedTableCells = tableUtils.getSelectedTableCells(model.document.selection);
      const firstTableCell = selectedTableCells.shift();
      const { mergeWidth, mergeHeight } = getMergeDimensions(firstTableCell, selectedTableCells, tableUtils);
      updateNumericAttribute("colspan", mergeWidth, firstTableCell, writer);
      updateNumericAttribute("rowspan", mergeHeight, firstTableCell, writer);
      for (const tableCell of selectedTableCells) {
        mergeTableCells2(tableCell, firstTableCell, writer);
      }
      const table = firstTableCell.findAncestor("table");
      removeEmptyRowsColumns(table, tableUtils);
      writer.setSelection(firstTableCell, "in");
    });
  }
};
function mergeTableCells2(cellBeingMerged, targetCell, writer) {
  if (!isEmpty2(cellBeingMerged)) {
    if (isEmpty2(targetCell)) {
      writer.remove(writer.createRangeIn(targetCell));
    }
    writer.move(writer.createRangeIn(cellBeingMerged), writer.createPositionAt(targetCell, "end"));
  }
  writer.remove(cellBeingMerged);
}
function isEmpty2(tableCell) {
  const firstTableChild = tableCell.getChild(0);
  return tableCell.childCount == 1 && firstTableChild.is("element", "paragraph") && firstTableChild.isEmpty;
}
function getMergeDimensions(firstTableCell, selectedTableCells, tableUtils) {
  let maxWidthOffset = 0;
  let maxHeightOffset = 0;
  for (const tableCell of selectedTableCells) {
    const { row, column } = tableUtils.getCellLocation(tableCell);
    maxWidthOffset = getMaxOffset(tableCell, column, maxWidthOffset, "colspan");
    maxHeightOffset = getMaxOffset(tableCell, row, maxHeightOffset, "rowspan");
  }
  const { row: firstCellRow, column: firstCellColumn } = tableUtils.getCellLocation(firstTableCell);
  const mergeWidth = maxWidthOffset - firstCellColumn;
  const mergeHeight = maxHeightOffset - firstCellRow;
  return { mergeWidth, mergeHeight };
}
function getMaxOffset(tableCell, start, currentMaxOffset, which) {
  const dimensionValue = parseInt(tableCell.getAttribute(which) || "1");
  return Math.max(currentMaxOffset, start + dimensionValue);
}

// node_modules/@ckeditor/ckeditor5-table/src/commands/selectrowcommand.js
var SelectRowCommand = class extends Command {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this.affectsData = false;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = selectedCells.length > 0;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const referenceCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const rowIndexes = tableUtils.getRowIndexes(referenceCells);
    const table = referenceCells[0].findAncestor("table");
    const rangesToSelect = [];
    for (let rowIndex = rowIndexes.first; rowIndex <= rowIndexes.last; rowIndex++) {
      for (const cell of table.getChild(rowIndex).getChildren()) {
        rangesToSelect.push(model.createRangeOn(cell));
      }
    }
    model.change((writer) => {
      writer.setSelection(rangesToSelect);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/commands/selectcolumncommand.js
var SelectColumnCommand = class extends Command {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this.affectsData = false;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
    this.isEnabled = selectedCells.length > 0;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const model = this.editor.model;
    const referenceCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const firstCell = referenceCells[0];
    const lastCell = referenceCells.pop();
    const table = firstCell.findAncestor("table");
    const startLocation = tableUtils.getCellLocation(firstCell);
    const endLocation = tableUtils.getCellLocation(lastCell);
    const startColumn = Math.min(startLocation.column, endLocation.column);
    const endColumn = Math.max(startLocation.column, endLocation.column);
    const rangesToSelect = [];
    for (const cellInfo of new TableWalker(table, { startColumn, endColumn })) {
      rangesToSelect.push(model.createRangeOn(cellInfo.cell));
    }
    model.change((writer) => {
      writer.setSelection(rangesToSelect);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/converters/table-layout-post-fixer.js
function injectTableLayoutPostFixer(model) {
  model.document.registerPostFixer((writer) => tableLayoutPostFixer(writer, model));
}
function tableLayoutPostFixer(writer, model) {
  const changes = model.document.differ.getChanges();
  let wasFixed = false;
  const analyzedTables = /* @__PURE__ */ new Set();
  for (const entry of changes) {
    let table = null;
    if (entry.type == "insert" && entry.name == "table") {
      table = entry.position.nodeAfter;
    }
    if ((entry.type == "insert" || entry.type == "remove") && (entry.name == "tableRow" || entry.name == "tableCell")) {
      table = entry.position.findAncestor("table");
    }
    if (isTableAttributeEntry(entry)) {
      table = entry.range.start.findAncestor("table");
    }
    if (table && !analyzedTables.has(table)) {
      wasFixed = fixTableCellsRowspan(table, writer) || wasFixed;
      wasFixed = fixTableRowsSizes(table, writer) || wasFixed;
      analyzedTables.add(table);
    }
  }
  return wasFixed;
}
function fixTableCellsRowspan(table, writer) {
  let wasFixed = false;
  const cellsToTrim = findCellsToTrim(table);
  if (cellsToTrim.length) {
    wasFixed = true;
    for (const data of cellsToTrim) {
      updateNumericAttribute("rowspan", data.rowspan, data.cell, writer, 1);
    }
  }
  return wasFixed;
}
function fixTableRowsSizes(table, writer) {
  let wasFixed = false;
  const childrenLengths = getChildrenLengths(table);
  const rowsToRemove = [];
  for (const [rowIndex, size] of childrenLengths.entries()) {
    if (!size && table.getChild(rowIndex).is("element", "tableRow")) {
      rowsToRemove.push(rowIndex);
    }
  }
  if (rowsToRemove.length) {
    wasFixed = true;
    for (const rowIndex of rowsToRemove.reverse()) {
      writer.remove(table.getChild(rowIndex));
      childrenLengths.splice(rowIndex, 1);
    }
  }
  const rowsLengths = childrenLengths.filter((row, rowIndex) => table.getChild(rowIndex).is("element", "tableRow"));
  const tableSize = rowsLengths[0];
  const isValid = rowsLengths.every((length) => length === tableSize);
  if (!isValid) {
    const maxColumns = rowsLengths.reduce((prev, current) => current > prev ? current : prev, 0);
    for (const [rowIndex, size] of rowsLengths.entries()) {
      const columnsToInsert = maxColumns - size;
      if (columnsToInsert) {
        for (let i = 0; i < columnsToInsert; i++) {
          createEmptyTableCell(writer, writer.createPositionAt(table.getChild(rowIndex), "end"));
        }
        wasFixed = true;
      }
    }
  }
  return wasFixed;
}
function findCellsToTrim(table) {
  const headingRows = parseInt(table.getAttribute("headingRows") || "0");
  const maxRows = Array.from(table.getChildren()).reduce((count, row) => row.is("element", "tableRow") ? count + 1 : count, 0);
  const cellsToTrim = [];
  for (const { row, cell, cellHeight } of new TableWalker(table)) {
    if (cellHeight < 2) {
      continue;
    }
    const isInHeader = row < headingRows;
    const rowLimit = isInHeader ? headingRows : maxRows;
    if (row + cellHeight > rowLimit) {
      const newRowspan = rowLimit - row;
      cellsToTrim.push({ cell, rowspan: newRowspan });
    }
  }
  return cellsToTrim;
}
function getChildrenLengths(table) {
  const lengths = new Array(table.childCount).fill(0);
  for (const { rowIndex } of new TableWalker(table, { includeAllSlots: true })) {
    lengths[rowIndex]++;
  }
  return lengths;
}
function isTableAttributeEntry(entry) {
  if (entry.type !== "attribute") {
    return false;
  }
  const key = entry.attributeKey;
  return key === "headingRows" || key === "colspan" || key === "rowspan";
}

// node_modules/@ckeditor/ckeditor5-table/src/converters/table-cell-paragraph-post-fixer.js
function injectTableCellParagraphPostFixer(model) {
  model.document.registerPostFixer((writer) => tableCellContentsPostFixer(writer, model));
}
function tableCellContentsPostFixer(writer, model) {
  const changes = model.document.differ.getChanges();
  let wasFixed = false;
  for (const entry of changes) {
    if (entry.type == "insert" && entry.name == "table") {
      wasFixed = fixTable(entry.position.nodeAfter, writer) || wasFixed;
    }
    if (entry.type == "insert" && entry.name == "tableRow") {
      wasFixed = fixTableRow(entry.position.nodeAfter, writer) || wasFixed;
    }
    if (entry.type == "insert" && entry.name == "tableCell") {
      wasFixed = fixTableCellContent(entry.position.nodeAfter, writer) || wasFixed;
    }
    if ((entry.type == "remove" || entry.type == "insert") && checkTableCellChange(entry)) {
      wasFixed = fixTableCellContent(entry.position.parent, writer) || wasFixed;
    }
  }
  return wasFixed;
}
function fixTable(table, writer) {
  let wasFixed = false;
  for (const row of table.getChildren()) {
    if (row.is("element", "tableRow")) {
      wasFixed = fixTableRow(row, writer) || wasFixed;
    }
  }
  return wasFixed;
}
function fixTableRow(tableRow, writer) {
  let wasFixed = false;
  for (const tableCell of tableRow.getChildren()) {
    wasFixed = fixTableCellContent(tableCell, writer) || wasFixed;
  }
  return wasFixed;
}
function fixTableCellContent(tableCell, writer) {
  if (tableCell.childCount == 0) {
    writer.insertElement("paragraph", tableCell);
    return true;
  }
  const textNodes = Array.from(tableCell.getChildren()).filter((child) => child.is("$text"));
  for (const child of textNodes) {
    writer.wrap(writer.createRangeOn(child), "paragraph");
  }
  return !!textNodes.length;
}
function checkTableCellChange(entry) {
  if (!entry.position.parent.is("element", "tableCell")) {
    return false;
  }
  return entry.type == "insert" && entry.name == "$text" || entry.type == "remove";
}

// node_modules/@ckeditor/ckeditor5-table/src/converters/table-headings-refresh-handler.js
function tableHeadingsRefreshHandler(model, editing) {
  const differ = model.document.differ;
  for (const change of differ.getChanges()) {
    let table;
    let isRowChange = false;
    if (change.type == "attribute") {
      const element = change.range.start.nodeAfter;
      if (!element || !element.is("element", "table")) {
        continue;
      }
      if (change.attributeKey != "headingRows" && change.attributeKey != "headingColumns") {
        continue;
      }
      table = element;
      isRowChange = change.attributeKey == "headingRows";
    } else if (change.name == "tableRow" || change.name == "tableCell") {
      table = change.position.findAncestor("table");
      isRowChange = change.name == "tableRow";
    }
    if (!table) {
      continue;
    }
    const headingRows = table.getAttribute("headingRows") || 0;
    const headingColumns = table.getAttribute("headingColumns") || 0;
    const tableWalker = new TableWalker(table);
    for (const tableSlot of tableWalker) {
      const isHeading = tableSlot.row < headingRows || tableSlot.column < headingColumns;
      const expectedElementName = isHeading ? "th" : "td";
      const viewElement = editing.mapper.toViewElement(tableSlot.cell);
      if (viewElement && viewElement.is("element") && viewElement.name != expectedElementName) {
        editing.reconvertItem(isRowChange ? tableSlot.cell.parent : tableSlot.cell);
      }
    }
  }
}

// node_modules/@ckeditor/ckeditor5-table/src/converters/table-cell-refresh-handler.js
function tableCellRefreshHandler(model, editing) {
  const differ = model.document.differ;
  const cellsToCheck = /* @__PURE__ */ new Set();
  for (const change of differ.getChanges()) {
    const parent = change.type == "attribute" ? change.range.start.parent : change.position.parent;
    if (parent.is("element", "tableCell")) {
      cellsToCheck.add(parent);
    }
  }
  for (const tableCell of cellsToCheck.values()) {
    const paragraphsToRefresh = Array.from(tableCell.getChildren()).filter((child) => shouldRefresh(child, editing.mapper));
    for (const paragraph of paragraphsToRefresh) {
      editing.reconvertItem(paragraph);
    }
  }
}
function shouldRefresh(child, mapper) {
  if (!child.is("element", "paragraph")) {
    return false;
  }
  const viewElement = mapper.toViewElement(child);
  if (!viewElement) {
    return false;
  }
  return isSingleParagraphWithoutAttributes(child) !== viewElement.is("element", "span");
}

// node_modules/@ckeditor/ckeditor5-table/src/tableediting.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/tableediting.css";
var TableEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableUtils];
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._additionalSlots = [];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const schema = model.schema;
    const conversion = editor.conversion;
    const tableUtils = editor.plugins.get(TableUtils);
    schema.register("table", {
      inheritAllFrom: "$blockObject",
      allowAttributes: ["headingRows", "headingColumns"]
    });
    schema.register("tableRow", {
      allowIn: "table",
      isLimit: true
    });
    schema.register("tableCell", {
      allowContentOf: "$container",
      allowIn: "tableRow",
      allowAttributes: ["colspan", "rowspan"],
      isLimit: true,
      isSelectable: true
    });
    conversion.for("upcast").add(upcastTableFigure());
    conversion.for("upcast").add(upcastTable());
    conversion.for("editingDowncast").elementToStructure({
      model: {
        name: "table",
        attributes: ["headingRows"]
      },
      view: downcastTable(tableUtils, {
        asWidget: true,
        additionalSlots: this._additionalSlots
      })
    });
    conversion.for("dataDowncast").elementToStructure({
      model: {
        name: "table",
        attributes: ["headingRows"]
      },
      view: downcastTable(tableUtils, {
        additionalSlots: this._additionalSlots
      })
    });
    conversion.for("upcast").elementToElement({ model: "tableRow", view: "tr" });
    conversion.for("upcast").add(skipEmptyTableRow());
    conversion.for("downcast").elementToElement({
      model: "tableRow",
      view: downcastRow()
    });
    conversion.for("upcast").elementToElement({ model: "tableCell", view: "td" });
    conversion.for("upcast").elementToElement({ model: "tableCell", view: "th" });
    conversion.for("upcast").add(ensureParagraphInTableCell("td"));
    conversion.for("upcast").add(ensureParagraphInTableCell("th"));
    conversion.for("editingDowncast").elementToElement({
      model: "tableCell",
      view: downcastCell({ asWidget: true })
    });
    conversion.for("dataDowncast").elementToElement({
      model: "tableCell",
      view: downcastCell()
    });
    conversion.for("editingDowncast").elementToElement({
      model: "paragraph",
      view: convertParagraphInTableCell({ asWidget: true }),
      converterPriority: "high"
    });
    conversion.for("dataDowncast").elementToElement({
      model: "paragraph",
      view: convertParagraphInTableCell(),
      converterPriority: "high"
    });
    conversion.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" });
    conversion.for("upcast").attributeToAttribute({
      model: { key: "colspan", value: upcastCellSpan("colspan") },
      view: "colspan"
    });
    conversion.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" });
    conversion.for("upcast").attributeToAttribute({
      model: { key: "rowspan", value: upcastCellSpan("rowspan") },
      view: "rowspan"
    });
    editor.config.define("table.defaultHeadings.rows", 0);
    editor.config.define("table.defaultHeadings.columns", 0);
    editor.commands.add("insertTable", new InsertTableCommand(editor));
    editor.commands.add("insertTableRowAbove", new InsertRowCommand(editor, { order: "above" }));
    editor.commands.add("insertTableRowBelow", new InsertRowCommand(editor, { order: "below" }));
    editor.commands.add("insertTableColumnLeft", new InsertColumnCommand(editor, { order: "left" }));
    editor.commands.add("insertTableColumnRight", new InsertColumnCommand(editor, { order: "right" }));
    editor.commands.add("removeTableRow", new RemoveRowCommand(editor));
    editor.commands.add("removeTableColumn", new RemoveColumnCommand(editor));
    editor.commands.add("splitTableCellVertically", new SplitCellCommand(editor, { direction: "vertically" }));
    editor.commands.add("splitTableCellHorizontally", new SplitCellCommand(editor, { direction: "horizontally" }));
    editor.commands.add("mergeTableCells", new MergeCellsCommand(editor));
    editor.commands.add("mergeTableCellRight", new MergeCellCommand(editor, { direction: "right" }));
    editor.commands.add("mergeTableCellLeft", new MergeCellCommand(editor, { direction: "left" }));
    editor.commands.add("mergeTableCellDown", new MergeCellCommand(editor, { direction: "down" }));
    editor.commands.add("mergeTableCellUp", new MergeCellCommand(editor, { direction: "up" }));
    editor.commands.add("setTableColumnHeader", new SetHeaderColumnCommand(editor));
    editor.commands.add("setTableRowHeader", new SetHeaderRowCommand(editor));
    editor.commands.add("selectTableRow", new SelectRowCommand(editor));
    editor.commands.add("selectTableColumn", new SelectColumnCommand(editor));
    injectTableLayoutPostFixer(model);
    injectTableCellParagraphPostFixer(model);
    this.listenTo(model.document, "change:data", () => {
      tableHeadingsRefreshHandler(model, editor.editing);
      tableCellRefreshHandler(model, editor.editing);
    });
  }
  /**
   * Registers downcast handler for the additional table slot.
   */
  registerAdditionalSlot(slotHandler) {
    this._additionalSlots.push(slotHandler);
  }
};
function upcastCellSpan(type) {
  return (cell) => {
    const span = parseInt(cell.getAttribute(type));
    if (Number.isNaN(span) || span <= 0) {
      return null;
    }
    return span;
  };
}

// node_modules/@ckeditor/ckeditor5-table/src/ui/inserttableview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css";
var InsertTableView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.items = this._createGridCollection();
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.set("rows", 0);
    this.set("columns", 0);
    this.bind("label").to(this, "columns", this, "rows", (columns, rows) => `${rows}  ${columns}`);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck"]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: ["ck-insert-table-dropdown__grid"]
          },
          on: {
            "mouseover@.ck-insert-table-dropdown-grid-box": bind.to("boxover")
          },
          children: this.items
        },
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-insert-table-dropdown__label"
            ],
            "aria-hidden": true
          },
          children: [
            {
              text: bind.to("label")
            }
          ]
        }
      ],
      on: {
        mousedown: bind.to((evt) => {
          evt.preventDefault();
        }),
        click: bind.to(() => {
          this.fire("execute");
        })
      }
    });
    this.on("boxover", (evt, domEvt) => {
      const { row, column } = domEvt.target.dataset;
      this.items.get((parseInt(row, 10) - 1) * 10 + (parseInt(column, 10) - 1)).focus();
    });
    this.focusTracker.on("change:focusedElement", (evt, name, focusedElement) => {
      if (!focusedElement) {
        return;
      }
      const { row, column } = focusedElement.dataset;
      this.set({
        rows: parseInt(row),
        columns: parseInt(column)
      });
    });
    this.on("change:columns", () => this._highlightGridBoxes());
    this.on("change:rows", () => this._highlightGridBoxes());
  }
  render() {
    super.render();
    addKeyboardHandlingForGrid({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.items,
      numberOfColumns: 10,
      uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
    });
    for (const item of this.items) {
      this.focusTracker.add(item.element);
    }
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  focus() {
    this.items.get(0).focus();
  }
  /**
   * @inheritDoc
   */
  focusLast() {
    this.items.get(0).focus();
  }
  /**
   * Highlights grid boxes depending on rows and columns selected.
   */
  _highlightGridBoxes() {
    const rows = this.rows;
    const columns = this.columns;
    this.items.map((boxView, index) => {
      const itemRow = Math.floor(index / 10);
      const itemColumn = index % 10;
      const isOn = itemRow < rows && itemColumn < columns;
      boxView.set("isOn", isOn);
    });
  }
  /**
   * Creates a new Button for the grid.
   *
   * @param locale The locale instance.
   * @param row Row number.
   * @param column Column number.
   * @param label The grid button label.
   */
  _createGridButton(locale, row, column, label) {
    const button = new ButtonView(locale);
    button.set({
      label,
      class: "ck-insert-table-dropdown-grid-box"
    });
    button.extendTemplate({
      attributes: {
        "data-row": row,
        "data-column": column
      }
    });
    return button;
  }
  /**
   * @returns A view collection containing boxes to be placed in a table grid.
   */
  _createGridCollection() {
    const boxes = [];
    for (let index = 0; index < 100; index++) {
      const row = Math.floor(index / 10);
      const column = index % 10;
      const label = `${row + 1}  ${column + 1}`;
      boxes.push(this._createGridButton(this.locale, row + 1, column + 1, label));
    }
    return this.createCollection(boxes);
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableui.js
import tableIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/icons/table.svg";
import tableColumnIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/icons/table-column.svg";
import tableRowIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/icons/table-row.svg";
import tableMergeCellIcon from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/icons/table-merge-cell.svg";
var TableUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    const contentLanguageDirection = editor.locale.contentLanguageDirection;
    const isContentLtr = contentLanguageDirection === "ltr";
    editor.ui.componentFactory.add("insertTable", (locale) => {
      const command = editor.commands.get("insertTable");
      const dropdownView = createDropdown(locale);
      dropdownView.bind("isEnabled").to(command);
      dropdownView.buttonView.set({
        icon: tableIcon,
        label: t("Insert table"),
        tooltip: true
      });
      let insertTableView;
      dropdownView.on("change:isOpen", () => {
        if (insertTableView) {
          return;
        }
        insertTableView = new InsertTableView(locale);
        dropdownView.panelView.children.add(insertTableView);
        insertTableView.delegate("execute").to(dropdownView);
        dropdownView.on("execute", () => {
          editor.execute("insertTable", { rows: insertTableView.rows, columns: insertTableView.columns });
          editor.editing.view.focus();
        });
      });
      return dropdownView;
    });
    editor.ui.componentFactory.add("tableColumn", (locale) => {
      const options = [
        {
          type: "switchbutton",
          model: {
            commandName: "setTableColumnHeader",
            label: t("Header column"),
            bindIsOn: true
          }
        },
        { type: "separator" },
        {
          type: "button",
          model: {
            commandName: isContentLtr ? "insertTableColumnLeft" : "insertTableColumnRight",
            label: t("Insert column left")
          }
        },
        {
          type: "button",
          model: {
            commandName: isContentLtr ? "insertTableColumnRight" : "insertTableColumnLeft",
            label: t("Insert column right")
          }
        },
        {
          type: "button",
          model: {
            commandName: "removeTableColumn",
            label: t("Delete column")
          }
        },
        {
          type: "button",
          model: {
            commandName: "selectTableColumn",
            label: t("Select column")
          }
        }
      ];
      return this._prepareDropdown(t("Column"), tableColumnIcon, options, locale);
    });
    editor.ui.componentFactory.add("tableRow", (locale) => {
      const options = [
        {
          type: "switchbutton",
          model: {
            commandName: "setTableRowHeader",
            label: t("Header row"),
            bindIsOn: true
          }
        },
        { type: "separator" },
        {
          type: "button",
          model: {
            commandName: "insertTableRowAbove",
            label: t("Insert row above")
          }
        },
        {
          type: "button",
          model: {
            commandName: "insertTableRowBelow",
            label: t("Insert row below")
          }
        },
        {
          type: "button",
          model: {
            commandName: "removeTableRow",
            label: t("Delete row")
          }
        },
        {
          type: "button",
          model: {
            commandName: "selectTableRow",
            label: t("Select row")
          }
        }
      ];
      return this._prepareDropdown(t("Row"), tableRowIcon, options, locale);
    });
    editor.ui.componentFactory.add("mergeTableCells", (locale) => {
      const options = [
        {
          type: "button",
          model: {
            commandName: "mergeTableCellUp",
            label: t("Merge cell up")
          }
        },
        {
          type: "button",
          model: {
            commandName: isContentLtr ? "mergeTableCellRight" : "mergeTableCellLeft",
            label: t("Merge cell right")
          }
        },
        {
          type: "button",
          model: {
            commandName: "mergeTableCellDown",
            label: t("Merge cell down")
          }
        },
        {
          type: "button",
          model: {
            commandName: isContentLtr ? "mergeTableCellLeft" : "mergeTableCellRight",
            label: t("Merge cell left")
          }
        },
        { type: "separator" },
        {
          type: "button",
          model: {
            commandName: "splitTableCellVertically",
            label: t("Split cell vertically")
          }
        },
        {
          type: "button",
          model: {
            commandName: "splitTableCellHorizontally",
            label: t("Split cell horizontally")
          }
        }
      ];
      return this._prepareMergeSplitButtonDropdown(t("Merge cells"), tableMergeCellIcon, options, locale);
    });
  }
  /**
   * Creates a dropdown view from a set of options.
   *
   * @param label The dropdown button label.
   * @param icon An icon for the dropdown button.
   * @param options The list of options for the dropdown.
   */
  _prepareDropdown(label, icon, options, locale) {
    const editor = this.editor;
    const dropdownView = createDropdown(locale);
    const commands = this._fillDropdownWithListOptions(dropdownView, options);
    dropdownView.buttonView.set({
      label,
      icon,
      tooltip: true
    });
    dropdownView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
      return areEnabled.some((isEnabled) => isEnabled);
    });
    this.listenTo(dropdownView, "execute", (evt) => {
      editor.execute(evt.source.commandName);
      if (!(evt.source instanceof SwitchButtonView)) {
        editor.editing.view.focus();
      }
    });
    return dropdownView;
  }
  /**
   * Creates a dropdown view with a {@link module:ui/dropdown/button/splitbuttonview~SplitButtonView} for
   * merge (and split)related commands.
   *
   * @param label The dropdown button label.
   * @param icon An icon for the dropdown button.
   * @param options The list of options for the dropdown.
   */
  _prepareMergeSplitButtonDropdown(label, icon, options, locale) {
    const editor = this.editor;
    const dropdownView = createDropdown(locale, SplitButtonView);
    const mergeCommandName = "mergeTableCells";
    const mergeCommand = editor.commands.get(mergeCommandName);
    const commands = this._fillDropdownWithListOptions(dropdownView, options);
    dropdownView.buttonView.set({
      label,
      icon,
      tooltip: true,
      isEnabled: true
    });
    dropdownView.bind("isEnabled").toMany([mergeCommand, ...commands], "isEnabled", (...areEnabled) => {
      return areEnabled.some((isEnabled) => isEnabled);
    });
    this.listenTo(dropdownView.buttonView, "execute", () => {
      editor.execute(mergeCommandName);
      editor.editing.view.focus();
    });
    this.listenTo(dropdownView, "execute", (evt) => {
      editor.execute(evt.source.commandName);
      editor.editing.view.focus();
    });
    return dropdownView;
  }
  /**
   * Injects a {@link module:ui/list/listview~ListView} into the passed dropdown with buttons
   * which execute editor commands as configured in passed options.
   *
   * @param options The list of options for the dropdown.
   * @returns Commands the list options are interacting with.
   */
  _fillDropdownWithListOptions(dropdownView, options) {
    const editor = this.editor;
    const commands = [];
    const itemDefinitions = new Collection();
    for (const option of options) {
      addListOption(option, editor, commands, itemDefinitions);
    }
    addListToDropdown(dropdownView, itemDefinitions);
    return commands;
  }
};
function addListOption(option, editor, commands, itemDefinitions) {
  if (option.type === "button" || option.type === "switchbutton") {
    const model = option.model = new Model(option.model);
    const { commandName, bindIsOn } = option.model;
    const command = editor.commands.get(commandName);
    commands.push(command);
    model.set({ commandName });
    model.bind("isEnabled").to(command);
    if (bindIsOn) {
      model.bind("isOn").to(command, "value");
    }
    model.set({
      withText: true
    });
  }
  itemDefinitions.add(option);
}

// node_modules/@ckeditor/ckeditor5-table/src/tableselection.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/tableselection.css";
var TableSelection = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableSelection";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableUtils, TableUtils];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    this.listenTo(model, "deleteContent", (evt, args) => this._handleDeleteContent(evt, args), { priority: "high" });
    this.listenTo(view.document, "insertText", (evt, data) => this._handleInsertTextEvent(evt, data), { priority: "high" });
    this._defineSelectionConverter();
    this._enablePluginDisabling();
  }
  /**
   * Returns the currently selected table cells or `null` if it is not a table cells selection.
   */
  getSelectedTableCells() {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const selection = this.editor.model.document.selection;
    const selectedCells = tableUtils.getSelectedTableCells(selection);
    if (selectedCells.length == 0) {
      return null;
    }
    return selectedCells;
  }
  /**
   * Returns the selected table fragment as a document fragment.
   */
  getSelectionAsFragment() {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const selectedCells = this.getSelectedTableCells();
    if (!selectedCells) {
      return null;
    }
    return this.editor.model.change((writer) => {
      const documentFragment = writer.createDocumentFragment();
      const { first: firstColumn, last: lastColumn } = tableUtils.getColumnIndexes(selectedCells);
      const { first: firstRow, last: lastRow } = tableUtils.getRowIndexes(selectedCells);
      const sourceTable = selectedCells[0].findAncestor("table");
      let adjustedLastRow = lastRow;
      let adjustedLastColumn = lastColumn;
      if (tableUtils.isSelectionRectangular(selectedCells)) {
        const dimensions = {
          firstColumn,
          lastColumn,
          firstRow,
          lastRow
        };
        adjustedLastRow = adjustLastRowIndex(sourceTable, dimensions);
        adjustedLastColumn = adjustLastColumnIndex(sourceTable, dimensions);
      }
      const cropDimensions = {
        startRow: firstRow,
        startColumn: firstColumn,
        endRow: adjustedLastRow,
        endColumn: adjustedLastColumn
      };
      const table = cropTableToDimensions(sourceTable, cropDimensions, writer);
      writer.insert(table, documentFragment, 0);
      return documentFragment;
    });
  }
  /**
   * Sets the model selection based on given anchor and target cells (can be the same cell).
   * Takes care of setting the backward flag.
   *
   * ```ts
   * const modelRoot = editor.model.document.getRoot();
   * const firstCell = modelRoot.getNodeByPath( [ 0, 0, 0 ] );
   * const lastCell = modelRoot.getNodeByPath( [ 0, 0, 1 ] );
   *
   * const tableSelection = editor.plugins.get( 'TableSelection' );
   * tableSelection.setCellSelection( firstCell, lastCell );
   * ```
   */
  setCellSelection(anchorCell, targetCell) {
    const cellsToSelect = this._getCellsToSelect(anchorCell, targetCell);
    this.editor.model.change((writer) => {
      writer.setSelection(cellsToSelect.cells.map((cell) => writer.createRangeOn(cell)), { backward: cellsToSelect.backward });
    });
  }
  /**
   * Returns the focus cell from the current selection.
   */
  getFocusCell() {
    const selection = this.editor.model.document.selection;
    const focusCellRange = [...selection.getRanges()].pop();
    const element = focusCellRange.getContainedElement();
    if (element && element.is("element", "tableCell")) {
      return element;
    }
    return null;
  }
  /**
   * Returns the anchor cell from the current selection.
   */
  getAnchorCell() {
    const selection = this.editor.model.document.selection;
    const anchorCellRange = first(selection.getRanges());
    const element = anchorCellRange.getContainedElement();
    if (element && element.is("element", "tableCell")) {
      return element;
    }
    return null;
  }
  /**
   * Defines a selection converter which marks the selected cells with a specific class.
   *
   * The real DOM selection is put in the last cell. Since the order of ranges is dependent on whether the
   * selection is backward or not, the last cell will usually be close to the "focus" end of the selection
   * (a selection has anchor and focus).
   *
   * The real DOM selection is then hidden with CSS.
   */
  _defineSelectionConverter() {
    const editor = this.editor;
    const highlighted = /* @__PURE__ */ new Set();
    editor.conversion.for("editingDowncast").add((dispatcher) => dispatcher.on("selection", (evt, data, conversionApi) => {
      const viewWriter = conversionApi.writer;
      clearHighlightedTableCells(viewWriter);
      const selectedCells = this.getSelectedTableCells();
      if (!selectedCells) {
        return;
      }
      for (const tableCell of selectedCells) {
        const viewElement = conversionApi.mapper.toViewElement(tableCell);
        viewWriter.addClass("ck-editor__editable_selected", viewElement);
        highlighted.add(viewElement);
      }
      const lastViewCell = conversionApi.mapper.toViewElement(selectedCells[selectedCells.length - 1]);
      viewWriter.setSelection(lastViewCell, 0);
    }, { priority: "lowest" }));
    function clearHighlightedTableCells(viewWriter) {
      for (const previouslyHighlighted of highlighted) {
        viewWriter.removeClass("ck-editor__editable_selected", previouslyHighlighted);
      }
      highlighted.clear();
    }
  }
  /**
   * Creates a listener that reacts to changes in {@link #isEnabled} and, if the plugin was disabled,
   * it collapses the multi-cell selection to a regular selection placed inside a table cell.
   *
   * This listener helps features that disable the table selection plugin bring the selection
   * to a clear state they can work with (for instance, because they don't support multiple cell selection).
   */
  _enablePluginDisabling() {
    const editor = this.editor;
    this.on("change:isEnabled", () => {
      if (!this.isEnabled) {
        const selectedCells = this.getSelectedTableCells();
        if (!selectedCells) {
          return;
        }
        editor.model.change((writer) => {
          const position = writer.createPositionAt(selectedCells[0], 0);
          const range = editor.model.schema.getNearestSelectionRange(position);
          writer.setSelection(range);
        });
      }
    });
  }
  /**
   * Overrides the default `model.deleteContent()` behavior over a selected table fragment.
   *
   * @param args Delete content method arguments.
   */
  _handleDeleteContent(event, args) {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const selection = args[0];
    const options = args[1];
    const model = this.editor.model;
    const isBackward = !options || options.direction == "backward";
    const selectedTableCells = tableUtils.getSelectedTableCells(selection);
    if (!selectedTableCells.length) {
      return;
    }
    event.stop();
    model.change((writer) => {
      const tableCellToSelect = selectedTableCells[isBackward ? selectedTableCells.length - 1 : 0];
      model.change((writer2) => {
        for (const tableCell of selectedTableCells) {
          model.deleteContent(writer2.createSelection(tableCell, "in"));
        }
      });
      const rangeToSelect = model.schema.getNearestSelectionRange(writer.createPositionAt(tableCellToSelect, 0));
      if (selection.is("documentSelection")) {
        writer.setSelection(rangeToSelect);
      } else {
        selection.setTo(rangeToSelect);
      }
    });
  }
  /**
   * This handler makes it possible to remove the content of all selected cells by starting to type.
   * If you take a look at {@link #_defineSelectionConverter} you will find out that despite the multi-cell selection being set
   * in the model, the view selection is collapsed in the last cell (because most browsers are unable to render multi-cell selections;
   * yes, it's a hack).
   *
   * When multiple cells are selected in the model and the user starts to type, the
   * {@link module:engine/view/document~Document#event:insertText} event carries information provided by the
   * beforeinput DOM  event, that in turn only knows about this collapsed DOM selection in the last cell.
   *
   * As a result, the selected cells have no chance to be cleaned up. To fix this, this listener intercepts
   * the event and injects the custom view selection in the data that translates correctly to the actual state
   * of the multi-cell selection in the model.
   *
   * @param data Insert text event data.
   */
  _handleInsertTextEvent(evt, data) {
    const editor = this.editor;
    const selectedCells = this.getSelectedTableCells();
    if (!selectedCells) {
      return;
    }
    const view = editor.editing.view;
    const mapper = editor.editing.mapper;
    const viewRanges = selectedCells.map((tableCell) => view.createRangeOn(mapper.toViewElement(tableCell)));
    data.selection = view.createSelection(viewRanges);
  }
  /**
   * Returns an array of table cells that should be selected based on the
   * given anchor cell and target (focus) cell.
   *
   * The cells are returned in a reverse direction if the selection is backward.
   */
  _getCellsToSelect(anchorCell, targetCell) {
    const tableUtils = this.editor.plugins.get("TableUtils");
    const startLocation = tableUtils.getCellLocation(anchorCell);
    const endLocation = tableUtils.getCellLocation(targetCell);
    const startRow = Math.min(startLocation.row, endLocation.row);
    const endRow = Math.max(startLocation.row, endLocation.row);
    const startColumn = Math.min(startLocation.column, endLocation.column);
    const endColumn = Math.max(startLocation.column, endLocation.column);
    const selectionMap = new Array(endRow - startRow + 1).fill(null).map(() => []);
    const walkerOptions = {
      startRow,
      endRow,
      startColumn,
      endColumn
    };
    for (const { row, cell } of new TableWalker(anchorCell.findAncestor("table"), walkerOptions)) {
      selectionMap[row - startRow].push(cell);
    }
    const flipVertically = endLocation.row < startLocation.row;
    const flipHorizontally = endLocation.column < startLocation.column;
    if (flipVertically) {
      selectionMap.reverse();
    }
    if (flipHorizontally) {
      selectionMap.forEach((row) => row.reverse());
    }
    return {
      cells: selectionMap.flat(),
      backward: flipVertically || flipHorizontally
    };
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableclipboard.js
var TableClipboard = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableClipboard";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableSelection, TableUtils];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    this.listenTo(viewDocument, "copy", (evt, data) => this._onCopyCut(evt, data));
    this.listenTo(viewDocument, "cut", (evt, data) => this._onCopyCut(evt, data));
    this.listenTo(editor.model, "insertContent", (evt, [content, selectable]) => this._onInsertContent(evt, content, selectable), { priority: "high" });
    this.decorate("_replaceTableSlotCell");
  }
  /**
   * Copies table content to a clipboard on "copy" & "cut" events.
   *
   * @param evt An object containing information about the handled event.
   * @param data Clipboard event data.
   */
  _onCopyCut(evt, data) {
    const tableSelection = this.editor.plugins.get(TableSelection);
    if (!tableSelection.getSelectedTableCells()) {
      return;
    }
    if (evt.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection)) {
      return;
    }
    data.preventDefault();
    evt.stop();
    const dataController = this.editor.data;
    const viewDocument = this.editor.editing.view.document;
    const content = dataController.toView(tableSelection.getSelectionAsFragment());
    viewDocument.fire("clipboardOutput", {
      dataTransfer: data.dataTransfer,
      content,
      method: evt.name
    });
  }
  /**
   * Overrides default {@link module:engine/model/model~Model#insertContent `model.insertContent()`} method to handle pasting table inside
   * selected table fragment.
   *
   * Depending on selected table fragment:
   * - If a selected table fragment is smaller than paste table it will crop pasted table to match dimensions.
   * - If dimensions are equal it will replace selected table fragment with a pasted table contents.
   *
   * @param content The content to insert.
   * @param selectable The selection into which the content should be inserted.
   * If not provided the current model document selection will be used.
   */
  _onInsertContent(evt, content, selectable) {
    if (selectable && !selectable.is("documentSelection")) {
      return;
    }
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get(TableUtils);
    let pastedTable = this.getTableIfOnlyTableInContent(content, model);
    if (!pastedTable) {
      return;
    }
    const selectedTableCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    if (!selectedTableCells.length) {
      removeEmptyRowsColumns(pastedTable, tableUtils);
      return;
    }
    evt.stop();
    model.change((writer) => {
      const pastedDimensions = {
        width: tableUtils.getColumns(pastedTable),
        height: tableUtils.getRows(pastedTable)
      };
      const selection = prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils);
      const selectionHeight = selection.lastRow - selection.firstRow + 1;
      const selectionWidth = selection.lastColumn - selection.firstColumn + 1;
      const cropDimensions = {
        startRow: 0,
        startColumn: 0,
        endRow: Math.min(selectionHeight, pastedDimensions.height) - 1,
        endColumn: Math.min(selectionWidth, pastedDimensions.width) - 1
      };
      pastedTable = cropTableToDimensions(pastedTable, cropDimensions, writer);
      const selectedTable = selectedTableCells[0].findAncestor("table");
      const cellsToSelect = this._replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer);
      if (this.editor.plugins.get("TableSelection").isEnabled) {
        const selectionRanges = tableUtils.sortRanges(cellsToSelect.map((cell) => writer.createRangeOn(cell)));
        writer.setSelection(selectionRanges);
      } else {
        writer.setSelection(cellsToSelect[0], 0);
      }
    });
  }
  /**
   * Replaces the part of selectedTable with pastedTable.
   */
  _replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer) {
    const { width: pastedWidth, height: pastedHeight } = pastedDimensions;
    const pastedTableLocationMap = createLocationMap(pastedTable, pastedWidth, pastedHeight);
    const selectedTableMap = [...new TableWalker(selectedTable, {
      startRow: selection.firstRow,
      endRow: selection.lastRow,
      startColumn: selection.firstColumn,
      endColumn: selection.lastColumn,
      includeAllSlots: true
    })];
    const cellsToSelect = [];
    let insertPosition;
    for (const tableSlot of selectedTableMap) {
      const { row, column } = tableSlot;
      if (column === selection.firstColumn) {
        insertPosition = tableSlot.getPositionBefore();
      }
      const pastedRow = row - selection.firstRow;
      const pastedColumn = column - selection.firstColumn;
      const pastedCell = pastedTableLocationMap[pastedRow % pastedHeight][pastedColumn % pastedWidth];
      const cellToInsert = pastedCell ? writer.cloneElement(pastedCell) : null;
      const newTableCell = this._replaceTableSlotCell(tableSlot, cellToInsert, insertPosition, writer);
      if (!newTableCell) {
        continue;
      }
      trimTableCellIfNeeded(newTableCell, row, column, selection.lastRow, selection.lastColumn, writer);
      cellsToSelect.push(newTableCell);
      insertPosition = writer.createPositionAfter(newTableCell);
    }
    const headingRows = parseInt(selectedTable.getAttribute("headingRows") || "0");
    const headingColumns = parseInt(selectedTable.getAttribute("headingColumns") || "0");
    const areHeadingRowsIntersectingSelection = selection.firstRow < headingRows && headingRows <= selection.lastRow;
    const areHeadingColumnsIntersectingSelection = selection.firstColumn < headingColumns && headingColumns <= selection.lastColumn;
    if (areHeadingRowsIntersectingSelection) {
      const columnsLimit = { first: selection.firstColumn, last: selection.lastColumn };
      const newCells = doHorizontalSplit(selectedTable, headingRows, columnsLimit, writer, selection.firstRow);
      cellsToSelect.push(...newCells);
    }
    if (areHeadingColumnsIntersectingSelection) {
      const rowsLimit = { first: selection.firstRow, last: selection.lastRow };
      const newCells = doVerticalSplit(selectedTable, headingColumns, rowsLimit, writer);
      cellsToSelect.push(...newCells);
    }
    return cellsToSelect;
  }
  /**
   * Replaces a single table slot.
   *
   * @returns Inserted table cell or null if slot should remain empty.
   * @private
   */
  _replaceTableSlotCell(tableSlot, cellToInsert, insertPosition, writer) {
    const { cell, isAnchor } = tableSlot;
    if (isAnchor) {
      writer.remove(cell);
    }
    if (!cellToInsert) {
      return null;
    }
    writer.insert(cellToInsert, insertPosition);
    return cellToInsert;
  }
  /**
   * Extracts the table for pasting into a table.
   *
   * @param content The content to insert.
   * @param model The editor model.
   */
  getTableIfOnlyTableInContent(content, model) {
    if (!content.is("documentFragment") && !content.is("element")) {
      return null;
    }
    if (content.is("element", "table")) {
      return content;
    }
    if (content.childCount == 1 && content.getChild(0).is("element", "table")) {
      return content.getChild(0);
    }
    const contentRange = model.createRangeIn(content);
    for (const element of contentRange.getItems()) {
      if (element.is("element", "table")) {
        const rangeBefore = model.createRange(contentRange.start, model.createPositionBefore(element));
        if (model.hasContent(rangeBefore, { ignoreWhitespaces: true })) {
          return null;
        }
        const rangeAfter = model.createRange(model.createPositionAfter(element), contentRange.end);
        if (model.hasContent(rangeAfter, { ignoreWhitespaces: true })) {
          return null;
        }
        return element;
      }
    }
    return null;
  }
};
function prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils) {
  const selectedTable = selectedTableCells[0].findAncestor("table");
  const columnIndexes = tableUtils.getColumnIndexes(selectedTableCells);
  const rowIndexes = tableUtils.getRowIndexes(selectedTableCells);
  const selection = {
    firstColumn: columnIndexes.first,
    lastColumn: columnIndexes.last,
    firstRow: rowIndexes.first,
    lastRow: rowIndexes.last
  };
  const shouldExpandSelection = selectedTableCells.length === 1;
  if (shouldExpandSelection) {
    selection.lastRow += pastedDimensions.height - 1;
    selection.lastColumn += pastedDimensions.width - 1;
    expandTableSize(selectedTable, selection.lastRow + 1, selection.lastColumn + 1, tableUtils);
  }
  if (shouldExpandSelection || !tableUtils.isSelectionRectangular(selectedTableCells)) {
    splitCellsToRectangularSelection(selectedTable, selection, writer);
  } else {
    selection.lastRow = adjustLastRowIndex(selectedTable, selection);
    selection.lastColumn = adjustLastColumnIndex(selectedTable, selection);
  }
  return selection;
}
function expandTableSize(table, expectedHeight, expectedWidth, tableUtils) {
  const tableWidth = tableUtils.getColumns(table);
  const tableHeight = tableUtils.getRows(table);
  if (expectedWidth > tableWidth) {
    tableUtils.insertColumns(table, {
      at: tableWidth,
      columns: expectedWidth - tableWidth
    });
  }
  if (expectedHeight > tableHeight) {
    tableUtils.insertRows(table, {
      at: tableHeight,
      rows: expectedHeight - tableHeight
    });
  }
}
function createLocationMap(table, width, height) {
  const map = new Array(height).fill(null).map(() => new Array(width).fill(null));
  for (const { column, row, cell } of new TableWalker(table)) {
    map[row][column] = cell;
  }
  return map;
}
function splitCellsToRectangularSelection(table, dimensions, writer) {
  const { firstRow, lastRow, firstColumn, lastColumn } = dimensions;
  const rowIndexes = { first: firstRow, last: lastRow };
  const columnIndexes = { first: firstColumn, last: lastColumn };
  doVerticalSplit(table, firstColumn, rowIndexes, writer);
  doVerticalSplit(table, lastColumn + 1, rowIndexes, writer);
  doHorizontalSplit(table, firstRow, columnIndexes, writer);
  doHorizontalSplit(table, lastRow + 1, columnIndexes, writer, firstRow);
}
function doHorizontalSplit(table, splitRow, limitColumns, writer, startRow = 0) {
  if (splitRow < 1) {
    return;
  }
  const overlappingCells = getVerticallyOverlappingCells(table, splitRow, startRow);
  const cellsToSplit = overlappingCells.filter(({ column, cellWidth }) => isAffectedBySelection(column, cellWidth, limitColumns));
  return cellsToSplit.map(({ cell }) => splitHorizontally(cell, splitRow, writer));
}
function doVerticalSplit(table, splitColumn, limitRows, writer) {
  if (splitColumn < 1) {
    return;
  }
  const overlappingCells = getHorizontallyOverlappingCells(table, splitColumn);
  const cellsToSplit = overlappingCells.filter(({ row, cellHeight }) => isAffectedBySelection(row, cellHeight, limitRows));
  return cellsToSplit.map(({ cell, column }) => splitVertically(cell, column, splitColumn, writer));
}
function isAffectedBySelection(index, span, limit) {
  const endIndex = index + span - 1;
  const { first: first2, last } = limit;
  const isInsideSelection = index >= first2 && index <= last;
  const overlapsSelectionFromOutside = index < first2 && endIndex >= first2;
  return isInsideSelection || overlapsSelectionFromOutside;
}

// node_modules/@ckeditor/ckeditor5-table/src/tablekeyboard.js
var TableKeyboard = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableKeyboard";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableSelection, TableUtils];
  }
  /**
   * @inheritDoc
   */
  init() {
    const view = this.editor.editing.view;
    const viewDocument = view.document;
    this.listenTo(viewDocument, "arrowKey", (...args) => this._onArrowKey(...args), { context: "table" });
    this.listenTo(viewDocument, "tab", (...args) => this._handleTabOnSelectedTable(...args), { context: "figure" });
    this.listenTo(viewDocument, "tab", (...args) => this._handleTab(...args), { context: ["th", "td"] });
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
   * when the table widget is selected.
   */
  _handleTabOnSelectedTable(bubblingEventInfo, domEventData) {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const selectedElement = selection.getSelectedElement();
    if (!selectedElement || !selectedElement.is("element", "table")) {
      return;
    }
    domEventData.preventDefault();
    domEventData.stopPropagation();
    bubblingEventInfo.stop();
    editor.model.change((writer) => {
      writer.setSelection(writer.createRangeIn(selectedElement.getChild(0).getChild(0)));
    });
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
   * inside table cells.
   */
  _handleTab(bubblingEventInfo, domEventData) {
    const editor = this.editor;
    const tableUtils = this.editor.plugins.get(TableUtils);
    const tableSelection = this.editor.plugins.get("TableSelection");
    const selection = editor.model.document.selection;
    const isForward = !domEventData.shiftKey;
    let tableCell = tableUtils.getTableCellsContainingSelection(selection)[0];
    if (!tableCell) {
      tableCell = tableSelection.getFocusCell();
    }
    if (!tableCell) {
      return;
    }
    domEventData.preventDefault();
    domEventData.stopPropagation();
    bubblingEventInfo.stop();
    const tableRow = tableCell.parent;
    const table = tableRow.parent;
    const currentRowIndex = table.getChildIndex(tableRow);
    const currentCellIndex = tableRow.getChildIndex(tableCell);
    const isFirstCellInRow = currentCellIndex === 0;
    if (!isForward && isFirstCellInRow && currentRowIndex === 0) {
      editor.model.change((writer) => {
        writer.setSelection(writer.createRangeOn(table));
      });
      return;
    }
    const isLastCellInRow = currentCellIndex === tableRow.childCount - 1;
    const isLastRow = currentRowIndex === tableUtils.getRows(table) - 1;
    if (isForward && isLastRow && isLastCellInRow) {
      editor.execute("insertTableRowBelow");
      if (currentRowIndex === tableUtils.getRows(table) - 1) {
        editor.model.change((writer) => {
          writer.setSelection(writer.createRangeOn(table));
        });
        return;
      }
    }
    let cellToFocus;
    if (isForward && isLastCellInRow) {
      const nextRow = table.getChild(currentRowIndex + 1);
      cellToFocus = nextRow.getChild(0);
    } else if (!isForward && isFirstCellInRow) {
      const previousRow = table.getChild(currentRowIndex - 1);
      cellToFocus = previousRow.getChild(previousRow.childCount - 1);
    } else {
      cellToFocus = tableRow.getChild(currentCellIndex + (isForward ? 1 : -1));
    }
    editor.model.change((writer) => {
      writer.setSelection(writer.createRangeIn(cellToFocus));
    });
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.
   */
  _onArrowKey(eventInfo, domEventData) {
    const editor = this.editor;
    const keyCode = domEventData.keyCode;
    const direction = getLocalizedArrowKeyCodeDirection(keyCode, editor.locale.contentLanguageDirection);
    const wasHandled = this._handleArrowKeys(direction, domEventData.shiftKey);
    if (wasHandled) {
      domEventData.preventDefault();
      domEventData.stopPropagation();
      eventInfo.stop();
    }
  }
  /**
   * Handles arrow keys to move the selection around the table.
   *
   * @param direction The direction of the arrow key.
   * @param expandSelection If the current selection should be expanded.
   * @returns Returns `true` if key was handled.
   */
  _handleArrowKeys(direction, expandSelection) {
    const tableUtils = this.editor.plugins.get(TableUtils);
    const tableSelection = this.editor.plugins.get("TableSelection");
    const model = this.editor.model;
    const selection = model.document.selection;
    const isForward = ["right", "down"].includes(direction);
    const selectedCells = tableUtils.getSelectedTableCells(selection);
    if (selectedCells.length) {
      let focusCell;
      if (expandSelection) {
        focusCell = tableSelection.getFocusCell();
      } else {
        focusCell = isForward ? selectedCells[selectedCells.length - 1] : selectedCells[0];
      }
      this._navigateFromCellInDirection(focusCell, direction, expandSelection);
      return true;
    }
    const tableCell = selection.focus.findAncestor("tableCell");
    if (!tableCell) {
      return false;
    }
    if (!selection.isCollapsed) {
      if (expandSelection) {
        if (selection.isBackward == isForward && !selection.containsEntireContent(tableCell)) {
          return false;
        }
      } else {
        const selectedElement = selection.getSelectedElement();
        if (!selectedElement || !model.schema.isObject(selectedElement)) {
          return false;
        }
      }
    }
    if (this._isSelectionAtCellEdge(selection, tableCell, isForward)) {
      this._navigateFromCellInDirection(tableCell, direction, expandSelection);
      return true;
    }
    return false;
  }
  /**
   * Returns `true` if the selection is at the boundary of a table cell according to the navigation direction.
   *
   * @param selection The current selection.
   * @param tableCell The current table cell element.
   * @param isForward The expected navigation direction.
   */
  _isSelectionAtCellEdge(selection, tableCell, isForward) {
    const model = this.editor.model;
    const schema = this.editor.model.schema;
    const focus = isForward ? selection.getLastPosition() : selection.getFirstPosition();
    if (!schema.getLimitElement(focus).is("element", "tableCell")) {
      const boundaryPosition = model.createPositionAt(tableCell, isForward ? "end" : 0);
      return boundaryPosition.isTouching(focus);
    }
    const probe = model.createSelection(focus);
    model.modifySelection(probe, { direction: isForward ? "forward" : "backward" });
    return focus.isEqual(probe.focus);
  }
  /**
   * Moves the selection from the given table cell in the specified direction.
   *
   * @param focusCell The table cell that is current multi-cell selection focus.
   * @param direction Direction in which selection should move.
   * @param expandSelection If the current selection should be expanded. Default value is false.
   */
  _navigateFromCellInDirection(focusCell, direction, expandSelection = false) {
    const model = this.editor.model;
    const table = focusCell.findAncestor("table");
    const tableMap = [...new TableWalker(table, { includeAllSlots: true })];
    const { row: lastRow, column: lastColumn } = tableMap[tableMap.length - 1];
    const currentCellInfo = tableMap.find(({ cell }) => cell == focusCell);
    let { row, column } = currentCellInfo;
    switch (direction) {
      case "left":
        column--;
        break;
      case "up":
        row--;
        break;
      case "right":
        column += currentCellInfo.cellWidth;
        break;
      case "down":
        row += currentCellInfo.cellHeight;
        break;
    }
    const isOutsideVertically = row < 0 || row > lastRow;
    const isBeforeFirstCell = column < 0 && row <= 0;
    const isAfterLastCell = column > lastColumn && row >= lastRow;
    if (isOutsideVertically || isBeforeFirstCell || isAfterLastCell) {
      model.change((writer) => {
        writer.setSelection(writer.createRangeOn(table));
      });
      return;
    }
    if (column < 0) {
      column = expandSelection ? 0 : lastColumn;
      row--;
    } else if (column > lastColumn) {
      column = expandSelection ? lastColumn : 0;
      row++;
    }
    const cellToSelect = tableMap.find((cellInfo) => cellInfo.row == row && cellInfo.column == column).cell;
    const isForward = ["right", "down"].includes(direction);
    const tableSelection = this.editor.plugins.get("TableSelection");
    if (expandSelection && tableSelection.isEnabled) {
      const anchorCell = tableSelection.getAnchorCell() || focusCell;
      tableSelection.setCellSelection(anchorCell, cellToSelect);
    } else {
      const positionToSelect = model.createPositionAt(cellToSelect, isForward ? 0 : "end");
      model.change((writer) => {
        writer.setSelection(positionToSelect);
      });
    }
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablemouse/mouseeventsobserver.js
var MouseEventsObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    this.domEventType = [
      "mousemove",
      "mouseleave"
    ];
  }
  /**
   * @inheritDoc
   */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablemouse.js
var TableMouse = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableMouse";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableSelection, TableUtils];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    editor.editing.view.addObserver(MouseEventsObserver);
    this._enableShiftClickSelection();
    this._enableMouseDragSelection();
  }
  /**
   * Enables making cells selection by <kbd>Shift</kbd>+click. Creates a selection from the cell which previously held
   * the selection to the cell which was clicked. It can be the same cell, in which case it selects a single cell.
   */
  _enableShiftClickSelection() {
    const editor = this.editor;
    const tableUtils = editor.plugins.get(TableUtils);
    let blockSelectionChange = false;
    const tableSelection = editor.plugins.get(TableSelection);
    this.listenTo(editor.editing.view.document, "mousedown", (evt, domEventData) => {
      const selection = editor.model.document.selection;
      if (!this.isEnabled || !tableSelection.isEnabled) {
        return;
      }
      if (!domEventData.domEvent.shiftKey) {
        return;
      }
      const anchorCell = tableSelection.getAnchorCell() || tableUtils.getTableCellsContainingSelection(selection)[0];
      if (!anchorCell) {
        return;
      }
      const targetCell = this._getModelTableCellFromDomEvent(domEventData);
      if (targetCell && haveSameTableParent(anchorCell, targetCell)) {
        blockSelectionChange = true;
        tableSelection.setCellSelection(anchorCell, targetCell);
        domEventData.preventDefault();
      }
    });
    this.listenTo(editor.editing.view.document, "mouseup", () => {
      blockSelectionChange = false;
    });
    this.listenTo(editor.editing.view.document, "selectionChange", (evt) => {
      if (blockSelectionChange) {
        evt.stop();
      }
    }, { priority: "highest" });
  }
  /**
   * Enables making cells selection by dragging.
   *
   * The selection is made only on mousemove. Mouse tracking is started on mousedown.
   * However, the cells selection is enabled only after the mouse cursor left the anchor cell.
   * Thanks to that normal text selection within one cell works just fine. However, you can still select
   * just one cell by leaving the anchor cell and moving back to it.
   */
  _enableMouseDragSelection() {
    const editor = this.editor;
    let anchorCell, targetCell;
    let beganCellSelection = false;
    let blockSelectionChange = false;
    const tableSelection = editor.plugins.get(TableSelection);
    this.listenTo(editor.editing.view.document, "mousedown", (evt, domEventData) => {
      if (!this.isEnabled || !tableSelection.isEnabled) {
        return;
      }
      if (domEventData.domEvent.shiftKey || domEventData.domEvent.ctrlKey || domEventData.domEvent.altKey) {
        return;
      }
      anchorCell = this._getModelTableCellFromDomEvent(domEventData);
    });
    this.listenTo(editor.editing.view.document, "mousemove", (evt, domEventData) => {
      if (!domEventData.domEvent.buttons) {
        return;
      }
      if (!anchorCell) {
        return;
      }
      const newTargetCell = this._getModelTableCellFromDomEvent(domEventData);
      if (newTargetCell && haveSameTableParent(anchorCell, newTargetCell)) {
        targetCell = newTargetCell;
        if (!beganCellSelection && targetCell != anchorCell) {
          beganCellSelection = true;
        }
      }
      if (!beganCellSelection) {
        return;
      }
      blockSelectionChange = true;
      tableSelection.setCellSelection(anchorCell, targetCell);
      domEventData.preventDefault();
    });
    this.listenTo(editor.editing.view.document, "mouseup", () => {
      beganCellSelection = false;
      blockSelectionChange = false;
      anchorCell = null;
      targetCell = null;
    });
    this.listenTo(editor.editing.view.document, "selectionChange", (evt) => {
      if (blockSelectionChange) {
        evt.stop();
      }
    }, { priority: "highest" });
  }
  /**
   * Returns the model table cell element based on the target element of the passed DOM event.
   *
   * @returns Returns the table cell or `undefined`.
   */
  _getModelTableCellFromDomEvent(domEventData) {
    const viewTargetElement = domEventData.target;
    const viewPosition = this.editor.editing.view.createPositionAt(viewTargetElement, 0);
    const modelPosition = this.editor.editing.mapper.toModelPosition(viewPosition);
    const modelElement = modelPosition.parent;
    return modelElement.findAncestor("tableCell", { includeSelf: true });
  }
};
function haveSameTableParent(cellA, cellB) {
  return cellA.parent.parent == cellB.parent.parent;
}

// node_modules/@ckeditor/ckeditor5-table/src/table.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/table.css";
var Table = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableEditing, TableUI, TableSelection, TableMouse, TableKeyboard, TableClipboard, Widget];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Table";
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/plaintableoutput.js
var PlainTableOutput = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PlainTableOutput";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Table];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    editor.conversion.for("dataDowncast").elementToStructure({
      model: "table",
      view: downcastTableElement,
      converterPriority: "high"
    });
    if (editor.plugins.has("TableCaption")) {
      editor.conversion.for("dataDowncast").elementToElement({
        model: "caption",
        view: (modelElement, { writer }) => {
          if (modelElement.parent.name === "table") {
            return writer.createContainerElement("caption");
          }
        },
        converterPriority: "high"
      });
    }
    if (editor.plugins.has("TableProperties")) {
      downcastTableBorderAndBackgroundAttributes(editor);
    }
  }
};
function downcastTableElement(table, { writer }) {
  const headingRows = table.getAttribute("headingRows") || 0;
  const headRowsSlot = writer.createSlot((element) => element.is("element", "tableRow") && element.index < headingRows);
  const bodyRowsSlot = writer.createSlot((element) => element.is("element", "tableRow") && element.index >= headingRows);
  const childrenSlot = writer.createSlot((element) => !element.is("element", "tableRow"));
  const theadElement = writer.createContainerElement("thead", null, headRowsSlot);
  const tbodyElement = writer.createContainerElement("tbody", null, bodyRowsSlot);
  const tableContentElements = [];
  if (headingRows) {
    tableContentElements.push(theadElement);
  }
  if (headingRows < table.childCount) {
    tableContentElements.push(tbodyElement);
  }
  return writer.createContainerElement("table", null, [childrenSlot, ...tableContentElements]);
}
function downcastTableBorderAndBackgroundAttributes(editor) {
  const modelAttributes = {
    "border-width": "tableBorderWidth",
    "border-color": "tableBorderColor",
    "border-style": "tableBorderStyle",
    "background-color": "tableBackgroundColor"
  };
  for (const [styleName, modelAttribute] of Object.entries(modelAttributes)) {
    editor.conversion.for("dataDowncast").add((dispatcher) => {
      return dispatcher.on(`attribute:${modelAttribute}:table`, (evt, data, conversionApi) => {
        const { item, attributeNewValue } = data;
        const { mapper, writer } = conversionApi;
        if (!conversionApi.consumable.consume(item, evt.name)) {
          return;
        }
        const table = mapper.toViewElement(item);
        if (attributeNewValue) {
          writer.setStyle(styleName, attributeNewValue, table);
        } else {
          writer.removeStyle(styleName, table);
        }
      }, { priority: "high" });
    });
  }
}

// node_modules/@ckeditor/ckeditor5-table/src/utils/ui/widget.js
function getSelectedTableWidget(selection) {
  const viewElement = selection.getSelectedElement();
  if (viewElement && isTableWidget(viewElement)) {
    return viewElement;
  }
  return null;
}
function getTableWidgetAncestor(selection) {
  const selectionPosition = selection.getFirstPosition();
  if (!selectionPosition) {
    return null;
  }
  let parent = selectionPosition.parent;
  while (parent) {
    if (parent.is("element") && isTableWidget(parent)) {
      return parent;
    }
    parent = parent.parent;
  }
  return null;
}
function isTableWidget(viewElement) {
  return !!viewElement.getCustomProperty("table") && isWidget(viewElement);
}

// node_modules/@ckeditor/ckeditor5-table/src/tabletoolbar.js
var TableToolbar = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [WidgetToolbarRepository];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableToolbar";
  }
  /**
   * @inheritDoc
   */
  afterInit() {
    const editor = this.editor;
    const t = editor.t;
    const widgetToolbarRepository = editor.plugins.get(WidgetToolbarRepository);
    const tableContentToolbarItems = editor.config.get("table.contentToolbar");
    const tableToolbarItems = editor.config.get("table.tableToolbar");
    if (tableContentToolbarItems) {
      widgetToolbarRepository.register("tableContent", {
        ariaLabel: t("Table toolbar"),
        items: tableContentToolbarItems,
        getRelatedElement: getTableWidgetAncestor
      });
    }
    if (tableToolbarItems) {
      widgetToolbarRepository.register("table", {
        ariaLabel: t("Table toolbar"),
        items: tableToolbarItems,
        getRelatedElement: getSelectedTableWidget
      });
    }
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/ui/colorinputview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/colorinput.css";
var ColorInputView = class extends View {
  /**
   * Creates an instance of the color input view.
   *
   * @param locale The locale instance.
   * @param options The input options.
   * @param options.colorDefinitions The colors to be displayed in the palette inside the input's dropdown.
   * @param options.columns The number of columns in which the colors will be displayed.
   * @param options.defaultColorValue If specified, the color input view will replace the "Remove color" button with
   * the "Restore default" button. Instead of clearing the input field, the default color value will be set.
   */
  constructor(locale, options) {
    super(locale);
    this.set("value", "");
    this.set("isReadOnly", false);
    this.set("isFocused", false);
    this.set("isEmpty", true);
    this.options = options;
    this.focusTracker = new FocusTracker();
    this._focusables = new ViewCollection();
    this.dropdownView = this._createDropdownView();
    this.inputView = this._createInputTextView();
    this.keystrokes = new KeystrokeHandler();
    this._stillTyping = false;
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
        focusPrevious: "shift + tab",
        // Navigate items forwards using the <kbd>Tab</kbd> key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-input-color"
        ]
      },
      children: [
        this.dropdownView,
        this.inputView
      ]
    });
    this.on("change:value", (evt, name, inputValue) => this._setInputValue(inputValue));
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.keystrokes.listenTo(this.dropdownView.panelView.element);
  }
  /**
   * Focuses the input.
   */
  focus() {
    this.inputView.focus();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Creates and configures the {@link #dropdownView}.
   */
  _createDropdownView() {
    const locale = this.locale;
    const t = locale.t;
    const bind = this.bindTemplate;
    const colorSelector = this._createColorSelector(locale);
    const dropdown = createDropdown(locale);
    const colorPreview = new View();
    colorPreview.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-input-color__button__preview"
        ],
        style: {
          backgroundColor: bind.to("value")
        }
      },
      children: [{
        tag: "span",
        attributes: {
          class: [
            "ck",
            "ck-input-color__button__preview__no-color-indicator",
            bind.if("value", "ck-hidden", (value) => value != "")
          ]
        }
      }]
    });
    dropdown.buttonView.extendTemplate({
      attributes: {
        class: "ck-input-color__button"
      }
    });
    dropdown.buttonView.children.add(colorPreview);
    dropdown.buttonView.label = t("Color picker");
    dropdown.buttonView.tooltip = true;
    dropdown.panelPosition = locale.uiLanguageDirection === "rtl" ? "se" : "sw";
    dropdown.panelView.children.add(colorSelector);
    dropdown.bind("isEnabled").to(this, "isReadOnly", (value) => !value);
    this._focusables.add(colorSelector);
    this.focusTracker.add(colorSelector.element);
    dropdown.on("change:isOpen", (evt, name, isVisible) => {
      if (isVisible) {
        colorSelector.updateSelectedColors();
        colorSelector.showColorGridsFragment();
      }
    });
    return dropdown;
  }
  /**
   * Creates and configures an instance of {@link module:ui/inputtext/inputtextview~InputTextView}.
   *
   * @returns A configured instance to be set as {@link #inputView}.
   */
  _createInputTextView() {
    const locale = this.locale;
    const inputView = new InputTextView(locale);
    inputView.extendTemplate({
      on: {
        blur: inputView.bindTemplate.to("blur")
      }
    });
    inputView.value = this.value;
    inputView.bind("isReadOnly", "hasError").to(this);
    this.bind("isFocused", "isEmpty").to(inputView);
    inputView.on("input", () => {
      const inputValue = inputView.element.value;
      const mappedColor = this.options.colorDefinitions.find((def) => inputValue === def.label);
      this._stillTyping = true;
      this.value = mappedColor && mappedColor.color || inputValue;
    });
    inputView.on("blur", () => {
      this._stillTyping = false;
      this._setInputValue(inputView.element.value);
    });
    inputView.delegate("input").to(this);
    return inputView;
  }
  /**
   * Creates and configures the panel with "color grid" and "color picker" inside the {@link #dropdownView}.
   */
  _createColorSelector(locale) {
    const t = locale.t;
    const defaultColor = this.options.defaultColorValue || "";
    const removeColorButtonLabel = defaultColor ? t("Restore default") : t("Remove color");
    const colorSelector = new ColorSelectorView(locale, {
      colors: this.options.colorDefinitions,
      columns: this.options.columns,
      removeButtonLabel: removeColorButtonLabel,
      colorPickerLabel: t("Color picker"),
      colorPickerViewConfig: this.options.colorPickerConfig === false ? false : {
        ...this.options.colorPickerConfig,
        hideInput: true
      }
    });
    colorSelector.appendUI();
    colorSelector.on("execute", (evt, data) => {
      if (data.source === "colorPickerSaveButton") {
        this.dropdownView.isOpen = false;
        return;
      }
      this.value = data.value || defaultColor;
      this.fire("input");
      if (data.source !== "colorPicker") {
        this.dropdownView.isOpen = false;
      }
    });
    let backupColor = this.value;
    colorSelector.on("colorPicker:cancel", () => {
      this.value = backupColor;
      this.fire("input");
      this.dropdownView.isOpen = false;
    });
    colorSelector.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
      backupColor = this.value;
    });
    colorSelector.bind("selectedColor").to(this, "value");
    return colorSelector;
  }
  /**
   * Sets {@link #inputView}'s value property to the color value or color label,
   * if there is one and the user is not typing.
   *
   * Handles cases like:
   *
   * * Someone picks the color in the grid.
   * * The color is set from the plugin level.
   *
   * @param inputValue Color value to be set.
   */
  _setInputValue(inputValue) {
    if (!this._stillTyping) {
      const normalizedInputValue = normalizeColor(inputValue);
      const mappedColor = this.options.colorDefinitions.find((def) => normalizedInputValue === normalizeColor(def.color));
      if (mappedColor) {
        this.inputView.value = mappedColor.label;
      } else {
        this.inputView.value = inputValue || "";
      }
    }
  }
};
function normalizeColor(colorString) {
  return colorString.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ");
}

// node_modules/@ckeditor/ckeditor5-table/src/utils/ui/table-properties.js
var isEmpty3 = (val) => val === "";
function getBorderStyleLabels(t) {
  return {
    none: t("None"),
    solid: t("Solid"),
    dotted: t("Dotted"),
    dashed: t("Dashed"),
    double: t("Double"),
    groove: t("Groove"),
    ridge: t("Ridge"),
    inset: t("Inset"),
    outset: t("Outset")
  };
}
function getLocalizedColorErrorText(t) {
  return t('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".');
}
function getLocalizedLengthErrorText(t) {
  return t('The value is invalid. Try "10px" or "2em" or simply "2".');
}
function colorFieldValidator(value) {
  value = value.trim().toLowerCase();
  return isEmpty3(value) || isColor(value);
}
function lengthFieldValidator(value) {
  value = value.trim();
  return isEmpty3(value) || isNumberString(value) || isLength(value) || isPercentage(value);
}
function lineWidthFieldValidator(value) {
  value = value.trim();
  return isEmpty3(value) || isNumberString(value) || isLength(value);
}
function getBorderStyleDefinitions(view, defaultStyle) {
  const itemDefinitions = new Collection();
  const styleLabels = getBorderStyleLabels(view.t);
  for (const style in styleLabels) {
    const definition = {
      type: "button",
      model: new Model({
        _borderStyleValue: style,
        label: styleLabels[style],
        role: "menuitemradio",
        withText: true
      })
    };
    if (style === "none") {
      definition.model.bind("isOn").to(view, "borderStyle", (value) => {
        if (defaultStyle === "none") {
          return !value;
        }
        return value === style;
      });
    } else {
      definition.model.bind("isOn").to(view, "borderStyle", (value) => {
        return value === style;
      });
    }
    itemDefinitions.add(definition);
  }
  return itemDefinitions;
}
function fillToolbar(options) {
  const { view, icons: icons2, toolbar, labels, propertyName, nameToValue, defaultValue } = options;
  for (const name in labels) {
    const button = new ButtonView(view.locale);
    button.set({
      label: labels[name],
      icon: icons2[name],
      tooltip: labels[name]
    });
    const buttonValue = nameToValue ? nameToValue(name) : name;
    button.bind("isOn").to(view, propertyName, (value) => {
      let valueToCompare = value;
      if (value === "" && defaultValue) {
        valueToCompare = defaultValue;
      }
      return buttonValue === valueToCompare;
    });
    button.on("execute", () => {
      view[propertyName] = buttonValue;
    });
    toolbar.items.add(button);
  }
}
var defaultColors = [
  {
    color: "hsl(0, 0%, 0%)",
    label: "Black"
  },
  {
    color: "hsl(0, 0%, 30%)",
    label: "Dim grey"
  },
  {
    color: "hsl(0, 0%, 60%)",
    label: "Grey"
  },
  {
    color: "hsl(0, 0%, 90%)",
    label: "Light grey"
  },
  {
    color: "hsl(0, 0%, 100%)",
    label: "White",
    hasBorder: true
  },
  {
    color: "hsl(0, 75%, 60%)",
    label: "Red"
  },
  {
    color: "hsl(30, 75%, 60%)",
    label: "Orange"
  },
  {
    color: "hsl(60, 75%, 60%)",
    label: "Yellow"
  },
  {
    color: "hsl(90, 75%, 60%)",
    label: "Light green"
  },
  {
    color: "hsl(120, 75%, 60%)",
    label: "Green"
  },
  {
    color: "hsl(150, 75%, 60%)",
    label: "Aquamarine"
  },
  {
    color: "hsl(180, 75%, 60%)",
    label: "Turquoise"
  },
  {
    color: "hsl(210, 75%, 60%)",
    label: "Light blue"
  },
  {
    color: "hsl(240, 75%, 60%)",
    label: "Blue"
  },
  {
    color: "hsl(270, 75%, 60%)",
    label: "Purple"
  }
];
function getLabeledColorInputCreator(options) {
  return (labeledFieldView, viewUid, statusUid) => {
    const colorInputView = new ColorInputView(labeledFieldView.locale, {
      colorDefinitions: colorConfigToColorGridDefinitions(options.colorConfig),
      columns: options.columns,
      defaultColorValue: options.defaultColorValue,
      colorPickerConfig: options.colorPickerConfig
    });
    colorInputView.inputView.set({
      id: viewUid,
      ariaDescribedById: statusUid
    });
    colorInputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
    colorInputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
    colorInputView.on("input", () => {
      labeledFieldView.errorText = null;
    });
    labeledFieldView.bind("isEmpty", "isFocused").to(colorInputView);
    return colorInputView;
  };
}
function isNumberString(value) {
  const parsedValue = parseFloat(value);
  return !Number.isNaN(parsedValue) && value === String(parsedValue);
}
function colorConfigToColorGridDefinitions(colorConfig) {
  return colorConfig.map((item) => ({
    color: item.model,
    label: item.label,
    options: {
      hasBorder: item.hasBorder
    }
  }));
}

// node_modules/@ckeditor/ckeditor5-table/src/ui/formrowview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/formrow.css";
var FormRowView = class extends View {
  /**
   * Creates an instance of the form row class.
   *
   * @param locale The locale instance.
   * @param options.labelView When passed, the row gets the `group` and `aria-labelledby`
   * DOM attributes and gets described by the label.
   */
  constructor(locale, options = {}) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("class", options.class || null);
    this.children = this.createCollection();
    if (options.children) {
      options.children.forEach((child) => this.children.add(child));
    }
    this.set("_role", null);
    this.set("_ariaLabelledBy", null);
    if (options.labelView) {
      this.set({
        _role: "group",
        _ariaLabelledBy: options.labelView.id
      });
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-form__row",
          bind.to("class")
        ],
        role: bind.to("_role"),
        "aria-labelledby": bind.to("_ariaLabelledBy")
      },
      children: this.children
    });
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/ui/tablecellpropertiesview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/form.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/tableform.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/tablecellproperties.css";
var ALIGNMENT_ICONS = {
  left: icons.alignLeft,
  center: icons.alignCenter,
  right: icons.alignRight,
  justify: icons.alignJustify,
  top: icons.alignTop,
  middle: icons.alignMiddle,
  bottom: icons.alignBottom
};
var TableCellPropertiesView = class extends View {
  /**
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param options Additional configuration of the view.
   * @param options.borderColors A configuration of the border color palette used by the
   * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#borderColorInput}.
   * @param options.backgroundColors A configuration of the background color palette used by the
   * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#backgroundInput}.
   * @param options.defaultTableCellProperties The default table cell properties.
   */
  constructor(locale, options) {
    super(locale);
    this.set({
      borderStyle: "",
      borderWidth: "",
      borderColor: "",
      padding: "",
      backgroundColor: "",
      width: "",
      height: "",
      horizontalAlignment: "",
      verticalAlignment: ""
    });
    this.options = options;
    const { borderStyleDropdown, borderWidthInput, borderColorInput, borderRowLabel } = this._createBorderFields();
    const { backgroundRowLabel, backgroundInput } = this._createBackgroundFields();
    const { widthInput, operatorLabel, heightInput, dimensionsLabel } = this._createDimensionFields();
    const { horizontalAlignmentToolbar, verticalAlignmentToolbar, alignmentLabel } = this._createAlignmentFields();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.children = this.createCollection();
    this.borderStyleDropdown = borderStyleDropdown;
    this.borderWidthInput = borderWidthInput;
    this.borderColorInput = borderColorInput;
    this.backgroundInput = backgroundInput;
    this.paddingInput = this._createPaddingField();
    this.widthInput = widthInput;
    this.heightInput = heightInput;
    this.horizontalAlignmentToolbar = horizontalAlignmentToolbar;
    this.verticalAlignmentToolbar = verticalAlignmentToolbar;
    const { saveButtonView, cancelButtonView } = this._createActionButtons();
    this.saveButtonView = saveButtonView;
    this.cancelButtonView = cancelButtonView;
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.children.add(new FormHeaderView(locale, {
      label: this.t("Cell properties")
    }));
    this.children.add(new FormRowView(locale, {
      labelView: borderRowLabel,
      children: [
        borderRowLabel,
        borderStyleDropdown,
        borderColorInput,
        borderWidthInput
      ],
      class: "ck-table-form__border-row"
    }));
    this.children.add(new FormRowView(locale, {
      labelView: backgroundRowLabel,
      children: [
        backgroundRowLabel,
        backgroundInput
      ],
      class: "ck-table-form__background-row"
    }));
    this.children.add(new FormRowView(locale, {
      children: [
        // Dimensions row.
        new FormRowView(locale, {
          labelView: dimensionsLabel,
          children: [
            dimensionsLabel,
            widthInput,
            operatorLabel,
            heightInput
          ],
          class: "ck-table-form__dimensions-row"
        }),
        // Padding row.
        new FormRowView(locale, {
          children: [
            this.paddingInput
          ],
          class: "ck-table-cell-properties-form__padding-row"
        })
      ]
    }));
    this.children.add(new FormRowView(locale, {
      labelView: alignmentLabel,
      children: [
        alignmentLabel,
        horizontalAlignmentToolbar,
        verticalAlignmentToolbar
      ],
      class: "ck-table-cell-properties-form__alignment-row"
    }));
    this.children.add(new FormRowView(locale, {
      children: [
        this.saveButtonView,
        this.cancelButtonView
      ],
      class: "ck-table-form__action-row"
    }));
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-form",
          "ck-table-form",
          "ck-table-cell-properties-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    [
      this.borderStyleDropdown,
      this.borderColorInput,
      this.borderColorInput.fieldView.dropdownView.buttonView,
      this.borderWidthInput,
      this.backgroundInput,
      this.backgroundInput.fieldView.dropdownView.buttonView,
      this.widthInput,
      this.heightInput,
      this.paddingInput,
      this.horizontalAlignmentToolbar,
      this.verticalAlignmentToolbar,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((view) => {
      this._focusables.add(view);
      this.focusTracker.add(view.element);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Focuses the fist focusable field in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #borderStyleDropdown},
   * * {@link #borderWidthInput},
   * * {@link #borderColorInput}.
   */
  _createBorderFields() {
    const defaultTableCellProperties = this.options.defaultTableCellProperties;
    const defaultBorder = {
      style: defaultTableCellProperties.borderStyle,
      width: defaultTableCellProperties.borderWidth,
      color: defaultTableCellProperties.borderColor
    };
    const colorInputCreator = getLabeledColorInputCreator({
      colorConfig: this.options.borderColors,
      columns: 5,
      defaultColorValue: defaultBorder.color,
      colorPickerConfig: this.options.colorPickerConfig
    });
    const locale = this.locale;
    const t = this.t;
    const accessibleLabel = t("Style");
    const borderRowLabel = new LabelView(locale);
    borderRowLabel.text = t("Border");
    const styleLabels = getBorderStyleLabels(t);
    const borderStyleDropdown = new LabeledFieldView(locale, createLabeledDropdown);
    borderStyleDropdown.set({
      label: accessibleLabel,
      class: "ck-table-form__border-style"
    });
    borderStyleDropdown.fieldView.buttonView.set({
      ariaLabel: accessibleLabel,
      ariaLabelledBy: void 0,
      isOn: false,
      withText: true,
      tooltip: accessibleLabel
    });
    borderStyleDropdown.fieldView.buttonView.bind("label").to(this, "borderStyle", (value) => {
      return styleLabels[value ? value : "none"];
    });
    borderStyleDropdown.fieldView.on("execute", (evt) => {
      this.borderStyle = evt.source._borderStyleValue;
    });
    borderStyleDropdown.bind("isEmpty").to(this, "borderStyle", (value) => !value);
    addListToDropdown(borderStyleDropdown.fieldView, getBorderStyleDefinitions(this, defaultBorder.style), {
      role: "menu",
      ariaLabel: accessibleLabel
    });
    const borderWidthInput = new LabeledFieldView(locale, createLabeledInputText);
    borderWidthInput.set({
      label: t("Width"),
      class: "ck-table-form__border-width"
    });
    borderWidthInput.fieldView.bind("value").to(this, "borderWidth");
    borderWidthInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet);
    borderWidthInput.fieldView.on("input", () => {
      this.borderWidth = borderWidthInput.fieldView.element.value;
    });
    const borderColorInput = new LabeledFieldView(locale, colorInputCreator);
    borderColorInput.set({
      label: t("Color"),
      class: "ck-table-form__border-color"
    });
    borderColorInput.fieldView.bind("value").to(this, "borderColor");
    borderColorInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet);
    borderColorInput.fieldView.on("input", () => {
      this.borderColor = borderColorInput.fieldView.value;
    });
    this.on("change:borderStyle", (evt, name, newValue, oldValue) => {
      if (!isBorderStyleSet(newValue)) {
        this.borderColor = "";
        this.borderWidth = "";
      }
      if (!isBorderStyleSet(oldValue)) {
        this.borderColor = defaultBorder.color;
        this.borderWidth = defaultBorder.width;
      }
    });
    return {
      borderRowLabel,
      borderStyleDropdown,
      borderColorInput,
      borderWidthInput
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #backgroundInput}.
   */
  _createBackgroundFields() {
    const locale = this.locale;
    const t = this.t;
    const backgroundRowLabel = new LabelView(locale);
    backgroundRowLabel.text = t("Background");
    const colorInputCreator = getLabeledColorInputCreator({
      colorConfig: this.options.backgroundColors,
      columns: 5,
      defaultColorValue: this.options.defaultTableCellProperties.backgroundColor,
      colorPickerConfig: this.options.colorPickerConfig
    });
    const backgroundInput = new LabeledFieldView(locale, colorInputCreator);
    backgroundInput.set({
      label: t("Color"),
      class: "ck-table-cell-properties-form__background"
    });
    backgroundInput.fieldView.bind("value").to(this, "backgroundColor");
    backgroundInput.fieldView.on("input", () => {
      this.backgroundColor = backgroundInput.fieldView.value;
    });
    return {
      backgroundRowLabel,
      backgroundInput
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #widthInput}.
   * * {@link #heightInput}.
   */
  _createDimensionFields() {
    const locale = this.locale;
    const t = this.t;
    const dimensionsLabel = new LabelView(locale);
    dimensionsLabel.text = t("Dimensions");
    const widthInput = new LabeledFieldView(locale, createLabeledInputText);
    widthInput.set({
      label: t("Width"),
      class: "ck-table-form__dimensions-row__width"
    });
    widthInput.fieldView.bind("value").to(this, "width");
    widthInput.fieldView.on("input", () => {
      this.width = widthInput.fieldView.element.value;
    });
    const operatorLabel = new View(locale);
    operatorLabel.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck-table-form__dimension-operator"
        ]
      },
      children: [
        { text: "" }
      ]
    });
    const heightInput = new LabeledFieldView(locale, createLabeledInputText);
    heightInput.set({
      label: t("Height"),
      class: "ck-table-form__dimensions-row__height"
    });
    heightInput.fieldView.bind("value").to(this, "height");
    heightInput.fieldView.on("input", () => {
      this.height = heightInput.fieldView.element.value;
    });
    return {
      dimensionsLabel,
      widthInput,
      operatorLabel,
      heightInput
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #paddingInput}.
   */
  _createPaddingField() {
    const locale = this.locale;
    const t = this.t;
    const paddingInput = new LabeledFieldView(locale, createLabeledInputText);
    paddingInput.set({
      label: t("Padding"),
      class: "ck-table-cell-properties-form__padding"
    });
    paddingInput.fieldView.bind("value").to(this, "padding");
    paddingInput.fieldView.on("input", () => {
      this.padding = paddingInput.fieldView.element.value;
    });
    return paddingInput;
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #horizontalAlignmentToolbar},
   * * {@link #verticalAlignmentToolbar}.
   */
  _createAlignmentFields() {
    const locale = this.locale;
    const t = this.t;
    const alignmentLabel = new LabelView(locale);
    alignmentLabel.text = t("Table cell text alignment");
    const horizontalAlignmentToolbar = new ToolbarView(locale);
    const isContentRTL = locale.contentLanguageDirection === "rtl";
    horizontalAlignmentToolbar.set({
      isCompact: true,
      ariaLabel: t("Horizontal text alignment toolbar")
    });
    fillToolbar({
      view: this,
      icons: ALIGNMENT_ICONS,
      toolbar: horizontalAlignmentToolbar,
      labels: this._horizontalAlignmentLabels,
      propertyName: "horizontalAlignment",
      nameToValue: (name) => {
        if (isContentRTL) {
          if (name === "left") {
            return "right";
          } else if (name === "right") {
            return "left";
          }
        }
        return name;
      },
      defaultValue: this.options.defaultTableCellProperties.horizontalAlignment
    });
    const verticalAlignmentToolbar = new ToolbarView(locale);
    verticalAlignmentToolbar.set({
      isCompact: true,
      ariaLabel: t("Vertical text alignment toolbar")
    });
    fillToolbar({
      view: this,
      icons: ALIGNMENT_ICONS,
      toolbar: verticalAlignmentToolbar,
      labels: this._verticalAlignmentLabels,
      propertyName: "verticalAlignment",
      defaultValue: this.options.defaultTableCellProperties.verticalAlignment
    });
    return {
      horizontalAlignmentToolbar,
      verticalAlignmentToolbar,
      alignmentLabel
    };
  }
  /**
   * Creates the following form controls:
   *
   * * {@link #saveButtonView},
   * * {@link #cancelButtonView}.
   */
  _createActionButtons() {
    const locale = this.locale;
    const t = this.t;
    const saveButtonView = new ButtonView(locale);
    const cancelButtonView = new ButtonView(locale);
    const fieldsThatShouldValidateToSave = [
      this.borderWidthInput,
      this.borderColorInput,
      this.backgroundInput,
      this.paddingInput
    ];
    saveButtonView.set({
      label: t("Save"),
      icon: icons.check,
      class: "ck-button-save",
      type: "submit",
      withText: true
    });
    saveButtonView.bind("isEnabled").toMany(fieldsThatShouldValidateToSave, "errorText", (...errorTexts) => {
      return errorTexts.every((errorText) => !errorText);
    });
    cancelButtonView.set({
      label: t("Cancel"),
      icon: icons.cancel,
      class: "ck-button-cancel",
      withText: true
    });
    cancelButtonView.delegate("execute").to(this, "cancel");
    return {
      saveButtonView,
      cancelButtonView
    };
  }
  /**
   * Provides localized labels for {@link #horizontalAlignmentToolbar} buttons.
   */
  get _horizontalAlignmentLabels() {
    const locale = this.locale;
    const t = this.t;
    const left = t("Align cell text to the left");
    const center = t("Align cell text to the center");
    const right = t("Align cell text to the right");
    const justify = t("Justify cell text");
    if (locale.uiLanguageDirection === "rtl") {
      return { right, center, left, justify };
    } else {
      return { left, center, right, justify };
    }
  }
  /**
   * Provides localized labels for {@link #verticalAlignmentToolbar} buttons.
   */
  get _verticalAlignmentLabels() {
    const t = this.t;
    return {
      top: t("Align cell text to the top"),
      middle: t("Align cell text to the middle"),
      bottom: t("Align cell text to the bottom")
    };
  }
};
function isBorderStyleSet(value) {
  return value !== "none";
}

// node_modules/@ckeditor/ckeditor5-table/src/utils/ui/contextualballoon.js
var DEFAULT_BALLOON_POSITIONS = BalloonPanelView.defaultPositions;
var BALLOON_POSITIONS = [
  DEFAULT_BALLOON_POSITIONS.northArrowSouth,
  DEFAULT_BALLOON_POSITIONS.northArrowSouthWest,
  DEFAULT_BALLOON_POSITIONS.northArrowSouthEast,
  DEFAULT_BALLOON_POSITIONS.southArrowNorth,
  DEFAULT_BALLOON_POSITIONS.southArrowNorthWest,
  DEFAULT_BALLOON_POSITIONS.southArrowNorthEast,
  DEFAULT_BALLOON_POSITIONS.viewportStickyNorth
];
function repositionContextualBalloon(editor, target) {
  const balloon = editor.plugins.get("ContextualBalloon");
  if (getTableWidgetAncestor(editor.editing.view.document.selection)) {
    let position;
    if (target === "cell") {
      position = getBalloonCellPositionData(editor);
    } else {
      position = getBalloonTablePositionData(editor);
    }
    balloon.updatePosition(position);
  }
}
function getBalloonTablePositionData(editor) {
  const firstPosition = editor.model.document.selection.getFirstPosition();
  const modelTable = firstPosition.findAncestor("table");
  const viewTable = editor.editing.mapper.toViewElement(modelTable);
  return {
    target: editor.editing.view.domConverter.mapViewToDom(viewTable),
    positions: BALLOON_POSITIONS
  };
}
function getBalloonCellPositionData(editor) {
  const mapper = editor.editing.mapper;
  const domConverter = editor.editing.view.domConverter;
  const selection = editor.model.document.selection;
  if (selection.rangeCount > 1) {
    return {
      target: () => createBoundingRect(selection.getRanges(), editor),
      positions: BALLOON_POSITIONS
    };
  }
  const modelTableCell = getTableCellAtPosition(selection.getFirstPosition());
  const viewTableCell = mapper.toViewElement(modelTableCell);
  return {
    target: domConverter.mapViewToDom(viewTableCell),
    positions: BALLOON_POSITIONS
  };
}
function getTableCellAtPosition(position) {
  const isTableCellSelected = position.nodeAfter && position.nodeAfter.is("element", "tableCell");
  return isTableCellSelected ? position.nodeAfter : position.findAncestor("tableCell");
}
function createBoundingRect(ranges, editor) {
  const mapper = editor.editing.mapper;
  const domConverter = editor.editing.view.domConverter;
  const rects = Array.from(ranges).map((range) => {
    const modelTableCell = getTableCellAtPosition(range.start);
    const viewTableCell = mapper.toViewElement(modelTableCell);
    return new Rect(domConverter.mapViewToDom(viewTableCell));
  });
  return Rect.getBoundingRect(rects);
}

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/tablecellpropertiesui.js
import tableCellProperties from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/icons/table-cell-properties.svg";

// node_modules/@ckeditor/ckeditor5-table/src/utils/table-properties.js
function getSingleValue(objectOrString) {
  if (!objectOrString || !isObject_default(objectOrString)) {
    return objectOrString;
  }
  const { top, right, bottom, left } = objectOrString;
  if (top == right && right == bottom && bottom == left) {
    return top;
  }
}
function addDefaultUnitToNumericValue(value, defaultUnit) {
  const numericValue = parseFloat(value);
  if (Number.isNaN(numericValue)) {
    return value;
  }
  if (String(numericValue) !== String(value)) {
    return value;
  }
  return `${numericValue}${defaultUnit}`;
}
function getNormalizedDefaultProperties(config, options = {}) {
  const normalizedConfig = {
    borderStyle: "none",
    borderWidth: "",
    borderColor: "",
    backgroundColor: "",
    width: "",
    height: "",
    ...config
  };
  if (options.includeAlignmentProperty && !normalizedConfig.alignment) {
    normalizedConfig.alignment = "center";
  }
  if (options.includePaddingProperty && !normalizedConfig.padding) {
    normalizedConfig.padding = "";
  }
  if (options.includeVerticalAlignmentProperty && !normalizedConfig.verticalAlignment) {
    normalizedConfig.verticalAlignment = "middle";
  }
  if (options.includeHorizontalAlignmentProperty && !normalizedConfig.horizontalAlignment) {
    normalizedConfig.horizontalAlignment = options.isRightToLeftContent ? "right" : "left";
  }
  return normalizedConfig;
}

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/tablecellpropertiesui.js
var ERROR_TEXT_TIMEOUT = 500;
var propertyToCommandMap = {
  borderStyle: "tableCellBorderStyle",
  borderColor: "tableCellBorderColor",
  borderWidth: "tableCellBorderWidth",
  height: "tableCellHeight",
  width: "tableCellWidth",
  padding: "tableCellPadding",
  backgroundColor: "tableCellBackgroundColor",
  horizontalAlignment: "tableCellHorizontalAlignment",
  verticalAlignment: "tableCellVerticalAlignment"
};
var TableCellPropertiesUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ContextualBalloon];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCellPropertiesUI";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    editor.config.define("table.tableCellProperties", {
      borderColors: defaultColors,
      backgroundColors: defaultColors
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    this._defaultTableCellProperties = getNormalizedDefaultProperties(editor.config.get("table.tableCellProperties.defaultProperties"), {
      includeVerticalAlignmentProperty: true,
      includeHorizontalAlignmentProperty: true,
      includePaddingProperty: true,
      isRightToLeftContent: editor.locale.contentLanguageDirection === "rtl"
    });
    this._balloon = editor.plugins.get(ContextualBalloon);
    this.view = null;
    this._isReady = false;
    editor.ui.componentFactory.add("tableCellProperties", (locale) => {
      const view = new ButtonView(locale);
      view.set({
        label: t("Cell properties"),
        icon: tableCellProperties,
        tooltip: true
      });
      this.listenTo(view, "execute", () => this._showView());
      const commands = Object.values(propertyToCommandMap).map((commandName) => editor.commands.get(commandName));
      view.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => areEnabled.some((isCommandEnabled) => isCommandEnabled));
      return view;
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    if (this.view) {
      this.view.destroy();
    }
  }
  /**
   * Creates the {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView} instance.
   *
   * @returns The cell properties form view instance.
   */
  _createPropertiesView() {
    const editor = this.editor;
    const config = editor.config.get("table.tableCellProperties");
    const borderColorsConfig = normalizeColorOptions(config.borderColors);
    const localizedBorderColors = getLocalizedColorOptions(editor.locale, borderColorsConfig);
    const backgroundColorsConfig = normalizeColorOptions(config.backgroundColors);
    const localizedBackgroundColors = getLocalizedColorOptions(editor.locale, backgroundColorsConfig);
    const hasColorPicker = config.colorPicker !== false;
    const view = new TableCellPropertiesView(editor.locale, {
      borderColors: localizedBorderColors,
      backgroundColors: localizedBackgroundColors,
      defaultTableCellProperties: this._defaultTableCellProperties,
      colorPickerConfig: hasColorPicker ? config.colorPicker || {} : false
    });
    const t = editor.t;
    view.render();
    this.listenTo(view, "submit", () => {
      this._hideView();
    });
    this.listenTo(view, "cancel", () => {
      if (this._undoStepBatch.operations.length) {
        editor.execute("undo", this._undoStepBatch);
      }
      this._hideView();
    });
    view.keystrokes.set("Esc", (data, cancel) => {
      this._hideView();
      cancel();
    });
    clickOutsideHandler({
      emitter: view,
      activator: () => this._isViewInBalloon,
      contextElements: [this._balloon.view.element],
      callback: () => this._hideView()
    });
    const colorErrorText = getLocalizedColorErrorText(t);
    const lengthErrorText = getLocalizedLengthErrorText(t);
    view.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle"));
    view.on("change:borderColor", this._getValidatedPropertyChangeCallback({
      viewField: view.borderColorInput,
      commandName: "tableCellBorderColor",
      errorText: colorErrorText,
      validator: colorFieldValidator
    }));
    view.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
      viewField: view.borderWidthInput,
      commandName: "tableCellBorderWidth",
      errorText: lengthErrorText,
      validator: lineWidthFieldValidator
    }));
    view.on("change:padding", this._getValidatedPropertyChangeCallback({
      viewField: view.paddingInput,
      commandName: "tableCellPadding",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:width", this._getValidatedPropertyChangeCallback({
      viewField: view.widthInput,
      commandName: "tableCellWidth",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:height", this._getValidatedPropertyChangeCallback({
      viewField: view.heightInput,
      commandName: "tableCellHeight",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
      viewField: view.backgroundInput,
      commandName: "tableCellBackgroundColor",
      errorText: colorErrorText,
      validator: colorFieldValidator
    }));
    view.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment"));
    view.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment"));
    return view;
  }
  /**
   * In this method the "editor data -> UI" binding is happening.
   *
   * When executed, this method obtains selected cell property values from various table commands
   * and passes them to the {@link #view}.
   *
   * This way, the UI stays uptodate with the editor data.
   */
  _fillViewFormFromCommandValues() {
    const commands = this.editor.commands;
    const borderStyleCommand = commands.get("tableCellBorderStyle");
    Object.entries(propertyToCommandMap).map(([property, commandName]) => {
      const defaultValue = this._defaultTableCellProperties[property] || "";
      return [
        property,
        commands.get(commandName).value || defaultValue
      ];
    }).forEach(([property, value]) => {
      if ((property === "borderColor" || property === "borderWidth") && borderStyleCommand.value === "none") {
        return;
      }
      this.view.set(property, value);
    });
    this._isReady = true;
  }
  /**
   * Shows the {@link #view} in the {@link #_balloon}.
   *
   * **Note**: Each time a view is shown, a new {@link #_undoStepBatch} is created. It contains
   * all changes made to the document when the view is visible, allowing a single undo step
   * for all of them.
   */
  _showView() {
    const editor = this.editor;
    if (!this.view) {
      this.view = this._createPropertiesView();
    }
    this.listenTo(editor.ui, "update", () => {
      this._updateView();
    });
    this._fillViewFormFromCommandValues();
    this._balloon.add({
      view: this.view,
      position: getBalloonCellPositionData(editor)
    });
    this._undoStepBatch = editor.model.createBatch();
    this.view.focus();
  }
  /**
   * Removes the {@link #view} from the {@link #_balloon}.
   */
  _hideView() {
    const editor = this.editor;
    this.stopListening(editor.ui, "update");
    this._isReady = false;
    this.view.saveButtonView.focus();
    this._balloon.remove(this.view);
    this.editor.editing.view.focus();
  }
  /**
   * Repositions the {@link #_balloon} or hides the {@link #view} if a table cell is no longer selected.
   */
  _updateView() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    if (!getTableWidgetAncestor(viewDocument.selection)) {
      this._hideView();
    } else if (this._isViewVisible) {
      repositionContextualBalloon(editor, "cell");
    }
  }
  /**
   * Returns `true` when the {@link #view} is visible in the {@link #_balloon}.
   */
  get _isViewVisible() {
    return !!this.view && this._balloon.visibleView === this.view;
  }
  /**
   * Returns `true` when the {@link #view} is in the {@link #_balloon}.
   */
  get _isViewInBalloon() {
    return !!this.view && this._balloon.hasView(this.view);
  }
  /**
   * Creates a callback that when executed upon the {@link #view view's} property change
   * executes a related editor command with the new property value.
   *
   * @param defaultValue The default value of the command.
   */
  _getPropertyChangeCallback(commandName) {
    return (evt, propertyName, newValue) => {
      if (!this._isReady) {
        return;
      }
      this.editor.execute(commandName, {
        value: newValue,
        batch: this._undoStepBatch
      });
    };
  }
  /**
   * Creates a callback that when executed upon the {@link #view view's} property change:
   * * Executes a related editor command with the new property value if the value is valid,
   * * Or sets the error text next to the invalid field, if the value did not pass the validation.
   */
  _getValidatedPropertyChangeCallback(options) {
    const { commandName, viewField, validator, errorText } = options;
    const setErrorTextDebounced = debounce_default(() => {
      viewField.errorText = errorText;
    }, ERROR_TEXT_TIMEOUT);
    return (evt, propertyName, newValue) => {
      setErrorTextDebounced.cancel();
      if (!this._isReady) {
        return;
      }
      if (validator(newValue)) {
        this.editor.execute(commandName, {
          value: newValue,
          batch: this._undoStepBatch
        });
        viewField.errorText = null;
      } else {
        setErrorTextDebounced();
      }
    };
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellpropertycommand.js
var TableCellPropertyCommand = class extends Command {
  /**
   * Creates a new `TableCellPropertyCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param attributeName Table cell attribute name.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, attributeName, defaultValue) {
    super(editor);
    this.attributeName = attributeName;
    this._defaultValue = defaultValue;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const selectedTableCells = tableUtils.getSelectionAffectedTableCells(editor.model.document.selection);
    this.isEnabled = !!selectedTableCells.length;
    this.value = this._getSingleValue(selectedTableCells);
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.value If set, the command will set the attribute on selected table cells.
   * If it is not set, the command will remove the attribute from the selected table cells.
   * @param options.batch Pass the model batch instance to the command to aggregate changes,
   * for example to allow a single undo step for multiple executions.
   */
  execute(options = {}) {
    const { value, batch } = options;
    const model = this.editor.model;
    const tableUtils = this.editor.plugins.get("TableUtils");
    const tableCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
    const valueToSet = this._getValueToSet(value);
    model.enqueueChange(batch, (writer) => {
      if (valueToSet) {
        tableCells.forEach((tableCell) => writer.setAttribute(this.attributeName, valueToSet, tableCell));
      } else {
        tableCells.forEach((tableCell) => writer.removeAttribute(this.attributeName, tableCell));
      }
    });
  }
  /**
   * Returns the attribute value for a table cell.
   */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = tableCell.getAttribute(this.attributeName);
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
   * Returns the proper model value. It can be used to add a default unit to numeric values.
   */
  _getValueToSet(value) {
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
   * Returns a single value for all selected table cells. If the value is the same for all cells,
   * it will be returned (`undefined` otherwise).
   */
  _getSingleValue(tableCells) {
    const firstCellValue = this._getAttribute(tableCells[0]);
    const everyCellHasAttribute = tableCells.every((tableCells2) => this._getAttribute(tableCells2) === firstCellValue);
    return everyCellHasAttribute ? firstCellValue : void 0;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellwidth/commands/tablecellwidthcommand.js
var TableCellWidthCommand = class extends TableCellPropertyCommand {
  /**
   * Creates a new `TableCellWidthCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableCellWidth", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(value) {
    value = addDefaultUnitToNumericValue(value, "px");
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellwidth/tablecellwidthediting.js
var TableCellWidthEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCellWidthEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableEditing];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const defaultTableCellProperties = getNormalizedDefaultProperties(editor.config.get("table.tableCellProperties.defaultProperties"));
    enableProperty(editor.model.schema, editor.conversion, {
      modelAttribute: "tableCellWidth",
      styleName: "width",
      defaultValue: defaultTableCellProperties.width
    });
    editor.commands.add("tableCellWidth", new TableCellWidthCommand(editor, defaultTableCellProperties.width));
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellpaddingcommand.js
var TableCellPaddingCommand = class extends TableCellPropertyCommand {
  /**
   * Creates a new `TableCellPaddingCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableCellPadding", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = getSingleValue(tableCell.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(value) {
    const newValue = addDefaultUnitToNumericValue(value, "px");
    if (newValue === this._defaultValue) {
      return;
    }
    return newValue;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellheightcommand.js
var TableCellHeightCommand = class extends TableCellPropertyCommand {
  /**
   * Creates a new `TableCellHeightCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableCellHeight", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(value) {
    const newValue = addDefaultUnitToNumericValue(value, "px");
    if (newValue === this._defaultValue) {
      return;
    }
    return newValue;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellbackgroundcolorcommand.js
var TableCellBackgroundColorCommand = class extends TableCellPropertyCommand {
  /**
   * Creates a new `TableCellBackgroundColorCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableCellBackgroundColor", defaultValue);
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellverticalalignmentcommand.js
var TableCellVerticalAlignmentCommand = class extends TableCellPropertyCommand {
  /**
   * Creates a new `TableCellVerticalAlignmentCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value for the "alignment" attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableCellVerticalAlignment", defaultValue);
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellhorizontalalignmentcommand.js
var TableCellHorizontalAlignmentCommand = class extends TableCellPropertyCommand {
  /**
   * Creates a new `TableCellHorizontalAlignmentCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value for the "alignment" attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableCellHorizontalAlignment", defaultValue);
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellborderstylecommand.js
var TableCellBorderStyleCommand = class extends TableCellPropertyCommand {
  /**
   * Creates a new `TableCellBorderStyleCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableCellBorderStyle", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = getSingleValue(tableCell.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellbordercolorcommand.js
var TableCellBorderColorCommand = class extends TableCellPropertyCommand {
  /**
   * Creates a new `TableCellBorderColorCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableCellBorderColor", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = getSingleValue(tableCell.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellborderwidthcommand.js
var TableCellBorderWidthCommand = class extends TableCellPropertyCommand {
  /**
   * Creates a new `TableCellBorderWidthCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableCellBorderWidth", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getAttribute(tableCell) {
    if (!tableCell) {
      return;
    }
    const value = getSingleValue(tableCell.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(value) {
    const newValue = addDefaultUnitToNumericValue(value, "px");
    if (newValue === this._defaultValue) {
      return;
    }
    return newValue;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties/tablecellpropertiesediting.js
var VALIGN_VALUES_REG_EXP = /^(top|middle|bottom)$/;
var ALIGN_VALUES_REG_EXP = /^(left|center|right|justify)$/;
var TableCellPropertiesEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCellPropertiesEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableEditing, TableCellWidthEditing];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    editor.config.define("table.tableCellProperties.defaultProperties", {});
    const defaultTableCellProperties = getNormalizedDefaultProperties(editor.config.get("table.tableCellProperties.defaultProperties"), {
      includeVerticalAlignmentProperty: true,
      includeHorizontalAlignmentProperty: true,
      includePaddingProperty: true,
      isRightToLeftContent: editor.locale.contentLanguageDirection === "rtl"
    });
    editor.data.addStyleProcessorRules(addBorderRules);
    enableBorderProperties(schema, conversion, {
      color: defaultTableCellProperties.borderColor,
      style: defaultTableCellProperties.borderStyle,
      width: defaultTableCellProperties.borderWidth
    });
    editor.commands.add("tableCellBorderStyle", new TableCellBorderStyleCommand(editor, defaultTableCellProperties.borderStyle));
    editor.commands.add("tableCellBorderColor", new TableCellBorderColorCommand(editor, defaultTableCellProperties.borderColor));
    editor.commands.add("tableCellBorderWidth", new TableCellBorderWidthCommand(editor, defaultTableCellProperties.borderWidth));
    enableProperty(schema, conversion, {
      modelAttribute: "tableCellHeight",
      styleName: "height",
      defaultValue: defaultTableCellProperties.height
    });
    editor.commands.add("tableCellHeight", new TableCellHeightCommand(editor, defaultTableCellProperties.height));
    editor.data.addStyleProcessorRules(addPaddingRules);
    enableProperty(schema, conversion, {
      modelAttribute: "tableCellPadding",
      styleName: "padding",
      reduceBoxSides: true,
      defaultValue: defaultTableCellProperties.padding
    });
    editor.commands.add("tableCellPadding", new TableCellPaddingCommand(editor, defaultTableCellProperties.padding));
    editor.data.addStyleProcessorRules(addBackgroundRules);
    enableProperty(schema, conversion, {
      modelAttribute: "tableCellBackgroundColor",
      styleName: "background-color",
      defaultValue: defaultTableCellProperties.backgroundColor
    });
    editor.commands.add("tableCellBackgroundColor", new TableCellBackgroundColorCommand(editor, defaultTableCellProperties.backgroundColor));
    enableHorizontalAlignmentProperty(schema, conversion, defaultTableCellProperties.horizontalAlignment);
    editor.commands.add("tableCellHorizontalAlignment", new TableCellHorizontalAlignmentCommand(editor, defaultTableCellProperties.horizontalAlignment));
    enableVerticalAlignmentProperty(schema, conversion, defaultTableCellProperties.verticalAlignment);
    editor.commands.add("tableCellVerticalAlignment", new TableCellVerticalAlignmentCommand(editor, defaultTableCellProperties.verticalAlignment));
  }
};
function enableBorderProperties(schema, conversion, defaultBorder) {
  const modelAttributes = {
    width: "tableCellBorderWidth",
    color: "tableCellBorderColor",
    style: "tableCellBorderStyle"
  };
  schema.extend("tableCell", {
    allowAttributes: Object.values(modelAttributes)
  });
  upcastBorderStyles(conversion, "td", modelAttributes, defaultBorder);
  upcastBorderStyles(conversion, "th", modelAttributes, defaultBorder);
  downcastAttributeToStyle(conversion, { modelElement: "tableCell", modelAttribute: modelAttributes.style, styleName: "border-style" });
  downcastAttributeToStyle(conversion, { modelElement: "tableCell", modelAttribute: modelAttributes.color, styleName: "border-color" });
  downcastAttributeToStyle(conversion, { modelElement: "tableCell", modelAttribute: modelAttributes.width, styleName: "border-width" });
}
function enableHorizontalAlignmentProperty(schema, conversion, defaultValue) {
  schema.extend("tableCell", {
    allowAttributes: ["tableCellHorizontalAlignment"]
  });
  conversion.for("downcast").attributeToAttribute({
    model: {
      name: "tableCell",
      key: "tableCellHorizontalAlignment"
    },
    view: (alignment) => ({
      key: "style",
      value: {
        "text-align": alignment
      }
    })
  });
  conversion.for("upcast").attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      styles: {
        "text-align": ALIGN_VALUES_REG_EXP
      }
    },
    model: {
      key: "tableCellHorizontalAlignment",
      value: (viewElement) => {
        const align = viewElement.getStyle("text-align");
        return align === defaultValue ? null : align;
      }
    }
  }).attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      attributes: {
        align: ALIGN_VALUES_REG_EXP
      }
    },
    model: {
      key: "tableCellHorizontalAlignment",
      value: (viewElement) => {
        const align = viewElement.getAttribute("align");
        return align === defaultValue ? null : align;
      }
    }
  });
}
function enableVerticalAlignmentProperty(schema, conversion, defaultValue) {
  schema.extend("tableCell", {
    allowAttributes: ["tableCellVerticalAlignment"]
  });
  conversion.for("downcast").attributeToAttribute({
    model: {
      name: "tableCell",
      key: "tableCellVerticalAlignment"
    },
    view: (alignment) => ({
      key: "style",
      value: {
        "vertical-align": alignment
      }
    })
  });
  conversion.for("upcast").attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      styles: {
        "vertical-align": VALIGN_VALUES_REG_EXP
      }
    },
    model: {
      key: "tableCellVerticalAlignment",
      value: (viewElement) => {
        const align = viewElement.getStyle("vertical-align");
        return align === defaultValue ? null : align;
      }
    }
  }).attributeToAttribute({
    view: {
      name: /^(td|th)$/,
      attributes: {
        valign: VALIGN_VALUES_REG_EXP
      }
    },
    model: {
      key: "tableCellVerticalAlignment",
      value: (viewElement) => {
        const valign = viewElement.getAttribute("valign");
        return valign === defaultValue ? null : valign;
      }
    }
  });
}

// node_modules/@ckeditor/ckeditor5-table/src/tablecellproperties.js
var TableCellProperties = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCellProperties";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableCellPropertiesEditing, TableCellPropertiesUI];
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/commands/tablepropertycommand.js
var TablePropertyCommand = class extends Command {
  /**
   * Creates a new `TablePropertyCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param attributeName Table cell attribute name.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, attributeName, defaultValue) {
    super(editor);
    this.attributeName = attributeName;
    this._defaultValue = defaultValue;
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const table = selection.getFirstPosition().findAncestor("table");
    this.isEnabled = !!table;
    this.value = this._getValue(table);
  }
  /**
   * Executes the command.
   *
   * @fires execute
   * @param options.value If set, the command will set the attribute on the selected table.
   * If not set, the command will remove the attribute from the selected table.
   * @param options.batch Pass the model batch instance to the command to aggregate changes,
   * for example, to allow a single undo step for multiple executions.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const { value, batch } = options;
    const table = selection.getFirstPosition().findAncestor("table");
    const valueToSet = this._getValueToSet(value);
    model.enqueueChange(batch, (writer) => {
      if (valueToSet) {
        writer.setAttribute(this.attributeName, valueToSet, table);
      } else {
        writer.removeAttribute(this.attributeName, table);
      }
    });
  }
  /**
   * Returns the attribute value for a table.
   */
  _getValue(table) {
    if (!table) {
      return;
    }
    const value = table.getAttribute(this.attributeName);
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
   * Returns the proper model value. It can be used to add a default unit to numeric values.
   */
  _getValueToSet(value) {
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/commands/tablebackgroundcolorcommand.js
var TableBackgroundColorCommand = class extends TablePropertyCommand {
  /**
   * Creates a new `TableBackgroundColorCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableBackgroundColor", defaultValue);
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/commands/tablebordercolorcommand.js
var TableBorderColorCommand = class extends TablePropertyCommand {
  /**
   * Creates a new `TableBorderColorCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableBorderColor", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getValue(table) {
    if (!table) {
      return;
    }
    const value = getSingleValue(table.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/commands/tableborderstylecommand.js
var TableBorderStyleCommand = class extends TablePropertyCommand {
  /**
   * Creates a new `TableBorderStyleCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableBorderStyle", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getValue(table) {
    if (!table) {
      return;
    }
    const value = getSingleValue(table.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/commands/tableborderwidthcommand.js
var TableBorderWidthCommand = class extends TablePropertyCommand {
  /**
   * Creates a new `TableBorderWidthCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableBorderWidth", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getValue(table) {
    if (!table) {
      return;
    }
    const value = getSingleValue(table.getAttribute(this.attributeName));
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(value) {
    const newValue = addDefaultUnitToNumericValue(value, "px");
    if (newValue === this._defaultValue) {
      return;
    }
    return newValue;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/commands/tablewidthcommand.js
var TableWidthCommand = class extends TablePropertyCommand {
  /**
   * Creates a new `TableWidthCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableWidth", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(value) {
    value = addDefaultUnitToNumericValue(value, "px");
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/commands/tableheightcommand.js
var TableHeightCommand = class extends TablePropertyCommand {
  /**
   * Creates a new `TableHeightCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value of the attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableHeight", defaultValue);
  }
  /**
   * @inheritDoc
   */
  _getValueToSet(value) {
    value = addDefaultUnitToNumericValue(value, "px");
    if (value === this._defaultValue) {
      return;
    }
    return value;
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/commands/tablealignmentcommand.js
var TableAlignmentCommand = class extends TablePropertyCommand {
  /**
   * Creates a new `TableAlignmentCommand` instance.
   *
   * @param editor An editor in which this command will be used.
   * @param defaultValue The default value for the "alignment" attribute.
   */
  constructor(editor, defaultValue) {
    super(editor, "tableAlignment", defaultValue);
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/tablepropertiesediting.js
var ALIGN_VALUES_REG_EXP2 = /^(left|center|right)$/;
var FLOAT_VALUES_REG_EXP = /^(left|none|right)$/;
var TablePropertiesEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TablePropertiesEditing";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableEditing];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    editor.config.define("table.tableProperties.defaultProperties", {});
    const defaultTableProperties = getNormalizedDefaultProperties(editor.config.get("table.tableProperties.defaultProperties"), {
      includeAlignmentProperty: true
    });
    editor.data.addStyleProcessorRules(addBorderRules);
    enableBorderProperties2(schema, conversion, {
      color: defaultTableProperties.borderColor,
      style: defaultTableProperties.borderStyle,
      width: defaultTableProperties.borderWidth
    });
    editor.commands.add("tableBorderColor", new TableBorderColorCommand(editor, defaultTableProperties.borderColor));
    editor.commands.add("tableBorderStyle", new TableBorderStyleCommand(editor, defaultTableProperties.borderStyle));
    editor.commands.add("tableBorderWidth", new TableBorderWidthCommand(editor, defaultTableProperties.borderWidth));
    enableAlignmentProperty(schema, conversion, defaultTableProperties.alignment);
    editor.commands.add("tableAlignment", new TableAlignmentCommand(editor, defaultTableProperties.alignment));
    enableTableToFigureProperty(schema, conversion, {
      modelAttribute: "tableWidth",
      styleName: "width",
      defaultValue: defaultTableProperties.width
    });
    editor.commands.add("tableWidth", new TableWidthCommand(editor, defaultTableProperties.width));
    enableTableToFigureProperty(schema, conversion, {
      modelAttribute: "tableHeight",
      styleName: "height",
      defaultValue: defaultTableProperties.height
    });
    editor.commands.add("tableHeight", new TableHeightCommand(editor, defaultTableProperties.height));
    editor.data.addStyleProcessorRules(addBackgroundRules);
    enableProperty2(schema, conversion, {
      modelAttribute: "tableBackgroundColor",
      styleName: "background-color",
      defaultValue: defaultTableProperties.backgroundColor
    });
    editor.commands.add("tableBackgroundColor", new TableBackgroundColorCommand(editor, defaultTableProperties.backgroundColor));
  }
};
function enableBorderProperties2(schema, conversion, defaultBorder) {
  const modelAttributes = {
    width: "tableBorderWidth",
    color: "tableBorderColor",
    style: "tableBorderStyle"
  };
  schema.extend("table", {
    allowAttributes: Object.values(modelAttributes)
  });
  upcastBorderStyles(conversion, "table", modelAttributes, defaultBorder);
  downcastTableAttribute(conversion, { modelAttribute: modelAttributes.color, styleName: "border-color" });
  downcastTableAttribute(conversion, { modelAttribute: modelAttributes.style, styleName: "border-style" });
  downcastTableAttribute(conversion, { modelAttribute: modelAttributes.width, styleName: "border-width" });
}
function enableAlignmentProperty(schema, conversion, defaultValue) {
  schema.extend("table", {
    allowAttributes: ["tableAlignment"]
  });
  conversion.for("downcast").attributeToAttribute({
    model: {
      name: "table",
      key: "tableAlignment"
    },
    view: (alignment) => ({
      key: "style",
      value: {
        // Model: `alignment:center` => CSS: `float:none`.
        float: alignment === "center" ? "none" : alignment
      }
    }),
    converterPriority: "high"
  });
  conversion.for("upcast").attributeToAttribute({
    view: {
      name: /^(table|figure)$/,
      styles: {
        float: FLOAT_VALUES_REG_EXP
      }
    },
    model: {
      key: "tableAlignment",
      value: (viewElement) => {
        let align = viewElement.getStyle("float");
        if (align === "none") {
          align = "center";
        }
        return align === defaultValue ? null : align;
      }
    }
  }).attributeToAttribute({
    view: {
      attributes: {
        align: ALIGN_VALUES_REG_EXP2
      }
    },
    model: {
      name: "table",
      key: "tableAlignment",
      value: (viewElement) => {
        const align = viewElement.getAttribute("align");
        return align === defaultValue ? null : align;
      }
    }
  });
}
function enableProperty2(schema, conversion, options) {
  const { modelAttribute } = options;
  schema.extend("table", {
    allowAttributes: [modelAttribute]
  });
  upcastStyleToAttribute(conversion, { viewElement: "table", ...options });
  downcastTableAttribute(conversion, options);
}
function enableTableToFigureProperty(schema, conversion, options) {
  const { modelAttribute } = options;
  schema.extend("table", {
    allowAttributes: [modelAttribute]
  });
  upcastStyleToAttribute(conversion, {
    viewElement: /^(table|figure)$/,
    shouldUpcast: (element) => !(element.name == "table" && element.parent.name == "figure"),
    ...options
  });
  downcastAttributeToStyle(conversion, { modelElement: "table", ...options });
}

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/ui/tablepropertiesview.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/form.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/tableform.css";
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/tableproperties.css";
var ALIGNMENT_ICONS2 = {
  left: icons.objectLeft,
  center: icons.objectCenter,
  right: icons.objectRight
};
var TablePropertiesView = class extends View {
  /**
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param options Additional configuration of the view.
   */
  constructor(locale, options) {
    super(locale);
    this.set({
      borderStyle: "",
      borderWidth: "",
      borderColor: "",
      backgroundColor: "",
      width: "",
      height: "",
      alignment: ""
    });
    this.options = options;
    const { borderStyleDropdown, borderWidthInput, borderColorInput, borderRowLabel } = this._createBorderFields();
    const { backgroundRowLabel, backgroundInput } = this._createBackgroundFields();
    const { widthInput, operatorLabel, heightInput, dimensionsLabel } = this._createDimensionFields();
    const { alignmentToolbar, alignmentLabel } = this._createAlignmentFields();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.children = this.createCollection();
    this.borderStyleDropdown = borderStyleDropdown;
    this.borderWidthInput = borderWidthInput;
    this.borderColorInput = borderColorInput;
    this.backgroundInput = backgroundInput;
    this.widthInput = widthInput;
    this.heightInput = heightInput;
    this.alignmentToolbar = alignmentToolbar;
    const { saveButtonView, cancelButtonView } = this._createActionButtons();
    this.saveButtonView = saveButtonView;
    this.cancelButtonView = cancelButtonView;
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.children.add(new FormHeaderView(locale, {
      label: this.t("Table properties")
    }));
    this.children.add(new FormRowView(locale, {
      labelView: borderRowLabel,
      children: [
        borderRowLabel,
        borderStyleDropdown,
        borderColorInput,
        borderWidthInput
      ],
      class: "ck-table-form__border-row"
    }));
    this.children.add(new FormRowView(locale, {
      labelView: backgroundRowLabel,
      children: [
        backgroundRowLabel,
        backgroundInput
      ],
      class: "ck-table-form__background-row"
    }));
    this.children.add(new FormRowView(locale, {
      children: [
        // Dimensions row.
        new FormRowView(locale, {
          labelView: dimensionsLabel,
          children: [
            dimensionsLabel,
            widthInput,
            operatorLabel,
            heightInput
          ],
          class: "ck-table-form__dimensions-row"
        }),
        // Alignment row.
        new FormRowView(locale, {
          labelView: alignmentLabel,
          children: [
            alignmentLabel,
            alignmentToolbar
          ],
          class: "ck-table-properties-form__alignment-row"
        })
      ]
    }));
    this.children.add(new FormRowView(locale, {
      children: [
        this.saveButtonView,
        this.cancelButtonView
      ],
      class: "ck-table-form__action-row"
    }));
    this.setTemplate({
      tag: "form",
      attributes: {
        class: [
          "ck",
          "ck-form",
          "ck-table-form",
          "ck-table-properties-form"
        ],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    submitHandler({
      view: this
    });
    [
      this.borderStyleDropdown,
      this.borderColorInput,
      this.borderColorInput.fieldView.dropdownView.buttonView,
      this.borderWidthInput,
      this.backgroundInput,
      this.backgroundInput.fieldView.dropdownView.buttonView,
      this.widthInput,
      this.heightInput,
      this.alignmentToolbar,
      this.saveButtonView,
      this.cancelButtonView
    ].forEach((view) => {
      this._focusables.add(view);
      this.focusTracker.add(view.element);
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Focuses the fist focusable field in the form.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #borderStyleDropdown},
   * * {@link #borderWidthInput},
   * * {@link #borderColorInput}.
   */
  _createBorderFields() {
    const defaultTableProperties = this.options.defaultTableProperties;
    const defaultBorder = {
      style: defaultTableProperties.borderStyle,
      width: defaultTableProperties.borderWidth,
      color: defaultTableProperties.borderColor
    };
    const colorInputCreator = getLabeledColorInputCreator({
      colorConfig: this.options.borderColors,
      columns: 5,
      defaultColorValue: defaultBorder.color,
      colorPickerConfig: this.options.colorPickerConfig
    });
    const locale = this.locale;
    const t = this.t;
    const accessibleLabel = t("Style");
    const borderRowLabel = new LabelView(locale);
    borderRowLabel.text = t("Border");
    const styleLabels = getBorderStyleLabels(t);
    const borderStyleDropdown = new LabeledFieldView(locale, createLabeledDropdown);
    borderStyleDropdown.set({
      label: accessibleLabel,
      class: "ck-table-form__border-style"
    });
    borderStyleDropdown.fieldView.buttonView.set({
      ariaLabel: accessibleLabel,
      ariaLabelledBy: void 0,
      isOn: false,
      withText: true,
      tooltip: accessibleLabel
    });
    borderStyleDropdown.fieldView.buttonView.bind("label").to(this, "borderStyle", (value) => {
      return styleLabels[value ? value : "none"];
    });
    borderStyleDropdown.fieldView.on("execute", (evt) => {
      this.borderStyle = evt.source._borderStyleValue;
    });
    borderStyleDropdown.bind("isEmpty").to(this, "borderStyle", (value) => !value);
    addListToDropdown(borderStyleDropdown.fieldView, getBorderStyleDefinitions(this, defaultBorder.style), {
      role: "menu",
      ariaLabel: accessibleLabel
    });
    const borderWidthInput = new LabeledFieldView(locale, createLabeledInputText);
    borderWidthInput.set({
      label: t("Width"),
      class: "ck-table-form__border-width"
    });
    borderWidthInput.fieldView.bind("value").to(this, "borderWidth");
    borderWidthInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet2);
    borderWidthInput.fieldView.on("input", () => {
      this.borderWidth = borderWidthInput.fieldView.element.value;
    });
    const borderColorInput = new LabeledFieldView(locale, colorInputCreator);
    borderColorInput.set({
      label: t("Color"),
      class: "ck-table-form__border-color"
    });
    borderColorInput.fieldView.bind("value").to(this, "borderColor");
    borderColorInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet2);
    borderColorInput.fieldView.on("input", () => {
      this.borderColor = borderColorInput.fieldView.value;
    });
    this.on("change:borderStyle", (evt, name, newValue, oldValue) => {
      if (!isBorderStyleSet2(newValue)) {
        this.borderColor = "";
        this.borderWidth = "";
      }
      if (!isBorderStyleSet2(oldValue)) {
        this.borderColor = defaultBorder.color;
        this.borderWidth = defaultBorder.width;
      }
    });
    return {
      borderRowLabel,
      borderStyleDropdown,
      borderColorInput,
      borderWidthInput
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #backgroundInput}.
   */
  _createBackgroundFields() {
    const locale = this.locale;
    const t = this.t;
    const backgroundRowLabel = new LabelView(locale);
    backgroundRowLabel.text = t("Background");
    const backgroundInputCreator = getLabeledColorInputCreator({
      colorConfig: this.options.backgroundColors,
      columns: 5,
      defaultColorValue: this.options.defaultTableProperties.backgroundColor,
      colorPickerConfig: this.options.colorPickerConfig
    });
    const backgroundInput = new LabeledFieldView(locale, backgroundInputCreator);
    backgroundInput.set({
      label: t("Color"),
      class: "ck-table-properties-form__background"
    });
    backgroundInput.fieldView.bind("value").to(this, "backgroundColor");
    backgroundInput.fieldView.on("input", () => {
      this.backgroundColor = backgroundInput.fieldView.value;
    });
    return {
      backgroundRowLabel,
      backgroundInput
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #widthInput},
   * * {@link #heightInput}.
   */
  _createDimensionFields() {
    const locale = this.locale;
    const t = this.t;
    const dimensionsLabel = new LabelView(locale);
    dimensionsLabel.text = t("Dimensions");
    const widthInput = new LabeledFieldView(locale, createLabeledInputText);
    widthInput.set({
      label: t("Width"),
      class: "ck-table-form__dimensions-row__width"
    });
    widthInput.fieldView.bind("value").to(this, "width");
    widthInput.fieldView.on("input", () => {
      this.width = widthInput.fieldView.element.value;
    });
    const operatorLabel = new View(locale);
    operatorLabel.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck-table-form__dimension-operator"
        ]
      },
      children: [
        { text: "" }
      ]
    });
    const heightInput = new LabeledFieldView(locale, createLabeledInputText);
    heightInput.set({
      label: t("Height"),
      class: "ck-table-form__dimensions-row__height"
    });
    heightInput.fieldView.bind("value").to(this, "height");
    heightInput.fieldView.on("input", () => {
      this.height = heightInput.fieldView.element.value;
    });
    return {
      dimensionsLabel,
      widthInput,
      operatorLabel,
      heightInput
    };
  }
  /**
   * Creates the following form fields:
   *
   * * {@link #alignmentToolbar}.
   */
  _createAlignmentFields() {
    const locale = this.locale;
    const t = this.t;
    const alignmentLabel = new LabelView(locale);
    alignmentLabel.text = t("Alignment");
    const alignmentToolbar = new ToolbarView(locale);
    alignmentToolbar.set({
      isCompact: true,
      ariaLabel: t("Table alignment toolbar")
    });
    fillToolbar({
      view: this,
      icons: ALIGNMENT_ICONS2,
      toolbar: alignmentToolbar,
      labels: this._alignmentLabels,
      propertyName: "alignment",
      defaultValue: this.options.defaultTableProperties.alignment
    });
    return {
      alignmentLabel,
      alignmentToolbar
    };
  }
  /**
   * Creates the following form controls:
   *
   * * {@link #saveButtonView},
   * * {@link #cancelButtonView}.
   */
  _createActionButtons() {
    const locale = this.locale;
    const t = this.t;
    const saveButtonView = new ButtonView(locale);
    const cancelButtonView = new ButtonView(locale);
    const fieldsThatShouldValidateToSave = [
      this.borderWidthInput,
      this.borderColorInput,
      this.backgroundInput,
      this.widthInput,
      this.heightInput
    ];
    saveButtonView.set({
      label: t("Save"),
      icon: icons.check,
      class: "ck-button-save",
      type: "submit",
      withText: true
    });
    saveButtonView.bind("isEnabled").toMany(fieldsThatShouldValidateToSave, "errorText", (...errorTexts) => {
      return errorTexts.every((errorText) => !errorText);
    });
    cancelButtonView.set({
      label: t("Cancel"),
      icon: icons.cancel,
      class: "ck-button-cancel",
      withText: true
    });
    cancelButtonView.delegate("execute").to(this, "cancel");
    return {
      saveButtonView,
      cancelButtonView
    };
  }
  /**
   * Provides localized labels for {@link #alignmentToolbar} buttons.
   */
  get _alignmentLabels() {
    const locale = this.locale;
    const t = this.t;
    const left = t("Align table to the left");
    const center = t("Center table");
    const right = t("Align table to the right");
    if (locale.uiLanguageDirection === "rtl") {
      return { right, center, left };
    } else {
      return { left, center, right };
    }
  }
};
function isBorderStyleSet2(value) {
  return value !== "none";
}

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties/tablepropertiesui.js
import tableProperties from "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/icons/table-properties.svg";
var ERROR_TEXT_TIMEOUT2 = 500;
var propertyToCommandMap2 = {
  borderStyle: "tableBorderStyle",
  borderColor: "tableBorderColor",
  borderWidth: "tableBorderWidth",
  backgroundColor: "tableBackgroundColor",
  width: "tableWidth",
  height: "tableHeight",
  alignment: "tableAlignment"
};
var TablePropertiesUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ContextualBalloon];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TablePropertiesUI";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this.view = null;
    editor.config.define("table.tableProperties", {
      borderColors: defaultColors,
      backgroundColors: defaultColors
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    this._defaultTableProperties = getNormalizedDefaultProperties(editor.config.get("table.tableProperties.defaultProperties"), {
      includeAlignmentProperty: true
    });
    this._balloon = editor.plugins.get(ContextualBalloon);
    editor.ui.componentFactory.add("tableProperties", (locale) => {
      const view = new ButtonView(locale);
      view.set({
        label: t("Table properties"),
        icon: tableProperties,
        tooltip: true
      });
      this.listenTo(view, "execute", () => this._showView());
      const commands = Object.values(propertyToCommandMap2).map((commandName) => editor.commands.get(commandName));
      view.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => areEnabled.some((isCommandEnabled) => isCommandEnabled));
      return view;
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    if (this.view) {
      this.view.destroy();
    }
  }
  /**
   * Creates the {@link module:table/tableproperties/ui/tablepropertiesview~TablePropertiesView} instance.
   *
   * @returns The table properties form view instance.
   */
  _createPropertiesView() {
    const editor = this.editor;
    const config = editor.config.get("table.tableProperties");
    const borderColorsConfig = normalizeColorOptions(config.borderColors);
    const localizedBorderColors = getLocalizedColorOptions(editor.locale, borderColorsConfig);
    const backgroundColorsConfig = normalizeColorOptions(config.backgroundColors);
    const localizedBackgroundColors = getLocalizedColorOptions(editor.locale, backgroundColorsConfig);
    const hasColorPicker = config.colorPicker !== false;
    const view = new TablePropertiesView(editor.locale, {
      borderColors: localizedBorderColors,
      backgroundColors: localizedBackgroundColors,
      defaultTableProperties: this._defaultTableProperties,
      colorPickerConfig: hasColorPicker ? config.colorPicker || {} : false
    });
    const t = editor.t;
    view.render();
    this.listenTo(view, "submit", () => {
      this._hideView();
    });
    this.listenTo(view, "cancel", () => {
      if (this._undoStepBatch.operations.length) {
        editor.execute("undo", this._undoStepBatch);
      }
      this._hideView();
    });
    view.keystrokes.set("Esc", (data, cancel) => {
      this._hideView();
      cancel();
    });
    clickOutsideHandler({
      emitter: view,
      activator: () => this._isViewInBalloon,
      contextElements: [this._balloon.view.element],
      callback: () => this._hideView()
    });
    const colorErrorText = getLocalizedColorErrorText(t);
    const lengthErrorText = getLocalizedLengthErrorText(t);
    view.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle"));
    view.on("change:borderColor", this._getValidatedPropertyChangeCallback({
      viewField: view.borderColorInput,
      commandName: "tableBorderColor",
      errorText: colorErrorText,
      validator: colorFieldValidator
    }));
    view.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
      viewField: view.borderWidthInput,
      commandName: "tableBorderWidth",
      errorText: lengthErrorText,
      validator: lineWidthFieldValidator
    }));
    view.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
      viewField: view.backgroundInput,
      commandName: "tableBackgroundColor",
      errorText: colorErrorText,
      validator: colorFieldValidator
    }));
    view.on("change:width", this._getValidatedPropertyChangeCallback({
      viewField: view.widthInput,
      commandName: "tableWidth",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:height", this._getValidatedPropertyChangeCallback({
      viewField: view.heightInput,
      commandName: "tableHeight",
      errorText: lengthErrorText,
      validator: lengthFieldValidator
    }));
    view.on("change:alignment", this._getPropertyChangeCallback("tableAlignment"));
    return view;
  }
  /**
   * In this method the "editor data -> UI" binding is happening.
   *
   * When executed, this method obtains selected table property values from various table commands
   * and passes them to the {@link #view}.
   *
   * This way, the UI stays uptodate with the editor data.
   */
  _fillViewFormFromCommandValues() {
    const commands = this.editor.commands;
    const borderStyleCommand = commands.get("tableBorderStyle");
    Object.entries(propertyToCommandMap2).map(([property, commandName]) => {
      const propertyKey = property;
      const defaultValue = this._defaultTableProperties[propertyKey] || "";
      return [propertyKey, commands.get(commandName).value || defaultValue];
    }).forEach(([property, value]) => {
      if ((property === "borderColor" || property === "borderWidth") && borderStyleCommand.value === "none") {
        return;
      }
      this.view.set(property, value);
    });
    this._isReady = true;
  }
  /**
   * Shows the {@link #view} in the {@link #_balloon}.
   *
   * **Note**: Each time a view is shown, the new {@link #_undoStepBatch} is created that contains
   * all changes made to the document when the view is visible, allowing a single undo step
   * for all of them.
   */
  _showView() {
    const editor = this.editor;
    if (!this.view) {
      this.view = this._createPropertiesView();
    }
    this.listenTo(editor.ui, "update", () => {
      this._updateView();
    });
    this._fillViewFormFromCommandValues();
    this._balloon.add({
      view: this.view,
      position: getBalloonTablePositionData(editor)
    });
    this._undoStepBatch = editor.model.createBatch();
    this.view.focus();
  }
  /**
   * Removes the {@link #view} from the {@link #_balloon}.
   */
  _hideView() {
    const editor = this.editor;
    this.stopListening(editor.ui, "update");
    this._isReady = false;
    this.view.saveButtonView.focus();
    this._balloon.remove(this.view);
    this.editor.editing.view.focus();
  }
  /**
   * Repositions the {@link #_balloon} or hides the {@link #view} if a table is no longer selected.
   */
  _updateView() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    if (!getTableWidgetAncestor(viewDocument.selection)) {
      this._hideView();
    } else if (this._isViewVisible) {
      repositionContextualBalloon(editor, "table");
    }
  }
  /**
   * Returns `true` when the {@link #view} is the visible in the {@link #_balloon}.
   */
  get _isViewVisible() {
    return !!this.view && this._balloon.visibleView === this.view;
  }
  /**
   * Returns `true` when the {@link #view} is in the {@link #_balloon}.
   */
  get _isViewInBalloon() {
    return !!this.view && this._balloon.hasView(this.view);
  }
  /**
   * Creates a callback that when executed upon {@link #view view's} property change
   * executes a related editor command with the new property value.
   *
   * If new value will be set to the default value, the command will not be executed.
   *
   * @param commandName The command that will be executed.
   */
  _getPropertyChangeCallback(commandName) {
    return (evt, propertyName, newValue) => {
      if (!this._isReady) {
        return;
      }
      this.editor.execute(commandName, {
        value: newValue,
        batch: this._undoStepBatch
      });
    };
  }
  /**
   * Creates a callback that when executed upon {@link #view view's} property change:
   * * executes a related editor command with the new property value if the value is valid,
   * * or sets the error text next to the invalid field, if the value did not pass the validation.
   */
  _getValidatedPropertyChangeCallback(options) {
    const { commandName, viewField, validator, errorText } = options;
    const setErrorTextDebounced = debounce_default(() => {
      viewField.errorText = errorText;
    }, ERROR_TEXT_TIMEOUT2);
    return (evt, propertyName, newValue) => {
      setErrorTextDebounced.cancel();
      if (!this._isReady) {
        return;
      }
      if (validator(newValue)) {
        this.editor.execute(commandName, {
          value: newValue,
          batch: this._undoStepBatch
        });
        viewField.errorText = null;
      } else {
        setErrorTextDebounced();
      }
    };
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tableproperties.js
var TableProperties = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableProperties";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TablePropertiesEditing, TablePropertiesUI];
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/converters/table-caption-post-fixer.js
function injectTableCaptionPostFixer(model) {
  model.document.registerPostFixer((writer) => tableCaptionPostFixer(writer, model));
}
function tableCaptionPostFixer(writer, model) {
  const changes = model.document.differ.getChanges();
  let wasFixed = false;
  for (const entry of changes) {
    if (entry.type != "insert") {
      continue;
    }
    const positionParent = entry.position.parent;
    if (positionParent.is("element", "table") || entry.name == "table") {
      const table = entry.name == "table" ? entry.position.nodeAfter : positionParent;
      const captionsToMerge = Array.from(table.getChildren()).filter((child) => child.is("element", "caption"));
      const firstCaption = captionsToMerge.shift();
      if (!firstCaption) {
        continue;
      }
      for (const caption of captionsToMerge) {
        writer.move(writer.createRangeIn(caption), firstCaption, "end");
        writer.remove(caption);
      }
      if (firstCaption.nextSibling) {
        writer.move(writer.createRangeOn(firstCaption), table, "end");
        wasFixed = true;
      }
      wasFixed = !!captionsToMerge.length || wasFixed;
    }
  }
  return wasFixed;
}

// node_modules/@ckeditor/ckeditor5-table/src/tablecaption/utils.js
function isTable(modelElement) {
  return !!modelElement && modelElement.is("element", "table");
}
function getCaptionFromTableModelElement(tableModelElement) {
  for (const node of tableModelElement.getChildren()) {
    if (node.is("element", "caption")) {
      return node;
    }
  }
  return null;
}
function getCaptionFromModelSelection(selection) {
  const tableElement = getSelectionAffectedTable(selection);
  if (!tableElement) {
    return null;
  }
  return getCaptionFromTableModelElement(tableElement);
}
function matchTableCaptionViewElement(element) {
  const parent = element.parent;
  if (element.name == "figcaption" && parent && parent.is("element", "figure") && parent.hasClass("table")) {
    return { name: true };
  }
  if (element.name == "caption" && parent && parent.is("element", "table")) {
    return { name: true };
  }
  return null;
}
function getSelectionAffectedTable(selection) {
  const selectedElement = selection.getSelectedElement();
  if (selectedElement && selectedElement.is("element", "table")) {
    return selectedElement;
  }
  return selection.getFirstPosition().findAncestor("table");
}

// node_modules/@ckeditor/ckeditor5-table/src/tablecaption/toggletablecaptioncommand.js
var ToggleTableCaptionCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    const editor = this.editor;
    const tableElement = getSelectionAffectedTable(editor.model.document.selection);
    this.isEnabled = !!tableElement;
    if (!this.isEnabled) {
      this.value = false;
    } else {
      this.value = !!getCaptionFromTableModelElement(tableElement);
    }
  }
  /**
   * Executes the command.
   *
   * ```ts
   * editor.execute( 'toggleTableCaption' );
   * ```
   *
   * @param options Options for the executed command.
   * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
   * @fires execute
   */
  execute({ focusCaptionOnShow = false } = {}) {
    this.editor.model.change((writer) => {
      if (this.value) {
        this._hideTableCaption(writer);
      } else {
        this._showTableCaption(writer, focusCaptionOnShow);
      }
    });
  }
  /**
   * Shows the table caption. Also:
   *
   * * it attempts to restore the caption content from the `TableCaptionEditing` caption registry,
   * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
   *
   * @param focusCaptionOnShow Default focus behavior when showing the caption.
   */
  _showTableCaption(writer, focusCaptionOnShow) {
    const model = this.editor.model;
    const tableElement = getSelectionAffectedTable(model.document.selection);
    const tableCaptionEditing = this.editor.plugins.get("TableCaptionEditing");
    const savedCaptionElement = tableCaptionEditing._getSavedCaption(tableElement);
    const newCaptionElement = savedCaptionElement || writer.createElement("caption");
    model.insertContent(newCaptionElement, tableElement, "end");
    if (focusCaptionOnShow) {
      writer.setSelection(newCaptionElement, "in");
    }
  }
  /**
   * Hides the caption of a selected table (or an table caption the selection is anchored to).
   *
   * The content of the caption is stored in the `TableCaptionEditing` caption registry to make this
   * a reversible action.
   */
  _hideTableCaption(writer) {
    const model = this.editor.model;
    const tableElement = getSelectionAffectedTable(model.document.selection);
    const tableCaptionEditing = this.editor.plugins.get("TableCaptionEditing");
    const captionElement = getCaptionFromTableModelElement(tableElement);
    tableCaptionEditing._saveCaption(tableElement, captionElement);
    model.deleteContent(writer.createSelection(captionElement, "on"));
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecaption/tablecaptionediting.js
var TableCaptionEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCaptionEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const view = editor.editing.view;
    const t = editor.t;
    if (!schema.isRegistered("caption")) {
      schema.register("caption", {
        allowIn: "table",
        allowContentOf: "$block",
        isLimit: true
      });
    } else {
      schema.extend("caption", {
        allowIn: "table"
      });
    }
    editor.commands.add("toggleTableCaption", new ToggleTableCaptionCommand(this.editor));
    editor.conversion.for("upcast").elementToElement({
      view: matchTableCaptionViewElement,
      model: "caption"
    });
    editor.conversion.for("dataDowncast").elementToElement({
      model: "caption",
      view: (modelElement, { writer }) => {
        if (!isTable(modelElement.parent)) {
          return null;
        }
        return writer.createContainerElement("figcaption");
      }
    });
    editor.conversion.for("editingDowncast").elementToElement({
      model: "caption",
      view: (modelElement, { writer }) => {
        if (!isTable(modelElement.parent)) {
          return null;
        }
        const figcaptionElement = writer.createEditableElement("figcaption");
        writer.setCustomProperty("tableCaption", true, figcaptionElement);
        figcaptionElement.placeholder = t("Enter table caption");
        enablePlaceholder({
          view,
          element: figcaptionElement,
          keepOnFocus: true
        });
        return toWidgetEditable(figcaptionElement, writer);
      }
    });
    injectTableCaptionPostFixer(editor.model);
  }
  /**
   * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
   * of a table model element.
   *
   * See {@link #_saveCaption}.
   *
   * @internal
   * @param tableModelElement The model element the caption should be returned for.
   * @returns The model caption element or `null` if there is none.
   */
  _getSavedCaption(tableModelElement) {
    const jsonObject = this._savedCaptionsMap.get(tableModelElement);
    return jsonObject ? Element.fromJSON(jsonObject) : null;
  }
  /**
   * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
   * a table element to allow restoring it in the future.
   *
   * A caption is saved every time it gets hidden. The
   * user should be able to restore it on demand.
   *
   * **Note**: The caption cannot be stored in the table model element attribute because,
   * for instance, when the model state propagates to collaborators, the attribute would get
   * lost (mainly because it does not convert to anything when the caption is hidden) and
   * the states of collaborators' models would de-synchronize causing numerous issues.
   *
   * See {@link #_getSavedCaption}.
   *
   * @internal
   * @param tableModelElement The model element the caption is saved for.
   * @param caption The caption model element to be saved.
   */
  _saveCaption(tableModelElement, caption) {
    this._savedCaptionsMap.set(tableModelElement, caption.toJSON());
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecaption/tablecaptionui.js
var TableCaptionUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCaptionUI";
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const t = editor.t;
    editor.ui.componentFactory.add("toggleTableCaption", (locale) => {
      const command = editor.commands.get("toggleTableCaption");
      const view = new ButtonView(locale);
      view.set({
        icon: icons.caption,
        tooltip: true,
        isToggleable: true
      });
      view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
      view.bind("label").to(command, "value", (value) => value ? t("Toggle caption off") : t("Toggle caption on"));
      this.listenTo(view, "execute", () => {
        editor.execute("toggleTableCaption", { focusCaptionOnShow: true });
        if (command.value) {
          const modelCaptionElement = getCaptionFromModelSelection(editor.model.document.selection);
          const figcaptionElement = editor.editing.mapper.toViewElement(modelCaptionElement);
          if (!figcaptionElement) {
            return;
          }
          editingView.scrollToTheSelection();
          editingView.change((writer) => {
            writer.addClass("table__caption_highlighted", figcaptionElement);
          });
        }
        editor.editing.view.focus();
      });
      return view;
    });
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecaption.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/tablecaption.css";
var TableCaption = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableCaption";
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableCaptionEditing, TableCaptionUI];
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecolumnresize/tablewidthscommand.js
var TableWidthsCommand = class extends Command {
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = true;
  }
  /**
   * Updated the `tableWidth` attribute of the table and the `columnWidth` attribute of the columns of that table.
   */
  execute(options = {}) {
    const { model, plugins } = this.editor;
    let { table = model.document.selection.getSelectedElement(), columnWidths, tableWidth } = options;
    if (columnWidths) {
      columnWidths = Array.isArray(columnWidths) ? columnWidths : columnWidths.split(",");
    }
    model.change((writer) => {
      if (tableWidth) {
        writer.setAttribute("tableWidth", tableWidth, table);
      } else {
        writer.removeAttribute("tableWidth", table);
      }
      const tableColumnGroup = plugins.get("TableColumnResizeEditing").getColumnGroupElement(table);
      if (!columnWidths && !tableColumnGroup) {
        return;
      }
      if (!columnWidths) {
        return writer.remove(tableColumnGroup);
      }
      const widths = normalizeColumnWidths(columnWidths);
      if (!tableColumnGroup) {
        const colGroupElement = writer.createElement("tableColumnGroup");
        widths.forEach((columnWidth) => writer.appendElement("tableColumn", { columnWidth }, colGroupElement));
        writer.append(colGroupElement, table);
      } else {
        Array.from(tableColumnGroup.getChildren()).forEach((column, index) => writer.setAttribute("columnWidth", widths[index], column));
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecolumnresize/converters.js
function upcastColgroupElement(tableUtilsPlugin) {
  return (dispatcher) => dispatcher.on("element:colgroup", (evt, data, conversionApi) => {
    const modelTable = data.modelCursor.findAncestor("table");
    const tableColumnGroup = getColumnGroupElement(modelTable);
    if (!tableColumnGroup) {
      return;
    }
    const columnElements = getTableColumnElements(tableColumnGroup);
    const columnsCount = tableUtilsPlugin.getColumns(modelTable);
    let columnWidths = translateColSpanAttribute(tableColumnGroup, conversionApi.writer);
    columnWidths = Array.from({ length: columnsCount }, (_, index) => columnWidths[index] || "auto");
    if (columnWidths.length != columnElements.length || columnWidths.includes("auto")) {
      updateColumnElements(columnElements, tableColumnGroup, normalizeColumnWidths(columnWidths), conversionApi.writer);
    }
  }, { priority: "low" });
}
function downcastTableResizedClass() {
  return (dispatcher) => dispatcher.on("insert:table", (evt, data, conversionApi) => {
    const viewWriter = conversionApi.writer;
    const modelTable = data.item;
    const viewElement = conversionApi.mapper.toViewElement(modelTable);
    const viewTable = viewElement.is("element", "table") ? viewElement : Array.from(viewElement.getChildren()).find((viewChild) => viewChild.is("element", "table"));
    const tableColumnGroup = getColumnGroupElement(modelTable);
    if (tableColumnGroup) {
      viewWriter.addClass("ck-table-resized", viewTable);
    } else {
      viewWriter.removeClass("ck-table-resized", viewTable);
    }
  }, { priority: "low" });
}

// node_modules/@ckeditor/ckeditor5-table/src/tablecolumnresize/tablecolumnresizeediting.js
var TableColumnResizeEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableEditing, TableUtils];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableColumnResizeEditing";
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._isResizingActive = false;
    this.set("_isResizingAllowed", true);
    this._resizingData = null;
    this._domEmitter = new (DomEmitterMixin())();
    this._tableUtilsPlugin = editor.plugins.get("TableUtils");
    this.on("change:_isResizingAllowed", (evt, name, value) => {
      const classAction = value ? "removeClass" : "addClass";
      editor.editing.view.change((writer) => {
        for (const root of editor.editing.view.document.roots) {
          writer[classAction]("ck-column-resize_disabled", editor.editing.view.document.getRoot(root.rootName));
        }
      });
    });
  }
  /**
   * @inheritDoc
   */
  init() {
    this._extendSchema();
    this._registerPostFixer();
    this._registerConverters();
    this._registerResizingListeners();
    this._registerResizerInserter();
    const editor = this.editor;
    const columnResizePlugin = editor.plugins.get("TableColumnResize");
    const tableEditing = editor.plugins.get("TableEditing");
    tableEditing.registerAdditionalSlot({
      filter: (element) => element.is("element", "tableColumnGroup"),
      positionOffset: 0
    });
    const tableWidthsCommand = new TableWidthsCommand(editor);
    editor.commands.add("resizeTableWidth", tableWidthsCommand);
    editor.commands.add("resizeColumnWidths", tableWidthsCommand);
    this.bind("_isResizingAllowed").to(editor, "isReadOnly", columnResizePlugin, "isEnabled", tableWidthsCommand, "isEnabled", (isEditorReadOnly, isPluginEnabled, isTableWidthsCommandCommandEnabled) => !isEditorReadOnly && isPluginEnabled && isTableWidthsCommandCommandEnabled);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._domEmitter.stopListening();
    super.destroy();
  }
  /**
   * Returns a 'tableColumnGroup' element from the 'table'.
   *
   * @param element A 'table' or 'tableColumnGroup' element.
   * @returns A 'tableColumnGroup' element.
   */
  getColumnGroupElement(element) {
    return getColumnGroupElement(element);
  }
  /**
   * Returns an array of 'tableColumn' elements.
   *
   * @param element A 'table' or 'tableColumnGroup' element.
   * @returns An array of 'tableColumn' elements.
   */
  getTableColumnElements(element) {
    return getTableColumnElements(element);
  }
  /**
   * Returns an array of table column widths.
   *
   * @param element A 'table' or 'tableColumnGroup' element.
   * @returns An array of table column widths.
   */
  getTableColumnsWidths(element) {
    return getTableColumnsWidths(element);
  }
  /**
   * Registers new attributes for a table model element.
   */
  _extendSchema() {
    this.editor.model.schema.extend("table", {
      allowAttributes: ["tableWidth"]
    });
    this.editor.model.schema.register("tableColumnGroup", {
      allowIn: "table",
      isLimit: true
    });
    this.editor.model.schema.register("tableColumn", {
      allowIn: "tableColumnGroup",
      allowAttributes: ["columnWidth", "colSpan"],
      isLimit: true
    });
  }
  /**
   * Registers table column resize post-fixer.
   *
   * It checks if the change from the differ concerns a table-related element or attribute. For detected changes it:
   *  * Adjusts the `columnWidths` attribute to guarantee that the sum of the widths from all columns is 100%.
   *  * Checks if the `columnWidths` attribute gets updated accordingly after columns have been added or removed.
   */
  _registerPostFixer() {
    const editor = this.editor;
    const model = editor.model;
    model.document.registerPostFixer((writer) => {
      let changed = false;
      for (const table of getChangedResizedTables(model)) {
        const tableColumnGroup = this.getColumnGroupElement(table);
        const columns = this.getTableColumnElements(tableColumnGroup);
        const columnWidths = this.getTableColumnsWidths(tableColumnGroup);
        let normalizedWidths = normalizeColumnWidths(columnWidths);
        normalizedWidths = adjustColumnWidths(normalizedWidths, table, this);
        if (isEqual_default(columnWidths, normalizedWidths)) {
          continue;
        }
        updateColumnElements(columns, tableColumnGroup, normalizedWidths, writer);
        changed = true;
      }
      return changed;
    });
    function adjustColumnWidths(columnWidths, table, plugin) {
      const newTableColumnsCount = plugin._tableUtilsPlugin.getColumns(table);
      const columnsCountDelta = newTableColumnsCount - columnWidths.length;
      if (columnsCountDelta === 0) {
        return columnWidths;
      }
      const widths = columnWidths.map((width) => Number(width.replace("%", "")));
      const cellSet = getAffectedCells(plugin.editor.model.document.differ, table);
      for (const cell of cellSet) {
        const currentColumnsDelta = newTableColumnsCount - widths.length;
        if (currentColumnsDelta === 0) {
          continue;
        }
        const hasMoreColumns = currentColumnsDelta > 0;
        const currentColumnIndex = plugin._tableUtilsPlugin.getCellLocation(cell).column;
        if (hasMoreColumns) {
          const columnMinWidthAsPercentage = getColumnMinWidthAsPercentage(table, plugin.editor);
          const columnWidthsToInsert = createFilledArray(currentColumnsDelta, columnMinWidthAsPercentage);
          widths.splice(currentColumnIndex, 0, ...columnWidthsToInsert);
        } else {
          const removedColumnWidths = widths.splice(currentColumnIndex, Math.abs(currentColumnsDelta));
          widths[currentColumnIndex] += sumArray(removedColumnWidths);
        }
      }
      return widths.map((width) => width + "%");
    }
    function getAffectedCells(differ, table) {
      const cellSet = /* @__PURE__ */ new Set();
      for (const change of differ.getChanges()) {
        if (change.type == "insert" && change.position.nodeAfter && change.position.nodeAfter.name == "tableCell" && change.position.nodeAfter.getAncestors().includes(table)) {
          cellSet.add(change.position.nodeAfter);
        } else if (change.type == "remove") {
          const referenceNode = change.position.nodeBefore || change.position.nodeAfter;
          if (referenceNode.name == "tableCell" && referenceNode.getAncestors().includes(table)) {
            cellSet.add(referenceNode);
          }
        }
      }
      return cellSet;
    }
  }
  /**
   * Registers table column resize converters.
   */
  _registerConverters() {
    const editor = this.editor;
    const conversion = editor.conversion;
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "figure",
        key: "style",
        value: {
          width: /[\s\S]+/
        }
      },
      model: {
        name: "table",
        key: "tableWidth",
        value: (viewElement) => viewElement.getStyle("width")
      }
    });
    conversion.for("downcast").attributeToAttribute({
      model: {
        name: "table",
        key: "tableWidth"
      },
      view: (width) => ({
        name: "figure",
        key: "style",
        value: {
          width
        }
      })
    });
    conversion.elementToElement({ model: "tableColumnGroup", view: "colgroup" });
    conversion.elementToElement({ model: "tableColumn", view: "col" });
    conversion.for("downcast").add(downcastTableResizedClass());
    conversion.for("upcast").add(upcastColgroupElement(this._tableUtilsPlugin));
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "col",
        styles: {
          width: /.*/
        }
      },
      model: {
        key: "columnWidth",
        value: (viewElement) => {
          const viewColWidth = viewElement.getStyle("width");
          if (!viewColWidth || !viewColWidth.endsWith("%") && !viewColWidth.endsWith("pt")) {
            return "auto";
          }
          return viewColWidth;
        }
      }
    });
    conversion.for("upcast").attributeToAttribute({
      view: {
        name: "col",
        key: "span"
      },
      model: "colSpan"
    });
    conversion.for("downcast").attributeToAttribute({
      model: {
        name: "tableColumn",
        key: "columnWidth"
      },
      view: (width) => ({ key: "style", value: { width } })
    });
  }
  /**
   * Registers listeners to handle resizing process.
   */
  _registerResizingListeners() {
    const editingView = this.editor.editing.view;
    editingView.addObserver(MouseEventsObserver);
    editingView.document.on("mousedown", this._onMouseDownHandler.bind(this), { priority: "high" });
    this._domEmitter.listenTo(global_default.window.document, "mousemove", throttle_default(this._onMouseMoveHandler.bind(this), 50));
    this._domEmitter.listenTo(global_default.window.document, "mouseup", this._onMouseUpHandler.bind(this));
  }
  /**
   * Handles the `mousedown` event on column resizer element:
   *  * calculates the initial column pixel widths,
   *  * inserts the `<colgroup>` element if it is not present in the `<table>`,
   *  * puts the necessary data in the temporary storage,
   *  * applies the attributes to the `<table>` view element.
   *
   * @param eventInfo An object containing information about the fired event.
   * @param domEventData The data related to the DOM event.
   */
  _onMouseDownHandler(eventInfo, domEventData) {
    const target = domEventData.target;
    if (!target.hasClass("ck-table-column-resizer")) {
      return;
    }
    if (!this._isResizingAllowed) {
      return;
    }
    const editor = this.editor;
    const modelTable = editor.editing.mapper.toModelElement(target.findAncestor("figure"));
    if (!editor.model.canEditAt(modelTable)) {
      return;
    }
    domEventData.preventDefault();
    eventInfo.stop();
    const columnWidthsInPx = _calculateDomColumnWidths(modelTable, this._tableUtilsPlugin, editor);
    const viewTable = target.findAncestor("table");
    const editingView = editor.editing.view;
    if (!Array.from(viewTable.getChildren()).find((viewCol) => viewCol.is("element", "colgroup"))) {
      editingView.change((viewWriter) => {
        _insertColgroupElement(viewWriter, columnWidthsInPx, viewTable);
      });
    }
    this._isResizingActive = true;
    this._resizingData = this._getResizingData(domEventData, columnWidthsInPx);
    editingView.change((writer) => _applyResizingAttributesToTable(writer, viewTable, this._resizingData));
    function _calculateDomColumnWidths(modelTable2, tableUtilsPlugin, editor2) {
      const columnWidthsInPx2 = Array(tableUtilsPlugin.getColumns(modelTable2));
      const tableWalker = new TableWalker(modelTable2);
      for (const cellSlot of tableWalker) {
        const viewCell = editor2.editing.mapper.toViewElement(cellSlot.cell);
        const domCell = editor2.editing.view.domConverter.mapViewToDom(viewCell);
        const domCellWidth = getDomCellOuterWidth(domCell);
        if (!columnWidthsInPx2[cellSlot.column] || domCellWidth < columnWidthsInPx2[cellSlot.column]) {
          columnWidthsInPx2[cellSlot.column] = toPrecision(domCellWidth);
        }
      }
      return columnWidthsInPx2;
    }
    function _insertColgroupElement(viewWriter, columnWidthsInPx2, viewTable2) {
      const colgroup = viewWriter.createContainerElement("colgroup");
      for (let i = 0; i < columnWidthsInPx2.length; i++) {
        const viewColElement = viewWriter.createEmptyElement("col");
        const columnWidthInPc = `${toPrecision(columnWidthsInPx2[i] / sumArray(columnWidthsInPx2) * 100)}%`;
        viewWriter.setStyle("width", columnWidthInPc, viewColElement);
        viewWriter.insert(viewWriter.createPositionAt(colgroup, "end"), viewColElement);
      }
      viewWriter.insert(viewWriter.createPositionAt(viewTable2, 0), colgroup);
    }
    function _applyResizingAttributesToTable(viewWriter, viewTable2, resizingData) {
      const figureInitialPcWidth = resizingData.widths.viewFigureWidth / resizingData.widths.viewFigureParentWidth;
      viewWriter.addClass("ck-table-resized", viewTable2);
      viewWriter.addClass("ck-table-column-resizer__active", resizingData.elements.viewResizer);
      viewWriter.setStyle("width", `${toPrecision(figureInitialPcWidth * 100)}%`, viewTable2.findAncestor("figure"));
    }
  }
  /**
   * Handles the `mousemove` event.
   *  * If resizing process is not in progress, it does nothing.
   *  * If resizing is active but not allowed, it stops the resizing process instantly calling the `mousedown` event handler.
   *  * Otherwise it dynamically updates the widths of the resized columns.
   *
   * @param eventInfo An object containing information about the fired event.
   * @param mouseEventData The native DOM event.
   */
  _onMouseMoveHandler(eventInfo, mouseEventData) {
    if (!this._isResizingActive) {
      return;
    }
    if (!this._isResizingAllowed) {
      this._onMouseUpHandler();
      return;
    }
    const { columnPosition, flags: { isRightEdge, isTableCentered, isLtrContent }, elements: { viewFigure, viewLeftColumn, viewRightColumn }, widths: { viewFigureParentWidth, tableWidth, leftColumnWidth, rightColumnWidth } } = this._resizingData;
    const dxLowerBound = -leftColumnWidth + COLUMN_MIN_WIDTH_IN_PIXELS;
    const dxUpperBound = isRightEdge ? viewFigureParentWidth - tableWidth : rightColumnWidth - COLUMN_MIN_WIDTH_IN_PIXELS;
    const multiplier = (isLtrContent ? 1 : -1) * (isRightEdge && isTableCentered ? 2 : 1);
    const dx = clamp((mouseEventData.clientX - columnPosition) * multiplier, Math.min(dxLowerBound, 0), Math.max(dxUpperBound, 0));
    if (dx === 0) {
      return;
    }
    this.editor.editing.view.change((writer) => {
      const leftColumnWidthAsPercentage = toPrecision((leftColumnWidth + dx) * 100 / tableWidth);
      writer.setStyle("width", `${leftColumnWidthAsPercentage}%`, viewLeftColumn);
      if (isRightEdge) {
        const tableWidthAsPercentage = toPrecision((tableWidth + dx) * 100 / viewFigureParentWidth);
        writer.setStyle("width", `${tableWidthAsPercentage}%`, viewFigure);
      } else {
        const rightColumnWidthAsPercentage = toPrecision((rightColumnWidth - dx) * 100 / tableWidth);
        writer.setStyle("width", `${rightColumnWidthAsPercentage}%`, viewRightColumn);
      }
    });
  }
  /**
   * Handles the `mouseup` event.
   *  * If resizing process is not in progress, it does nothing.
   *  * If resizing is active but not allowed, it cancels the resizing process restoring the original widths.
   *  * Otherwise it propagates the changes from view to the model by executing the adequate commands.
   */
  _onMouseUpHandler() {
    if (!this._isResizingActive) {
      return;
    }
    const { viewResizer, modelTable, viewFigure, viewColgroup } = this._resizingData.elements;
    const editor = this.editor;
    const editingView = editor.editing.view;
    const tableColumnGroup = this.getColumnGroupElement(modelTable);
    const viewColumns = Array.from(viewColgroup.getChildren()).filter((column) => column.is("view:element"));
    const columnWidthsAttributeOld = tableColumnGroup ? this.getTableColumnsWidths(tableColumnGroup) : null;
    const columnWidthsAttributeNew = viewColumns.map((column) => column.getStyle("width"));
    const isColumnWidthsAttributeChanged = !isEqual_default(columnWidthsAttributeOld, columnWidthsAttributeNew);
    const tableWidthAttributeOld = modelTable.getAttribute("tableWidth");
    const tableWidthAttributeNew = viewFigure.getStyle("width");
    const isTableWidthAttributeChanged = tableWidthAttributeOld !== tableWidthAttributeNew;
    if (isColumnWidthsAttributeChanged || isTableWidthAttributeChanged) {
      if (this._isResizingAllowed) {
        editor.execute("resizeTableWidth", {
          table: modelTable,
          tableWidth: `${toPrecision(tableWidthAttributeNew)}%`,
          columnWidths: columnWidthsAttributeNew
        });
      } else {
        editingView.change((writer) => {
          if (columnWidthsAttributeOld) {
            for (const viewCol of viewColumns) {
              writer.setStyle("width", columnWidthsAttributeOld.shift(), viewCol);
            }
          } else {
            writer.remove(viewColgroup);
          }
          if (isTableWidthAttributeChanged) {
            if (tableWidthAttributeOld) {
              writer.setStyle("width", tableWidthAttributeOld, viewFigure);
            } else {
              writer.removeStyle("width", viewFigure);
            }
          }
          if (!columnWidthsAttributeOld && !tableWidthAttributeOld) {
            writer.removeClass("ck-table-resized", [...viewFigure.getChildren()].find((element) => element.name === "table"));
          }
        });
      }
    }
    editingView.change((writer) => {
      writer.removeClass("ck-table-column-resizer__active", viewResizer);
    });
    this._isResizingActive = false;
    this._resizingData = null;
  }
  /**
   * Retrieves and returns required data needed for the resizing process.
   *
   * @param domEventData The data of the `mousedown` event.
   * @param columnWidths The current widths of the columns.
   * @returns The data needed for the resizing process.
   */
  _getResizingData(domEventData, columnWidths) {
    const editor = this.editor;
    const columnPosition = domEventData.domEvent.clientX;
    const viewResizer = domEventData.target;
    const viewLeftCell = viewResizer.findAncestor("td") || viewResizer.findAncestor("th");
    const modelLeftCell = editor.editing.mapper.toModelElement(viewLeftCell);
    const modelTable = modelLeftCell.findAncestor("table");
    const leftColumnIndex = getColumnEdgesIndexes(modelLeftCell, this._tableUtilsPlugin).rightEdge;
    const lastColumnIndex = this._tableUtilsPlugin.getColumns(modelTable) - 1;
    const isRightEdge = leftColumnIndex === lastColumnIndex;
    const isTableCentered = !modelTable.hasAttribute("tableAlignment");
    const isLtrContent = editor.locale.contentLanguageDirection !== "rtl";
    const viewTable = viewLeftCell.findAncestor("table");
    const viewFigure = viewTable.findAncestor("figure");
    const viewColgroup = [...viewTable.getChildren()].find((viewCol) => viewCol.is("element", "colgroup"));
    const viewLeftColumn = viewColgroup.getChild(leftColumnIndex);
    const viewRightColumn = isRightEdge ? void 0 : viewColgroup.getChild(leftColumnIndex + 1);
    const viewFigureParentWidth = getElementWidthInPixels(editor.editing.view.domConverter.mapViewToDom(viewFigure.parent));
    const viewFigureWidth = getElementWidthInPixels(editor.editing.view.domConverter.mapViewToDom(viewFigure));
    const tableWidth = getTableWidthInPixels(modelTable, editor);
    const leftColumnWidth = columnWidths[leftColumnIndex];
    const rightColumnWidth = isRightEdge ? void 0 : columnWidths[leftColumnIndex + 1];
    return {
      columnPosition,
      flags: {
        isRightEdge,
        isTableCentered,
        isLtrContent
      },
      elements: {
        viewResizer,
        modelTable,
        viewFigure,
        viewColgroup,
        viewLeftColumn,
        viewRightColumn
      },
      widths: {
        viewFigureParentWidth,
        viewFigureWidth,
        tableWidth,
        leftColumnWidth,
        rightColumnWidth
      }
    };
  }
  /**
   * Registers a listener ensuring that each resizable cell have a resizer handle.
   */
  _registerResizerInserter() {
    this.editor.conversion.for("editingDowncast").add((dispatcher) => {
      dispatcher.on("insert:tableCell", (evt, data, conversionApi) => {
        const modelElement = data.item;
        const viewElement = conversionApi.mapper.toViewElement(modelElement);
        const viewWriter = conversionApi.writer;
        viewWriter.insert(viewWriter.createPositionAt(viewElement, "end"), viewWriter.createUIElement("div", { class: "ck-table-column-resizer" }));
      }, { priority: "lowest" });
    });
  }
};

// node_modules/@ckeditor/ckeditor5-table/src/tablecolumnresize.js
import "C:/complydex/Source/vue.jsonforms/node_modules/@ckeditor/ckeditor5-table/theme/tablecolumnresize.css";
var TableColumnResize = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [TableColumnResizeEditing, TableCellWidthEditing];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "TableColumnResize";
  }
};
export {
  PlainTableOutput,
  Table,
  TableCaption,
  TableCaptionEditing,
  TableCaptionUI,
  TableCellProperties,
  TableCellPropertiesEditing,
  TableCellPropertiesUI,
  TableCellWidthEditing,
  TableClipboard,
  TableColumnResize,
  TableColumnResizeEditing,
  TableEditing,
  TableKeyboard,
  TableMouse,
  TableProperties,
  TablePropertiesEditing,
  TablePropertiesUI,
  TableSelection,
  TableToolbar,
  TableUI,
  TableUtils
};
/*! Bundled license information:

@ckeditor/ckeditor5-table/src/converters/tableproperties.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/utils/common.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/converters/upcasttable.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablewalker.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/converters/downcast.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/inserttablecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/insertrowcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/insertcolumncommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/splitcellcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/utils/structure.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/mergecellcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/removerowcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/removecolumncommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/setheaderrowcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/setheadercolumncommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecolumnresize/constants.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecolumnresize/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableutils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-table/src/commands/mergecellscommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/selectrowcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/commands/selectcolumncommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/converters/table-layout-post-fixer.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/converters/table-cell-paragraph-post-fixer.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/converters/table-headings-refresh-handler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/converters/table-cell-refresh-handler.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/ui/inserttableview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableselection.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableclipboard.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablekeyboard.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore if: paranoid check -- @preserve *)

@ckeditor/ckeditor5-table/src/tablemouse/mouseeventsobserver.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablemouse.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/table.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/plaintableoutput.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/utils/ui/widget.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tabletoolbar.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/ui/colorinputview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/utils/ui/table-properties.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/ui/formrowview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/ui/tablecellpropertiesview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/utils/ui/contextualballoon.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/utils/table-properties.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/tablecellpropertiesui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellpropertycommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellwidth/commands/tablecellwidthcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellwidth/tablecellwidthediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellpaddingcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellheightcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellbackgroundcolorcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellverticalalignmentcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellhorizontalalignmentcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellborderstylecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellbordercolorcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/commands/tablecellborderwidthcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties/tablecellpropertiesediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecellproperties.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/commands/tablepropertycommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/commands/tablebackgroundcolorcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/commands/tablebordercolorcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/commands/tableborderstylecommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/commands/tableborderwidthcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/commands/tablewidthcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/commands/tableheightcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/commands/tablealignmentcommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/tablepropertiesediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/ui/tablepropertiesview.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties/tablepropertiesui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tableproperties.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/converters/table-caption-post-fixer.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecaption/utils.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecaption/toggletablecaptioncommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecaption/tablecaptionediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecaption/tablecaptionui.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecaption.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecolumnresize/tablewidthscommand.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecolumnresize/converters.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecolumnresize/tablecolumnresizeediting.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/tablecolumnresize.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-table/src/index.js:
  (**
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-table.js.map
