{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-autoformat/src/blockautoformatediting.js", "../../@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js", "../../@ckeditor/ckeditor5-autoformat/src/autoformat.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { LiveRange } from 'ckeditor5/src/engine';\nimport { first } from 'ckeditor5/src/utils';\n/**\n * The block autoformatting engine. It allows to format various block patterns. For example,\n * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the {@link module:autoformat/blockautoformatediting~blockAutoformatEditing `blockAutoformatEditing`} documentation\n * to learn how to create custom block autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n *\n * @module autoformat/blockautoformatediting\n */\n/**\n * Creates a listener triggered on {@link module:engine/model/document~Document#event:change:data `change:data`} event in the document.\n * Calls the callback when inserted text matches the regular expression or the command name\n * if provided instead of the callback.\n *\n * Examples of usage:\n *\n * To convert a paragraph into heading 1 when `- ` is typed, using just the command name:\n *\n * ```ts\n * blockAutoformatEditing( editor, plugin, /^\\- $/, 'heading1' );\n * ```\n *\n * To convert a paragraph into heading 1 when `- ` is typed, using just the callback:\n *\n * ```ts\n * blockAutoformatEditing( editor, plugin, /^\\- $/, ( context ) => {\n * \tconst { match } = context;\n * \tconst headingLevel = match[ 1 ].length;\n *\n * \teditor.execute( 'heading', {\n * \t\tformatId: `heading${ headingLevel }`\n * \t} );\n * } );\n * ```\n *\n * @param editor The editor instance.\n * @param plugin The autoformat plugin instance.\n * @param pattern The regular expression to execute on just inserted text. The regular expression is tested against the text\n * from the beginning until the caret position.\n * @param callbackOrCommand The callback to execute or the command to run when the text is matched.\n * In case of providing the callback, it receives the following parameter:\n * * match RegExp.exec() result of matching the pattern to inserted text.\n */\nexport default function blockAutoformatEditing(editor, plugin, pattern, callbackOrCommand) {\n    let callback;\n    let command = null;\n    if (typeof callbackOrCommand == 'function') {\n        callback = callbackOrCommand;\n    }\n    else {\n        // We assume that the actual command name was provided.\n        command = editor.commands.get(callbackOrCommand);\n        callback = () => {\n            editor.execute(callbackOrCommand);\n        };\n    }\n    editor.model.document.on('change:data', (evt, batch) => {\n        if (command && !command.isEnabled || !plugin.isEnabled) {\n            return;\n        }\n        const range = first(editor.model.document.selection.getRanges());\n        if (!range.isCollapsed) {\n            return;\n        }\n        if (batch.isUndo || !batch.isLocal) {\n            return;\n        }\n        const changes = Array.from(editor.model.document.differ.getChanges());\n        const entry = changes[0];\n        // Typing is represented by only a single change.\n        if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {\n            return;\n        }\n        const blockToFormat = entry.position.parent;\n        // Block formatting should be disabled in codeBlocks (#5800).\n        if (blockToFormat.is('element', 'codeBlock')) {\n            return;\n        }\n        // Only list commands and custom callbacks can be applied inside a list.\n        if (blockToFormat.is('element', 'listItem') &&\n            typeof callbackOrCommand !== 'function' &&\n            !['numberedList', 'bulletedList', 'todoList'].includes(callbackOrCommand)) {\n            return;\n        }\n        // In case a command is bound, do not re-execute it over an existing block style which would result in a style removal.\n        // Instead, just drop processing so that autoformat trigger text is not lost. E.g. writing \"# \" in a level 1 heading.\n        if (command && command.value === true) {\n            return;\n        }\n        const firstNode = blockToFormat.getChild(0);\n        const firstNodeRange = editor.model.createRangeOn(firstNode);\n        // Range is only expected to be within or at the very end of the first text node.\n        if (!firstNodeRange.containsRange(range) && !range.end.isEqual(firstNodeRange.end)) {\n            return;\n        }\n        const match = pattern.exec(firstNode.data.substr(0, range.end.offset));\n        // ...and this text node's data match the pattern.\n        if (!match) {\n            return;\n        }\n        // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n        editor.model.enqueueChange(writer => {\n            // Matched range.\n            const start = writer.createPositionAt(blockToFormat, 0);\n            const end = writer.createPositionAt(blockToFormat, match[0].length);\n            const range = new LiveRange(start, end);\n            const wasChanged = callback({ match });\n            // Remove matched text.\n            if (wasChanged !== false) {\n                writer.remove(range);\n                const selectionRange = editor.model.document.selection.getFirstRange();\n                const blockRange = writer.createRangeIn(blockToFormat);\n                // If the block is empty and the document selection has been moved when\n                // applying formatting (e.g. is now in newly created block).\n                if (blockToFormat.isEmpty && !blockRange.isEqual(selectionRange) && !blockRange.containsRange(selectionRange, true)) {\n                    writer.remove(blockToFormat);\n                }\n            }\n            range.detach();\n            editor.model.enqueueChange(() => {\n                const deletePlugin = editor.plugins.get('Delete');\n                deletePlugin.requestUndoOnBackspace();\n            });\n        });\n    });\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.\n *\n * It formats the matched text by applying the given model attribute or by running the provided formatting callback.\n * On every {@link module:engine/model/document~Document#event:change:data data change} in the model document\n * the autoformatting engine checks the text on the left of the selection\n * and executes the provided action if the text matches given criteria (regular expression or callback).\n *\n * @param editor The editor instance.\n * @param plugin The autoformat plugin instance.\n * @param testRegexpOrCallback The regular expression or callback to execute on text.\n * Provided regular expression *must* have three capture groups. The first and the third capture group\n * should match opening and closing delimiters. The second capture group should match the text to format.\n *\n * ```ts\n * // Matches the `**bold text**` pattern.\n * // There are three capturing groups:\n * // - The first to match the starting `**` delimiter.\n * // - The second to match the text to format.\n * // - The third to match the ending `**` delimiter.\n * inlineAutoformatEditing( editor, plugin, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, formatCallback );\n * ```\n *\n * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.\n * The function should return proper \"ranges\" to delete and format.\n *\n * ```ts\n * {\n * \tremove: [\n * \t\t[ 0, 1 ],\t// Remove the first letter from the given text.\n * \t\t[ 5, 6 ]\t// Remove the 6th letter from the given text.\n * \t],\n * \tformat: [\n * \t\t[ 1, 5 ]\t// Format all letters from 2nd to 5th.\n * \t]\n * }\n * ```\n *\n * @param formatCallback A callback to apply actual formatting.\n * It should return `false` if changes should not be applied (e.g. if a command is disabled).\n *\n * ```ts\n * inlineAutoformatEditing( editor, plugin, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, ( writer, rangesToFormat ) => {\n * \tconst command = editor.commands.get( 'bold' );\n *\n * \tif ( !command.isEnabled ) {\n * \t\treturn false;\n * \t}\n *\n * \tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );\n *\n * \tfor ( let range of validRanges ) {\n * \t\twriter.setAttribute( 'bold', true, range );\n * \t}\n * } );\n * ```\n */\nexport default function inlineAutoformatEditing(editor, plugin, testRegexpOrCallback, formatCallback) {\n    let regExp;\n    let testCallback;\n    if (testRegexpOrCallback instanceof RegExp) {\n        regExp = testRegexpOrCallback;\n    }\n    else {\n        testCallback = testRegexpOrCallback;\n    }\n    // A test callback run on changed text.\n    testCallback = testCallback || (text => {\n        let result;\n        const remove = [];\n        const format = [];\n        while ((result = regExp.exec(text)) !== null) {\n            // There should be full match and 3 capture groups.\n            if (result && result.length < 4) {\n                break;\n            }\n            let { index, '1': leftDel, '2': content, '3': rightDel } = result;\n            // Real matched string - there might be some non-capturing groups so we need to recalculate starting index.\n            const found = leftDel + content + rightDel;\n            index += result[0].length - found.length;\n            // Start and End offsets of delimiters to remove.\n            const delStart = [\n                index,\n                index + leftDel.length\n            ];\n            const delEnd = [\n                index + leftDel.length + content.length,\n                index + leftDel.length + content.length + rightDel.length\n            ];\n            remove.push(delStart);\n            remove.push(delEnd);\n            format.push([index + leftDel.length, index + leftDel.length + content.length]);\n        }\n        return {\n            remove,\n            format\n        };\n    });\n    editor.model.document.on('change:data', (evt, batch) => {\n        if (batch.isUndo || !batch.isLocal || !plugin.isEnabled) {\n            return;\n        }\n        const model = editor.model;\n        const selection = model.document.selection;\n        // Do nothing if selection is not collapsed.\n        if (!selection.isCollapsed) {\n            return;\n        }\n        const changes = Array.from(model.document.differ.getChanges());\n        const entry = changes[0];\n        // Typing is represented by only a single change.\n        if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {\n            return;\n        }\n        const focus = selection.focus;\n        const block = focus.parent;\n        const { text, range } = getTextAfterCode(model.createRange(model.createPositionAt(block, 0), focus), model);\n        const testOutput = testCallback(text);\n        const rangesToFormat = testOutputToRanges(range.start, testOutput.format, model);\n        const rangesToRemove = testOutputToRanges(range.start, testOutput.remove, model);\n        if (!(rangesToFormat.length && rangesToRemove.length)) {\n            return;\n        }\n        // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n        model.enqueueChange(writer => {\n            // Apply format.\n            const hasChanged = formatCallback(writer, rangesToFormat);\n            // Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).\n            if (hasChanged === false) {\n                return;\n            }\n            // Remove delimiters - use reversed order to not mix the offsets while removing.\n            for (const range of rangesToRemove.reverse()) {\n                writer.remove(range);\n            }\n            model.enqueueChange(() => {\n                const deletePlugin = editor.plugins.get('Delete');\n                deletePlugin.requestUndoOnBackspace();\n            });\n        });\n    });\n}\n/**\n * Converts output of the test function provided to the inlineAutoformatEditing and converts it to the model ranges\n * inside provided block.\n */\nfunction testOutputToRanges(start, arrays, model) {\n    return arrays\n        .filter(array => (array[0] !== undefined && array[1] !== undefined))\n        .map(array => {\n        return model.createRange(start.getShiftedBy(array[0]), start.getShiftedBy(array[1]));\n    });\n}\n/**\n * Returns the last text line after the last code element from the given range.\n * It is similar to {@link module:typing/utils/getlasttextline.getLastTextLine `getLastTextLine()`},\n * but it ignores any text before the last `code`.\n */\nfunction getTextAfterCode(range, model) {\n    let start = range.start;\n    const text = Array.from(range.getItems()).reduce((rangeText, node) => {\n        // Trim text to a last occurrence of an inline element and update range start.\n        if (!(node.is('$text') || node.is('$textProxy')) || node.getAttribute('code')) {\n            start = model.createPositionAfter(node);\n            return '';\n        }\n        return rangeText + node.data;\n    }, '');\n    return { text, range: model.createRange(start, range.end) };\n}\n", "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { Delete } from 'ckeditor5/src/typing';\nimport blockAutoformatEditing from './blockautoformatediting';\nimport inlineAutoformatEditing from './inlineautoformatediting';\n/**\n * Enables a set of predefined autoformatting actions.\n *\n * For a detailed overview, check the {@glink features/autoformat Autoformatting} feature guide\n * and the {@glink api/autoformat package page}.\n */\nexport default class Autoformat extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [Delete];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Autoformat';\n    }\n    /**\n     * @inheritDoc\n     */\n    afterInit() {\n        this._addListAutoformats();\n        this._addBasicStylesAutoformats();\n        this._addHeadingAutoformats();\n        this._addBlockQuoteAutoformats();\n        this._addCodeBlockAutoformats();\n        this._addHorizontalLineAutoformats();\n    }\n    /**\n     * Adds autoformatting related to the {@link module:list/list~List}.\n     *\n     * When typed:\n     * - `* ` or `- ` &ndash; A paragraph will be changed into a bulleted list.\n     * - `1. ` or `1) ` &ndash; A paragraph will be changed into a numbered list (\"1\" can be any digit or a list of digits).\n     * - `[] ` or `[ ] ` &ndash; A paragraph will be changed into a to-do list.\n     * - `[x] ` or `[ x ] ` &ndash; A paragraph will be changed into a checked to-do list.\n     */\n    _addListAutoformats() {\n        const commands = this.editor.commands;\n        if (commands.get('bulletedList')) {\n            blockAutoformatEditing(this.editor, this, /^[*-]\\s$/, 'bulletedList');\n        }\n        if (commands.get('numberedList')) {\n            blockAutoformatEditing(this.editor, this, /^1[.|)]\\s$/, 'numberedList');\n        }\n        if (commands.get('todoList')) {\n            blockAutoformatEditing(this.editor, this, /^\\[\\s?\\]\\s$/, 'todoList');\n        }\n        if (commands.get('checkTodoList')) {\n            blockAutoformatEditing(this.editor, this, /^\\[\\s?x\\s?\\]\\s$/, () => {\n                this.editor.execute('todoList');\n                this.editor.execute('checkTodoList');\n            });\n        }\n    }\n    /**\n     * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},\n     * {@link module:basic-styles/italic~Italic}, {@link module:basic-styles/code~Code}\n     * and {@link module:basic-styles/strikethrough~Strikethrough}\n     *\n     * When typed:\n     * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,\n     * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,\n     * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,\n     * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,\n     * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code,\n     * - `~~foobar~~` &ndash; `~~` characters are removed and `foobar` is set to strikethrough.\n     */\n    _addBasicStylesAutoformats() {\n        const commands = this.editor.commands;\n        if (commands.get('bold')) {\n            const boldCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'bold');\n            inlineAutoformatEditing(this.editor, this, /(?:^|\\s)(\\*\\*)([^*]+)(\\*\\*)$/g, boldCallback);\n            inlineAutoformatEditing(this.editor, this, /(?:^|\\s)(__)([^_]+)(__)$/g, boldCallback);\n        }\n        if (commands.get('italic')) {\n            const italicCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'italic');\n            // The italic autoformatter cannot be triggered by the bold markers, so we need to check the\n            // text before the pattern (e.g. `(?:^|[^\\*])`).\n            inlineAutoformatEditing(this.editor, this, /(?:^|\\s)(\\*)([^*_]+)(\\*)$/g, italicCallback);\n            inlineAutoformatEditing(this.editor, this, /(?:^|\\s)(_)([^_]+)(_)$/g, italicCallback);\n        }\n        if (commands.get('code')) {\n            const codeCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'code');\n            inlineAutoformatEditing(this.editor, this, /(`)([^`]+)(`)$/g, codeCallback);\n        }\n        if (commands.get('strikethrough')) {\n            const strikethroughCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'strikethrough');\n            inlineAutoformatEditing(this.editor, this, /(~~)([^~]+)(~~)$/g, strikethroughCallback);\n        }\n    }\n    /**\n     * Adds autoformatting related to {@link module:heading/heading~Heading}.\n     *\n     * It is using a number at the end of the command name to associate it with the proper trigger:\n     *\n     * * `heading` with a `heading1` value will be executed when typing `#`,\n     * * `heading` with a `heading2` value will be executed when typing `##`,\n     * * ... up to `heading6` for `######`.\n     */\n    _addHeadingAutoformats() {\n        const command = this.editor.commands.get('heading');\n        if (command) {\n            command.modelElements\n                .filter(name => name.match(/^heading[1-6]$/))\n                .forEach(modelName => {\n                const level = modelName[7];\n                const pattern = new RegExp(`^(#{${level}})\\\\s$`);\n                blockAutoformatEditing(this.editor, this, pattern, () => {\n                    // Should only be active if command is enabled and heading style associated with pattern is inactive.\n                    if (!command.isEnabled || command.value === modelName) {\n                        return false;\n                    }\n                    this.editor.execute('heading', { value: modelName });\n                });\n            });\n        }\n    }\n    /**\n     * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.\n     *\n     * When typed:\n     * * `> ` &ndash; A paragraph will be changed to a block quote.\n     */\n    _addBlockQuoteAutoformats() {\n        if (this.editor.commands.get('blockQuote')) {\n            blockAutoformatEditing(this.editor, this, /^>\\s$/, 'blockQuote');\n        }\n    }\n    /**\n     * Adds autoformatting related to {@link module:code-block/codeblock~CodeBlock}.\n     *\n     * When typed:\n     * - `` ``` `` &ndash; A paragraph will be changed to a code block.\n     */\n    _addCodeBlockAutoformats() {\n        const editor = this.editor;\n        const selection = editor.model.document.selection;\n        if (editor.commands.get('codeBlock')) {\n            blockAutoformatEditing(editor, this, /^```$/, () => {\n                if (selection.getFirstPosition().parent.is('element', 'listItem')) {\n                    return false;\n                }\n                this.editor.execute('codeBlock', {\n                    usePreviousLanguageChoice: true\n                });\n            });\n        }\n    }\n    /**\n     * Adds autoformatting related to {@link module:horizontal-line/horizontalline~HorizontalLine}.\n     *\n     * When typed:\n     * - `` --- `` &ndash; Will be replaced with a horizontal line.\n     */\n    _addHorizontalLineAutoformats() {\n        if (this.editor.commands.get('horizontalLine')) {\n            blockAutoformatEditing(this.editor, this, /^---$/, 'horizontalLine');\n        }\n    }\n}\n/**\n * Helper function for getting `inlineAutoformatEditing` callbacks that checks if command is enabled.\n */\nfunction getCallbackFunctionForInlineAutoformat(editor, attributeKey) {\n    return (writer, rangesToFormat) => {\n        const command = editor.commands.get(attributeKey);\n        if (!command.isEnabled) {\n            return false;\n        }\n        const validRanges = editor.model.schema.getValidRanges(rangesToFormat, attributeKey);\n        for (const range of validRanges) {\n            writer.setAttribute(attributeKey, true, range);\n        }\n        // After applying attribute to the text, remove given attribute from the selection.\n        // This way user is able to type a text without attribute used by auto formatter.\n        writer.removeSelectionAttribute(attributeKey);\n    };\n}\n"],
  "mappings": "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",
  "names": ["range", "range"]
}
