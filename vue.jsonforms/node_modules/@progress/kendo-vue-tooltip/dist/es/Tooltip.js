var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var isV3 = allVue.version && allVue.version[0] === '3';
import { classNames, validatePackage, getDefaultSlots, getListeners, templateRendering, getTemplate, setRef, getRef, canUseDOM, guid } from '@progress/kendo-vue-common';
import { getLeftPosition, getTopPosition, getDomRect, isTooltipElement } from './utils';
import { packageMetadata } from './package-metadata';
var DEFAULT_TOOLTIP_ZINDEX = 100;
var ARIAIDSUFFIX = '_tb_active';
/**
 * @hidden
 */
var TooltipVue2 = {
  name: 'KendoTooltip',
  inheritAttrs: false,
  props: {
    showCallout: {
      type: Boolean,
      default: true
    },
    setCalloutOnPositionAuto: {
      type: String,
      default: undefined
    },
    anchorElement: {
      type: String,
      default: 'pointer',
      validator: function validator(value) {
        return ['pointer', 'target'].includes(value);
      }
    },
    content: [String, Object, Function],
    filter: Function,
    openDelay: {
      type: Number,
      default: 400
    },
    open: {
      type: Boolean,
      default: undefined
    },
    position: {
      type: String,
      default: 'auto',
      validator: function validator(value) {
        return ['right', 'left', 'top', 'bottom', 'auto'].includes(value);
      }
    },
    updatePosition: {
      type: Function,
      default: undefined
    },
    updateInterval: Number,
    className: String,
    wrapperStyle: Object,
    tooltipClassName: String,
    tooltipStyle: Object,
    targetElement: {
      type: undefined
    },
    parentTitle: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      top: 0,
      left: 0,
      currentTargetElement: null,
      currentOpen: false,
      title: ''
    };
  },
  computed: {
    wrapperClass: function wrapperClass() {
      var _a;
      return _a = {
        'k-animation-container': true,
        'k-animation-container-fixed': true,
        'k-animation-container-shown': true
      }, _a[this.$props.className] = true, _a;
    },
    computedTarget: function computedTarget() {
      return this.targetElement !== undefined ? this.targetElement : this.currentTargetElement;
    },
    computedOpen: function computedOpen() {
      return this.open !== undefined ? this.open : this.currentOpen;
    }
  },
  inject: {
    kCurrentZIndex: {
      default: null
    }
  },
  created: function created() {
    validatePackage(packageMetadata);
    this.top = 0;
    this.left = 0;
    this.willOpen = false;
  },
  mounted: function mounted() {
    this.element = getRef(this, 'element');
    if (document) {
      document.body.addEventListener('mousemove', this.handleBodyMousemove);
    }
  },
  destroyed: !!isV3 ? undefined : function () {
    this.destroyElement();
  },
  // @ts-ignore
  unmounted: function unmounted() {
    this.destroyElement();
  },
  updated: function updated() {
    if (this.$props.open && this.$props.targetElement) {
      this.showToolTip({
        target: this.$props.targetElement
      });
    }
    this.element = getRef(this, 'element');
    if (!this.element) {
      return;
    }
    this.resetPosition();
    if (this.computedTarget) {
      var appendToElement = this.$props.appendTo ? this.$props.appendTo : this.computedTarget.ownerDocument.body;
      if (this.element.parentElement !== appendToElement) {
        this.computedTarget.ownerDocument.body.append(this.element);
      }
    }
    this.callout = this.v3 ? this.calloutRef : this.$refs.callout;
    if (!this.callout) {
      return;
    }
    this.callout.className = this.calloutClassName();
    if (this.$props.position === 'auto' && canUseDOM) {
      this.left < window.screen.availWidth / 2 ? this.callout.style.left = this.$props.setCalloutOnPositionAuto || '25%' : this.callout.style.left = this.$props.setCalloutOnPositionAuto || '75%';
    }
  },
  // @ts-ignore
  setup: !isV3 ? undefined : function () {
    var v3 = !!isV3;
    return {
      v3: v3
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var h = gh || createElement;
    var defaultSlot = getDefaultSlots(this);
    var currentZIndex = this.getCurrentZIndex();
    var content = this.$props.content ? templateRendering.call(this, this.$props.content, getListeners.call(this)) : undefined;
    var contentDefaultRendering = this.title;
    var ariaId = guid() + ARIAIDSUFFIX;
    if (this.computedTarget) {
      if (this.computedTarget.hasAttribute('id')) {
        ariaId = this.computedTarget.getAttribute('id') + ARIAIDSUFFIX;
      }
      this.computedTarget.setAttribute('aria-describedby', ariaId);
    }
    var contentRendering = getTemplate.call(this, {
      h: h,
      template: content,
      defaultRendering: contentDefaultRendering,
      additionalProps: {
        title: this.title,
        target: this.computedTarget
      }
    });
    var innerToolTip = this.computedOpen && h("div", {
      "class": classNames('k-tooltip', this.$props.tooltipClassName),
      role: 'tooltip',
      attrs: this.v3 ? undefined : {
        role: 'tooltip',
        id: ariaId
      },
      id: ariaId,
      style: __assign({
        position: 'relative'
      }, this.$props.tooltipStyle)
    }, [h("div", {
      "class": "k-tooltip-content"
    }, [contentRendering]), this.$props.showCallout && h("div", {
      ref: setRef(this, 'callout')
    })]);
    var tooltip = this.computedTarget && this.title && this.computedTarget.ownerDocument && h("div", {
      ref: setRef(this, 'element'),
      "class": this.wrapperClass,
      style: __assign({
        zIndex: currentZIndex
      }, this.$props.wrapperStyle),
      tabindex: 0,
      attrs: this.v3 ? undefined : {
        tabindex: 0
      }
    }, [h("div", {
      "class": "k-child-animation-container"
    }, [innerToolTip])]);
    if (defaultSlot) {
      return h("div", {
        onMouseover: this.handleMouseOver,
        on: this.v3 ? undefined : {
          "mouseover": this.handleMouseOver,
          "mouseout": this.handleMouseOut
        },
        onMouseout: this.handleMouseOut
      }, [tooltip, defaultSlot]);
    } else {
      return tooltip;
    }
  },
  methods: {
    destroyElement: function destroyElement() {
      clearTimeout(this.openTimeoutId);
      clearInterval(this.updateIntervalId);
      if (document) {
        document.body.removeEventListener('mousemove', this.handleBodyMousemove);
      }
      if (this.element) {
        this.element.remove();
      }
    },
    handleMouseOut: function handleMouseOut(event) {
      var currentDocument = this.computedTarget ? this.computedTarget.ownerDocument : document;
      var element = currentDocument && currentDocument.elementFromPoint(event.clientX, event.clientY);
      this.willOpen = false;
      if (isTooltipElement(element) || this.computedTarget !== event.target) {
        return;
      }
      if (this.$props.open) {
        return;
      }
      clearInterval(this.updateIntervalId);
      this.onClose(event);
    },
    handleMouseOver: function handleMouseOver(event) {
      var target = event.target;
      if (!this.isVisible(target) || isTooltipElement(target) || target === this.computedTarget) {
        return;
      }
      this.showToolTip(event);
    },
    handleBodyMousemove: function handleBodyMousemove(event) {
      this.top = event.clientY;
      this.left = event.clientX;
    },
    onClose: function onClose(event) {
      this.$emit('close', {
        event: event,
        component: this
      });
      this.computedTarget.removeAttribute('aria-describedby');
      this.currentTargetElement = null;
      this.currentOpen = false;
      this.title = '';
    },
    showToolTip: function showToolTip(event) {
      var _this = this;
      clearTimeout(this.openTimeoutId);
      clearInterval(this.updateIntervalId);
      if (event.target.hasChildNodes()) {
        event.target.childNodes.forEach(function (childElement) {
          if (childElement.nodeName === 'title') {
            event.target.titleExpando = childElement.innerHTML;
            childElement.remove();
          }
        });
      }
      var target = this.computedTarget || event.target;
      var titleResult = this.getTitle(target);
      if (!titleResult.title) {
        if (this.computedOpen) {
          this.onClose(event);
        }
        return;
      }
      if (titleResult.element) {
        titleResult.element.titleExpando = titleResult.title;
        titleResult.element.title = '';
      }
      this.willOpen = true;
      if (!this.$props.openDelay) {
        this.currentTargetElement = target;
        this.currentOpen = true;
        this.title = titleResult.title;
        this.setUpdateInterval();
      } else {
        if (canUseDOM) {
          this.openTimeoutId = window.setTimeout(function () {
            if (_this.willOpen) {
              _this.currentTargetElement = target;
              _this.currentOpen = true;
              _this.title = titleResult.title;
              _this.setUpdateInterval();
            }
          }, this.$props.openDelay);
        }
      }
      if (this.title !== titleResult.title) {
        this.$emit('open', {
          event: event,
          compoponent: this
        });
      }
    },
    setUpdateInterval: function setUpdateInterval() {
      if (this.$props.updateInterval) {
        this.updateIntervalId = setInterval(this.onIntervalUpdate, this.$props.updateInterval);
      }
    },
    onIntervalUpdate: function onIntervalUpdate() {
      var target = this.computedTarget;
      if (!target) {
        return;
      }
      if (target.parentElement === null) {
        // Getting element from previous target coordinates will cause reflow which is performance hit.
        // Also remount case can be avoided easily
        this.onClose({
          target: target
        });
      } else {
        this.showToolTip({
          target: target
        });
      }
    },
    resetPosition: function resetPosition() {
      if (this.element) {
        var position = this.setPosition(this.element);
        if (this.$props.updatePosition) {
          position = this.$props.updatePosition({
            element: this.element,
            targetElement: this.computedTarget,
            mouseTop: this.top,
            mouseLeft: this.left,
            anchorElement: this.$props.anchorElement,
            position: this.$props.position,
            target: this,
            defaultPosition: position
          });
        }
        this.element.style.left = position.left + 'px';
        this.element.style.top = position.top + 'px';
      }
    },
    isVisible: function isVisible(element) {
      return !this.$props.filter || this.$props.filter(element);
    },
    setPosition: function setPosition(element) {
      var target = this.parentTitle ? this.getTitle(this.computedTarget).element : this.computedTarget;
      var domRect = getDomRect(target);
      var left = getLeftPosition(this.left, element.offsetWidth, domRect, this.$props.anchorElement, this.$props.position);
      var top = getTopPosition(this.top, domRect, element.offsetHeight, this.$props.anchorElement, this.$props.position);
      return {
        left: left,
        top: top
      };
    },
    getTitle: function getTitle(element) {
      while (element) {
        if (element.getAttribute('title') !== null || element.titleExpando) {
          var title = element.getAttribute('title') || element.titleExpando;
          return {
            title: title,
            element: element
          };
        }
        element = this.$props.parentTitle && element.parentElement || null;
      }
      return {
        title: '',
        element: element
      };
    },
    calloutClassName: function calloutClassName() {
      switch (this.$props.position) {
        case 'bottom':
          return 'k-callout k-callout-n';
        case 'left':
          return 'k-callout k-callout-e';
        case 'right':
          return 'k-callout k-callout-w';
        case 'top':
          return 'k-callout k-callout-s';
        default:
          return canUseDOM && this.top < window.innerHeight / 2 ? 'k-callout k-callout-n' : 'k-callout k-callout-s';
      }
    },
    getCurrentZIndex: function getCurrentZIndex() {
      return this.kCurrentZIndex ? this.kCurrentZIndex : DEFAULT_TOOLTIP_ZINDEX;
    }
  }
};
/**
 * @hidden
 */
var Tooltip = TooltipVue2;
export { Tooltip, TooltipVue2 };