// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var isV3 = allVue.version && allVue.version[0] === '3';
import { cloneDate } from '@progress/kendo-date-math';
import { first, isInTimeRange, intersects } from '../utils/main.js';
import { getRect } from '../views/common/utils.js';
var combineWidths = function combineWidths(slots) {
  var result = 0;
  slots.forEach(function (slot) {
    if (slot) {
      var rect = getRect(slot.$el);
      result += rect.width;
    }
  });
  return result;
};
var combineHeights = function combineHeights(slots) {
  var result = 0;
  slots.forEach(function (slot) {
    if (slot) {
      var rect = getRect(slot.$el);
      result += rect.height;
    }
  });
  return result;
};
var setTime = function setTime(origin, candidate) {
  var date = cloneDate(origin);
  date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());
  return date;
};
/**
 * @hidden
 */
var CurrentTimeMarkerVue2 = {
  name: 'KendoCurrentTimeMarker',
  props: {
    updateInterval: {
      type: Number,
      default: 60000
    },
    groupIndex: Number,
    vertical: Boolean,
    attachArrow: Object
  },
  inject: {
    ks: {
      default: null
    },
    bv: {
      default: null
    }
  },
  created: function created() {
    this.interval = undefined;
    this.arrowRef = null;
    this.observer = null;
    this.line = null;
  },
  data: function data() {
    return {
      show: false
    };
  },
  mounted: function mounted() {
    this.line = this.$el;
    var that = this;
    this.$nextTick(function () {
      that.position();
    });
    if (!this.ks.scheduler || !this.ks.scheduler.$el || !window) {
      return;
    }
    clearInterval(this.interval);
    this.interval = window.setInterval(this.position, this.updateInterval);
    this.observer = new window.ResizeObserver(this.position);
    this.observer.observe(this.ks.scheduler.$el);
  },
  destroyed: !!isV3 ? undefined : function () {
    if (this.observer) {
      this.observer.disconnect();
    }
  },
  // @ts-ignore
  unmounted: function unmounted() {
    if (this.observer) {
      this.observer.disconnect();
    }
  },
  // @ts-ignore
  setup: !isV3 ? undefined : function () {
    var v3 = !!isV3;
    return {
      v3: v3
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var _a;
    var h = gh || createElement;
    //   const dir = useDir(line, schedulerProps.rtl === true ? 'rtl' : undefined);
    return h("div", {
      "class": "k-current-time",
      style: (_a = {
        transform: this.$props.vertical ? 'translateX(-50%)' : 'translateY(-50%)'
      }, _a[this.$props.vertical ? 'width' : 'height'] = '1px', _a.visibility = !this.show ? 'hidden' : undefined, _a)
    });
  },
  methods: {
    position: function position() {
      var _this = this;
      if (!this.bv.slots) {
        return;
      }
      var groupIndex = this.$props.groupIndex;
      var sameTimeSlots = this.bv.slots.filter(function (s) {
        return (groupIndex === undefined || groupIndex === null || s.cSlot.group.index === groupIndex) && (_this.$props.vertical ? intersects(new Date(), new Date(), s.cSlot.start, s.cSlot.end, true) : isInTimeRange(new Date(), s.cSlot.start, s.cSlot.end)) && !s.isAllDay;
      });
      if (sameTimeSlots && sameTimeSlots.length && this.line) {
        var firstSlot = first(sameTimeSlots);
        if (!firstSlot) {
          return;
        }
        var size = this.$props.vertical ? combineHeights(sameTimeSlots) : combineWidths(sameTimeSlots);
        var rect = getRect(firstSlot.$el);
        var arrowRect = getRect(this.arrowRef);
        var pxPerMillisecond = (this.$props.vertical ? rect.width : rect.height) / (firstSlot.cSlot.end.getTime() - firstSlot.cSlot.start.getTime());
        var offset = (Date.now() - setTime(new Date(), firstSlot.cSlot.start).getTime()) * pxPerMillisecond;
        var rtl = this.$props.dir === 'rtl';
        var top_1 = this.$props.vertical ? rect.top : rect.top + offset - arrowRect.height / 2;
        var horizontalDimension = rtl ? 'right' : 'left';
        var horizontalMeasure = this.$props.vertical ? rect[horizontalDimension] + offset - arrowRect.width / 2 : rect[horizontalDimension];
        // if (this.$props.vertical) {
        //     this.arrowRef.style[horizontalDimension] = `${horizontalMeasure}px`;
        // } else {
        //     this.arrowRef.style.top = `${top}px`;
        // }
        this.line.style[horizontalDimension] = "".concat(horizontalMeasure, "px");
        this.line.style.top = "".concat(top_1, "px");
        this.line.style[this.$props.vertical ? 'height' : 'width'] = "".concat(size - 1, "px");
        this.show = true;
      } else {
        this.show = false;
      }
    }
  }
};
/**
 * @hidden
 */
var CurrentTimeMarker = CurrentTimeMarkerVue2;
export { CurrentTimeMarker, CurrentTimeMarkerVue2 };