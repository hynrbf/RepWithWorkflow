// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var isV3 = allVue.version && allVue.version[0] === '3';
import { GRID_OFFSET } from './MultiDayView.js';
import { isInTimeRange, intersects, first, last } from '../../utils/main.js';
import { SchedulerEditSlot } from '../../slots/SchedulerEditSlot.js';
import { DayViewRowContent } from './DayViewRowContent.js';
import { CurrentTimeMarker } from '../../components/CurrentTimeMarker.js';
import { CurrentTimeMarkerArrow } from '../../components/CurrentTimeMarkerArrow.js';
/** @hidden */
var DayViewVerticalSlotsRowVue2 = {
  name: 'KendoDayViewVerticalSlotsRow',
  props: {
    currentTimeMarker: {
      type: Boolean,
      default: true
    },
    slotRender: [String, Function, Object],
    viewSlot: [String, Function, Object],
    editable: [Object, Boolean],
    groupIndex: Number,
    root: Object,
    rootIndex: Number,
    filtered: Array,
    slotDivisions: {
      type: Number,
      default: 2
    },
    timeSlots: Array,
    timeRanges: Array,
    numberOfDays: Number,
    workDayStart: Date,
    workDayEnd: Date,
    workWeekStart: Number,
    workWeekEnd: Number
  },
  inject: {
    ri: {
      default: null
    },
    setSlots: {
      default: null
    }
  },
  provide: function provide() {
    return {
      ksSlots: this.ksSlots
    };
  },
  data: function data() {
    var timeSlots = this.timeSlots;
    var root = this.root;
    var groupIndex = this.groupIndex;
    var cSlots = this.calculateRanges(timeSlots, groupIndex, this.timeRanges, root);
    return {
      ksSlots: {
        cSlots: cSlots
      }
    };
  },
  watch: {
    currentCellSlots: function currentCellSlots(newValue) {
      this.ksSlots.cSlots = newValue;
    }
  },
  computed: {
    currentCellSlots: function currentCellSlots() {
      var timeSlots = this.timeSlots;
      var root = this.root;
      var groupIndex = this.groupIndex;
      return this.calculateRanges(timeSlots, groupIndex, this.timeRanges, root);
    }
  },
  // @ts-ignore
  setup: !isV3 ? undefined : function () {
    var v3 = !!isV3;
    return {
      v3: v3
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var h = gh || createElement;
    var EditSlot = this.$props.editSlot || SchedulerEditSlot;
    var groupIndex = this.groupIndex;
    var that = this;
    var _a = this.$props,
      root = _a.root,
      rootIndex = _a.rootIndex,
      slotDivisions = _a.slotDivisions,
      filtered = _a.filtered,
      workDayStart = _a.workDayStart,
      workDayEnd = _a.workDayEnd,
      numberOfDays = _a.numberOfDays,
      workWeekStart = _a.workWeekStart,
      workWeekEnd = _a.workWeekEnd,
      viewSlot = _a.viewSlot,
      renderSlot = _a.renderSlot,
      form = _a.form,
      editable = _a.editable;
    return h("div", {
      "class": "k-scheduler-row",
      key: root.index
    }, [h(DayViewRowContent, {
      contentSlot: root,
      attrs: this.v3 ? undefined : {
        contentSlot: root,
        isMaster: rootIndex % slotDivisions === 0,
        isLast: (rootIndex + 1) % slotDivisions === 0,
        timeHeaderCell: this.$props.timeHeaderCell
      },
      isMaster: rootIndex % slotDivisions === 0,
      isLast: (rootIndex + 1) % slotDivisions === 0,
      timeHeaderCell: this.$props.timeHeaderCell
    }), this.currentCellSlots.map(function (slot, slotIndex) {
      return h(EditSlot, {
        slotRender: renderSlot,
        attrs: this.v3 ? undefined : {
          slotRender: renderSlot,
          viewSlot: viewSlot,
          form: form,
          index: slotIndex,
          row: filtered.length * (groupIndex || 0) + rootIndex + (groupIndex || 0) * GRID_OFFSET + GRID_OFFSET,
          col: slot.range.index,
          editable: editable,
          isWorkHour: isInTimeRange(slot.zonedStart, workDayStart, workDayEnd),
          isWorkDay: 0 <= slot.zonedStart.getDay() + (numberOfDays - workWeekStart) && (slot.zonedStart.getDay() + (numberOfDays - workWeekStart)) % numberOfDays <= workWeekEnd + (numberOfDays - workWeekStart)
        },
        viewSlot: viewSlot,
        form: form,
        onDataaction: that.handleDataAction,
        on: this.v3 ? undefined : {
          "dataaction": that.handleDataAction
        },
        index: slotIndex,
        row: filtered.length * (groupIndex || 0) + rootIndex + (groupIndex || 0) * GRID_OFFSET + GRID_OFFSET,
        col: slot.range.index,
        editable: editable,
        isWorkHour: isInTimeRange(slot.zonedStart, workDayStart, workDayEnd),
        isWorkDay: 0 <= slot.zonedStart.getDay() + (numberOfDays - workWeekStart) && (slot.zonedStart.getDay() + (numberOfDays - workWeekStart)) % numberOfDays <= workWeekEnd + (numberOfDays - workWeekStart)
      });
    }, true), this.$props.currentTimeMarker && intersects(first(this.timeRanges).start, last(this.timeRanges).end, new Date(), new Date(), true) && [h(CurrentTimeMarkerArrow, {
      groupIndex: groupIndex,
      attrs: this.v3 ? undefined : {
        groupIndex: groupIndex
      }
    }), h(CurrentTimeMarker, {
      groupIndex: groupIndex,
      attrs: this.v3 ? undefined : {
        groupIndex: groupIndex
      }
    })]]);
  },
  methods: {
    handleDataAction: function handleDataAction(action) {
      this.$emit('dataaction', action);
    },
    calculateRanges: function calculateRanges(timeSlots, groupIndex, timeRanges, root) {
      return timeRanges.map(function (_, rangeIndex) {
        return timeSlots.filter(function (s) {
          return s.index === root.index && s.group.index === groupIndex && s.range.index === rangeIndex;
        });
      }).flat();
    }
  }
};
/** @hidden */
var DayViewVerticalSlotsRow = DayViewVerticalSlotsRowVue2;
export { DayViewVerticalSlotsRow, DayViewVerticalSlotsRowVue2 };