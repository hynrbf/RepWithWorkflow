var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
import { clone } from '@progress/kendo-vue-common';
import { DATA_ACTION } from '../../main.js';
import { getField, setField, slotDive } from '../../utils/main.js';
/**
 * Represents the available `action` types for the `SchedulerItemDragItemAction` objects.
 *
 * The available types are:
 * - `DRAG_ITEM_SET'`
 * - `DRAG_ITEM_START'`
 * - `DRAG_ITEM_DRAG'`
 * - `DRAG_ITEM_COMPLETE'`
 * - `DRAG_ITEM_COMPLETE_OCCURRENCE'`
 * - `DRAG_ITEM_COMPLETE_SERIES'`
 * - `DRAG_ITEM_RESET'`
 * - `DRAG_ITEM_DRAG_SELECTED`
 */
export var DRAG_ITEM_ACTION;
(function (DRAG_ITEM_ACTION) {
  DRAG_ITEM_ACTION["set"] = "DRAG_ITEM_SET";
  DRAG_ITEM_ACTION["start"] = "DRAG_ITEM_START";
  DRAG_ITEM_ACTION["drag"] = "DRAG_ITEM_DRAG";
  DRAG_ITEM_ACTION["complete"] = "DRAG_ITEM_COMPLETE";
  DRAG_ITEM_ACTION["completeOccurrence"] = "DRAG_ITEM_COMPLETE_OCCURRENCE";
  DRAG_ITEM_ACTION["completeSeries"] = "DRAG_ITEM_COMPLETE_SERIES";
  DRAG_ITEM_ACTION["reset"] = "DRAG_ITEM_RESET";
  DRAG_ITEM_ACTION["dragSelected"] = "DRAG_ITEM_DRAG_SELECTED";
})(DRAG_ITEM_ACTION || (DRAG_ITEM_ACTION = {}));
var offset = 0;
var initialXRef = 0;
var initialYRef = 0;
var oldSlot = null;
/** @hidden */
export var useDragItem = function useDragItem(action) {
  var _this = this;
  var dataItem = clone(this.dataItem);
  switch (action.type) {
    case DRAG_ITEM_ACTION.set:
      {
        this.currentDragItem = action.payload;
        break;
      }
    case DRAG_ITEM_ACTION.reset:
      {
        this.currentDragItem = null;
        break;
      }
    case DRAG_ITEM_ACTION.dragSelected:
      {
        if (Math.abs(initialXRef - action.payload.x) < 10 && Math.abs(initialYRef - action.payload.y) < 10) {
          return;
        }
        var slot = slotDive(action.payload.x, action.payload.y, 7);
        if (!slot) {
          return;
        }
        if (slot === oldSlot) {
          return;
        }
        var slotStart = slot.getAttribute('data-slot-start');
        var slotIsAllDay = slot.getAttribute('data-slot-allday') === 'true';
        if (!this.ignoreIsAllDay && slotIsAllDay !== this.isAllDay) {
          return;
        }
        var itemStart = new Date(getField(dataItem, this.ks.fields.start));
        var distance_1 = Number(slotStart) - itemStart.getTime();
        var newDragItems = this.bv.selectedItems.map(function (si) {
          if (!si) {
            return null;
          }
          var selectedDataItem = clone(si.props.dataItem);
          var selectedStart = new Date(si.props.start.getTime() + distance_1);
          var selectedEnd = new Date(si.props.end.getTime() + distance_1);
          setField(selectedDataItem, _this.ks.fields.start, selectedStart);
          setField(selectedDataItem, _this.ks.fields.end, selectedEnd);
          return selectedDataItem;
        }).filter(Boolean);
        oldSlot = slot;
        this.currentDragItem = __spreadArray([], newDragItems, true);
        break;
      }
    case DRAG_ITEM_ACTION.start:
      {
        var clientX = action.payload.x;
        var clientY = action.payload.y;
        initialXRef = clientX;
        initialYRef = clientY;
        var slot = slotDive(clientX, clientY, 7);
        if (!slot) {
          return;
        }
        var slotStart = slot.getAttribute('data-slot-start');
        var itemStart = getField(dataItem, this.ks.fields.start);
        if (slotStart === null) {
          return;
        }
        offset = Number(slotStart) - new Date(itemStart).getTime();
        break;
      }
    case DRAG_ITEM_ACTION.drag:
      {
        if (Math.abs(initialXRef - action.payload.x) < 10 && Math.abs(initialYRef - action.payload.y) < 10) {
          return;
        }
        var slot = slotDive(action.payload.x, action.payload.y, 7);
        if (!slot) {
          return;
        }
        if (slot === oldSlot) {
          return;
        }
        var slotStart = slot.getAttribute('data-slot-start');
        var slotGroupIndex_1 = slot.getAttribute('data-slot-group');
        var slotIsAllDay = slot.getAttribute('data-slot-allday') === 'true';
        if (!this.ignoreIsAllDay && slotIsAllDay !== this.isAllDay) {
          return;
        }
        var itemStart = new Date(getField(dataItem, this.ks.fields.start));
        var itemEnd = new Date(getField(dataItem, this.ks.fields.end));
        var duration = itemEnd.getTime() - itemStart.getTime();
        var start = new Date(Number(slotStart) - Number(offset));
        var end = new Date(Number(slotStart) - Number(offset) + duration);
        var group = this.ks.groups.find(function (g) {
          return g.index === Number(slotGroupIndex_1);
        });
        setField(dataItem, this.ks.fields.start, start);
        setField(dataItem, this.ks.fields.end, end);
        if (group && this.ks.groups.length > 1) {
          group.resources.forEach(function (resource) {
            if (!resource.multiple) {
              setField(dataItem, resource.field, resource[resource.valueField]);
            }
          });
        }
        oldSlot = slot;
        if (dataItem) {
          this.currentDragItem = dataItem;
        }
        break;
      }
    case DRAG_ITEM_ACTION.complete:
      {
        var currentDataItem = this.compDragItem;
        this.currentDragItem = null;
        if (currentDataItem) {
          this.$emit('dataaction', {
            type: DATA_ACTION.update,
            series: false,
            dataItem: currentDataItem
          });
        }
        break;
      }
    case DRAG_ITEM_ACTION.completeOccurrence:
      {
        var newDataItem = Array.isArray(this.compDragItem) ? this.compDragItem.slice() : clone(this.compDragItem);
        var currentDataItem = this.compDragItem;
        this.currentDragItem = null;
        if (currentDataItem) {
          this.$emit('dataaction', {
            type: DATA_ACTION.update,
            series: false,
            dataItem: newDataItem
          });
        }
        break;
      }
    case DRAG_ITEM_ACTION.completeSeries:
      {
        var newDataItems = void 0;
        if (Array.isArray(this.compDragItem)) {
          newDataItems = this.compDragItem.map(function (di) {
            var updated = clone(di);
            setField(updated, _this.ks.fields.start, getField(di, _this.ks.fields.start));
            setField(updated, _this.ks.fields.end, getField(di, _this.ks.fields.end));
            return updated;
          });
        } else {
          var updated = clone(this.compDragItem);
          setField(updated, this.ks.fields.start, getField(this.compDragItem, this.ks.fields.start));
          setField(updated, this.ks.fields.end, getField(this.compDragItem, this.ks.fields.end));
          newDataItems = updated;
        }
        this.currentDragItem = null;
        if (newDataItems) {
          this.$emit('dataaction', {
            type: DATA_ACTION.update,
            series: true,
            dataItem: newDataItems
          });
        }
        break;
      }
    default:
      this.currentDragItem = this.compDragItem;
      break;
  }
  this.$emit('dragitemchange', this.currentDragItem);
};