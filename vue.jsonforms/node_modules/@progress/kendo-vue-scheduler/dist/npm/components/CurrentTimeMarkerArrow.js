"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CurrentTimeMarkerArrowVue2 = exports.CurrentTimeMarkerArrow = void 0;
// @ts-ignore
var Vue = require("vue");
var allVue = Vue;
var gh = allVue.h;
var isV3 = allVue.version && allVue.version[0] === '3';
var kendo_date_math_1 = require("@progress/kendo-date-math");
var kendo_vue_common_1 = require("@progress/kendo-vue-common");
var main_1 = require("../utils/main");
var utils_1 = require("../views/common/utils");
var setTime = function setTime(origin, candidate) {
  var date = (0, kendo_date_math_1.cloneDate)(origin);
  date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());
  return date;
};
/** @hidden */
var CurrentTimeMarkerArrowVue2 = {
  name: 'KendoCurrentTimeMarkerArrow',
  props: {
    updateInterval: {
      type: Number,
      default: 60000
    },
    groupIndex: Number,
    vertical: Boolean,
    attachArrow: Object
  },
  inject: {
    ks: {
      default: null
    },
    bv: {
      default: null
    }
  },
  created: function created() {
    this.interval = undefined;
    this.arrowRef = null;
  },
  data: function data() {
    return {
      show: false
    };
  },
  mounted: function mounted() {
    this.arrowRef = this.$el;
    this.position();
    if (!this.ks.scheduler || !this.ks.scheduler.$el || !window) {
      return;
    }
    clearInterval(this.interval);
    this.interval = window.setInterval(this.position, this.updateInterval);
    this.observer = new window.ResizeObserver(this.position);
    this.observer.observe(this.ks.scheduler.$el);
  },
  destroyed: !!isV3 ? undefined : function () {
    if (this.observer) {
      this.observer.disconnect();
    }
  },
  // @ts-ignore
  unmounted: function unmounted() {
    if (this.observer) {
      this.observer.disconnect();
    }
  },
  // @ts-ignore
  setup: !isV3 ? undefined : function () {
    var v3 = !!isV3;
    return {
      v3: v3
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var h = gh || createElement;
    //   const dir = useDir(line, schedulerProps.rtl === true ? 'rtl' : undefined);
    return h("div", {
      "class": (0, kendo_vue_common_1.classNames)('k-current-time', {
        'k-current-time-arrow-right': !this.$props.vertical && this.$props.dir !== 'rtl',
        'k-current-time-arrow-left': !this.$props.vertical && this.$props.dir === 'rtl',
        'k-current-time-arrow-down': this.$props.vertical
      }),
      style: {
        transform: this.$props.vertical ? this.$props.dir === 'rtl' ? 'translateX(50%)' : 'translateX(-50%)' : 'translateY(-50%)',
        visibility: !this.show ? 'hidden' : undefined
      }
    });
  },
  methods: {
    position: function position() {
      var _this = this;
      if (!this.bv.slots) {
        return;
      }
      var groupIndex = this.$props.groupIndex;
      var sameTimeSlots = this.bv.slots.filter(function (s) {
        return (groupIndex === undefined || groupIndex === null || s.cSlot.group.index === groupIndex) && (_this.$props.vertical ? (0, main_1.intersects)(new Date(), new Date(), s.cSlot.start, s.cSlot.end, true) : (0, main_1.isInTimeRange)(new Date(), s.cSlot.start, s.cSlot.end)) && !s.isAllDay;
      });
      if (sameTimeSlots && sameTimeSlots.length && this.$el) {
        var firstSlot = (0, main_1.first)(sameTimeSlots);
        if (!firstSlot) {
          return;
        }
        var rect = (0, utils_1.getRect)(firstSlot.$el);
        var arrowRect = (0, utils_1.getRect)(this.arrowRef);
        var pxPerMillisecond = (this.$props.vertical ? rect.width : rect.height) / (firstSlot.cSlot.end.getTime() - firstSlot.cSlot.start.getTime());
        var offset = (Date.now() - setTime(new Date(), firstSlot.cSlot.start).getTime()) * pxPerMillisecond;
        var rtl = this.$props.dir === 'rtl';
        var top_1 = this.$props.vertical ? rect.top : rect.top + offset - arrowRect.height / 2;
        var horizontalDimension = rtl ? 'right' : 'left';
        var horizontalMeasure = this.$props.vertical ? rect[horizontalDimension] + offset - arrowRect.width / 2 : rect[horizontalDimension];
        if (this.$props.vertical) {
          this.arrowRef.style[horizontalDimension] = "".concat(horizontalMeasure, "px");
        } else {
          this.arrowRef.style.top = "".concat(top_1, "px");
        }
        this.show = true;
      } else {
        this.show = false;
      }
    }
  }
};
exports.CurrentTimeMarkerArrowVue2 = CurrentTimeMarkerArrowVue2;
/**
 * @hidden
 */
var CurrentTimeMarkerArrow = CurrentTimeMarkerArrowVue2;
exports.CurrentTimeMarkerArrow = CurrentTimeMarkerArrow;