/// <reference types="react" />
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 */
import * as React$1 from 'react';
import React__default, { SVGProps, useEffect } from 'react';
import { Placement } from '@popperjs/core';
import { TransitionProps } from 'react-transition-group/Transition';
import Cropper$1 from 'cropperjs';
import * as react_dnd from 'react-dnd';

declare const Avatar: React$1.FC<Props$3a>;
interface Props$3a {
    /**
     * ID used for determining color.
     */
    id: string;
    /**
     * Name to abbreviate.
     */
    name: string;
    /**
     * Whether to use primary color.
     */
    primary?: boolean;
    /**
     * Shows full name next to avatar.
     */
    showFullName?: boolean;
}

declare const Bottombar: React$1.ForwardRefExoticComponent<Props$39 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$39 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Content rendered on the right side of the bar.
     */
    sideContent: React$1.ReactNode;
    /**
     * Content rendered as status summary in a absolute left-positioned container
     */
    statusContent?: React$1.ReactNode;
}

type ButtonSize = 'small' | 'medium' | 'large';
type ButtonType = 'fill' | 'outline' | 'plain' | 'link';
type ButtonColor = 'action' | 'success' | 'danger' | 'neutral';

declare const AccessTimeOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const AddOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const AdminPanelSettingsOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ArrowBackIosNewOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ArrowBackOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ArrowForwardIosOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ArrowForwardOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ArrowRightOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ArticleOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const CheckCircleOutlineOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const CheckOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ChevronLeftOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ChevronRightOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const CloseOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ContentCopyOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const CreateNewFolderOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const Crop169Outlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const Crop916Outlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const CropLandscapeOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const CropOriginalOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const CropOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const CropPortraitOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const CropSquareOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const DeleteOutlineOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const DragIndicatorOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const DriveFileRenameOutlineOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const DriveFolderUploadOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const EditOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const ExpandMoreOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const FileCopyOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const FileDownloadOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const FileMoveOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const FileUploadOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const FilterListOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const FirstPageOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const FlipHorizontalOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const FlipVerticalOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const Folder: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const FolderOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const HighlightOffOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const InfoOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const Inventory2Outlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const KeyboardDoubleArrowLeftOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const KeyboardDoubleArrowRightOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const LastPageOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const LockOpenOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const LockOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const MoreVertOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const PhotoOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const RemoveOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const RotateLeftOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const RotateRightOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const SaveOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const SearchMissingResults: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const SearchOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const SettingsOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const Sort: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const TuneOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const UploadFileOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const VisibilityOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const Warning: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

declare const WarningAmberOutlined: (props: SVGProps<SVGSVGElement>) => React$1.JSX.Element;

interface Props$38 {
    /**
     * Toggles optional icon animation.
     */
    animateIn?: boolean;
    /**
     * Sets root class name.
     */
    className?: string;
    /**
     * Optional test ID.
     */
    'data-testid'?: string;
}

declare const ArrowRightOutlinedAnimated: React$1.FC<Props$38>;

declare const SettingsOutlinedAnimated: React$1.FC<Props$38>;

declare const SortAscending: React$1.FC<Props$38>;

declare const SortDescending: React$1.FC<Props$38>;

declare const Spinner: React$1.FC<Props$38>;

declare const icons$1_AccessTimeOutlined: typeof AccessTimeOutlined;
declare const icons$1_AddOutlined: typeof AddOutlined;
declare const icons$1_AdminPanelSettingsOutlined: typeof AdminPanelSettingsOutlined;
declare const icons$1_ArrowBackIosNewOutlined: typeof ArrowBackIosNewOutlined;
declare const icons$1_ArrowBackOutlined: typeof ArrowBackOutlined;
declare const icons$1_ArrowForwardIosOutlined: typeof ArrowForwardIosOutlined;
declare const icons$1_ArrowForwardOutlined: typeof ArrowForwardOutlined;
declare const icons$1_ArrowRightOutlined: typeof ArrowRightOutlined;
declare const icons$1_ArrowRightOutlinedAnimated: typeof ArrowRightOutlinedAnimated;
declare const icons$1_ArticleOutlined: typeof ArticleOutlined;
declare const icons$1_CheckCircleOutlineOutlined: typeof CheckCircleOutlineOutlined;
declare const icons$1_CheckOutlined: typeof CheckOutlined;
declare const icons$1_ChevronLeftOutlined: typeof ChevronLeftOutlined;
declare const icons$1_ChevronRightOutlined: typeof ChevronRightOutlined;
declare const icons$1_CloseOutlined: typeof CloseOutlined;
declare const icons$1_ContentCopyOutlined: typeof ContentCopyOutlined;
declare const icons$1_CreateNewFolderOutlined: typeof CreateNewFolderOutlined;
declare const icons$1_Crop169Outlined: typeof Crop169Outlined;
declare const icons$1_Crop916Outlined: typeof Crop916Outlined;
declare const icons$1_CropLandscapeOutlined: typeof CropLandscapeOutlined;
declare const icons$1_CropOriginalOutlined: typeof CropOriginalOutlined;
declare const icons$1_CropOutlined: typeof CropOutlined;
declare const icons$1_CropPortraitOutlined: typeof CropPortraitOutlined;
declare const icons$1_CropSquareOutlined: typeof CropSquareOutlined;
declare const icons$1_DeleteOutlineOutlined: typeof DeleteOutlineOutlined;
declare const icons$1_DragIndicatorOutlined: typeof DragIndicatorOutlined;
declare const icons$1_DriveFileRenameOutlineOutlined: typeof DriveFileRenameOutlineOutlined;
declare const icons$1_DriveFolderUploadOutlined: typeof DriveFolderUploadOutlined;
declare const icons$1_EditOutlined: typeof EditOutlined;
declare const icons$1_ExpandMoreOutlined: typeof ExpandMoreOutlined;
declare const icons$1_FileCopyOutlined: typeof FileCopyOutlined;
declare const icons$1_FileDownloadOutlined: typeof FileDownloadOutlined;
declare const icons$1_FileMoveOutlined: typeof FileMoveOutlined;
declare const icons$1_FileUploadOutlined: typeof FileUploadOutlined;
declare const icons$1_FilterListOutlined: typeof FilterListOutlined;
declare const icons$1_FirstPageOutlined: typeof FirstPageOutlined;
declare const icons$1_FlipHorizontalOutlined: typeof FlipHorizontalOutlined;
declare const icons$1_FlipVerticalOutlined: typeof FlipVerticalOutlined;
declare const icons$1_Folder: typeof Folder;
declare const icons$1_FolderOutlined: typeof FolderOutlined;
declare const icons$1_HighlightOffOutlined: typeof HighlightOffOutlined;
declare const icons$1_InfoOutlined: typeof InfoOutlined;
declare const icons$1_Inventory2Outlined: typeof Inventory2Outlined;
declare const icons$1_KeyboardDoubleArrowLeftOutlined: typeof KeyboardDoubleArrowLeftOutlined;
declare const icons$1_KeyboardDoubleArrowRightOutlined: typeof KeyboardDoubleArrowRightOutlined;
declare const icons$1_LastPageOutlined: typeof LastPageOutlined;
declare const icons$1_LockOpenOutlined: typeof LockOpenOutlined;
declare const icons$1_LockOutlined: typeof LockOutlined;
declare const icons$1_MoreVertOutlined: typeof MoreVertOutlined;
declare const icons$1_PhotoOutlined: typeof PhotoOutlined;
declare const icons$1_RemoveOutlined: typeof RemoveOutlined;
declare const icons$1_RotateLeftOutlined: typeof RotateLeftOutlined;
declare const icons$1_RotateRightOutlined: typeof RotateRightOutlined;
declare const icons$1_SaveOutlined: typeof SaveOutlined;
declare const icons$1_SearchMissingResults: typeof SearchMissingResults;
declare const icons$1_SearchOutlined: typeof SearchOutlined;
declare const icons$1_SettingsOutlined: typeof SettingsOutlined;
declare const icons$1_SettingsOutlinedAnimated: typeof SettingsOutlinedAnimated;
declare const icons$1_Sort: typeof Sort;
declare const icons$1_SortAscending: typeof SortAscending;
declare const icons$1_SortDescending: typeof SortDescending;
declare const icons$1_Spinner: typeof Spinner;
declare const icons$1_TuneOutlined: typeof TuneOutlined;
declare const icons$1_UploadFileOutlined: typeof UploadFileOutlined;
declare const icons$1_VisibilityOutlined: typeof VisibilityOutlined;
declare const icons$1_Warning: typeof Warning;
declare const icons$1_WarningAmberOutlined: typeof WarningAmberOutlined;
declare namespace icons$1 {
  export {
    icons$1_AccessTimeOutlined as AccessTimeOutlined,
    icons$1_AddOutlined as AddOutlined,
    icons$1_AdminPanelSettingsOutlined as AdminPanelSettingsOutlined,
    icons$1_ArrowBackIosNewOutlined as ArrowBackIosNewOutlined,
    icons$1_ArrowBackOutlined as ArrowBackOutlined,
    icons$1_ArrowForwardIosOutlined as ArrowForwardIosOutlined,
    icons$1_ArrowForwardOutlined as ArrowForwardOutlined,
    icons$1_ArrowRightOutlined as ArrowRightOutlined,
    icons$1_ArrowRightOutlinedAnimated as ArrowRightOutlinedAnimated,
    icons$1_ArticleOutlined as ArticleOutlined,
    icons$1_CheckCircleOutlineOutlined as CheckCircleOutlineOutlined,
    icons$1_CheckOutlined as CheckOutlined,
    icons$1_ChevronLeftOutlined as ChevronLeftOutlined,
    icons$1_ChevronRightOutlined as ChevronRightOutlined,
    icons$1_CloseOutlined as CloseOutlined,
    icons$1_ContentCopyOutlined as ContentCopyOutlined,
    icons$1_CreateNewFolderOutlined as CreateNewFolderOutlined,
    icons$1_Crop169Outlined as Crop169Outlined,
    icons$1_Crop916Outlined as Crop916Outlined,
    icons$1_CropLandscapeOutlined as CropLandscapeOutlined,
    icons$1_CropOriginalOutlined as CropOriginalOutlined,
    icons$1_CropOutlined as CropOutlined,
    icons$1_CropPortraitOutlined as CropPortraitOutlined,
    icons$1_CropSquareOutlined as CropSquareOutlined,
    icons$1_DeleteOutlineOutlined as DeleteOutlineOutlined,
    icons$1_DragIndicatorOutlined as DragIndicatorOutlined,
    icons$1_DriveFileRenameOutlineOutlined as DriveFileRenameOutlineOutlined,
    icons$1_DriveFolderUploadOutlined as DriveFolderUploadOutlined,
    icons$1_EditOutlined as EditOutlined,
    icons$1_ExpandMoreOutlined as ExpandMoreOutlined,
    icons$1_FileCopyOutlined as FileCopyOutlined,
    icons$1_FileDownloadOutlined as FileDownloadOutlined,
    icons$1_FileMoveOutlined as FileMoveOutlined,
    icons$1_FileUploadOutlined as FileUploadOutlined,
    icons$1_FilterListOutlined as FilterListOutlined,
    icons$1_FirstPageOutlined as FirstPageOutlined,
    icons$1_FlipHorizontalOutlined as FlipHorizontalOutlined,
    icons$1_FlipVerticalOutlined as FlipVerticalOutlined,
    icons$1_Folder as Folder,
    icons$1_FolderOutlined as FolderOutlined,
    icons$1_HighlightOffOutlined as HighlightOffOutlined,
    icons$1_InfoOutlined as InfoOutlined,
    icons$1_Inventory2Outlined as Inventory2Outlined,
    icons$1_KeyboardDoubleArrowLeftOutlined as KeyboardDoubleArrowLeftOutlined,
    icons$1_KeyboardDoubleArrowRightOutlined as KeyboardDoubleArrowRightOutlined,
    icons$1_LastPageOutlined as LastPageOutlined,
    icons$1_LockOpenOutlined as LockOpenOutlined,
    icons$1_LockOutlined as LockOutlined,
    icons$1_MoreVertOutlined as MoreVertOutlined,
    icons$1_PhotoOutlined as PhotoOutlined,
    icons$1_RemoveOutlined as RemoveOutlined,
    icons$1_RotateLeftOutlined as RotateLeftOutlined,
    icons$1_RotateRightOutlined as RotateRightOutlined,
    icons$1_SaveOutlined as SaveOutlined,
    icons$1_SearchMissingResults as SearchMissingResults,
    icons$1_SearchOutlined as SearchOutlined,
    icons$1_SettingsOutlined as SettingsOutlined,
    icons$1_SettingsOutlinedAnimated as SettingsOutlinedAnimated,
    icons$1_Sort as Sort,
    icons$1_SortAscending as SortAscending,
    icons$1_SortDescending as SortDescending,
    icons$1_Spinner as Spinner,
    icons$1_TuneOutlined as TuneOutlined,
    icons$1_UploadFileOutlined as UploadFileOutlined,
    icons$1_VisibilityOutlined as VisibilityOutlined,
    icons$1_Warning as Warning,
    icons$1_WarningAmberOutlined as WarningAmberOutlined,
  };
}

type IconRenderer = (props: {
    className?: string;
}) => JSX.Element;
type IconRenderProp = string | IconRenderer;
type IconName = keyof typeof icons$1;
type IconSize = 'small' | 'base' | 'medium' | 'big' | 'bigger' | 'humongous';
type IconColor = 'accent' | 'danger' | 'default' | 'disabled' | 'muted' | 'success' | 'warning';

declare const Icon: React$1.FC<Props$37>;
interface Props$37 {
    /**
     * Toggles optional icon animation.
     */
    animateIn?: boolean;
    /**
     * Optional class name added to the icon's root.
     */
    className?: string;
    /**
     * Icon color.
     */
    color?: IconColor;
    /**
     * Name of selected icon.
     */
    name?: IconName;
    /**
     * Renders custom icon.
     *
     * Pass either a React component or raw markup as string.
     * Passed string must be sanitized beforehand so that it's safe to use.
     */
    render?: IconRenderProp;
    /**
     * Icon size.
     */
    size?: IconSize;
}

declare const Button: React$1.ForwardRefExoticComponent<Props$36 & React$1.RefAttributes<HTMLButtonElement>>;
interface Props$36 {
    /**
     * Applies active styling.
     */
    active?: boolean;
    /**
     * Sets root class.
     */
    className?: string;
    /**
     * Sets color type. Use in combination with `type` to achieve desired styling.
     */
    color?: ButtonColor;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Displays as disabled.
     */
    disabled?: boolean;
    /**
     * Id of a form element this button is associated with.
     */
    form?: string;
    /**
     * Sets full-width mode.
     */
    fullWidth?: boolean;
    /**
     * Occupies space but is not displayed.
     */
    hidden?: boolean;
    /**
     * Button's html type.
     */
    htmlType?: 'button' | 'reset' | 'submit';
    /**
     * Button's aria label.
     */
    label?: string;
    /**
     * Icon to show next to content.
     */
    icon?: IconName;
    /**
     * Render method for icon to be shown next to content.
     */
    iconRender?: IconRenderProp;
    /**
     * Allows to pass custom content.
     */
    content?: React$1.ReactNode;
    /**
     * Toggles icon animation.
     */
    iconAnimateIn?: boolean;
    /**
     * Icon placement.
     */
    iconPlacement?: 'left' | 'right';
    /**
     * Sets `click` event handler.
     */
    onClick?: React$1.MouseEventHandler;
    /**
     * Sets `mouseleave` event handler.
     */
    onMouseLeave?: React$1.MouseEventHandler;
    /**
     * Uses smaller horizontal paddings.
     */
    narrow?: boolean;
    /**
     * Allows to make text color transparent.
     */
    textColor?: 'default' | 'transparent';
    /**
     * Sets styling type. Use in combination with `color` to achieve desired styling.
     */
    type?: ButtonType;
    /**
     * Specifies tab index for the button.
     */
    tabIndex?: number;
    /**
     * Sets sizing of the button.
     */
    sizing?: ButtonSize;
    /**
     * Disables line wrapping for label text
     */
    disabledLabelWrapping?: boolean;
}

declare const ButtonGroup: React$1.FC<Props$35>;
interface Props$35 {
    /**
     * Button components.
     */
    children: React$1.ReactNode;
}

declare const ButtonRow: React$1.FC<Props$34>;
interface Props$34 {
    /**
     * Button components.
     */
    children: React$1.ReactNode;
}

declare const CircularLoader: React$1.ForwardRefExoticComponent<Props$33 & React$1.RefAttributes<HTMLButtonElement>>;
interface Props$33 {
    /**
     * Component's label.
     */
    label?: string;
    /**
     * Current value in %.
     */
    value: number;
    /**
     * Displays error icon.
     */
    error?: boolean;
    /**
     * Displays aborted icon.
     */
    warning?: boolean;
    /**
     * Callback invoked upon click event.
     */
    onClick?: () => void;
}

declare const DialogNextTitle: React$1.ForwardRefExoticComponent<Props$32 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$32 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
    /**
     * Optional subtitle of the component.
     */
    subtitle?: React$1.ReactNode;
    /**
     * Sets ID of dialog title element.
     */
    titleId?: string;
}

declare const DialogNextColumn: React$1.ForwardRefExoticComponent<Props$31 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$31 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const DialogNextContent: React$1.ForwardRefExoticComponent<Props$30 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$30 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
    /**
     * Adds default horizontal spacing.
     */
    horizontalSpacing?: boolean;
    /**
     * Sets the dialog content ID.
     */
    id?: string;
}

declare const DialogNextFooter: React$1.ForwardRefExoticComponent<Props$2$ & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2$ {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const DialogNextCloseButton: React$1.ForwardRefExoticComponent<Props$2_ & React$1.RefAttributes<HTMLButtonElement>>;
interface Props$2_ {
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Sets button class.
     */
    className?: string;
}

declare const DialogNextHeader: React$1.ForwardRefExoticComponent<Props$2Z & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2Z {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const DialogNextSeparator: React$1.ForwardRefExoticComponent<Props$2Y & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2Y {
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const DialogNext: React$1.ForwardRefExoticComponent<Props$2X & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2X {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root dialog class.
     */
    className?: string;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens dialog. Use in combination with `onClose`.
     */
    open?: boolean;
    /**
     * Sets the dialog label.
     */
    label?: string;
    /**
     * Sets the ID of label element.
     */
    labelledBy?: string;
    /**
     * Sets the ID of description element.
     */
    describedBy?: string;
    /**
     * Sets dialog width.
     */
    width?: 'sm' | 'md';
    /**
     * Marks dialog as an alert.
     */
    alert?: boolean;
}

declare const DialogActions: React$1.FC<Props$2W>;
interface Props$2W {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const DialogColumn: React$1.ForwardRefExoticComponent<Props$2V & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2V extends React$1.HTMLAttributes<HTMLDivElement> {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Allows its content to overflow.
     */
    overflow?: boolean;
}

declare const DialogFooter: React$1.FC<Props$2U>;
interface Props$2U {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Content placed on a right-side of the footer.
     */
    sideContent?: {
        label: React$1.ReactNode;
        error?: boolean;
        warning?: boolean;
        onClick?: () => void;
    }[];
}

declare const DialogHeader: React$1.FC<Props$2T>;
interface Props$2T {
    /**
     * Sets focus on close button on mount.
     */
    autofocus?: boolean;
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Sets ID of dialog header description element.
     */
    descriptionId?: string;
    /**
     * Dialog title.
     */
    title?: string;
    /**
     * Dialog header type.
     */
    type?: 'success' | 'error' | 'info';
}

declare const DialogProgressHeader: React$1.FC<Props$2S>;
interface Props$2S {
    /**
     * Sets focus on close button on mount.
     */
    autofocus?: boolean;
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Sets ID of dialog header description element.
     */
    descriptionId?: string;
    /**
     * Indicates that progress is ongoing.
     */
    inProgress?: boolean;
    /**
     * Progress value.
     */
    progressValue?: number;
    /**
     * Secondary title.
     */
    subTitle?: React$1.ReactNode;
    /**
     * Dialog title.
     */
    title?: string;
}

declare const DialogRow: React$1.FC<Props$2R>;
interface Props$2R extends React$1.HTMLAttributes<HTMLDivElement> {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const DialogSection: React$1.FC<Props$2Q>;
interface Props$2Q {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Removes top spacing.
     */
    collapse?: boolean;
    /**
     * Makes component full height of its container.
     */
    fullHeight?: boolean;
    /**
     * Sets dialog section height.
     */
    height?: 'md';
    /**
     * Turns on accent background color.
     */
    accent?: boolean;
    /**
     * Toggles content spacing.
     */
    spacing?: boolean;
    /**
     * Accepts ref.
     */
    ref?: React$1.Ref<HTMLDivElement>;
    /**
     * Shows content as an error.
     */
    error?: boolean;
    /**
     * Shows content as a header.
     */
    header?: boolean;
    /**
     * Sets the dialog section ID.
     */
    id?: string;
}

interface DialogRootProps {
    /**
     * Main content of the component.
     */
    children: React.ReactNode;
    /**
     * Sets dialog height.
     */
    height?: 'md' | 'lg';
    /**
     * Shows dialog as a modal.
     */
    modal?: boolean;
    /**
     * Marks dialog as an alert.
     */
    alert?: boolean;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Callback invoked on `keydown` event.
     */
    onKeyDown?: React.KeyboardEventHandler<HTMLElement>;
    /**
     * Sets dialog width.
     */
    width?: 'sm' | 'md' | 'lg' | 'xl';
    /**
     * Sets the dialog label.
     */
    label?: string;
    /**
     * Sets the ID of label element.
     */
    labelledBy?: string;
    /**
     * Sets the ID of description element.
     */
    describedBy?: string;
}
interface DialogSwitchProps extends DialogRootProps {
    /**
     * Dialog's minimize / maximize action will be animated if set to `true`.
     * Dialogs in `modal` mode cannot be animated.
     */
    animated?: boolean;
    /**
     * Element associated with dialog's minimize / maximize action. Use in combination with `animated` prop.
     */
    animationAnchor?: HTMLElement | null;
    /**
     * Shows dialog as a modal.
     */
    modal?: boolean;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens dialog. Use in combination with `onClose`.
     */
    open?: boolean;
}
interface DialogProps extends DialogSwitchProps {
    /**
     * Makes dialog draggable. Dialogs in `modal` mode cannot be draggable.
     */
    draggable?: boolean;
    /**
     * Callback invoked on dragging the dialog. Use in combination with `draggable`.
     */
    onDrag?: () => void;
}

/**
 * Entry component for the dialog.
 * Initializes selected dialog mode and optionally adds common options and draggability if needed.
 */
declare const Dialog: React$1.FC<Props$2P>;
type Props$2P = DialogProps;

interface Props$2O {
    /**
     * Sets root class.
     */
    className: string;
}

declare const Zip: React$1.FC<Props$2O>;

declare const Empty: React$1.FC<Props$2O>;

declare const Excel: React$1.FC<Props$2O>;

declare const Img: React$1.FC<Props$2O>;

declare const Movie: React$1.FC<Props$2O>;

declare const Music: React$1.FC<Props$2O>;

declare const Pdf: React$1.FC<Props$2O>;

declare const Ppt: React$1.FC<Props$2O>;

declare const Txt: React$1.FC<Props$2O>;

declare const Word: React$1.FC<Props$2O>;

declare const icons_Empty: typeof Empty;
declare const icons_Excel: typeof Excel;
declare const icons_Img: typeof Img;
declare const icons_Movie: typeof Movie;
declare const icons_Music: typeof Music;
declare const icons_Pdf: typeof Pdf;
declare const icons_Ppt: typeof Ppt;
declare const icons_Txt: typeof Txt;
declare const icons_Word: typeof Word;
declare namespace icons {
  export {
    Zip as Archive,
    icons_Empty as Empty,
    icons_Excel as Excel,
    icons_Img as Img,
    icons_Movie as Movie,
    icons_Music as Music,
    icons_Pdf as Pdf,
    icons_Ppt as Ppt,
    icons_Txt as Txt,
    icons_Word as Word,
  };
}

declare const DocIcon: React$1.FC<Props$2N>;
type DocIconName = keyof typeof icons;
interface Props$2N {
    /**
     * Name of selected icon.
     */
    name: DocIconName;
    /**
     * Flag indicating whether icon should have limited size.
     */
    limitSize?: boolean;
}

declare const GalleryFigure: React$1.ForwardRefExoticComponent<Props$2M & React$1.RefAttributes<HTMLElement>>;
interface Props$2M {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Figure caption.
     */
    caption: string;
    /**
     * Use `data-visible` attribute for testing purposes.
     */
    'data-visible'?: boolean;
}

declare const GalleryItem: React$1.ForwardRefExoticComponent<Props$2L & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2L {
    /**
     * Sets item as active.
     */
    active?: boolean;
    /**
     * Sets item's ID.
     */
    id?: string;
    /**
     * Toggles loading.
     */
    loading?: boolean;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Item name.
     */
    name: string;
    /**
     * Label of the button for selecting action.
     */
    selectButtonLabel?: string;
    /**
     * Label of the button for deselecting action.
     */
    deselectButtonLabel?: string;
    /**
     * Sets `click` event handler.
     */
    onClick?: React$1.MouseEventHandler<HTMLDivElement>;
    /**
     * Sets `keydown` event handler.
     */
    onKeyDown?: React$1.KeyboardEventHandler<HTMLDivElement>;
    /**
     * Sets `mousedown` event handler.
     */
    onMouseDown?: React$1.MouseEventHandler<HTMLDivElement>;
    /**
     * Sets `dblclick` event handler.
     */
    onDoubleClick?: React$1.MouseEventHandler<HTMLDivElement>;
    /**
     * Sets `click` event handler for checkbox.
     */
    onCheckboxClick?: React$1.MouseEventHandler<HTMLButtonElement>;
}

declare const Gallery: React$1.FC<Props$2K>;
interface Props$2K {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Callback invoked whenever number of columns changes.
     */
    onColumnCountChange?: (columnsCount: number) => void;
    /**
     * Controls element focusability.
     */
    tabIndex?: number;
    /**
     * Represents zoom value. Pass value in range 0 .. 1.
     */
    zoom?: number;
}

declare const MenuItem: React$1.FC<Props$2J>;
interface Props$2J {
    /**
     * Disables auto-close on click.
     */
    disableAutoClose?: boolean;
    /**
     * Displays as disabled.
     */
    disabled?: boolean;
    /**
     * Associated icon.
     */
    icon?: IconName;
    /**
     * Icon size.
     */
    iconSize?: IconSize;
    /**
     * Action label.
     */
    label: string;
    /**
     * Action invoked upon click.
     */
    onClick?: () => void;
}

declare const MenuSubSection: React$1.FC<Props$2I>;
interface Props$2I {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Indicates how content and title should be aligned.
     */
    align?: 'column' | 'row';
    /**
     * Indicates how children should be aligned.
     */
    alignChildren?: 'column' | 'row';
    /**
     * Display title as label.
     */
    label?: boolean;
    /**
     * Sets `for` attribute if title is displayed as label.
     */
    labelFor?: string;
    /**
     * Title of the subsection.
     */
    title: string;
}

declare const MenuSection: React$1.FC<Props$2H>;
interface Props$2H {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Adds bottom border.
     */
    borderBottom?: boolean;
    /**
     * Title of the section.
     */
    title: string;
}

interface PopperContext {
    /**
     * Forces synchronous popper position update.
     */
    forceUpdate?: () => void;
}
/**
 * Defines React context for `Popper` component.
 */
declare const PopperContext: React$1.Context<PopperContext>;
declare const usePopperCtx: () => PopperContext;

type PopperPlacement = Placement;
type PopperAnchorRef = HTMLElement | null | undefined;
type PopperOffsetValue = 'none' | 'xs' | 'sm' | 'md' | 'lg' | 'xl';
type PopperOffset = [PopperOffsetValue, PopperOffsetValue];

declare const PopperArrow: React__default.FC<Props$2G>;
interface Props$2G {
    /**
     * Sets arrow size.
     */
    size?: 'sm' | 'md';
}

declare const Popper: React__default.ForwardRefExoticComponent<Props$2F & React__default.RefAttributes<HTMLElement>>;
interface Props$2F {
    /**
     * Anchor element. Popper will be mounted to this element.
     */
    anchorEl?: HTMLElement | null;
    /**
     * Popper content.
     */
    children: React__default.ReactNode;
    /**
     * Class name that will be applied to popper content-wrapper.
     */
    className?: string;
    /**
     * Disables popper auto-flip.
     */
    disableFlip?: boolean;
    /**
     * Popper placement.
     */
    placement?: PopperPlacement;
    /**
     * Displacement from its reference element.
     */
    offset?: PopperOffset;
    /**
     * Aria role.
     */
    role?: React__default.AriaRole;
    /**
     * Makes popper same width as its anchor.
     */
    sameWidth?: boolean;
    /**
     * Callback invoked on keydown event inside the popper.
     */
    onKeyDown?: React__default.KeyboardEventHandler;
}

declare const Menu: React$1.ForwardRefExoticComponent<Props$2E & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2E {
    /**
     * Anchor element.
     */
    anchorEl?: HTMLElement | null;
    /**
     * Shows an arrow pointing to the anchor element.
     */
    arrow?: boolean;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Offsets popper element.
     */
    offset?: PopperOffset;
    /**
     * Callback invoked when component is about to close.
     */
    onClose?: () => void;
    /**
     * Menu popper's placement.
     */
    placement?: PopperPlacement;
    /**
     * Makes menu same width as its anchor.
     */
    sameWidth?: boolean;
}

declare const ModalDialogActionContent: React$1.ForwardRefExoticComponent<Props$2D & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2D {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ModalDialogActionItem: React$1.ForwardRefExoticComponent<Props$2C & React$1.RefAttributes<HTMLLIElement>>;
interface Props$2C {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Callback invoked upon action click.
     */
    onClick?: () => void;
    /**
     * Marks action as disabled.
     */
    disabled?: boolean;
    /**
     * Marks action as in progress.
     */
    isLoading?: boolean;
}

declare const ModalDialogCallout: React$1.ForwardRefExoticComponent<Props$2B & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2B {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets the dialog content ID.
     */
    id?: string;
    /**
     * Indicates callout type.
     */
    type: 'error' | 'warning';
}

declare const ModalDialogContent: React$1.ForwardRefExoticComponent<Props$2A & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2A {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets the dialog content ID.
     */
    id?: string;
}

declare const ModalDialogContentColumn: React$1.ForwardRefExoticComponent<Props$2z & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2z {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets the dialog content ID.
     */
    id?: string;
}

declare const ModalDialogList: React$1.ForwardRefExoticComponent<Props$2y & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2y {
    /**
     * Sets the dialog content ID.
     */
    id?: string;
    /**
     * Adds list title.
     */
    title?: string;
    /**
     * List items
     */
    children: React$1.ReactNode;
}

declare const ModalDialogListItem: React$1.ForwardRefExoticComponent<Props$2x & React$1.RefAttributes<HTMLLIElement>>;
interface Props$2x {
    /**
     * Item to display in the list.
     */
    children: React$1.ReactNode;
}

declare const ModalDialogFooter: React$1.ForwardRefExoticComponent<Props$2w & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2w {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Spaces out children components with space between them.
     */
    spaceBetween?: boolean;
}

declare const ModalDialogFooterAction: React$1.ForwardRefExoticComponent<Props$2v & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2v {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ModalDialogHeader: React$1.ForwardRefExoticComponent<Props$2u & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2u {
    /**
     * Enables the top border accent.
     */
    accent?: boolean;
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Name of selected icon.
     */
    icon?: 'info' | 'success' | 'error' | 'warning' | React$1.ReactElement<Props$37>;
    /**
     * Optional sub title of the modal.
     */
    subTitle?: React$1.ReactNode;
    /**
     * Title of the modal.
     */
    title: React$1.ReactNode;
    /**
     * Sets ID of dialog header title element.
     */
    titleId?: string;
}

declare const ModalDialog: React$1.ForwardRefExoticComponent<Props$2t & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2t {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root dialog class.
     */
    className?: string;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens dialog. Use in combination with `onClose`.
     */
    open?: boolean;
    /**
     * Sets the dialog label.
     */
    label?: string;
    /**
     * Sets the ID of label element.
     */
    labelledBy?: string;
    /**
     * Sets the ID of description element.
     */
    describedBy?: string;
    /**
     * Indicates modal type.
     */
    type?: 'info' | 'success' | 'error' | 'warning';
    /**
     * Sets dialog width.
     */
    width?: 'sm' | 'md';
    /**
     * Marks dialog as an alert.
     */
    alert?: boolean;
}

/**
 * Width of the collapsed navbar.
 */
declare const NAVBAR_COLLAPSED_WIDTH = 58;
/**
 * Minimum width of navbar in non-collapsed mode.
 */
declare const NAVBAR_MIN_WIDTH = 200;
/**
 * Maximum width of navbar in non-collapsed mode.
 */
declare const NAVBAR_MAX_WIDTH = 400;
/**
 * Defines how far user must scroll left or right to trigger navbar mode change.
 */
declare const COLLAPSE_THRESHOLD = 40;
/**
 * Delay for the purposes of toggling navbar preview.
 */
declare const NAVBAR_PREVIEW_TIMEOUT = 250;
/**
 * Delay before showing loading spinner animation.
 */
declare const NAVBAR_LOADING_DELAY = 250;

declare const navbarContextInitProps: NavbarContext;
interface NavbarContext {
    /**
     * Whether item should receive focus once it becomes active.
     */
    focusActiveItem?: boolean;
    /**
     * Indicates if navbar is in collapsed mode.
     */
    navbarCollapsed?: boolean;
    /**
     * Indicates if collapsed navbar is in preview mode.
     */
    navbarPreviewed?: boolean;
    /**
     * Callback invoked when item gets focus when it becomes active.
     */
    onActiveItemFocus?: () => void;
    /**
     * Callback invoked whenever navbar collapse mode is changed.
     */
    onNavbarCollapseChange: (collapsed: boolean) => void;
    /**
     * Callback invoked whenever navbar preview mode is changed.
     */
    onNavbarPreviewChange: (previewed: boolean) => void;
}
declare const NavbarContext: React$1.Context<NavbarContext>;
declare const useNavbarCtx: () => NavbarContext;

declare const NavbarItem: React$1.FC<Props$2s>;
interface Props$2s {
    /**
     * Applies active styling.
     */
    active?: boolean;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Indicates if item is collapsible.
     */
    collapsible?: boolean;
    /**
     * Indicates if item is collapsed.
     */
    collapsed?: boolean;
    /**
     * Label used by toggle button in expanded state.
     */
    collapseLabel?: string;
    /**
     * Applies compact spacing.
     */
    compact?: boolean;
    /**
     * Marks item as disabled.
     */
    disabled?: boolean;
    /**
     * Marks item as unselectable.
     */
    unselectable?: boolean;
    /**
     * Label used by toggle button in collapsed state.
     */
    expandLabel?: string;
    /**
     * Marks item as loading.
     */
    loading?: boolean;
    /**
     * Marks item as currently loading own details.
     */
    isLoadingDetails?: boolean;
    /**
     * Click handler.
     */
    onClick?: () => void;
    /**
     * Handler invoked on collapsing an item.
     */
    onCollapse?: () => void;
    /**
     * Handler invoked on expanding an item.
     */
    onExpand?: () => void;
    /**
     * Handler invoked on toggling an item.
     */
    onToggle?: () => void;
    /**
     * Handler invoked on deleting an item.
     */
    onDelete?: () => void;
}

declare const NavbarItemContainer: React$1.FC<Props$2r>;
interface Props$2r {
    /**
     * Marks container as active.
     */
    active?: boolean;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const NavbarItemContent: React$1.FC<Props$2q>;
interface Props$2q {
    /**
     * Adds enter / exit animation.
     */
    animate?: boolean;
    /**
     * Aligns navbar item content.
     */
    align?: 'start' | 'end';
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Hides component visually.
     */
    hidden?: boolean;
}

declare const NavbarItemLabel: React$1.FC<Props$2p>;
interface Props$2p {
    /**
     * Toggles icon animation if parent item is hovered.
     */
    animateIconOnItemHover?: boolean;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Displayed icon.
     */
    icon?: React$1.ReactElement<Props$37>;
}

declare const NavbarItemsGroup: React$1.FC<Props$2o>;
interface Props$2o {
    /**
     * Animates group on collapse.
     */
    animated?: boolean;
    /**
     * Toggles animation.
     */
    animateIn?: boolean;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Nesting level. Starts at 1.
     */
    level?: number;
}

declare const NavbarLink: React$1.FC<Props$2n>;
interface Props$2n {
    /**
     * Renders link content.
     */
    children: React$1.ReactNode | (({ collapsed }: {
        collapsed?: boolean;
    }) => React$1.ReactNode);
    /**
     * The URL that the link points to.
     */
    href?: string;
}

declare const NavbarScrollableContent: React$1.FC<Props$2m>;
interface Props$2m {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const NavbarSeparator: React$1.FC;

declare const NavbarToggleButton: React$1.FC<Props$2l>;
interface Props$2l {
    /**
     * Label shown when navbar will collapse.
     */
    closeLabel?: string;
    /**
     * Label shown when navbar will lock expanded state.
     */
    lockLabel?: string;
    /**
     * Label shown when navbar will expand or will be in preview mode.
     */
    openLabel?: string;
}

declare const Navbar: React$1.FC<Props$2k>;
interface Props$2k {
    /**
     * Labels navigation element.
     */
    ariaLabel?: string;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Whether item should receive focus once it becomes active.
     */
    focusActiveItem?: boolean;
    /**
     * Callback invoked when item gets focus when it becomes active.
     */
    onActiveItemFocus?: () => void;
}

declare const Modal: React$1.FC<Props$2j>;
interface Props$2j {
    /**
     * Optional children.
     */
    children?: React$1.ReactNode;
    /**
     * Optional class to append.
     */
    className?: string;
    /**
     * Callback invoked upon clicking on the overlay.
     */
    onClick?: React$1.MouseEventHandler;
    /**
     * Increases stacking of the modal. Useful to force one of few open modals to be always on top.
     */
    onTop?: boolean;
    /**
     * Color variant.
     */
    variant?: 'transparent' | 'semi-transparent';
}

declare const PanelActions: React$1.FC<Props$2i>;
interface Props$2i {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const PanelColumn: React$1.FC<Props$2h>;
interface Props$2h {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const PanelContent: React$1.ForwardRefExoticComponent<Props$2g & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2g {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Optional panel content's class name in non-edit mode.
     */
    className?: string;
    /**
     * Component shown in edit mode. By default, regular input field is shown in edit mode.
     */
    editComponent?: React$1.ReactNode;
    /**
     * Optional header in non-edit mode.
     */
    header?: string;
}

declare const PanelContentProp: React$1.FC<Props$2f>;
interface Props$2f {
    /**
     * Property label.
     */
    label: string;
    /**
     * Property value.
     */
    value: string;
}

declare const PanelDragHandle: React$1.ForwardRefExoticComponent<React$1.RefAttributes<HTMLDivElement>>;

declare const PanelList: React$1.FC<Props$2e>;
interface Props$2e {
    /**
     * Main content.
     */
    children: React$1.ReactNode;
    /**
     * Optional toolbar rendered on top of the list.
     */
    toolbar?: React$1.ReactNode;
    /**
     * Toggles loading effect for the toolbar.
     */
    toolbarLoading?: boolean;
}

declare const PanelListDivider: React$1.FC<Props$2d>;
interface Props$2d {
    /**
     * Toggles component opacity.
     */
    opaque?: boolean;
}

declare const PanelSide: React$1.FC<Props$2c>;
interface Props$2c {
    /**
     * Custom content rendered instead of icon.
     */
    children?: React$1.ReactNode;
    /**
     * Icon to display.
     */
    icon?: IconName;
    /**
     * Renders custom icon.
     *
     * Pass either a React component or raw markup as string.
     * Passed string must be sanitized beforehand so that it's safe to use.
     */
    iconRender?: IconRenderProp;
    /**
     * Whether to use vertical spacing.
     */
    verticalSpacing?: boolean;
}

declare const PanelSkeleton: React$1.FC<Props$2b>;
interface Props$2b {
    /**
     * Number of loading blocks.
     */
    blocks?: number;
    /**
     * Relative size of a loading block.
     */
    size?: 'sm' | 'md' | 'lg';
    /**
     * Sets bottom spacing.
     */
    spacing?: boolean;
}

declare const PanelTitle: React$1.ForwardRefExoticComponent<Props$2a & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2a extends Omit<Props$2g, 'children'> {
    /**
     * Panel's title.
     */
    title: string;
    /**
     * Panel's description.
     */
    description?: React$1.ReactNode;
}

interface ListDndItem {
    /**
     * Unique id of a dnd item.
     */
    id: string;
    /**
     * Indicates if an item can be dragged.
     */
    isDraggable?: boolean;
}
interface ListDndItemHookProps extends ListDndItem {
    /**
     * Drag handle element.
     */
    dragHandle?: HTMLElement | null;
    /**
     * Current index of a drag item.
     */
    index: number;
    /**
     * Item root element.
     */
    itemRoot?: HTMLElement | null;
}
type ListDndMoveItem = (dragIndex: number, hoverIndex: number) => void;
type ListDndSetDraggable = (id: string) => ListDndSetDraggablePartial;
type ListDndSetDraggablePartial = (isDraggable: boolean) => void;
type ListDndOnDragEnd = () => void;
/**
 * List of props that a child of `SortableListItem` receives.
 * This type is intended to be used by components that want to be aware that they are dragged.
 */
interface ListDndChildProps {
    /**
     * Indicates if an item is in preview mode.
     */
    isPreview?: boolean;
    /**
     * Indicates if an item is being dragged.
     */
    isDragging?: boolean;
    /**
     * Indicates if an item is draggable.
     */
    isDraggable?: boolean;
    /**
     * Drag handle setter. Use it to separate drag handle from a preview.
     */
    setDragHandle?: (el: HTMLElement | null) => void;
    /**
     * Sets root item.
     *
     * In some scenarios, drag handle might be located inside an item.
     * In such cases, item root.
     */
    setItemRoot?: (el: HTMLElement | null) => void;
    /**
     * Marks item as draggable / non-draggable.
     */
    setDraggable?: ListDndSetDraggablePartial;
}

/**
 * Top-level hook that manages list state.
 *
 * @param initItems initial list items
 * @returns list info
 */
declare const useListDnd: (initItems: ListDndItem[]) => {
    items: ListDndItem[];
    moveItem: ListDndMoveItem;
    setItems: React$1.Dispatch<React$1.SetStateAction<ListDndItem[]>>;
    setDraggable: ListDndSetDraggable;
};

declare const SortableDndListItem: React$1.FC<Props$29>;
interface Props$29 {
    /**
     * Current item's index in a list.
     */
    index: number;
    /**
     * Item's id.
     */
    id: string;
    /**
     * Indicates if item is draggable.
     */
    isDraggable?: boolean;
    /**
     * Indicates if item is currently in preview mode.
     */
    isPreview?: boolean;
    /**
     * Accepts a single child.
     */
    children: React$1.ReactElement | null;
}

interface SortableDndListContextShape {
    /**
     * Callback that performs list reordering.
     */
    moveItem: ListDndMoveItem;
    /**
     * Marks item as draggable / non-draggable.
     */
    setDraggable: ListDndSetDraggable;
    /**
     * Item type. Same value must be provided for all list items.
     */
    type: string;
    /**
     * Optional callback invoked when drag is over.
     */
    onDragEnd?: ListDndOnDragEnd;
}

declare const SortableDndList: React$1.FC<Props$28>;
interface Props$28 extends SortableDndListContextShape {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Container element to scroll while dragging.
     */
    scrollableContainer?: HTMLElement | null;
}

interface PanelContextShape extends Partial<ListDndChildProps> {
    /**
     * Toggles `edit` mode.
     */
    edit?: boolean;
}

declare const Panel: React$1.ForwardRefExoticComponent<Props$27 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$27 extends PanelContextShape {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Uses compact spacing between main content and side content.
     */
    compactGap?: boolean;
    /**
     * Toggles component opacity.
     */
    opaque?: boolean;
    /**
     * Toggles component's `elevated` mode.
     */
    elevated?: boolean;
}

declare const Pagination: React$1.FC<Props$26>;
interface Props$26 {
    /**
     * Disables interaction with pagination.
     */
    disabled?: boolean;
    /**
     * Aria label for input element.
     */
    enterPageLabel: string;
    /**
     * Total number of pages.
     */
    totalPages: number;
    /**
     * Label indicating total number of pages.
     */
    totalPagesLabel: string;
    /**
     * Callback invoked when page is changed.
     */
    onPageChange: (page: number) => void;
    /**
     * Currently selected page.
     */
    page: number;
    /**
     * Label for the first page button.
     */
    firstPageLabel?: string;
    /**
     * Label for the last page button.
     */
    lastPageLabel?: string;
    /**
     * Label for the next page button.
     */
    nextPageLabel?: string;
    /**
     * Label for the previous page button.
     */
    prevPageLabel?: string;
}

declare const ProgressPanel: React$1.ForwardRefExoticComponent<Props$25 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$25 {
    /**
     * Additional info rendered close to a title.
     */
    additionalInfo?: React$1.ReactNode;
    /**
     * Applies error styling.
     */
    error?: boolean;
    /**
     * Applies warning styling.
     */
    warning?: boolean;
    /**
     * Applies full progress styling.
     */
    completed?: boolean;
    /**
     * Help text displayed below the bar.
     */
    helpText?: React$1.ReactNode;
    /**
     * Unique identifier of a panel.
     */
    id: string;
    /**
     * Panel title.
     */
    title: string;
    /**
     * Current progress value in %.
     */
    value: number;
    /**
     * Callback invoked with the navigation button.
     */
    onNavigate?: () => void;
    /**
     * Label of the navigation button.
     */
    navigationLabel?: string;
}

declare const PropertiesTableRow: React$1.FC<Props$24>;
interface Props$24 {
    /**
     * Item's label.
     */
    label: string;
    /**
     * Item's value.
     */
    value: React$1.ReactNode;
}

declare const PropertiesTable: React$1.FC<Props$23>;
interface Props$23 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const ResponsiveImageFit: React$1.FC<Props$22>;
interface Props$22 {
    /**
     * Image alt text.
     */
    alt: string;
    /**
     * Turns on cover mode.
     */
    allowCover?: boolean;
    /**
     * Set of default image sources.
     */
    defaultSrcSet?: string;
    /**
     * Visually hides image.
     */
    hidden?: boolean;
    /**
     * Callback invoked when resource failed to load.
     */
    onError?: () => void;
    /**
     * Callback invoked when resource has been loaded.
     */
    onLoad?: () => void;
    /**
     * Mime type of the optional source.
     */
    optionalSrcMimeType?: string;
    /**
     * Set of optional image sources.
     */
    optionalSrcSet?: string;
    /**
     * Current `sizes` value based on container size.
     */
    sizes?: number;
}

declare const ResponsiveImageFallback: React$1.FC<Props$21>;
interface Props$21 {
    /**
     * Indicates if cover is allowed for the image.
     */
    allowCover?: boolean;
    /**
     * Original image's blurhash. Blurhash will be decoded under the hood into base64.
     */
    blurHash?: string;
    /**
     * Container element.
     */
    containerEl?: HTMLElement | null;
    /**
     * Original image's height.
     */
    originalHeight?: number;
    /**
     * Original image's width.
     */
    originalWidth?: number;
    /**
     * Flag indicating if fallback should be displayed.
     */
    showFallback?: boolean;
}

declare const ResponsiveImageScalable: React$1.FC<Props$20>;
interface Props$20 {
    /**
     * Image alt text.
     */
    alt: string;
    /**
     * Element that contains responsive image.
     */
    containerEl?: HTMLElement | null;
    /**
     * Set of default image sources.
     */
    defaultSrcSet?: string;
    /**
     * Visually hides image.
     */
    hidden?: boolean;
    /**
     * Callback invoked when resource failed to load.
     */
    onError?: () => void;
    /**
     * Callback invoked when resource has been loaded.
     */
    onLoad?: () => void;
    /**
     * Mime type of the optional source.
     */
    optionalSrcMimeType?: string;
    /**
     * Set of optional image sources.
     */
    optionalSrcSet?: string;
    /**
     * Original width of the image.
     */
    originalWidth?: number;
    /**
     * Original height of the image.
     */
    originalHeight?: number;
    /**
     * Current `sizes` value based on container size.
     */
    sizes?: number;
}

declare const ResponsiveImageSkeleton: React$1.FC;

declare const ResponsiveImage: React$1.FC<Props$1$>;
interface Props$1$ {
    /**
     * List of available breakpoints.
     */
    breakpoints?: number[];
    /**
     * Responsive image.
     */
    children: React$1.ReactNode;
    /**
     * Element that contains responsive image.
     */
    containerEl?: HTMLElement | null;
    /**
     * Maps breakpoint value to a flag indicating if it is possible to display thumbnail as a cover for that breakpoint.
     */
    cover?: Record<number, boolean>;
    /**
     * Optional loader to show when image loading is in progress.
     */
    loader?: React$1.ReactNode;
}

declare const Skeleton: React$1.FC<Props$1_>;
interface Props$1_ {
    /**
     * Optional class name. It overrides class responsible for background color.
     */
    className?: string;
    /**
     * Specifies component height.
     */
    height?: string;
    /**
     * Specifies component width.
     */
    width?: string;
}

declare const SortButton: React$1.FC<Props$1Z>;
interface Props$1Z {
    /**
     * Button's aria label.
     */
    label?: string;
    /**
     * Tooltip displayed on hover.
     */
    tooltip: string;
    /**
     * Order indicated on button's icon.
     */
    order: 'asc' | 'desc';
    /**
     * Sets `click` event handler.
     */
    onClick?: () => void;
}

declare const SwitchView: React$1.FC<Props$1Y>;
interface Props$1Y {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * View ID.
     */
    id?: string | string[];
}

declare const Switch: React$1.FC<Props$1X>;
interface Props$1X {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * View ID to match.
     */
    match?: string;
}

declare const SwitchInput: React$1.FC<Props$1W>;
interface Props$1W {
    /**
     * Sets current input's value.
     */
    checked: boolean;
    /**
     * Underlying input's id.
     */
    id: string;
    /**
     * Underlying input's name.
     */
    name: string;
    /**
     * Callback invoked upon value's change.
     */
    onChange: (checked: boolean) => void;
}

declare const TagList: React$1.FC<Props$1V>;
interface Props$1V {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Optional root class name.
     */
    className?: string;
}

declare const TagLabel: React$1.FC<Props$1U>;
interface Props$1U {
    /**
     * Emphasizes tag content.
     */
    bold?: boolean;
    /**
     * Sets component's children.
     */
    children: React$1.ReactNode;
}

declare const Tag: React$1.ForwardRefExoticComponent<Props$1T & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1T {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
    /**
     * Disables focusability of any focusable element.
     */
    disableFocusability?: boolean;
    /**
     * Callback invoked upon clicking on remove icon.
     */
    onRemove?: React$1.MouseEventHandler;
    /**
     * Sets tag radius.
     */
    radius?: 'md' | 'lg' | 'xl';
    /**
     * Sets tag size.
     */
    size?: 'sm' | 'md';
    /**
     * Sets tag as removable.
     */
    removable?: boolean;
    /**
     * Label associated with remove button.
     */
    removeLabel?: string;
}

declare const TagInput: React$1.FC<Props$1S>;
interface Props$1S {
    /**
     * Input's class name.
     */
    className?: string;
    /**
     * Label displayed in the popup when hovering over copy button.
     */
    copyBtnLabel?: string;
    /**
     * Label displayed in the popup upon clicking on the copy button.
     */
    copyBtnLabelCopied?: string;
    /**
     * Input field id.
     */
    id: string;
    /**
     * Callback invoked when component gains focus.
     */
    onFocus?: () => void;
    /**
     * Callback invoked when component loses focus.
     */
    onBlur?: () => void;
    /**
     * Callback invoked when tags change.
     */
    onChange: (tags: string[]) => void;
    /**
     * Input placeholder.
     */
    placeholder?: string;
    /**
     * Indicate error in input element.
     */
    error?: boolean;
    /**
     * List of tags to render.
     */
    tags: {
        label: string;
        bold?: boolean;
        removeLabel?: string;
        title?: string;
    }[];
}

declare const Tab: React$1.FC<Props$1R>;
interface Props$1R {
    /**
     * Main content.
     */
    children: React$1.ReactNode;
    /**
     * Tab's unique ID.
     */
    id: string;
    /**
     * Tab's label.
     */
    label: string;
    /**
     * Associated panel's ID.
     */
    panelId: string;
}

declare const TabPanel: React$1.FC<Props$1Q>;
interface Props$1Q {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * ID of associated tab.
     */
    labelledBy: string;
    /**
     * Panel's unique ID.
     */
    id: string;
}

declare const Tabs: React$1.FC<Props$1P>;
interface Props$1P {
    /**
     * Currently selected tab.
     */
    active?: string;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Callback invoked upon selecting a tab.
     */
    onSelect?: (id: string) => void;
}

declare const Tooltip: React$1.FC<Props$1O>;
interface Props$1O {
    /**
     * Main content of the component.
     * It must be a single child that accepts `ref`.
     */
    children: React$1.ReactNode;
    /**
     * If true, the tooltip will display after 1.5s delay.
     */
    delayed?: boolean;
    /**
     * Tooltip placement.
     */
    placement?: PopperPlacement;
    /**
     * Tooltip helper component or text.
     */
    title: React$1.ReactNode;
    /**
     * Allows to wrap text.
     */
    wrap?: boolean;
}

declare const TopbarAction: React$1.FC<Props$1N>;
interface Props$1N {
    /**
     * Applies active styling.
     */
    active?: boolean;
    /**
     * Associated icon.
     */
    icon: IconName;
    /**
     * Icon size.
     */
    iconSize?: IconSize;
    /**
     * Action label.
     */
    label: string;
    /**
     * Indicates if loading is in progress.
     */
    loading?: boolean;
    /**
     * Displays as disabled.
     */
    disabled?: boolean;
    /**
     * Action invoked upon click.
     */
    onClick?: () => void;
}

declare const Topbar: React$1.FC<Props$1M>;
interface Props$1M {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Adds label to "More" button in closed state.
     */
    moreBtnLabel?: string;
    /**
     * Content rendered on the right side of the bar.
     */
    sideContent?: React$1.ReactNode;
}

declare const CONTAINER_QUERY_BREAKPOINTS: {
    xs: number;
    sm: number;
    md: number;
    lg: number;
    xl: number;
};

declare const uiContextInitProps: {
    rootEl: null;
    animationDuration: {
        primary: number;
        secondary: number;
    };
    navbarCollapsed: boolean;
    onNavbarCollapseChange: () => void;
    onNavbarPreviewChange: () => void;
    onNavbarWidthChange: () => void;
};
interface UIContext {
    /**
     * Represents UI's root element.
     */
    rootEl: HTMLDivElement | null;
    /**
     * Holds info about animation duration (in ms).
     *
     * Note that these values are extracted from CSS variables.
     * Therefore, CSS variables act here as the single source of truth.
     */
    animationDuration: {
        primary: number;
        secondary: number;
    };
    /**
     * Whether app is in dialog mode.
     */
    dialogMode?: boolean;
    /**
     * Indicates if navbar should be collapsed.
     */
    navbarCollapsed?: boolean;
    /**
     * Indicates if collapsed navbar is in preview mode.
     */
    navbarPreviewed?: boolean;
    /**
     * Initial navbar width.
     */
    navbarWidth?: number;
    /**
     * Callback invoked whenever navbar collapse mode is changed.
     */
    onNavbarCollapseChange: (collapsed: boolean) => void;
    /**
     * Callback invoked whenever navbar preview mode is changed.
     */
    onNavbarPreviewChange: (previewed: boolean) => void;
    /**
     * Callback invoked whenever navbar width changes.
     */
    onNavbarWidthChange: (width: number) => void;
}
/**
 * Defines React context for i18n and sets defaults.
 */
declare const UIContext: React$1.Context<UIContext>;
declare const useUIContext: () => UIContext;

/**
 * Checks if both lists of items contain same items (order irrelevant).
 *
 * @param items1 list of items
 * @param items2 list of items
 * @returns flag indicating if lists of items are identical
 */
declare const areItemsIdentical: (items1: string[], items2: string[]) => boolean;

/**
 * Generates base64-encoded image from its `blurhash` representation.
 *
 * @param hash blurhash representation of an image
 * @returns base64-encoded image
 */
declare const base64FromBlurHash: (hash?: string) => string;

/**
 * Given preferred value and optional edge values,
 * chooses the one that is most suitable:
 *
 * - min value if preferred value is below min
 * - max value if preferred value is above max
 * - preferred value otherwise
 *
 * @param val preferred value
 * @param min optional minimum value
 * @param max optional maximum value
 * @returns chosen value
 */
declare const clamp: (val: number, min?: number, max?: number) => number;

/**
 * Writes text to clipboard in async manner.
 *
 * @param text text to write to clipboard
 * @returns promise
 */
declare const writeTextToClipboard: (text: string) => Promise<void>;
/**
 * Writes custom data to clipboard in async manner.
 *
 * @param data data to write to clipboard
 * @returns promise
 */
declare const writeToClipboard: (data: ClipboardItem) => Promise<void>;
/**
 * Reads data from clipboard.
 *
 * @returns promise with data
 */
declare const readFromClipboard: () => Promise<ClipboardItems>;
/**
 * Tries writing text to clipboard in async manner.
 *
 * @param text text to write to clipboard
 * @returns promise whether write to clipboard was successful
 */
declare const tryWriteTextToClipboard: (text: string) => Promise<boolean>;
/**
 * Tries reading from clipboard in async manner.
 *
 * @returns promise with data
 */
declare const tryReadFromClipboard: () => Promise<ClipboardItems | void>;
/**
 * Tries writing custom data to clipboard in async manner.
 *
 * @param data data to write to clipboard
 * @returns promise whether write to clipboard was successful
 */
declare const tryWriteToClipboard: (data: ClipboardItem) => Promise<boolean>;
/**
 * Checks if `ClipboardItem` API is available.
 * Safari and Chrome support it by default while support in Firefox it must be enabled in advanced settings.
 *
 * @returns promise whether `ClipboardItem` API is available
 */
declare const isClipboardItemSupported: () => boolean;

/**
 * Filters off falsey values and concatenates list of classes.
 *
 * @param classes list of classes / falsey values
 * @returns classes
 */
declare const clsx: (...classes: (string | undefined | null | number | boolean)[]) => string;

/**
 * Values representing mouse button.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
 */
declare enum MouseEventButton {
    Main = 0,
    Auxiliary = 1,
    Secondary = 2,
    Fourth = 3,
    Fifth = 4
}

/**
 * Given time distance in s, formats it by rounding to nearest time unit in accordance with predefined buckets.
 *
 * @param t time left (in s)
 */
declare const formatTimeDistance: (t: number) => {
    h: number;
    m: number;
    s: number;
};

/**
 * Retrieves amount of pixels in a blob if it's an image.
 * If given blob is an invalid image, returns undefined.
 *
 * @param data blob data to measure
 * @returns amount of pixels
 */
declare const getPixelCountFromImageBlob: (data: Blob) => Promise<number | undefined>;

/**
 * Calculates standard deviation based on provided list of numbers.
 *
 * @param array list of numbers
 * @returns standard deviation
 */
declare const getStandardDeviation: (array: number[]) => number | undefined;

declare const getValidChildren: <ChildProps>(children: React$1.ReactNode) => React$1.ReactElement<ChildProps, string | React$1.JSXElementConstructor<any>>[];

/**
 * Shorthand for recommended use of hasOwnProperty (see https://eslint.org/docs/rules/no-prototype-builtins).
 *
 * @param object checked object
 * @param propertyKey property key to check
 */
declare const hasOwnProperty: (object: Record<string, unknown>, propertyKey: string) => boolean;

type KeyModifier = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey';
type KeyAction = (evt: KeyEventLike) => void;
interface KeyCombination {
    value: string;
    mod?: KeyModifier;
}
/**
 * `KeyboardEvent`-like interface that will allow to use generated handlers as React's synthetic event handlers.
 * Only a subset of event properties are used.
 */
type KeyEventLike = Pick<KeyboardEvent, 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey' | 'code' | 'key' | 'preventDefault' | 'stopPropagation'>;
interface KeyProps {
    /**
     * Defines which code will invoke the `onKeyDown` callback.
     * `code.value` corresponds to `evt.code`.
     *
     * Provide either `code` or `key`.
     */
    code?: KeyCombination;
    /**
     * Defines which key will invoke the `onKeyDown` callback.
     * `key.value` corresponds to `evt.key`.
     *
     * Provide either `code` or `key`.
     */
    key?: KeyCombination;
    /**
     * Callback to invoke when proper key code is detected.
     */
    action?: KeyAction;
    /**
     * Determines if action should propagate event further.
     */
    propagate?: boolean;
}

/**
 * Checks if event matches a single key combination.
 *
 * @param evt keyboard event
 * @param currentValue event key or code value
 * @param combination key combination
 * @returns flag indicating if combination is matched
 */
declare const matchesCombination: (evt: KeyEventLike, currentValue: string, { value, mod }: KeyCombination) => boolean;
/**
 * Creates `keydown` event listener for configured key combination(s).
 *
 * @param props key props
 * @returns event listener
 */
declare const getKeyHandler: (props: KeyProps[] | KeyProps) => (evt: KeyEventLike) => void;

declare const noOp: () => void;

interface RInterval {
    clear: () => void;
}

/**
 * Allows to use `requestAnimationFrame` in a manner similar to `setInterval`.
 * It should be used for animations instead of `setTimeout` and `setInterval`.
 *
 * @param callback callback invoked within a fram
 * @param delay optional callback invocation delay
 * @returns interval utils
 */
declare const rInterval: (callback: () => void, delay?: number) => RInterval;

interface BatchUpdatePayload {
    /**
     * Id of an update group. Each update group is registered under the provided `id` as key.
     */
    id: string;
}
interface BatchUpdateBatch<Payload> {
    /**
     * Holds latest update for each update group.
     */
    data: Record<string, Payload>;
    /**
     * Total number of updates that happened during specified interval.
     */
    count: number;
}

/**
 * Batches updates and releases them in specified intervals.
 * Accumulates total number of updates that happened within a batch.
 *
 * This hook is useful for grouping high frequency updates into a single batch,
 * so that downstream updates do not happen too often.
 *
 * @param updateCb callback that receives current batch in specified intervals
 * @param batchUpdateInterval instructs how often batch is released
 * @returns actions and batch
 */
declare const useBatchUpdate: <Payload extends BatchUpdatePayload>(updateCb: (batch: BatchUpdateBatch<Payload>) => void, batchUpdateInterval: number) => {
    batch: React$1.MutableRefObject<BatchUpdateBatch<Payload>>;
    pushUpdate: (payload: Payload) => void;
};

/**
 * Hook that allows to detect click events within app root but outside specified element.
 *
 * @param container outer container
 * @param el element outside which clicks should be detected
 * @param ignoredEl optional element to ignore
 * @param onClick callback invoked if click outside registered elements was detected
 * @returns action for registering elements
 */
declare const useClickAway: (container?: HTMLElement | null, el?: HTMLElement | null, ignoredEl?: HTMLElement | null, onClick?: () => void) => void;

/**
 * Hook that allows to detect keydown events within specified container.
 *
 * @param container outer container
 * @param onKeyDown callback invoked on container keydown
 */
declare const useContainerKeyDown: (container?: HTMLElement | null, onKeyDown?: ((evt: KeyEventLike) => void) | undefined) => void;

type CropperLockedDimension = 'height' | 'width';
type CropperDimensions = [number, number];
interface CropperResult {
    /**
     * Cropper instance.
     */
    cropper: Cropper | null;
    /**
     * Whether instance of Cropper is ready for interaction.
     */
    cropperReady: boolean;
}

/**
 * Initializes an instance of CropperJS.
 * Returns the instance once it is ready.
 * Reuses the instance on rerenders.
 *
 * @param element preview element
 * @param options cropper options
 * @returns cropper instance
 */
declare function useCropper(element?: HTMLCanvasElement | null, options?: Cropper$1.Options<HTMLCanvasElement>): CropperResult;
declare function useCropper(element?: HTMLImageElement | null, options?: Cropper$1.Options<HTMLImageElement>): CropperResult;

interface CropperCropOptions {
    /**
     * HTML element on which events will be registered.
     */
    element?: HTMLElement | null;
}
interface CropperCropResult {
    /**
     * Clears crop box within Cropper and resets React state.
     */
    clearCrop: () => void;
    /**
     * Applies crop box with specified aspect ratio.
     * If aspect ratio is not provided, then crop box in freeform will be applied.
     *
     * @param aspectRatio crop item aspect ratio
     */
    crop: (aspectRatio?: number) => void;
    /**
     * Whether aspect ratio of crop box is locked.
     */
    cropBoxAspectRatioLocked: boolean;
    /**
     * Height of the crop box (if it's applied).
     * This always shows real size of the crop box, even in FIXED_CROP_SIZE mode.
     */
    cropBoxHeight?: number;
    /**
     * Width of the crop box (if it's applied).
     * This always shows real size of the crop box, even in FIXED_CROP_SIZE mode.
     */
    cropBoxWidth?: number;
    /**
     * Whether crop is enabled.
     */
    cropEnabled: boolean;
    /**
     * Sets custom crop box dimensions with free aspect ratio.
     *
     * @param width crop box width
     * @param height crop box height
     */
    cropWithCustomDimensions: (width: number, height: number) => void;
    /**
     * Sets custom crop box dimensions with one of the dimensions locked.
     *
     * @param size crop box width
     * @param locked dimension locked
     */
    cropWithCustomDimensionsLocked: (size: number, lock?: CropperLockedDimension) => void;
    /**
     * Sets fixed crop box dimensions and enables crop box within Cropper if disabled.
     *
     * From CropperJS's perspective, this is similar to setting a custom crop box.
     * For the user, this is a different experience: The crop box dimensions have also fixed sized in pixels.
     * This operation basically equals setting a crop box along with scaling the image at the same time.
     * Actual scaling will be performed on the server, not with the CropperJS.
     *
     * @param width crop box fixed width
     * @param height crop box fixed height
     */
    cropWithFixedDimensions: (width: number, height: number) => void;
    /**
     * Height of the crop box in FIXED_CROP_SIZE.
     */
    fixedCropBoxHeight?: number;
    /**
     * Width of the crop box in FIXED_CROP_SIZE.
     */
    fixedCropBoxWidth?: number;
    /**
     * Whether crop box is in CROP mode.
     */
    isCropMode: boolean;
    /**
     * Whether crop box is in FIXED_CROP_SIZE.
     */
    isFixedCropMode: boolean;
    /**
     * Toggles crop box dimensions lock.
     */
    toggleAspectRatioLock: () => void;
}

/**
 * Hook that allows to crop CropperJS image. Exposes helper methods.
 *
 * @param cropper instance of CropperJS
 * @param options hook options
 * @returns crop result and methods
 */
declare const useCropperCrop: (cropper: Cropper$1 | null, options?: CropperCropOptions) => CropperCropResult;

declare const CROPPER_ROTATION_ANGLE = 90;
declare const CROPPER_FULL_ROTATION = 360;

interface CropperRotateResult {
    /**
     * Whether image has inverted orientation in relation to the original one.
     */
    hasInvertedOrientation: boolean;
    /**
     * Rotates image left by 90 degrees.
     */
    rotateLeft: () => void;
    /**
     * Rotates image right by 90 degrees.
     */
    rotateRight: () => void;
    /**
     * Rotates image to a given angle.
     *
     * @param angle angle to rotate to
     */
    rotateTo: (angle: number) => void;
    /**
     * Current rotation angle.
     */
    rotationAngle: number;
}

/**
 * Hook that allows to rotate CropperJS image.
 *
 * @param cropper instance of CropperJS
 * @returns result
 */
declare const useCropperRotate: (cropper: Cropper$1 | null) => CropperRotateResult;

declare const CROPPER_FLIP_FACTOR = -1;
declare const CROPPER_INIT_SCALE = 1;

interface CropperScaleOptions {
    /**
     * Callback invoked when image is rotated to a given angle.
     *
     * @param angle current angle
     */
    onRotateTo?: (angle: number) => void;
}
interface CropperScaleResult {
    /**
     * Flips image horizontally.
     */
    flipHorizontal: () => void;
    /**
     * Flips image vertically.
     */
    flipVertical: () => void;
    /**
     * Scale value in X dimension.
     */
    scaleX: number;
    /**
     * Scale value in Y dimension.
     */
    scaleY: number;
}

/**
 * Hook that allows to scale CropperJS image.
 *
 * @param cropper instance of CropperJS
 * @param options callback invoked when image is rotated to a given angle
 * @returns result
 */
declare const useCropperScale: (cropper: Cropper$1 | null, options?: CropperScaleOptions) => CropperScaleResult;

declare const CROPPER_ZOOM_THRESHOLD = 50;
declare const CROPPER_ZOOM_STEP_FINE = 10;
declare const CROPPER_ZOOM_STEP = 25;
declare const CROPPER_ZOOM_FACTOR = 100;
declare const CROPPER_MIN_ZOOM_VALUE = 1;

interface CropperZoomOptions {
    /**
     * HTML element on which events will be registered.
     */
    element?: HTMLElement | null;
}
interface CropperZoomResult {
    /**
     * Enlarges image.
     */
    zoomIn: () => void;
    /**
     * Zooms out.
     */
    zoomOut: () => void;
    /**
     * Resets zoom to initial value.
     * Centers image with regards to the canvas.
     */
    resetZoom: () => void;
    /**
     * Initial zoom value.
     */
    zoomBaseline: number;
    /**
     * Current zoom value.
     */
    zoomValue: number;
}

/**
 * Hook that allows to zoom CropperJS image.
 * Zoom values are reported in %.
 *
 * @param cropper instance of CropperJS
 * @param options hook options
 * @returns result
 */
declare const useCropperZoom: (cropper: Cropper$1 | null, options?: CropperZoomOptions) => CropperZoomResult;

/**
 * This hook encapsulates logic related to toggling loading effects.
 *
 * @param isLoading whether original loading is in progress
 * @returns whether to show loader
 */
declare const useDeferredLoader: (isLoading: boolean) => boolean;

/**
 * Use this hook in order to defer unmount of a component.
 * It makes sure that component relying on this hook can be mounted for at least `waitFor` period.
 * This is useful to keep loader-like components mounted for a minimum time to avoid "flashing" effect.
 *
 * @param loading loading flag
 * @param waitFor indicates minimum mount time
 * @returns flag indicating if component relying on this hook should be kept mounted
 */
declare const useDeferredUnmount: (loading: boolean, waitFor?: number) => boolean;

/**
 * Allows to delay `shouldWait` flag by a value specified by `delay` option.
 *
 * @param shouldWait observed flag
 * @param delay delay time (in ms)
 * @returns flag indicating if `delay` time has passed and `shouldWait` is still `true`.
 */
declare const useDelay: (shouldWait: boolean, delay: number) => boolean;

interface Dimensions {
    width: number;
    height: number;
    top: number;
    left: number;
}
interface ResizeOptions {
    /**
     * Resize direction.
     */
    dir?: 'SE' | 'SW';
    /**
     * Minimum resize width.
     */
    minWidth?: number;
    /**
     * Callback invoked when resizing is done.
     */
    onResizeEnd?: (dimensions: Dimensions) => void;
}

/**
 * Manages element resize.
 *
 * @param opts resize options
 * @returns resize state and utils
 */
declare const useResize: (opts: ResizeOptions) => {
    onMouseDown: React$1.MouseEventHandler<HTMLElement> | undefined;
    setResizableEl: (el: HTMLElement | null) => void;
    isResizing: boolean | undefined;
};

type DragHandler = (diff: {
    /**
     * Dragged element.
     */
    draggableEl: HTMLElement;
    /**
     * Initial X offset of dragged element in relation to its closest positioned ancestor.
     */
    initOffsetX: number;
    /**
     * Initial Y offset of dragged element in relation to its closest positioned ancestor.
     */
    initOffsetY: number;
    /**
     * Initial offset width of dragged element.
     */
    initOffsetWidth: number;
    /**
     * Initial offset height of dragged element.
     */
    initOffsetHeight: number;
    /**
     * Pointer's X client offset.
     */
    clientOffsetX: number;
    /**
     * Pointer's Y client offset.
     */
    clientOffsetY: number;
    /**
     * Value of a vector representing pointer movement in X axis.
     */
    clientVX: number;
    /**
     * Value of a vector representing pointer movement in Y axis.
     */
    clientVY: number;
}) => void;
type DragDimensionsHandler = (dimensions: Dimensions) => void;
interface DraggableOptions {
    /**
     * Callback invoked on dragging. Passes most recent drag vectors.
     */
    onDrag?: DragHandler;
    /**
     * Callback invoked on drag end.
     */
    onDragEnd?: DragDimensionsHandler;
    /**
     * Callback invoked on drag start.
     */
    onDragStart?: React.MouseEventHandler<HTMLElement>;
}
interface DraggableState {
    /**
     * Dragged element.
     */
    draggableEl: HTMLElement | null;
    /**
     * Indicates if dragging is happening.
     */
    isDragging?: boolean;
    /**
     * Event handler that should be attached to drag handle.
     */
    onMouseDown?: React.MouseEventHandler<HTMLElement>;
    /**
     * Setter for element that will be dragged.
     */
    setDraggableEl: (el: HTMLElement | null) => void;
}

/**
 * Manages element dragging.
 *
 * @param opts dragging options
 * @returns dragging state and utils
 */
declare const useDraggable: (opts?: DraggableOptions) => DraggableState;

/**
 * Keeps info about mount state.
 *
 * This hook is useful when paired with async effects.
 * For instance, an effect might be in progress but its parent hook gets unmounted. In such case, it's advised to not update hook state.
 *
 * @returns callback that returns info about mount state
 */
declare const useIsMounted: () => () => boolean;

declare const useIsomorphicLayoutEffect: typeof useEffect;

interface ItemsOverflowOptions {
    /**
     * Total number of items.
     */
    items: number;
    /**
     * Margin added to items at each breakpoint. Provide a value to accommodate space for e.g. `more` button.
     */
    itemsMargin: number;
}

/**
 * Calculates number of items that are visible within a container.
 *
 * @param opts hook options
 * @returns items overflow state
 */
declare const useItemsOverflow: (opts: ItemsOverflowOptions) => {
    init: boolean;
    setContainer: React$1.Dispatch<React$1.SetStateAction<HTMLDivElement | null>>;
    visibleItems: number;
};

/**
 * Use this hook in order to invoke a callback once the specified time passes.
 *
 * The hook exposes actions for initializing and resetting the timeout.
 *
 * @param onTimeout callback invoked when time specified by `delay` passes
 * @param delay timeout (in ms)
 * @returns timeout actions
 */
declare const useResettableTimeout: (onTimeout: () => void, delay?: number) => {
    initTimeout: () => void;
    removeTimeout: () => void;
    resetTimeout: () => void;
};

/**
 * Provided with a list of breakpoints, chooses a breakpoint value that is greater than or equal container's width.
 * Additionally, it chooses another breakpoint by taking device's pixel ratio into account.
 *
 * Container's size changes are observed via `ResizeObserver`. Observer's callback invocation is throttled.
 *
 * @param breakpoints list of possible image widths
 * @param containerEl container element
 * @param enabled toggles `ResizeObserver`
 * @returns state and ref setters
 */
declare const useResponsiveSizes: (breakpoints: number[], containerEl?: HTMLElement | null, enabled?: boolean) => {
    sizes: number | undefined;
    pixelAdjSizes: number | undefined;
};

/**
 * Detects visibility of an element inside a scrollable container.
 *
 * @param element element to observe
 * @param scrollableContainerEl scrollable container
 * @param enabled toggles observer
 * @returns hook state and methods
 */
declare const useElementVisibility: (element?: HTMLElement | null, scrollableContainerEl?: HTMLElement | null, enabled?: boolean) => {
    visible: boolean;
};

interface DropFile {
    /**
     * File object.
     */
    file: File;
    /**
     * Path to the file, relative to the folder in which drag and drop started.
     */
    relativePath: string;
}
interface UseFilesDropProps {
    /**
     * Callback invoked when files are dropped.
     */
    onDrop?: (files: DropFile[]) => void;
}

/**
 * Hook that allows to connect any container and make it a drop target for files.
 *
 * @param hook props
 * @returns hook state and methods
 */
declare const useFilesDrop: ({ onDrop }: UseFilesDropProps) => {
    drop: react_dnd.ConnectDropTarget;
    isActive: boolean;
};

/**
 * Utility hook allowing syncing two refs.
 *
 * @param ref
 * @returns single forked ref synced with the provided ref
 */
declare const useForkRef: <T>(ref: React$1.MutableRefObject<T | null> | ((instance: T | null) => void) | null | undefined) => React$1.RefObject<T>;

type Selected = Set<string>;

/**
 * This hook is responsible for selecting cells in a 2-dimensional grid.
 *
 * @param initCells initial list of cell ids
 * @param initColumnCount initial number of columns in the grid
 * @returns state setters / state slices
 */
declare const useGridSelection: (initCells?: string[], initColumnCount?: number) => {
    deselectAll: () => void;
    isAnySelected: boolean;
    isSingleSelected: boolean;
    lastSelectedId: string | undefined;
    selectAll: () => void;
    selectDown: () => void;
    selectedIds: Selected;
    selectedSize: number;
    selectLeft: () => void;
    selectRange: (id: string) => void;
    selectRangeDown: () => void;
    selectRangeLeft: () => void;
    selectRangeRight: () => void;
    selectRangeUp: () => void;
    selectRight: () => void;
    selectSingle: (id: string) => void;
    selectSome: (ids: string[]) => void;
    selectUp: () => void;
    toggleSelection: (id: string) => void;
    updateCells: (ids: string[]) => void;
    updateColumnCount: (columnCount: number) => void;
};

/**
 * A helper hook for a building a simple state machine. Useful for togglable popper-based components such as menus.
 *
 * @param initValue initial value
 * @returns toggle actions
 */
declare const useToggle: (initValue?: boolean) => {
    value: boolean;
    toggle: () => void;
    on: () => void;
    off: () => void;
};

/**
 * Listens to container element's size changes and sets target's width and height accordingly.
 *
 * This hook is useful if `object-fit: scale-down` CSS rule cannot be used,
 * e.g. if image's placeholder has different size than the original image
 * but the placeholder must be still scaled to fit the size of the original image.
 *
 * @param originalWidth original image's width
 * @param originalHeight original image's height
 * @param containerEl container element
 * @param enabled toggles `ResizeObserver`
 * @returns ref setters
 */
declare const useScaleDown: (originalWidth?: number, originalHeight?: number, containerEl?: HTMLElement | null, enabled?: boolean) => {
    setTargetElement: React$1.Dispatch<React$1.SetStateAction<HTMLElement | null>>;
};

interface XYCoord {
    x: number;
    y: number;
}
interface ScrollCoordsConfig {
    /**
     * Specifies fraction of the container
     * that will be used as upper and lower scroll bounds
     * (scrolling can happen only within those bounds).
     */
    containerMargin?: number;
    /**
     * Represents a value by which scroll vector is multiplied.
     * Adjust the value to fine tune scrolling speed.
     */
    speedCoef?: number;
    /**
     * Specifies the number of pixels that vertical mouse movement
     * must exceed so that scroll can happen.
     */
    initThresh?: number;
}
type OnScrollHandler = (vStart: {
    startX: number;
    startY: number;
}, vCurrent: {
    currentX: number;
    currentY: number;
}) => void;
interface ScrollOptions {
    /**
     * Triggering `mousedown` events on elements with the provided selector
     * will not initialize scrolling.
     */
    ignoredSelector?: string;
    /**
     * Callback that is invoked in intervals if scrolling has been initialied.
     * The callback is invoked for every `tick` of scrolling interval.
     */
    onScroll?: OnScrollHandler;
    /**
     * Callback invoked upon scroll end.
     */
    onScrollEnd?: () => void;
    /**
     * Callback invoked upon scroll start.
     */
    onScrollStart?: () => void;
}

/**
 * Calculates scrolling vector based on initial client coords, current client coords, and scrolling options.
 *
 * @param container scrollable container
 * @param initOffset initial client offset (e.g. mouse coords)
 * @param currentOffset current client offset (e.g. mouse coords)
 * @param config config option
 * @returns scrolling vector
 */
declare const getScrollVectors: (container: HTMLElement, initOffset: XYCoord, currentOffset: XYCoord, config?: ScrollCoordsConfig) => number;

/**
 * Allows to scroll a container while performing actions within that container.
 *
 * Container scrolling is initiated by a `mousedown` event within that container.
 * Then, on `mousemove` the scrolling can be either accelerated or slowed down.
 *
 * Scrolling can happen only if mouse pointer is placed close to the upper or lower edge of the container.
 *
 * @param container scrollable container
 * @param opts scroll options
 * @returns scroll info
 */
declare const useScroll: (container?: HTMLElement | null, opts?: ScrollOptions) => {
    isScrolling: boolean;
};

/**
 * Allows to scroll a container while dragging an item.
 *
 * @param container scrollable container
 * @param type item type that will trigger scrolling
 */
declare const useScrollDnd: (container?: HTMLElement | null, type?: string) => void;

/**
 * Hook for downloading file using hidden anchor tag.
 *
 * @returns function for downloading file
 */
declare const useDownload: (root?: HTMLElement | null) => {
    downloadFile: (downloadUrl: string) => void;
};

/**
 * Defines validators that can be used to check various user inputs.
 * They are intended to be used downstream to build validation rules for HTML forms.
 *
 * Validators must conform to the convention used by `react-hook-form`: They must return either `boolean` or an error message.
 * For more info see `validate` option: https://react-hook-form.com/api/useform/register
 */
/**
 * Creates validation rule that checks if supplied `value` is non-empty.
 * Whitespaces are trimmed before the check.
 *
 * @param msg error message
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const nonEmpty: (msg: string) => (value?: string) => string | true;
/**
 * Creates validation rule that checks if supplied `value` is present in `allowedValues`.
 *
 * @param msg error message
 * @param allowedValues list of allowed values
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const isAllowed: <T>(msg: string, allowedValues: T[]) => (value?: T | undefined) => string | true;
/**
 * Creates validation rule that checks if supplied `value` string is present in `allowedValues`.
 * Makes comparison without taking letter case into account.
 *
 * @param msg error message
 * @param allowedValues list of allowed values
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const isCaseInsensitiveStringAllowed: (msg: string, allowedValues: string[]) => (value?: string) => string | true;
/**
 * Creates validation rule that checks if supplied array has at least one item.
 *
 * @param msg error message
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const nonEmptyArray: <T>(msg: string) => (value?: T[] | undefined) => string | true;
/**
 * Creates validation rule that checks if supplied array does not exceed `max` items.
 *
 * @param msg error message
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const maxItems: <T>(msg: string, max: number) => (value?: T[] | undefined) => string | true;
/**
 * Creates validation rule that checks if supplied `value` is not already present within `existingValues`.
 *
 * @param msg error message
 * @param existingValues list of existing values
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const unique: <T>(msg: string, existingValues: T[]) => (value?: T | undefined) => string | true;
/**
 * Creates validation rule that checks if supplied value contains a dot.
 *
 * @param msg error message
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const nonDotValue: (msg: string) => (values?: string[]) => string | true;
/**
 * Creates validation rule that checks if string length in an array doesn't exceed max length.
 *
 * @param msg error message
 * @param maxLength maximum length of the string in the array
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const maxLength: (msg: string, maxLength: number) => (values?: string[]) => string | true;
/**
 * Creates validation rule that checks if maximum value has not been exceeded.
 *
 * @param msg error message
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const maxValue: (msg: string, max: number) => (value?: number) => string | true;

declare const validators_d_isAllowed: typeof isAllowed;
declare const validators_d_isCaseInsensitiveStringAllowed: typeof isCaseInsensitiveStringAllowed;
declare const validators_d_maxItems: typeof maxItems;
declare const validators_d_maxLength: typeof maxLength;
declare const validators_d_maxValue: typeof maxValue;
declare const validators_d_nonDotValue: typeof nonDotValue;
declare const validators_d_nonEmpty: typeof nonEmpty;
declare const validators_d_nonEmptyArray: typeof nonEmptyArray;
declare const validators_d_unique: typeof unique;
declare namespace validators_d {
  export {
    validators_d_isAllowed as isAllowed,
    validators_d_isCaseInsensitiveStringAllowed as isCaseInsensitiveStringAllowed,
    validators_d_maxItems as maxItems,
    validators_d_maxLength as maxLength,
    validators_d_maxValue as maxValue,
    validators_d_nonDotValue as nonDotValue,
    validators_d_nonEmpty as nonEmpty,
    validators_d_nonEmptyArray as nonEmptyArray,
    validators_d_unique as unique,
  };
}

declare const ViewDialog: React$1.FC<Props$1L>;
interface Props$1L {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label of close button.
     */
    closeLabel?: string;
    /**
     * Initial height of dialog window.
     */
    height: number | string;
    /**
     * Initial offset from the left.
     */
    left?: number;
    /**
     * Minimum height (in px) of dialog window.
     */
    minHeight?: number;
    /**
     * Minimum width (in px) of dialog window.
     */
    minWidth?: number;
    /**
     * Callback invoked upon closing of dialog window.
     */
    onClose?: () => void;
    /**
     * Callback invoked whenever dialog dragging is completed.
     */
    onDragEnd?: (dimensions: Dimensions) => void;
    /**
     * Callback invoked whenever dialog resizing is completed.
     */
    onResizeEnd?: (dimensions: Dimensions) => void;
    /**
     * Toggles open state of dialog window.
     */
    open: boolean;
    /**
     * Label of resize button (SE direction).
     */
    resizeSELabel?: string;
    /**
     * Label of resize button (SW direction).
     */
    resizeSWLabel?: string;
    /**
     * Initial offset from the top.
     */
    top?: number;
    /**
     * Initial width of dialog window.
     */
    width: number | string;
    /**
     * Label of the root dialog element.
     */
    label?: string;
}

declare const UIProvider: React$1.FC<Props$1K>;
interface Props$1K {
    /**
     * Main content.
     */
    children: React$1.ReactNode;
    /**
     * Initial navbar mode.
     */
    navbarCollapsed?: boolean;
    /**
     * Initial navbar width.
     */
    navbarWidth?: number;
    /**
     * Registers callback for `keydown` events.
     */
    onKeyDown?: React$1.KeyboardEventHandler;
    /**
     * Callback invoked whenever navbar mode changes.
     */
    onNavbarCollapseChange?: (collapsed: boolean) => void;
    /**
     * Callback invoked whenever navbar resize ends.
     */
    onNavbarWidthChange?: (width: number) => void;
    /**
     * Dialog mode options.
     */
    dialog?: Omit<Props$1L, 'children'>;
    /**
     * Name of selected theme.
     */
    theme?: string;
    /**
     * Aria label to set on root element.
     */
    label?: string;
}

declare const View: React$1.FC<Props$1J>;
interface Props$1J {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewContent: React$1.ForwardRefExoticComponent<Props$1I & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1I {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
    /**
     * Indicates if content's area is active.
     */
    active?: boolean;
    /**
     * Sets content `mousedown` event handler.
     */
    onMouseDown?: React$1.MouseEventHandler<HTMLDivElement>;
    /**
     * Sets content `keydown` event handler.
     */
    onKeyDown?: React$1.KeyboardEventHandler;
    /**
     * Whether increased spacing should be used.
     */
    spacing?: 'xl';
}

declare const ViewContentBar: React$1.FC<Props$1H>;
interface Props$1H {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
    /**
     * Justifies content.
     */
    justify?: 'start' | 'end';
}

declare const ViewContentWrapper: React$1.FC<Props$1G>;
interface Props$1G {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewFooter: React$1.FC<Props$1F>;
interface Props$1F {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewHeader: React$1.FC<Props$1E>;
interface Props$1E {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewPaper: React$1.ForwardRefExoticComponent<Props$1D & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1D {
    /**
     * Sets component's children.
     */
    children: React$1.ReactNode;
}

declare const ViewSideContent: React$1.FC<Props$1C>;
interface Props$1C {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewWrapper: React$1.FC<Props$1B>;
interface Props$1B {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Sets navbar.
     */
    navbar?: React$1.ReactNode;
}

declare const RangeSlider: React$1.FC<Props$1A>;
type Props$1A = {
    /**
     * Slider value.
     */
    value: number;
    /**
     * Slider on change callback.
     *
     * @param value new slider value
     */
    onChange(value: number): void;
    /**
     * Slider step.
     */
    step: number;
    /**
     * Slider minimum value.
     */
    min: number;
    /**
     * Slider maximum value.
     */
    max: number;
    /**
     * Slider text values.
     */
    textValues?: Record<string, string>;
    /**
     * Renders range slider values labels.
     */
    showLabels?: boolean;
};

declare const FormFeedback: React$1.FC<Props$1z>;
type Props$1z = {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Feedback error.
     */
    error?: boolean;
    /**
     * Feedback warning.
     */
    warning?: boolean;
};

declare const FormGroup: React$1.FC<Props$1y>;
interface Props$1y {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Makes component occupy 50% of available width.
     */
    halfWidth?: boolean;
}

declare const FormGroupColumn: React$1.FC<Props$1x>;
interface Props$1x {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FormGroupInfo: React$1.FC<Props$1w>;
interface Props$1w {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FormInputLabel: React$1.FC<Props$1v>;
type Props$1v = {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Whether label is disabled.
     */
    disabled?: boolean;
    /**
     * Input id.
     */
    htmlFor: string;
};

declare const Form: React$1.ForwardRefExoticComponent<Props$1u & React$1.RefAttributes<HTMLFormElement>>;
type Props$1u = {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Form class.
     */
    className?: string;
    /**
     * Data attribute useful for testing.
     */
    'data-form-ready'?: boolean;
    /**
     * Form element's id.
     */
    id?: string;
    /**
     * Form submit callback.
     */
    onSubmit: React$1.FormEventHandler<HTMLFormElement>;
};

declare const EmptyViewLabel: React$1.FC<Props$1t>;
interface Props$1t {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Adds styling for muted label.
     */
    muted?: boolean;
}

declare const EmptyView: React$1.ForwardRefExoticComponent<Props$1s & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1s {
    /**
     * Adds active styling.
     */
    active?: boolean;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Data attribute useful for testing.
     */
    'data-loaded'?: boolean;
    /**
     * Empty view icon.
     */
    icon: IconName;
    /**
     * Sets styling mode.
     */
    type?: 'dropzone' | 'default';
}

declare const Ellipsis: React$1.FC<Props$1r>;
interface Props$1r {
    /**
     * Items to display.
     */
    items: string[];
    /**
     * Maximum items to display before shortening.
     */
    maxVisibleItems?: number;
}

declare const FilePreviewActions: React$1.FC<Props$1q>;
interface Props$1q {
    /**
     * Label of the back button.
     */
    backBtnLabel: string;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Text displayed as title in the action bar.
     */
    title: string;
}

declare const FilePreviewColumn: React$1.FC<Props$1p>;
interface Props$1p {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FilePreviewContent: React$1.ForwardRefExoticComponent<Props$1o & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1o {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FilePreviewHoverable: React$1.ForwardRefExoticComponent<Props$1n & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1n {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FilePreviewNavButton: React$1.FC<Props$1m>;
type Side = 'left' | 'right';
interface Props$1m {
    /**
     * Disables button.
     */
    disabled?: boolean;
    /**
     * Button's aria label.
     */
    label: string;
    /**
     * Callback invoked on click.
     */
    onClick?: () => void;
    /**
     * Places button on the specified side of the `FilePreview`.
     */
    side?: Side;
    /**
     * Placement of the button tooltip.
     */
    tooltipPlacement?: PopperPlacement;
}

declare const FilePreviewTooltip: React$1.FC<Props$1l>;
interface Props$1l {
    /**
     * Main content of the tooltip.
     */
    children?: React$1.ReactNode;
}

declare const FilePreview: React$1.ForwardRefExoticComponent<Props$1k & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1k {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label of the dialog element.
     */
    label?: string;
    /**
     * Callback invoked when file preview is closed.
     */
    onClose?: () => void;
    /**
     * Callback invoked when next item is requested.
     */
    onNext?: () => void;
    /**
     * Callback invoked when previous item is requested.
     */
    onPrev?: () => void;
    /**
     * Opens file preview.
     */
    open?: boolean;
}

/**
 * Selection rectangle's coordinates.
 * All coordinates are in relation to container's top left corner.
 */
interface SelectionAreaCoords {
    /**
     * Selection rectangle's `x` position.
     */
    x: number;
    /**
     * Selection rectangle's `y` position.
     */
    y: number;
    /**
     * Selection rectangle's width.
     */
    width: number;
    /**
     * Selection rectangle's height.
     */
    height: number;
}

declare const SelectionArea: React$1.FC<Props$1j>;
interface Props$1j {
    /**
     * Selection area container.
     */
    container?: HTMLDivElement | null;
    /**
     * Area selection change handler.
     */
    onSelectionChange?: (area: SelectionAreaCoords) => void;
    /**
     * Selector for ignoring areas started within passed selector.
     */
    ignoredSelector?: string;
}

interface SelectOption extends Record<string, unknown> {
    /**
     * Unique ID of an option.
     */
    id: string;
    /**
     * Value displayed for the user.
     */
    label: string;
    /**
     * Additional description.
     */
    description?: string;
}
interface SelectSection<T extends SelectOption = SelectOption> {
    /**
     * Unique ID of a section.
     */
    id: string;
    /**
     * Section's label.
     */
    label: string;
    /**
     * Options contained in section.
     */
    options: T[];
}
interface SelectRenderableOption extends SelectOption {
    /**
     * Indicates entry should be rendered as a section header.
     */
    isSectionHeader?: boolean;
}
interface SelectKeyboardNavProps {
    /**
     * Listbox element.
     */
    listboxEl: HTMLElement | null;
    /**
     * Flag indicating if listbox is currently open.
     */
    listboxOpen: boolean;
    /**
     * Callback that is called whenever listbox opening is requested.
     */
    onListboxOpen: () => void;
    /**
     * Toggles selection of an option.
     */
    onSelectToggle: SelectToggleHandler;
    /**
     * List of options to navigate.
     */
    options: SelectOption[];
    /**
     * Flag indicating if searchable select has text.
     */
    searchInProgress: boolean;
}
/**
 * Toggles selection of a provided option.
 */
type SelectToggleHandler = (opt: SelectOption) => void;
/**
 * Gets next / previous option (for keyboard selection).
 */
type SelectKeyboardNextIdGetter = (options: SelectOption[], currentIndex: number) => SelectOption | undefined;

declare const Select: React$1.FC<Props$1i>;
interface Props$1i {
    /**
     * Aria label for clear button.
     */
    clearBtnLabel?: string;
    /**
     * Disables component.
     */
    disabled?: boolean;
    /**
     * Indicate error in input element.
     */
    error?: boolean;
    /**
     * Whether expand button is rendered in compact mode.
     */
    expandBtnCompact?: boolean;
    /**
     * ID of the input element.
     */
    id?: string;
    /**
     * Allows to select multiple options.
     */
    multiSelect?: boolean;
    /**
     * Turns on/off select border.
     */
    noBorder?: boolean;
    /**
     * Message displayed if listbox is empty.
     */
    noOptionsLabel?: string;
    /**
     * Callback invoked when component loses focus.
     */
    onBlur?: () => void;
    /**
     * Callback invoked when clear button is activated.
     */
    onClear?: () => void;
    /**
     * List of options.
     */
    options: SelectOption[] | SelectSection[];
    /**
     * Callback invoked whenever an item is selected or deselected.
     */
    onSelectToggle: SelectToggleHandler;
    /**
     * Padding sizing variant.
     */
    padding?: 'large';
    /**
     * Textual placeholder if there are no options selected.
     */
    placeholder?: string;
    /**
     * Custom render prop for a list item.
     *
     * @param option option
     */
    renderListItem?: (option: SelectOption) => React$1.ReactNode;
    /**
     * Custom render prop for selected item.
     *
     * @param selected selected option
     */
    renderSelectedItem?: (selected: SelectOption) => React$1.ReactNode;
    /**
     * Allows to search through options.
     */
    searchable?: boolean;
    /**
     * List of selected options.
     */
    selected: SelectOption[];
    /**
     * Sizing variant.
     */
    size?: 'base' | 'small' | 'medium';
}

declare const Notifications: React$1.FC<Props$1h>;
interface Props$1h {
    /**
     * Container's position will be adjusted in accordance with provided element's height.
     */
    bottomOffsetEl?: HTMLElement | null;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

type NotificationType = 'success' | 'error' | 'warning';

declare const Notification: React$1.FC<Props$1g>;
/**
 * `Notification` component is rendered as part of `TransitionGroup` and therefore gets transition props in addition to its regular props.
 */
type Props$1g = Partial<TransitionProps> & {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label for "Close" button.
     */
    closeLabel: string;
    /**
     * Callback for close button.
     */
    onClose?: () => void;
    /**
     * Callback for details button.
     */
    onDetailsClick?: () => void;
    /**
     * Label for "Open Details" button.
     */
    openDetailsLabel?: string;
    /**
     * Notification type.
     */
    type: NotificationType;
};

declare const CopyableInput: React$1.FC<Props$1f>;
interface Props$1f {
    /**
     * Unique input's id.
     */
    id: string;
    /**
     * Input's value. This value will be copied to clipboard upon clicking on the copy button.
     */
    value?: string;
    /**
     * Input's class name.
     */
    className?: string;
    /**
     * Label displayed in the popup on hover and the internal button's aria-label.
     */
    labelCopy: string;
    /**
     * Label displayed in the popup upon clicking on the copy button.
     */
    labelCopied: string;
}

declare const CopyableLabel: React$1.FC<Props$1e>;
interface Props$1e {
    /**
     * Label's text. This text will be copied to clipboard upon clicking on the label.
     */
    value?: string;
    /**
     * Label's class name.
     */
    className?: string;
    /**
     * Label displayed in the popup on hover and the internal button's aria-label.
     */
    labelCopy: string;
    /**
     * Label displayed in the popup upon clicking on the copyable text.
     */
    labelCopied: string;
}

declare const CopyButton: React$1.FC<Props$1d>;
interface Props$1d {
    /**
     * Value to be copied to clipboard.
     */
    value?: string;
    /**
     * Label displayed in the popup on hover and the internal button's aria-label.
     */
    labelCopy: string;
    /**
     * Label displayed in the popup upon clicking on the copy button.
     */
    labelCopied: string;
}

type BreakpointKey = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
type BreakpointMap = Record<BreakpointKey, number>;
/**
 * Encapsulates logic that allows to compare specified breakpoints.
 * Breakpoint values are treated as equivalent of CSS `min-width` property.
 * For instance, key `md` with value `900` means that breakpoint `md` is achieved for at least 900px of width.
 */
declare class Breakpoints {
    breakpoints: BreakpointMap;
    constructor(breakpoints: BreakpointMap);
    /**
     * Checks if requested key is lower than reference breakpoint.
     * Matches [0px, {key}) (`key` exclusive).
     *
     * @param key maximum requested breakpoint
     * @param breakpoint reference breakpoint
     * @returns flag indicating if requested key is lower than reference breakpoint
     */
    down(key: BreakpointKey, breakpoint: BreakpointKey): boolean;
    /**
     * Gets matching breakpoint key for the specified width.
     *
     * @param width width in px
     * @returns matching breakpoint key
     */
    toKey(width: number): BreakpointKey;
    /**
     * Checks if requested key is greater than or equal reference breakpoint.
     * Matches [{key}, ) (`key` inclusive).
     *
     * @param key minimum requested key
     * @param breakpoint reference breakpoint
     * @returns flag indicating if requested key is greater than or equal reference breakpoint
     */
    up(key: BreakpointKey, breakpoint: BreakpointKey): boolean;
}

interface ContainerQueryContext {
    /**
     * Current breakpoint key of the container.
     */
    key?: BreakpointKey;
    /**
     * Current vertical breakpoint key of the container.
     */
    keyVertical?: BreakpointKey;
    /**
     * Breakpoint utils.
     */
    breakpoints?: Breakpoints;
}
declare const ContainerQueryContext: React$1.Context<ContainerQueryContext>;
declare const useContainerQuery: () => ContainerQueryContext;

declare const ContainerQueryProvider: React$1.FC<Props$1c>;
interface Props$1c {
    /**
     * Maps breakpoint keys to width values. Each key corresponds to minimum value (in px).
     */
    breakpointValues: BreakpointMap;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Element used as container.
     */
    containerEl?: HTMLElement | null;
}

declare const ContainerQuery: React$1.FC<Props$1b>;
interface Props$1b {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Specifies maximum breakpoint key at which component should be still shown.
     */
    down?: BreakpointKey;
    /**
     * Specifies minimum breakpoint key starting from which component should be shown.
     */
    up?: BreakpointKey;
}

interface FixedContext {
    /**
     * Element used a root for fixed UI components within the context.
     */
    rootEl?: HTMLElement | null;
}
declare const FixedContext: React$1.Context<FixedContext>;
declare const useFixedCtx: () => FixedContext;

declare const FixedProvider: React$1.FC<Props$1a>;
interface Props$1a {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * By default fixed components will be mounted at main UI root.
     * Provide a different element to use as a root.
     */
    rootEl?: HTMLElement | null;
}

declare const Fixed: React$1.FC<Props$19>;
interface Props$19 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const LoadingButton: React$1.ForwardRefExoticComponent<Props$18 & React$1.RefAttributes<HTMLButtonElement>>;
interface Props$18 extends Props$36 {
    /**
     * Delays loader appearance. Defaults to `true`.
     */
    delay?: boolean;
    /**
     * Toggles loading state.
     */
    loading?: boolean;
    /**
     * Positions loader. Defaults to `center`.
     */
    loaderPosition?: 'left' | 'center' | 'right';
}

declare const ListItem: React$1.FC<Props$17>;
interface Props$17 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Callback invoked when clicking on list item content.
     */
    onClick?: () => void;
}

declare const ListItemActions: React$1.FC<Props$16>;
interface Props$16 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const ListItemContent: React$1.FC<Props$15>;
interface Props$15 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Applied styling for muted variant.
     */
    muted?: boolean;
}

declare const List: React$1.FC<Props$14>;
interface Props$14 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * List's class name.
     */
    className?: string;
}

declare const SearchDialogActions: React$1.FC<Props$13>;
interface Props$13 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const SearchDialogContent: React$1.FC<Props$12>;
interface Props$12 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const SearchDialogFallback: React$1.FC<Props$11>;
interface Props$11 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const SearchDialogHeader: React$1.FC<Props$10>;
interface Props$10 {
    /**
     * Optional action rendered next to close button.
     */
    action?: React$1.ReactNode;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Aria label for the close button.
     */
    closeBtnLabel: string;
    /**
     * Aria label for the input.
     */
    inputLabel: string;
    /**
     * Callback invoked when form is submitted.
     */
    onSubmit?: React$1.FormEventHandler;
}

declare const SearchDialogInput: React$1.ForwardRefExoticComponent<Props$$ & React$1.RefAttributes<HTMLInputElement>>;
interface Props$$ {
    /**
     * Input's name to register.
     */
    name?: string;
    /**
     * Callback invoked when the blur event is fired.
     */
    onBlur?: (evt: React$1.ChangeEvent) => void;
    /**
     * Callback invoked when the value is changed.
     */
    onChange?: (evt: React$1.ChangeEvent) => void;
    /**
     * Callback invoked when the element receives focus.
     */
    onFocus?: (evt: React$1.ChangeEvent) => void;
    /**
     * Input's placeholder text.
     */
    placeholder?: string;
    /**
     * Input's value.
     */
    value?: string;
}

declare const SearchDialogSection: React$1.FC<Props$_>;
interface Props$_ {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Header of the section.
     */
    header?: string;
    /**
     * Side header buttons of the section
     */
    headerButtons?: React$1.ReactNode;
}

declare const SearchDialog: React$1.FC<Props$Z>;
interface Props$Z {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label of the dialog element.
     */
    label?: string;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens file preview.
     */
    open?: boolean;
}

declare const DrawerActions: React$1.FC<Props$Y>;
interface Props$Y {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const DrawerContent: React$1.FC<Props$X>;
interface Props$X {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const DrawerHeader: React$1.FC<Props$W>;
interface Props$W {
    /**
     * Text displayed as title in the bar.
     */
    title: string;
    /**
     * Label of the close button.
     */
    closeBtnLabel: string;
    /**
     * Name of selected icon.
     */
    iconName?: IconName;
    /**
     * Renders custom icon.
     */
    iconRender?: IconRenderProp;
}

declare const DrawerSection: React$1.ForwardRefExoticComponent<Props$V & React$1.RefAttributes<HTMLDivElement>>;
interface Props$V {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Fixes section's height.
     */
    fixedHeight?: boolean;
    /**
     * Centers section's content.
     */
    centeredContent?: boolean;
}

declare const Drawer: React$1.FC<Props$U>;
interface Props$U {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label of the dialog element.
     */
    label?: string;
    /**
     * Callback invoked when drawer is closed.
     */
    onClose?: () => void;
    /**
     * Opens drawer.
     */
    open?: boolean;
    /**
     * Mounts drawer in a fixed mode. Defaults to `true`.
     */
    fixed?: boolean;
}

declare const TextEllipsis: React$1.FC<Props$T>;
interface Props$T {
    /**
     * Text content.
     */
    children: React$1.ReactNode;
    /**
     * Applies font size.
     */
    fontSize?: 'small';
    /**
     * Flag indicating if text should wrap.
     */
    wrap?: boolean;
}

declare const FileInput: React$1.ForwardRefExoticComponent<Props$S & React$1.RefAttributes<HTMLInputElement>>;
interface Props$S {
    /**
     * Specify comma-separated list of allowed file extensions.
     */
    accept?: string;
    /**
     * Allows to select directory instead of file.
     */
    directory?: boolean;
    /**
     * Allows to select multiple files.
     */
    multiple?: boolean;
    /**
     * Callback invoked when the value is changed.
     */
    onChange?: React$1.ChangeEventHandler<HTMLInputElement>;
}

declare const NavigationDialogContent: React$1.ForwardRefExoticComponent<Props$R & React$1.RefAttributes<HTMLDivElement>>;
interface Props$R {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const NavigationDialogFallbackContent: React$1.ForwardRefExoticComponent<Props$Q & React$1.RefAttributes<HTMLDivElement>>;
interface Props$Q {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const NavigationDialogFooter: React$1.ForwardRefExoticComponent<Props$P & React$1.RefAttributes<HTMLDivElement>>;
interface Props$P {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const NavigationDialogHeader: React$1.ForwardRefExoticComponent<Props$O & React$1.RefAttributes<HTMLDivElement>>;
interface Props$O {
    /**
     * Optional action component rendered next to title.
     */
    action?: React$1.ReactNode;
    /**
     * Main content of the header.
     */
    children: React$1.ReactNode;
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Indicates if title should be emphasized.
     */
    emphasized?: boolean;
    /**
     * Sets ID of dialog header title element.
     */
    titleId?: string;
}

declare const NavigationDialogItem: React$1.ForwardRefExoticComponent<Props$N & React$1.RefAttributes<HTMLLIElement>>;
interface Props$N {
    /**
     * Indicates if navbar item is active.
     */
    active?: boolean;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Indicates if navbar item is disabled.
     */
    disabled?: boolean;
    /**
     * Callback invoked upon button click.
     */
    onClick?: () => void;
    /**
     * Callback invoked upon button click.
     */
    onDoubleClick?: () => void;
}

declare const NavigationDialogItemAction: React$1.FC<Props$M>;
interface Props$M {
    /**
     * Optional button.
     */
    button?: React$1.ReactElement<Props$36> | null;
    /**
     * Optional icon.
     */
    icon?: React$1.ReactElement<Props$37> | ((props: Props$37) => React$1.ReactNode) | null;
}

declare const NavigationDialogItemLabel: React$1.FC<Props$L>;
interface Props$L {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Displayed icon.
     */
    icon?: React$1.ReactElement<Props$37>;
}

declare const NavigationDialog: React$1.ForwardRefExoticComponent<Props$K & React$1.RefAttributes<HTMLDivElement>>;
interface Props$K {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets the ID of description element.
     */
    describedBy?: string;
    /**
     * Sets the dialog label.
     */
    label?: string;
    /**
     * Sets the ID of label element.
     */
    labelledBy?: string;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens dialog. Use in combination with `onClose`.
     */
    open?: boolean;
}

declare const CheckboxLabel: React$1.ForwardRefExoticComponent<Props$J & React$1.RefAttributes<HTMLLabelElement>>;
interface Props$J {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Sets `for` attribute.
     */
    labelFor?: string;
}

declare const Checkbox: React$1.FC<Props$I>;
interface Props$I {
    /**
     * Optional content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets current input's value.
     */
    checked: boolean;
    /**
     * Disables focusability of input element.
     */
    disableFocusability?: boolean;
    /**
     * Underlying input's id.
     */
    id?: string;
    /**
     * Aria label of the input element.
     */
    label?: string;
    /**
     * Underlying input's name.
     */
    name?: string;
    /**
     * Callback invoked upon click.
     */
    onClick?: (evt: React$1.MouseEvent) => void;
    /**
     * Callback invoked upon value's change.
     */
    onChange: (checked: boolean) => void;
    /**
     * Marks checkbox as disabled.
     */
    disabled?: boolean;
}

type ImageEditorPresetOption = SelectOption & {
    height?: number;
    width?: number;
};
type ImageEditorPresetGroup = SelectSection<ImageEditorPresetOption>;
interface ImageEditorEditingResult {
    /**
     * Offset of the crop box horizontally.
     */
    x: number;
    /**
     * Offset of the crop box vertically.
     */
    y: number;
    /**
     * Width of the crop box.
     */
    width: number;
    /**
     * Height of the crop box.
     */
    height: number;
    /**
     * Rotation of the image.
     */
    rotation: number;
    /**
     * Whether the image is flipped horizontally.
     */
    flipX: boolean;
    /**
     * Whether the image is flipped vertically.
     */
    flipY: boolean;
}

declare const imageEditorContextDefaultValue: ImageEditorContext;
interface ImageEditorContext {
    /**
     * Currently active crop item.
     */
    activeCropItemId?: string;
    /**
     * Deselects any selected crop item and clears crop box.
     */
    clearCrop: () => void;
    /**
     * Closes image editor.
     */
    close: () => void;
    /**
     * Closes save dialog.
     */
    closeSaveDialog: () => void;
    /**
     * Uses a predefined crop item to apply crop box.
     * Keeps aspect ratio if specified.
     *
     * @param id ID of the crop item
     * @param aspectRatio aspect ratio of the crop box
     */
    crop: (id: string, aspectRatio?: number) => void;
    /**
     * Whether crop is enabled.
     */
    cropEnabled: boolean;
    /**
     * Cropper ready state.
     */
    cropperReady: boolean;
    /**
     * Indicates if cropper image loading is in progress.
     * Initially, this is set to `false`. If image loading takes too long, then this flag is enabled.
     */
    cropperImgDeferredLoading?: boolean;
    /**
     * Instance of Cropper.
     */
    cropper?: Cropper | null;
    /**
     * Whether aspect ratio of custom crop box dimensions is locked.
     */
    cropBoxAspectRatioLocked?: boolean;
    /**
     * Disables crop box dimensions lock.
     */
    cropBoxAspectRatioLockDisabled?: boolean;
    /**
     * Height of current crop box.
     */
    cropBoxHeight?: number;
    /**
     * Width of current crop box.
     */
    cropBoxWidth?: number;
    /**
     * Applies crop box with custom dimensions.
     *
     * If none of the crop box items has been selected, then freeform crop item will be selected.
     * If freeform crop item has been selected, it will remain selected.
     *
     * @param width width of the crop box
     * @param height height of the crop box
     */
    cropWithCustomDimensions: (width: number, height: number) => void;
    /**
     * Sets custom crop box dimensions with one of the dimensions locked.
     * If any crop item with predefined aspect ratio has been selected, then aspect ratio will be respected.
     *
     * @param size crop box width
     * @param locked dimension locked
     */
    cropWithCustomDimensionsLocked: (size: number, locked?: CropperLockedDimension) => void;
    /**
     * Applies crop box in FIXED_CROP_SIZE mode. In this mode crop box will always have the same size in pixels.
     *
     * @param id ID of the crop item
     * @param width width of the crop box in px
     * @param height height of the crop box in px
     */
    cropWithFixedDimensions: (id: string, width: number, height: number) => void;
    /**
     * ID of the custom crop item.
     */
    freeformCropItemId: string;
    /**
     * Height of the crop box in FIXED_CROP_SIZE mode.
     */
    fixedCropBoxHeight?: number;
    /**
     * Width of the crop box in FIXED_CROP_SIZE mode.
     */
    fixedCropBoxWidth?: number;
    /**
     * Flips image horizontally.
     */
    flipHorizontal: () => void;
    /**
     * Flips image vertically.
     */
    flipVertical: () => void;
    /**
     * Underlying image element.
     */
    imgElement: HTMLImageElement | null;
    /**
     * Whether crop box is in CROP mode.
     */
    isCropMode: boolean;
    /**
     * Whether crop box is in FIXED_CROP_SIZE.
     */
    isFixedCropMode: boolean;
    /**
     * Opens save dialog.
     */
    openSaveDialog: () => void;
    /**
     * Original aspect ratio of the edited image.
     */
    originalImageAspectRatio?: number;
    /**
     * Original height of the edited image.
     */
    originalImageHeight?: number;
    /**
     * Original width of the edited image.
     */
    originalImageWidth?: number;
    /**
     * Mime type of the original image.
     */
    originalImageMimeType?: string;
    /**
     * Source URL of the original image.
     */
    originalImageSrc?: string;
    /**
     * ID of the crop item with original ratio.
     */
    originalCropItemId: string;
    /**
     * Resets editing to initial values.
     */
    reset: () => void;
    /**
     * Resets zoom of edited image to baseline value.
     */
    resetZoom: () => void;
    /**
     * Rotates image left by 90 degrees.
     */
    rotateLeft: () => void;
    /**
     * Rotates image right by 90 degrees.
     */
    rotateRight: () => void;
    /**
     * Whether save dialog is open.
     */
    saveDialogOpen?: boolean;
    /**
     * Setter for underlying canvas element.
     *
     * @param canvasElement canvas element
     */
    setImgElement: (canvasElement: HTMLImageElement | null) => void;
    /**
     * Target (final) height of the edited image.
     */
    targetImageHeight: number;
    /**
     * Target (final) width of the edited image.
     */
    targetImageWidth: number;
    /**
     * Toggles locked state of custom crop box dimensions.
     */
    toggleAspectRatioLock: () => void;
    /**
     * Zooms in.
     */
    zoomIn: () => void;
    /**
     * Zooms out.
     */
    zoomOut: () => void;
    /**
     * Current zoom value.
     */
    zoomValue?: number;
}
declare const ImageEditorContext: React$1.Context<ImageEditorContext>;
declare const useImageEditorContext: () => ImageEditorContext;

declare const imageEditorPreviewContextDefaultValue: ImageEditorPreviewContext;
interface ImageEditorPreviewContext {
    /**
     * Instance of Cropper.
     */
    cropper?: Cropper | null;
    /**
     * Cropper ready state.
     */
    cropperReady: boolean;
    /**
     * Underlying image element.
     */
    imgElement: HTMLImageElement | null;
    /**
     * Resized width.
     */
    resizedWidth: number;
    /**
     * Resized height.
     */
    resizedHeight: number;
    /**
     * Resizes image by respecting aspect ratio.
     * Locked dimension will be used as provided while the other one will be adjusted.
     *
     * @param size requested size
     * @param locked specifies locked dimension
     */
    resize: (size: number, locked?: CropperLockedDimension) => [number, number];
    /**
     * Gets final image data.
     */
    getSaveData: () => ImageEditorEditingResult | void;
    /**
     * Setter for underlying canvas element.
     *
     * @param canvasElement canvas element
     */
    setImgElement: (canvasElement: HTMLImageElement | null) => void;
}
declare const ImageEditorPreviewContext: React$1.Context<ImageEditorPreviewContext>;
declare const useImageEditorPreviewContext: () => ImageEditorPreviewContext;

/**
 * Parses raw dimension value and checks if it's within predefined range.
 * Clamped value is returned.
 *
 * It might happen that raw dimension is not available.
 * In such case `undefined` is returned.
 *
 * @param dimension raw dimension
 * @returns clamped dimension
 */
declare function getClampedDimension(dimension: string): number;
/**
 * Parses raw dimension values.
 *
 * @param width raw width
 * @param height raw height
 * @returns clamped dimensions
 */
declare const getClampedDimensions: (width: string, height: string) => [number, number];

declare const ImageEditorDimensionsInput: React$1.FC<Props$H>;
interface Props$H {
    /**
     * Indicates whether input is disabled.
     */
    disabled?: boolean;
    /**
     * Label of the input.
     */
    label?: string;
    /**
     * Blur event handler.
     */
    onBlur?: React$1.ChangeEventHandler;
    /**
     * Change event handler.
     */
    onChange: (value: string) => void;
    /**
     * Focus event handler.
     */
    onFocus?: React$1.ChangeEventHandler;
    /**
     * Current input's value.
     */
    value: string;
}

declare const ImageEditorActions: React$1.FC<Props$G>;
interface Props$G {
    /**
     * Label of the back button.
     */
    backBtnLabel?: string;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Text displayed as title in the action bar.
     */
    title?: string;
}

declare const ImageEditorApplyButton: React$1.ForwardRefExoticComponent<Omit<Props$36, "onClick"> & React$1.RefAttributes<HTMLButtonElement>>;

declare const ImageEditorButtonsGroup: React$1.ForwardRefExoticComponent<Props$F & React$1.RefAttributes<HTMLDivElement>>;
interface Props$F {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ImageEditorButtonsRow: React$1.ForwardRefExoticComponent<Props$E & React$1.RefAttributes<HTMLDivElement>>;
interface Props$E {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ImageEditorCanvas: React$1.ForwardRefExoticComponent<Props$D & React$1.RefAttributes<HTMLDivElement>>;
interface Props$D {
    /**
     * Alternative text description of the image.
     */
    alt: string;
    /**
     * Optional loading label to display when image is being loaded.
     */
    loadingLabel?: string;
}

declare const ImageEditorContent: React$1.ForwardRefExoticComponent<Props$C & React$1.RefAttributes<HTMLDivElement>>;
interface Props$C {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ImageEditorCropBoxDimensions: React$1.ForwardRefExoticComponent<Props$B & React$1.RefAttributes<HTMLDivElement>>;
interface Props$B {
    /**
     * Label displayed above the height input.
     */
    heightLabel?: string;
    /**
     * Label of the lock button in unlocked state.
     */
    lockBtnLabel?: string;
    /**
     * Label of the lock button in locked state.
     */
    unlockBtnLabel?: string;
    /**
     * Label displayed above the width input.
     */
    widthLabel?: string;
}

declare const ImageEditorCropCard: React$1.ForwardRefExoticComponent<Props$A & React$1.RefAttributes<HTMLDivElement>>;
interface Props$A {
    /**
     * Aspect ratio to set on the crop box.
     */
    aspectRatio?: number;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * ID that uniquely identifies the crop card.
     */
    id: string;
    /**
     * Icon to display.
     */
    icon?: React$1.ReactElement<Props$37>;
}

declare const ImageEditorCropCardFreeform: React$1.ForwardRefExoticComponent<Props$z & React$1.RefAttributes<HTMLDivElement>>;
interface Props$z {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Icon to display
     */
    icon?: React$1.ReactElement<Props$37>;
}

declare const ImageEditorCropCardList: React$1.ForwardRefExoticComponent<Props$y & React$1.RefAttributes<HTMLDivElement>>;
interface Props$y {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ImageEditorCropCardOriginal: React$1.ForwardRefExoticComponent<Props$x & React$1.RefAttributes<HTMLDivElement>>;
interface Props$x {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Icon to display
     */
    icon?: React$1.ReactElement<Props$37>;
}

declare const ImageEditorFlipHorizontalButton: React$1.FC<Omit<Props$36, 'children' | 'onClick'>>;

declare const ImageEditorFlipVerticalButton: React$1.FC<Omit<Props$36, 'children' | 'onClick'>>;

declare const ImageEditorLoader: React$1.ForwardRefExoticComponent<Props$w & React$1.RefAttributes<HTMLDivElement>>;
interface Props$w {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ImageEditorMenu: React$1.ForwardRefExoticComponent<Props$v & React$1.RefAttributes<HTMLDivElement>>;
interface Props$v {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ImageEditorMenuContainer: React$1.ForwardRefExoticComponent<Props$u & React$1.RefAttributes<HTMLDivElement>>;
interface Props$u {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Fills remaining menu space.
     */
    fillSpace?: boolean;
    /**
     * Renders with muted background.
     */
    muted?: boolean;
}

declare const ImageEditorMenuSection: React$1.ForwardRefExoticComponent<Props$t & React$1.RefAttributes<HTMLDivElement>>;
interface Props$t {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Title of the section.
     */
    title?: string;
}

declare const ImageEditorMenuSubSection: React$1.ForwardRefExoticComponent<Props$s & React$1.RefAttributes<HTMLDivElement>>;
interface Props$s {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Additional info.
     */
    info?: string;
    /**
     * Title of the section.
     */
    title?: string;
}

declare const ImageEditorPresetSelect: React$1.FC<Props$r>;
interface Props$r {
    /**
     * Aria label for clear button.
     */
    clearBtnLabel?: string;
    /**
     * Predefined option groups to select from.
     */
    options: ImageEditorPresetGroup[];
    /**
     * Input placeholder.
     */
    placeholder?: string;
}

declare const ImageEditorResetButton: React$1.ForwardRefExoticComponent<Omit<Props$36, "onClick"> & React$1.RefAttributes<HTMLButtonElement>>;

declare const ImageEditorResizeDimensions: React$1.ForwardRefExoticComponent<Props$q & React$1.RefAttributes<HTMLDivElement>>;
interface Props$q {
    /**
     * Error message.
     */
    errMsg?: string;
    /**
     * Height input component.
     */
    heightInput: React$1.ReactNode;
    /**
     * Width input component.
     */
    widthInput: React$1.ReactNode;
}

declare const ImageEditorRotateLeftButton: React$1.FC<Omit<Props$36, 'children' | 'onClick'>>;

declare const ImageEditorRotateRightButton: React$1.FC<Omit<Props$36, 'children' | 'onClick'>>;

declare const ImageEditorSaveDialog: React$1.ForwardRefExoticComponent<Props$p & React$1.RefAttributes<HTMLDivElement>>;
interface Props$p {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets the ID of label element.
     */
    labelledBy?: string;
}

declare const ImageEditorSaveDialogActions: React$1.ForwardRefExoticComponent<Props$o & React$1.RefAttributes<HTMLDivElement>>;
interface Props$o {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const ImageEditorSaveDialogCanvas: React$1.ForwardRefExoticComponent<Props$n & React$1.RefAttributes<HTMLDivElement>>;
interface Props$n {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Title of the canvas.
     */
    title?: string;
}

declare const ImageEditorPreviewCloseButton: React$1.ForwardRefExoticComponent<Omit<Props$36, "onClick"> & React$1.RefAttributes<HTMLButtonElement>>;

declare const ImageEditorSaveDialogHeader: React$1.ForwardRefExoticComponent<Props$m & React$1.RefAttributes<HTMLDivElement>>;
interface Props$m {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Sets ID of dialog header title element.
     */
    titleId?: string;
}

declare const ImageEditorSaveDialogImage: React$1.ForwardRefExoticComponent<Props$l & React$1.RefAttributes<HTMLDivElement>>;
interface Props$l {
    /**
     * Alternative text description of the preview image.
     */
    alt: string;
}

declare const ImageEditorSaveDialogInfo: React$1.ForwardRefExoticComponent<Props$1u & React$1.RefAttributes<HTMLFormElement>>;

declare const ImageEditorSaveDialogPreview: React$1.ForwardRefExoticComponent<Props$k & React$1.RefAttributes<HTMLDivElement>>;
interface Props$k {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ImageEditorSaveDialogSaveButton: React$1.ForwardRefExoticComponent<Props$18 & React$1.RefAttributes<HTMLButtonElement>>;

declare const ImageEditorSaveDialogSection: React$1.ForwardRefExoticComponent<Props$j & React$1.RefAttributes<HTMLDivElement>>;
interface Props$j {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Additional info.
     */
    info?: string;
    /**
     * Title of the section.
     */
    title?: string;
}

declare const ImageEditorToolbar: React$1.ForwardRefExoticComponent<Props$i & React$1.RefAttributes<HTMLDivElement>>;
interface Props$i {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

interface Props$h {
    /**
     * Main button content.
     */
    children?: React$1.ReactNode;
    /**
     * Optional aria-label for the button.
     */
    label?: string;
    /**
     * Click event handler.
     */
    onClick?: React$1.MouseEventHandler;
}

declare const ImageEditorToolbarFlipHorizontalButton: React$1.FC<Omit<Props$h, 'children' | 'onClick'>>;

declare const ImageEditorToolbarFlipVerticalButton: React$1.FC<Omit<Props$h, 'children' | 'onClick'>>;

declare const ImageEditorToolbarImageSize: React$1.ForwardRefExoticComponent<React$1.RefAttributes<HTMLDivElement>>;

declare const ImageEditorToolbarRotateLeftButton: React$1.FC<Omit<Props$h, 'children' | 'onClick'>>;

declare const ImageEditorToolbarRotateRightButton: React$1.FC<Omit<Props$h, 'children' | 'onClick'>>;

declare const ImageEditorToolbarSection: React$1.ForwardRefExoticComponent<Props$g & React$1.RefAttributes<HTMLDivElement>>;
interface Props$g {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const ImageEditorToolbarZoomInButton: React$1.FC<Omit<Props$h, 'children' | 'onClick'>>;

declare const ImageEditorToolbarZoomOutButton: React$1.FC<Omit<Props$h, 'children' | 'onClick'>>;

declare const ImageEditorToolbarZoomValue: React$1.FC<Props$f>;
interface Props$f {
    /**
     * Optional aria-label for the button.
     */
    label: string;
}

declare const ImageEditorWorkspace: React$1.ForwardRefExoticComponent<Props$e & React$1.RefAttributes<HTMLDivElement>>;
interface Props$e {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ImageEditor: React$1.ForwardRefExoticComponent<Props$d & React$1.RefAttributes<HTMLDivElement>>;
interface Props$d {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label of the dialog element.
     */
    label?: string;
    /**
     * Callback fired when the component requests to be closed.
     */
    onClose: () => void;
    /**
     * If `true`, the component is shown.
     */
    open?: boolean;
    /**
     * Mime type of the original image.
     */
    originalImageMimeType?: string;
    /**
     * Source URL of the original image.
     */
    originalImageSrc?: string;
}

declare const Textarea: React$1.ForwardRefExoticComponent<Props$c & React$1.RefAttributes<HTMLTextAreaElement>>;
interface Props$c {
    /**
     * Input's class name.
     */
    className?: string;
    /**
     * Marks input as disabled.
     */
    disabled?: boolean;
    /**
     * Marks input as read-only.
     */
    readOnly?: boolean;
    /**
     * Unique input's id.
     */
    id: string;
    /**
     * Input's name to register.
     */
    name?: string;
    /**
     * Callback invoked when the blur event is fired.
     */
    onBlur?: (evt: React$1.ChangeEvent<HTMLTextAreaElement>) => void;
    /**
     * Callback invoked when the value is changed.
     */
    onChange?: (evt: React$1.ChangeEvent<HTMLTextAreaElement>) => void;
    /**
     * Callback invoked when the element receives focus.
     */
    onFocus?: (evt: React$1.ChangeEvent<HTMLTextAreaElement>) => void;
    /**
     * Callback invoked when the element is clicked.
     */
    onClick?: (evt: React$1.MouseEvent<HTMLTextAreaElement>) => void;
    /**
     * Input's placeholder text value.
     */
    placeholder?: string;
    /**
     * Input's value.
     */
    value?: string;
    /**
     * Indicate error in input element.
     */
    error?: boolean;
    /**
     * Input's label.
     */
    label?: string;
    /**
     * Maximum number of textarea lines.
     */
    maxRows?: number;
}

declare const TextFieldInput: React$1.ForwardRefExoticComponent<React$1.InputHTMLAttributes<HTMLInputElement> & {
    /**
     * Used as aria-label attribute.
     */
    label?: string | undefined;
} & React$1.RefAttributes<HTMLInputElement>>;

type TextFieldSize = 'md' | 'base';
type TextFieldVariant = 'outlined' | 'underlined';

declare const TextField: React$1.ForwardRefExoticComponent<Props$b & React$1.RefAttributes<HTMLDivElement>>;
interface Props$b {
    /**
     * Text field's adornment.
     */
    adornment?: string;
    /**
     * Instance of `TextFieldInput`.
     */
    children: React$1.ReactNode;
    /**
     * Root class name.
     */
    className?: string;
    /**
     * Whether text field is in disabled state.
     */
    disabled?: boolean;
    /**
     * Whether text field is in error state.
     */
    error?: boolean;
    /**
     * ID of the text field.
     */
    id?: string;
    /**
     * Text field's size.
     */
    size?: TextFieldSize;
    /**
     * Text field styling variant.
     */
    variant?: TextFieldVariant;
}

declare const Pill: React$1.FC<Props$a>;
interface Props$a {
    /**
     * Whether component is active.
     */
    active?: boolean;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * ID of associated tab panel.
     */
    controlsId?: string;
    /**
     * Icon to display.
     */
    icon?: React$1.ReactElement<Props$37>;
    /**
     * Unique ID of a tab.
     */
    id?: string;
    /**
     * Click handler.
     */
    onClick?: React$1.MouseEventHandler<HTMLButtonElement>;
}

declare const Pills: React$1.FC<Props$9>;
interface Props$9 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const PdfViewer: React$1.FC<Props$8>;
interface Props$8 {
    /**
     * Location of data source.
     */
    src: string;
    /**
     * Identifies content of the PDF.
     */
    title: string;
}

declare const TableBody: React$1.FC<Props$7>;
interface Props$7 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const TableCell: React$1.FC<Props$6>;
interface Props$6 {
    /**
     * Text alignment.
     */
    align?: 'left' | 'right';
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Optional root class name.
     */
    className?: string;
}

declare const TableContainer: React$1.FC<Props$5>;
interface Props$5 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const TableHead: React$1.FC<Props$4>;
interface Props$4 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const TableHeader: React$1.FC<Props$3>;
interface Props$3 {
    /**
     * Text alignment.
     */
    align?: 'left' | 'right';
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Optional root class name.
     */
    className?: string;
}

declare const TableRow: React$1.FC<Props$2>;
interface Props$2 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const TableToolbar: React$1.FC<Props$1>;
interface Props$1 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const Table: React$1.FC<Props>;
interface Props {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Optional root class name.
     */
    className?: string;
}

export { Avatar, Bottombar, Button, ButtonColor, ButtonGroup, ButtonRow, ButtonSize, ButtonType, COLLAPSE_THRESHOLD, CONTAINER_QUERY_BREAKPOINTS, CROPPER_FLIP_FACTOR, CROPPER_FULL_ROTATION, CROPPER_INIT_SCALE, CROPPER_MIN_ZOOM_VALUE, CROPPER_ROTATION_ANGLE, CROPPER_ZOOM_FACTOR, CROPPER_ZOOM_STEP, CROPPER_ZOOM_STEP_FINE, CROPPER_ZOOM_THRESHOLD, Checkbox, CheckboxLabel, CircularLoader, ContainerQuery, ContainerQueryProvider, CopyButton, CopyableInput, CopyableLabel, CropperDimensions, CropperLockedDimension, Dialog, DialogActions, DialogColumn, DialogFooter, DialogHeader, DialogNext, DialogNextCloseButton, DialogNextColumn, DialogNextContent, DialogNextFooter, DialogNextHeader, DialogNextSeparator, DialogNextTitle, DialogProgressHeader, DialogRow, DialogSection, Dimensions, DocIcon, DocIconName, DragDimensionsHandler, DragHandler, DraggableOptions, DraggableState, Drawer, DrawerActions, DrawerContent, DrawerHeader, DrawerSection, Ellipsis, EmptyView, EmptyViewLabel, FileInput, FilePreview, FilePreviewActions, FilePreviewColumn, FilePreviewContent, FilePreviewHoverable, FilePreviewNavButton, FilePreviewTooltip, Fixed, FixedContext, FixedProvider, Form, FormFeedback, FormGroup, FormGroupColumn, FormGroupInfo, FormInputLabel, Gallery, GalleryFigure, GalleryItem, Icon, IconColor, IconName, IconRenderProp, IconRenderer, IconSize, ImageEditor, ImageEditorActions, ImageEditorApplyButton, ImageEditorButtonsGroup, ImageEditorButtonsRow, ImageEditorCanvas, ImageEditorContent, ImageEditorContext, ImageEditorCropBoxDimensions, ImageEditorCropCard, ImageEditorCropCardFreeform, ImageEditorCropCardList, ImageEditorCropCardOriginal, ImageEditorDimensionsInput, ImageEditorEditingResult, ImageEditorFlipHorizontalButton, ImageEditorFlipVerticalButton, ImageEditorLoader, ImageEditorMenu, ImageEditorMenuContainer, ImageEditorMenuSection, ImageEditorMenuSubSection, ImageEditorPresetGroup, ImageEditorPresetOption, ImageEditorPresetSelect, ImageEditorPreviewContext, ImageEditorResetButton, ImageEditorResizeDimensions, ImageEditorRotateLeftButton, ImageEditorRotateRightButton, ImageEditorSaveDialog, ImageEditorSaveDialogActions, ImageEditorSaveDialogCanvas, ImageEditorPreviewCloseButton as ImageEditorSaveDialogCloseButton, ImageEditorSaveDialogHeader, ImageEditorSaveDialogImage, ImageEditorSaveDialogInfo, ImageEditorSaveDialogPreview, ImageEditorSaveDialogSaveButton, ImageEditorSaveDialogSection, ImageEditorToolbar, ImageEditorToolbarFlipHorizontalButton, ImageEditorToolbarFlipVerticalButton, ImageEditorToolbarImageSize, ImageEditorToolbarRotateLeftButton, ImageEditorToolbarRotateRightButton, ImageEditorToolbarSection, ImageEditorToolbarZoomInButton, ImageEditorToolbarZoomOutButton, ImageEditorToolbarZoomValue, ImageEditorWorkspace, KeyAction, KeyCombination, KeyEventLike, KeyModifier, KeyProps, List, ListDndChildProps, ListDndItem, ListDndItemHookProps, ListDndMoveItem, ListDndOnDragEnd, ListDndSetDraggable, ListDndSetDraggablePartial, ListItem, ListItemActions, ListItemContent, LoadingButton, Menu, MenuItem, MenuSection, MenuSubSection, ModalDialog, ModalDialogActionContent, ModalDialogActionItem, ModalDialogCallout, ModalDialogContent, ModalDialogContentColumn, ModalDialogFooter, ModalDialogFooterAction, ModalDialogHeader, ModalDialogList, ModalDialogListItem, MouseEventButton, NAVBAR_COLLAPSED_WIDTH, NAVBAR_LOADING_DELAY, NAVBAR_MAX_WIDTH, NAVBAR_MIN_WIDTH, NAVBAR_PREVIEW_TIMEOUT, Navbar, NavbarContext, NavbarItem, NavbarItemContainer, NavbarItemContent, NavbarItemLabel, NavbarItemsGroup, NavbarLink, NavbarScrollableContent, NavbarSeparator, NavbarToggleButton, NavigationDialog, NavigationDialogContent, NavigationDialogFallbackContent, NavigationDialogFooter, NavigationDialogHeader, NavigationDialogItem, NavigationDialogItemAction, NavigationDialogItemLabel, Notification, Notifications, OnScrollHandler, Modal as Overlay, Pagination, Panel, PanelActions, PanelColumn, PanelContent, PanelContentProp, PanelDragHandle, PanelList, PanelListDivider, PanelSide, PanelSkeleton, PanelTitle, PdfViewer, Pill, Pills, Popper, PopperAnchorRef, PopperArrow, PopperContext, PopperOffset, PopperOffsetValue, PopperPlacement, ProgressPanel, PropertiesTable, PropertiesTableRow, Props$37 as Props, RInterval, RangeSlider, ResizeOptions, ResponsiveImage, ResponsiveImageFallback, ResponsiveImageFit, ResponsiveImageScalable, ResponsiveImageSkeleton, ScrollCoordsConfig, ScrollOptions, SearchDialog, SearchDialogActions, SearchDialogContent, SearchDialogFallback, SearchDialogHeader, SearchDialogInput, SearchDialogSection, Select, SelectKeyboardNavProps, SelectKeyboardNextIdGetter, SelectOption, SelectRenderableOption, SelectSection, SelectToggleHandler, SelectionArea, SelectionAreaCoords, Skeleton, SortButton, SortableDndList, SortableDndListItem, Switch, SwitchInput, SwitchView, Tab, TabPanel, Table, TableBody, TableCell, TableContainer, TableHead, TableHeader, TableRow, TableToolbar, Tabs, Tag, TagInput, TagLabel, TagList, TextEllipsis, TextField, TextFieldInput, Textarea, Props$c as TextareaProps, Tooltip, Topbar, TopbarAction, UIContext, UIProvider, Props$1K as UIProviderProps, View, ViewContent, ViewContentBar, ViewContentWrapper, ViewDialog, Props$1L as ViewDialogProps, ViewFooter, ViewHeader, ViewPaper, ViewSideContent, ViewWrapper, XYCoord, areItemsIdentical, base64FromBlurHash, clamp, clsx, formatTimeDistance, getClampedDimension, getClampedDimensions, getKeyHandler, getPixelCountFromImageBlob, getScrollVectors, getStandardDeviation, getValidChildren, hasOwnProperty, imageEditorContextDefaultValue, imageEditorPreviewContextDefaultValue, isClipboardItemSupported, matchesCombination, navbarContextInitProps, noOp, rInterval, readFromClipboard, tryReadFromClipboard, tryWriteTextToClipboard, tryWriteToClipboard, uiContextInitProps, useBatchUpdate, useClickAway, useContainerKeyDown, useContainerQuery, useCropper, useCropperCrop, useCropperRotate, useCropperScale, useCropperZoom, useDeferredLoader, useDeferredUnmount, useDelay, useDownload, useDraggable, useElementVisibility, useFilesDrop, useFixedCtx, useForkRef, useGridSelection, useImageEditorContext, useImageEditorPreviewContext, useIsMounted, useIsomorphicLayoutEffect, useItemsOverflow, useListDnd, useNavbarCtx, usePopperCtx, useResettableTimeout, useResize, useResponsiveSizes, useScaleDown, useScroll, useScrollDnd, useToggle, useUIContext, validators_d as validators, writeTextToClipboard, writeToClipboard };
